/* eoddataC.cpp
   Generated by gSOAP 2.8.28 from eoddata.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "eoddataH.h"

namespace eoddata {

SOAP_SOURCE_STAMP("@(#) eoddataC.cpp ver 2.8.28 2016-06-06 11:57:31 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap);
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap);
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = soap_new_SOAP_ENV__Detail(soap);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if ((soap->error && soap->error != SOAP_TAG_MISMATCH) || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_eoddata_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_eoddata_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_eoddata_LONG64:
		return soap_in_LONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_eoddata_double:
		return soap_in_double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_eoddata_dateTime:
		return soap_in_dateTime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_eoddata_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_eoddata_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_eoddata_eoddata1__DATAFORMAT_USCORECOLUMN:
		return soap_in_eoddata1__DATAFORMAT_USCORECOLUMN(soap, NULL, NULL, "eoddata1:DATAFORMAT_COLUMN");
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN:
		return soap_in_eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN(soap, NULL, NULL, "eoddata1:ArrayOfDATAFORMAT_COLUMN");
	case SOAP_TYPE_eoddata_eoddata1__DATAFORMAT:
		return soap_in_eoddata1__DATAFORMAT(soap, NULL, NULL, "eoddata1:DATAFORMAT");
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfDATAFORMAT:
		return soap_in_eoddata1__ArrayOfDATAFORMAT(soap, NULL, NULL, "eoddata1:ArrayOfDATAFORMAT");
	case SOAP_TYPE_eoddata_eoddata1__NEWS:
		return soap_in_eoddata1__NEWS(soap, NULL, NULL, "eoddata1:NEWS");
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfNEWS:
		return soap_in_eoddata1__ArrayOfNEWS(soap, NULL, NULL, "eoddata1:ArrayOfNEWS");
	case SOAP_TYPE_eoddata_eoddata1__SYMBOLCHANGE:
		return soap_in_eoddata1__SYMBOLCHANGE(soap, NULL, NULL, "eoddata1:SYMBOLCHANGE");
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfSYMBOLCHANGE:
		return soap_in_eoddata1__ArrayOfSYMBOLCHANGE(soap, NULL, NULL, "eoddata1:ArrayOfSYMBOLCHANGE");
	case SOAP_TYPE_eoddata_eoddata1__TECHNICAL:
		return soap_in_eoddata1__TECHNICAL(soap, NULL, NULL, "eoddata1:TECHNICAL");
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfTECHNICAL:
		return soap_in_eoddata1__ArrayOfTECHNICAL(soap, NULL, NULL, "eoddata1:ArrayOfTECHNICAL");
	case SOAP_TYPE_eoddata_eoddata1__FUNDAMENTAL:
		return soap_in_eoddata1__FUNDAMENTAL(soap, NULL, NULL, "eoddata1:FUNDAMENTAL");
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfFUNDAMENTAL:
		return soap_in_eoddata1__ArrayOfFUNDAMENTAL(soap, NULL, NULL, "eoddata1:ArrayOfFUNDAMENTAL");
	case SOAP_TYPE_eoddata_eoddata1__CountryBase:
		return soap_in_eoddata1__CountryBase(soap, NULL, NULL, "eoddata1:CountryBase");
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfCountryBase:
		return soap_in_eoddata1__ArrayOfCountryBase(soap, NULL, NULL, "eoddata1:ArrayOfCountryBase");
	case SOAP_TYPE_eoddata_eoddata1__SPLIT:
		return soap_in_eoddata1__SPLIT(soap, NULL, NULL, "eoddata1:SPLIT");
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfSPLIT:
		return soap_in_eoddata1__ArrayOfSPLIT(soap, NULL, NULL, "eoddata1:ArrayOfSPLIT");
	case SOAP_TYPE_eoddata_eoddata1__QUOTE2:
		return soap_in_eoddata1__QUOTE2(soap, NULL, NULL, "eoddata1:QUOTE2");
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfQUOTE2:
		return soap_in_eoddata1__ArrayOfQUOTE2(soap, NULL, NULL, "eoddata1:ArrayOfQUOTE2");
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfQUOTE:
		return soap_in_eoddata1__ArrayOfQUOTE(soap, NULL, NULL, "eoddata1:ArrayOfQUOTE");
	case SOAP_TYPE_eoddata_eoddata1__QUOTE:
		return soap_in_eoddata1__QUOTE(soap, NULL, NULL, "eoddata1:QUOTE");
	case SOAP_TYPE_eoddata_eoddata1__SYMBOL2:
		return soap_in_eoddata1__SYMBOL2(soap, NULL, NULL, "eoddata1:SYMBOL2");
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfSYMBOL2:
		return soap_in_eoddata1__ArrayOfSYMBOL2(soap, NULL, NULL, "eoddata1:ArrayOfSYMBOL2");
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfSYMBOL:
		return soap_in_eoddata1__ArrayOfSYMBOL(soap, NULL, NULL, "eoddata1:ArrayOfSYMBOL");
	case SOAP_TYPE_eoddata_eoddata1__SYMBOL:
		return soap_in_eoddata1__SYMBOL(soap, NULL, NULL, "eoddata1:SYMBOL");
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfEXCHANGE:
		return soap_in_eoddata1__ArrayOfEXCHANGE(soap, NULL, NULL, "eoddata1:ArrayOfEXCHANGE");
	case SOAP_TYPE_eoddata_eoddata1__EXCHANGE:
		return soap_in_eoddata1__EXCHANGE(soap, NULL, NULL, "eoddata1:EXCHANGE");
	case SOAP_TYPE_eoddata_eoddata1__RESPONSE:
		return soap_in_eoddata1__RESPONSE(soap, NULL, NULL, "eoddata1:RESPONSE");
	case SOAP_TYPE_eoddata_eoddata1__LOGINRESPONSE:
		return soap_in_eoddata1__LOGINRESPONSE(soap, NULL, NULL, "eoddata1:LOGINRESPONSE");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__ValidateAccess:
		return soap_in_PointerTo_eoddata1__ValidateAccess(soap, NULL, NULL, "eoddata1:ValidateAccess");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__UpdateDataFormat:
		return soap_in_PointerTo_eoddata1__UpdateDataFormat(soap, NULL, NULL, "eoddata1:UpdateDataFormat");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__DataFormats:
		return soap_in_PointerTo_eoddata1__DataFormats(soap, NULL, NULL, "eoddata1:DataFormats");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__DataClientLatestVersion:
		return soap_in_PointerTo_eoddata1__DataClientLatestVersion(soap, NULL, NULL, "eoddata1:DataClientLatestVersion");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__SymbolChangesByExchange:
		return soap_in_PointerTo_eoddata1__SymbolChangesByExchange(soap, NULL, NULL, "eoddata1:SymbolChangesByExchange");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__QuoteListByDatePeriod2:
		return soap_in_PointerTo_eoddata1__QuoteListByDatePeriod2(soap, NULL, NULL, "eoddata1:QuoteListByDatePeriod2");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__QuoteListByDatePeriod:
		return soap_in_PointerTo_eoddata1__QuoteListByDatePeriod(soap, NULL, NULL, "eoddata1:QuoteListByDatePeriod");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__SymbolHistoryPeriodByDateRange:
		return soap_in_PointerTo_eoddata1__SymbolHistoryPeriodByDateRange(soap, NULL, NULL, "eoddata1:SymbolHistoryPeriodByDateRange");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__SymbolHistoryPeriod:
		return soap_in_PointerTo_eoddata1__SymbolHistoryPeriod(soap, NULL, NULL, "eoddata1:SymbolHistoryPeriod");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__CountryList:
		return soap_in_PointerTo_eoddata1__CountryList(soap, NULL, NULL, "eoddata1:CountryList");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__SplitListBySymbol:
		return soap_in_PointerTo_eoddata1__SplitListBySymbol(soap, NULL, NULL, "eoddata1:SplitListBySymbol");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__SplitListByExchange:
		return soap_in_PointerTo_eoddata1__SplitListByExchange(soap, NULL, NULL, "eoddata1:SplitListByExchange");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__ExchangeMonths:
		return soap_in_PointerTo_eoddata1__ExchangeMonths(soap, NULL, NULL, "eoddata1:ExchangeMonths");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__SymbolChart:
		return soap_in_PointerTo_eoddata1__SymbolChart(soap, NULL, NULL, "eoddata1:SymbolChart");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__Top10Losses:
		return soap_in_PointerTo_eoddata1__Top10Losses(soap, NULL, NULL, "eoddata1:Top10Losses");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__Top10Gains:
		return soap_in_PointerTo_eoddata1__Top10Gains(soap, NULL, NULL, "eoddata1:Top10Gains");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__SymbolHistory:
		return soap_in_PointerTo_eoddata1__SymbolHistory(soap, NULL, NULL, "eoddata1:SymbolHistory");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__QuoteListByDate2:
		return soap_in_PointerTo_eoddata1__QuoteListByDate2(soap, NULL, NULL, "eoddata1:QuoteListByDate2");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__QuoteListByDate:
		return soap_in_PointerTo_eoddata1__QuoteListByDate(soap, NULL, NULL, "eoddata1:QuoteListByDate");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__TechnicalList:
		return soap_in_PointerTo_eoddata1__TechnicalList(soap, NULL, NULL, "eoddata1:TechnicalList");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__FundamentalList:
		return soap_in_PointerTo_eoddata1__FundamentalList(soap, NULL, NULL, "eoddata1:FundamentalList");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__NewsListBySymbol:
		return soap_in_PointerTo_eoddata1__NewsListBySymbol(soap, NULL, NULL, "eoddata1:NewsListBySymbol");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__NewsList:
		return soap_in_PointerTo_eoddata1__NewsList(soap, NULL, NULL, "eoddata1:NewsList");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__QuoteList:
		return soap_in_PointerTo_eoddata1__QuoteList(soap, NULL, NULL, "eoddata1:QuoteList");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__SymbolGet:
		return soap_in_PointerTo_eoddata1__SymbolGet(soap, NULL, NULL, "eoddata1:SymbolGet");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__QuoteList2:
		return soap_in_PointerTo_eoddata1__QuoteList2(soap, NULL, NULL, "eoddata1:QuoteList2");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__QuoteGet:
		return soap_in_PointerTo_eoddata1__QuoteGet(soap, NULL, NULL, "eoddata1:QuoteGet");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__SymbolList2:
		return soap_in_PointerTo_eoddata1__SymbolList2(soap, NULL, NULL, "eoddata1:SymbolList2");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__SymbolList:
		return soap_in_PointerTo_eoddata1__SymbolList(soap, NULL, NULL, "eoddata1:SymbolList");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__ExchangeGet:
		return soap_in_PointerTo_eoddata1__ExchangeGet(soap, NULL, NULL, "eoddata1:ExchangeGet");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__ExchangeList:
		return soap_in_PointerTo_eoddata1__ExchangeList(soap, NULL, NULL, "eoddata1:ExchangeList");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__Membership:
		return soap_in_PointerTo_eoddata1__Membership(soap, NULL, NULL, "eoddata1:Membership");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__Login2:
		return soap_in_PointerTo_eoddata1__Login2(soap, NULL, NULL, "eoddata1:Login2");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__Login:
		return soap_in_PointerTo_eoddata1__Login(soap, NULL, NULL, "eoddata1:Login");
	case SOAP_TYPE_eoddata_PointerToeoddata1__RESPONSE:
		return soap_in_PointerToeoddata1__RESPONSE(soap, NULL, NULL, "eoddata1:RESPONSE");
	case SOAP_TYPE_eoddata_PointerToeoddata1__LOGINRESPONSE:
		return soap_in_PointerToeoddata1__LOGINRESPONSE(soap, NULL, NULL, "eoddata1:LOGINRESPONSE");
	case SOAP_TYPE_eoddata_PointerToeoddata1__DATAFORMAT_USCORECOLUMN:
		return soap_in_PointerToeoddata1__DATAFORMAT_USCORECOLUMN(soap, NULL, NULL, "eoddata1:DATAFORMAT_COLUMN");
	case SOAP_TYPE_eoddata_PointerToeoddata1__ArrayOfDATAFORMAT_USCORECOLUMN:
		return soap_in_PointerToeoddata1__ArrayOfDATAFORMAT_USCORECOLUMN(soap, NULL, NULL, "eoddata1:ArrayOfDATAFORMAT_COLUMN");
	case SOAP_TYPE_eoddata_PointerToeoddata1__DATAFORMAT:
		return soap_in_PointerToeoddata1__DATAFORMAT(soap, NULL, NULL, "eoddata1:DATAFORMAT");
	case SOAP_TYPE_eoddata_PointerToeoddata1__NEWS:
		return soap_in_PointerToeoddata1__NEWS(soap, NULL, NULL, "eoddata1:NEWS");
	case SOAP_TYPE_eoddata_PointerToeoddata1__SYMBOLCHANGE:
		return soap_in_PointerToeoddata1__SYMBOLCHANGE(soap, NULL, NULL, "eoddata1:SYMBOLCHANGE");
	case SOAP_TYPE_eoddata_PointerToeoddata1__TECHNICAL:
		return soap_in_PointerToeoddata1__TECHNICAL(soap, NULL, NULL, "eoddata1:TECHNICAL");
	case SOAP_TYPE_eoddata_PointerToeoddata1__FUNDAMENTAL:
		return soap_in_PointerToeoddata1__FUNDAMENTAL(soap, NULL, NULL, "eoddata1:FUNDAMENTAL");
	case SOAP_TYPE_eoddata_PointerToeoddata1__CountryBase:
		return soap_in_PointerToeoddata1__CountryBase(soap, NULL, NULL, "eoddata1:CountryBase");
	case SOAP_TYPE_eoddata_PointerToeoddata1__SPLIT:
		return soap_in_PointerToeoddata1__SPLIT(soap, NULL, NULL, "eoddata1:SPLIT");
	case SOAP_TYPE_eoddata_PointerToeoddata1__QUOTE2:
		return soap_in_PointerToeoddata1__QUOTE2(soap, NULL, NULL, "eoddata1:QUOTE2");
	case SOAP_TYPE_eoddata_PointerToeoddata1__SYMBOL2:
		return soap_in_PointerToeoddata1__SYMBOL2(soap, NULL, NULL, "eoddata1:SYMBOL2");
	case SOAP_TYPE_eoddata_PointerToeoddata1__ArrayOfDATAFORMAT:
		return soap_in_PointerToeoddata1__ArrayOfDATAFORMAT(soap, NULL, NULL, "eoddata1:ArrayOfDATAFORMAT");
	case SOAP_TYPE_eoddata_PointerToeoddata1__ArrayOfNEWS:
		return soap_in_PointerToeoddata1__ArrayOfNEWS(soap, NULL, NULL, "eoddata1:ArrayOfNEWS");
	case SOAP_TYPE_eoddata_PointerToeoddata1__ArrayOfSYMBOLCHANGE:
		return soap_in_PointerToeoddata1__ArrayOfSYMBOLCHANGE(soap, NULL, NULL, "eoddata1:ArrayOfSYMBOLCHANGE");
	case SOAP_TYPE_eoddata_PointerToeoddata1__ArrayOfTECHNICAL:
		return soap_in_PointerToeoddata1__ArrayOfTECHNICAL(soap, NULL, NULL, "eoddata1:ArrayOfTECHNICAL");
	case SOAP_TYPE_eoddata_PointerToeoddata1__ArrayOfFUNDAMENTAL:
		return soap_in_PointerToeoddata1__ArrayOfFUNDAMENTAL(soap, NULL, NULL, "eoddata1:ArrayOfFUNDAMENTAL");
	case SOAP_TYPE_eoddata_PointerToeoddata1__ArrayOfCountryBase:
		return soap_in_PointerToeoddata1__ArrayOfCountryBase(soap, NULL, NULL, "eoddata1:ArrayOfCountryBase");
	case SOAP_TYPE_eoddata_PointerToeoddata1__ArrayOfSPLIT:
		return soap_in_PointerToeoddata1__ArrayOfSPLIT(soap, NULL, NULL, "eoddata1:ArrayOfSPLIT");
	case SOAP_TYPE_eoddata_PointerToeoddata1__ArrayOfQUOTE2:
		return soap_in_PointerToeoddata1__ArrayOfQUOTE2(soap, NULL, NULL, "eoddata1:ArrayOfQUOTE2");
	case SOAP_TYPE_eoddata_PointerToeoddata1__ArrayOfQUOTE:
		return soap_in_PointerToeoddata1__ArrayOfQUOTE(soap, NULL, NULL, "eoddata1:ArrayOfQUOTE");
	case SOAP_TYPE_eoddata_PointerToeoddata1__QUOTE:
		return soap_in_PointerToeoddata1__QUOTE(soap, NULL, NULL, "eoddata1:QUOTE");
	case SOAP_TYPE_eoddata_PointerToeoddata1__ArrayOfSYMBOL2:
		return soap_in_PointerToeoddata1__ArrayOfSYMBOL2(soap, NULL, NULL, "eoddata1:ArrayOfSYMBOL2");
	case SOAP_TYPE_eoddata_PointerToeoddata1__ArrayOfSYMBOL:
		return soap_in_PointerToeoddata1__ArrayOfSYMBOL(soap, NULL, NULL, "eoddata1:ArrayOfSYMBOL");
	case SOAP_TYPE_eoddata_PointerToeoddata1__SYMBOL:
		return soap_in_PointerToeoddata1__SYMBOL(soap, NULL, NULL, "eoddata1:SYMBOL");
	case SOAP_TYPE_eoddata_PointerToeoddata1__ArrayOfEXCHANGE:
		return soap_in_PointerToeoddata1__ArrayOfEXCHANGE(soap, NULL, NULL, "eoddata1:ArrayOfEXCHANGE");
	case SOAP_TYPE_eoddata_PointerToeoddata1__EXCHANGE:
		return soap_in_PointerToeoddata1__EXCHANGE(soap, NULL, NULL, "eoddata1:EXCHANGE");
	case SOAP_TYPE_eoddata_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_eoddata__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_eoddata_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_eoddata_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:DATAFORMAT_COLUMN"))
		{	*type = SOAP_TYPE_eoddata_eoddata1__DATAFORMAT_USCORECOLUMN;
			return soap_in_eoddata1__DATAFORMAT_USCORECOLUMN(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:ArrayOfDATAFORMAT_COLUMN"))
		{	*type = SOAP_TYPE_eoddata_eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN;
			return soap_in_eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:DATAFORMAT"))
		{	*type = SOAP_TYPE_eoddata_eoddata1__DATAFORMAT;
			return soap_in_eoddata1__DATAFORMAT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:ArrayOfDATAFORMAT"))
		{	*type = SOAP_TYPE_eoddata_eoddata1__ArrayOfDATAFORMAT;
			return soap_in_eoddata1__ArrayOfDATAFORMAT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:NEWS"))
		{	*type = SOAP_TYPE_eoddata_eoddata1__NEWS;
			return soap_in_eoddata1__NEWS(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:ArrayOfNEWS"))
		{	*type = SOAP_TYPE_eoddata_eoddata1__ArrayOfNEWS;
			return soap_in_eoddata1__ArrayOfNEWS(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:SYMBOLCHANGE"))
		{	*type = SOAP_TYPE_eoddata_eoddata1__SYMBOLCHANGE;
			return soap_in_eoddata1__SYMBOLCHANGE(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:ArrayOfSYMBOLCHANGE"))
		{	*type = SOAP_TYPE_eoddata_eoddata1__ArrayOfSYMBOLCHANGE;
			return soap_in_eoddata1__ArrayOfSYMBOLCHANGE(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:TECHNICAL"))
		{	*type = SOAP_TYPE_eoddata_eoddata1__TECHNICAL;
			return soap_in_eoddata1__TECHNICAL(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:ArrayOfTECHNICAL"))
		{	*type = SOAP_TYPE_eoddata_eoddata1__ArrayOfTECHNICAL;
			return soap_in_eoddata1__ArrayOfTECHNICAL(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:FUNDAMENTAL"))
		{	*type = SOAP_TYPE_eoddata_eoddata1__FUNDAMENTAL;
			return soap_in_eoddata1__FUNDAMENTAL(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:ArrayOfFUNDAMENTAL"))
		{	*type = SOAP_TYPE_eoddata_eoddata1__ArrayOfFUNDAMENTAL;
			return soap_in_eoddata1__ArrayOfFUNDAMENTAL(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:CountryBase"))
		{	*type = SOAP_TYPE_eoddata_eoddata1__CountryBase;
			return soap_in_eoddata1__CountryBase(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:ArrayOfCountryBase"))
		{	*type = SOAP_TYPE_eoddata_eoddata1__ArrayOfCountryBase;
			return soap_in_eoddata1__ArrayOfCountryBase(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:SPLIT"))
		{	*type = SOAP_TYPE_eoddata_eoddata1__SPLIT;
			return soap_in_eoddata1__SPLIT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:ArrayOfSPLIT"))
		{	*type = SOAP_TYPE_eoddata_eoddata1__ArrayOfSPLIT;
			return soap_in_eoddata1__ArrayOfSPLIT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:QUOTE2"))
		{	*type = SOAP_TYPE_eoddata_eoddata1__QUOTE2;
			return soap_in_eoddata1__QUOTE2(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:ArrayOfQUOTE2"))
		{	*type = SOAP_TYPE_eoddata_eoddata1__ArrayOfQUOTE2;
			return soap_in_eoddata1__ArrayOfQUOTE2(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:ArrayOfQUOTE"))
		{	*type = SOAP_TYPE_eoddata_eoddata1__ArrayOfQUOTE;
			return soap_in_eoddata1__ArrayOfQUOTE(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:QUOTE"))
		{	*type = SOAP_TYPE_eoddata_eoddata1__QUOTE;
			return soap_in_eoddata1__QUOTE(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:SYMBOL2"))
		{	*type = SOAP_TYPE_eoddata_eoddata1__SYMBOL2;
			return soap_in_eoddata1__SYMBOL2(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:ArrayOfSYMBOL2"))
		{	*type = SOAP_TYPE_eoddata_eoddata1__ArrayOfSYMBOL2;
			return soap_in_eoddata1__ArrayOfSYMBOL2(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:ArrayOfSYMBOL"))
		{	*type = SOAP_TYPE_eoddata_eoddata1__ArrayOfSYMBOL;
			return soap_in_eoddata1__ArrayOfSYMBOL(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:SYMBOL"))
		{	*type = SOAP_TYPE_eoddata_eoddata1__SYMBOL;
			return soap_in_eoddata1__SYMBOL(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:ArrayOfEXCHANGE"))
		{	*type = SOAP_TYPE_eoddata_eoddata1__ArrayOfEXCHANGE;
			return soap_in_eoddata1__ArrayOfEXCHANGE(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:EXCHANGE"))
		{	*type = SOAP_TYPE_eoddata_eoddata1__EXCHANGE;
			return soap_in_eoddata1__EXCHANGE(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:RESPONSE"))
		{	*type = SOAP_TYPE_eoddata_eoddata1__RESPONSE;
			return soap_in_eoddata1__RESPONSE(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:LOGINRESPONSE"))
		{	*type = SOAP_TYPE_eoddata_eoddata1__LOGINRESPONSE;
			return soap_in_eoddata1__LOGINRESPONSE(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_eoddata_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_eoddata_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_eoddata_LONG64;
			return soap_in_LONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_eoddata_double;
			return soap_in_double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_eoddata_dateTime;
			return soap_in_dateTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_eoddata_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE_eoddata__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_eoddata_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "eoddata1:ValidateAccessResponse"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__ValidateAccessResponse;
			return soap_in__eoddata1__ValidateAccessResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:ValidateAccess"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__ValidateAccess;
			return soap_in__eoddata1__ValidateAccess(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:UpdateDataFormatResponse"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__UpdateDataFormatResponse;
			return soap_in__eoddata1__UpdateDataFormatResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:UpdateDataFormat"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__UpdateDataFormat;
			return soap_in__eoddata1__UpdateDataFormat(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:DataFormatsResponse"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__DataFormatsResponse;
			return soap_in__eoddata1__DataFormatsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:DataFormats"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__DataFormats;
			return soap_in__eoddata1__DataFormats(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:DataClientLatestVersionResponse"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__DataClientLatestVersionResponse;
			return soap_in__eoddata1__DataClientLatestVersionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:DataClientLatestVersion"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__DataClientLatestVersion;
			return soap_in__eoddata1__DataClientLatestVersion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:SymbolChangesByExchangeResponse"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__SymbolChangesByExchangeResponse;
			return soap_in__eoddata1__SymbolChangesByExchangeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:SymbolChangesByExchange"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__SymbolChangesByExchange;
			return soap_in__eoddata1__SymbolChangesByExchange(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:QuoteListByDatePeriod2Response"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__QuoteListByDatePeriod2Response;
			return soap_in__eoddata1__QuoteListByDatePeriod2Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:QuoteListByDatePeriod2"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__QuoteListByDatePeriod2;
			return soap_in__eoddata1__QuoteListByDatePeriod2(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:QuoteListByDatePeriodResponse"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__QuoteListByDatePeriodResponse;
			return soap_in__eoddata1__QuoteListByDatePeriodResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:QuoteListByDatePeriod"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__QuoteListByDatePeriod;
			return soap_in__eoddata1__QuoteListByDatePeriod(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:SymbolHistoryPeriodByDateRangeResponse"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__SymbolHistoryPeriodByDateRangeResponse;
			return soap_in__eoddata1__SymbolHistoryPeriodByDateRangeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:SymbolHistoryPeriodByDateRange"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__SymbolHistoryPeriodByDateRange;
			return soap_in__eoddata1__SymbolHistoryPeriodByDateRange(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:SymbolHistoryPeriodResponse"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__SymbolHistoryPeriodResponse;
			return soap_in__eoddata1__SymbolHistoryPeriodResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:SymbolHistoryPeriod"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__SymbolHistoryPeriod;
			return soap_in__eoddata1__SymbolHistoryPeriod(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:CountryListResponse"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__CountryListResponse;
			return soap_in__eoddata1__CountryListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:CountryList"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__CountryList;
			return soap_in__eoddata1__CountryList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:SplitListBySymbolResponse"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__SplitListBySymbolResponse;
			return soap_in__eoddata1__SplitListBySymbolResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:SplitListBySymbol"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__SplitListBySymbol;
			return soap_in__eoddata1__SplitListBySymbol(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:SplitListByExchangeResponse"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__SplitListByExchangeResponse;
			return soap_in__eoddata1__SplitListByExchangeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:SplitListByExchange"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__SplitListByExchange;
			return soap_in__eoddata1__SplitListByExchange(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:ExchangeMonthsResponse"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__ExchangeMonthsResponse;
			return soap_in__eoddata1__ExchangeMonthsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:ExchangeMonths"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__ExchangeMonths;
			return soap_in__eoddata1__ExchangeMonths(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:SymbolChartResponse"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__SymbolChartResponse;
			return soap_in__eoddata1__SymbolChartResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:SymbolChart"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__SymbolChart;
			return soap_in__eoddata1__SymbolChart(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:Top10LossesResponse"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__Top10LossesResponse;
			return soap_in__eoddata1__Top10LossesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:Top10Losses"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__Top10Losses;
			return soap_in__eoddata1__Top10Losses(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:Top10GainsResponse"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__Top10GainsResponse;
			return soap_in__eoddata1__Top10GainsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:Top10Gains"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__Top10Gains;
			return soap_in__eoddata1__Top10Gains(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:SymbolHistoryResponse"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__SymbolHistoryResponse;
			return soap_in__eoddata1__SymbolHistoryResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:SymbolHistory"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__SymbolHistory;
			return soap_in__eoddata1__SymbolHistory(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:QuoteListByDate2Response"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__QuoteListByDate2Response;
			return soap_in__eoddata1__QuoteListByDate2Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:QuoteListByDate2"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__QuoteListByDate2;
			return soap_in__eoddata1__QuoteListByDate2(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:QuoteListByDateResponse"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__QuoteListByDateResponse;
			return soap_in__eoddata1__QuoteListByDateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:QuoteListByDate"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__QuoteListByDate;
			return soap_in__eoddata1__QuoteListByDate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:TechnicalListResponse"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__TechnicalListResponse;
			return soap_in__eoddata1__TechnicalListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:TechnicalList"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__TechnicalList;
			return soap_in__eoddata1__TechnicalList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:FundamentalListResponse"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__FundamentalListResponse;
			return soap_in__eoddata1__FundamentalListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:FundamentalList"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__FundamentalList;
			return soap_in__eoddata1__FundamentalList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:NewsListBySymbolResponse"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__NewsListBySymbolResponse;
			return soap_in__eoddata1__NewsListBySymbolResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:NewsListBySymbol"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__NewsListBySymbol;
			return soap_in__eoddata1__NewsListBySymbol(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:NewsListResponse"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__NewsListResponse;
			return soap_in__eoddata1__NewsListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:NewsList"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__NewsList;
			return soap_in__eoddata1__NewsList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:QuoteListResponse"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__QuoteListResponse;
			return soap_in__eoddata1__QuoteListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:QuoteList"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__QuoteList;
			return soap_in__eoddata1__QuoteList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:SymbolGetResponse"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__SymbolGetResponse;
			return soap_in__eoddata1__SymbolGetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:SymbolGet"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__SymbolGet;
			return soap_in__eoddata1__SymbolGet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:QuoteList2Response"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__QuoteList2Response;
			return soap_in__eoddata1__QuoteList2Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:QuoteList2"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__QuoteList2;
			return soap_in__eoddata1__QuoteList2(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:QuoteGetResponse"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__QuoteGetResponse;
			return soap_in__eoddata1__QuoteGetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:QuoteGet"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__QuoteGet;
			return soap_in__eoddata1__QuoteGet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:SymbolList2Response"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__SymbolList2Response;
			return soap_in__eoddata1__SymbolList2Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:SymbolList2"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__SymbolList2;
			return soap_in__eoddata1__SymbolList2(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:SymbolListResponse"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__SymbolListResponse;
			return soap_in__eoddata1__SymbolListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:SymbolList"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__SymbolList;
			return soap_in__eoddata1__SymbolList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:ExchangeGetResponse"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__ExchangeGetResponse;
			return soap_in__eoddata1__ExchangeGetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:ExchangeGet"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__ExchangeGet;
			return soap_in__eoddata1__ExchangeGet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:ExchangeListResponse"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__ExchangeListResponse;
			return soap_in__eoddata1__ExchangeListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:ExchangeList"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__ExchangeList;
			return soap_in__eoddata1__ExchangeList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:MembershipResponse"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__MembershipResponse;
			return soap_in__eoddata1__MembershipResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:Membership"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__Membership;
			return soap_in__eoddata1__Membership(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:Login2Response"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__Login2Response;
			return soap_in__eoddata1__Login2Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:Login2"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__Login2;
			return soap_in__eoddata1__Login2(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:LoginResponse"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__LoginResponse;
			return soap_in__eoddata1__LoginResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "eoddata1:Login"))
		{	*type = SOAP_TYPE_eoddata__eoddata1__Login;
			return soap_in__eoddata1__Login(soap, NULL, NULL, NULL);
		}
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level = %u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_eoddata_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_eoddata_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_eoddata_LONG64:
		return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_eoddata_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_eoddata_dateTime:
		return soap_out_dateTime(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_eoddata_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_eoddata_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_eoddata__eoddata1__ValidateAccessResponse:
		return ((_eoddata1__ValidateAccessResponse *)ptr)->soap_out(soap, "eoddata1:ValidateAccessResponse", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__ValidateAccess:
		return ((_eoddata1__ValidateAccess *)ptr)->soap_out(soap, "eoddata1:ValidateAccess", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__UpdateDataFormatResponse:
		return ((_eoddata1__UpdateDataFormatResponse *)ptr)->soap_out(soap, "eoddata1:UpdateDataFormatResponse", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__UpdateDataFormat:
		return ((_eoddata1__UpdateDataFormat *)ptr)->soap_out(soap, "eoddata1:UpdateDataFormat", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__DataFormatsResponse:
		return ((_eoddata1__DataFormatsResponse *)ptr)->soap_out(soap, "eoddata1:DataFormatsResponse", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__DataFormats:
		return ((_eoddata1__DataFormats *)ptr)->soap_out(soap, "eoddata1:DataFormats", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__DataClientLatestVersionResponse:
		return ((_eoddata1__DataClientLatestVersionResponse *)ptr)->soap_out(soap, "eoddata1:DataClientLatestVersionResponse", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__DataClientLatestVersion:
		return ((_eoddata1__DataClientLatestVersion *)ptr)->soap_out(soap, "eoddata1:DataClientLatestVersion", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__SymbolChangesByExchangeResponse:
		return ((_eoddata1__SymbolChangesByExchangeResponse *)ptr)->soap_out(soap, "eoddata1:SymbolChangesByExchangeResponse", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__SymbolChangesByExchange:
		return ((_eoddata1__SymbolChangesByExchange *)ptr)->soap_out(soap, "eoddata1:SymbolChangesByExchange", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__QuoteListByDatePeriod2Response:
		return ((_eoddata1__QuoteListByDatePeriod2Response *)ptr)->soap_out(soap, "eoddata1:QuoteListByDatePeriod2Response", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__QuoteListByDatePeriod2:
		return ((_eoddata1__QuoteListByDatePeriod2 *)ptr)->soap_out(soap, "eoddata1:QuoteListByDatePeriod2", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__QuoteListByDatePeriodResponse:
		return ((_eoddata1__QuoteListByDatePeriodResponse *)ptr)->soap_out(soap, "eoddata1:QuoteListByDatePeriodResponse", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__QuoteListByDatePeriod:
		return ((_eoddata1__QuoteListByDatePeriod *)ptr)->soap_out(soap, "eoddata1:QuoteListByDatePeriod", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__SymbolHistoryPeriodByDateRangeResponse:
		return ((_eoddata1__SymbolHistoryPeriodByDateRangeResponse *)ptr)->soap_out(soap, "eoddata1:SymbolHistoryPeriodByDateRangeResponse", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__SymbolHistoryPeriodByDateRange:
		return ((_eoddata1__SymbolHistoryPeriodByDateRange *)ptr)->soap_out(soap, "eoddata1:SymbolHistoryPeriodByDateRange", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__SymbolHistoryPeriodResponse:
		return ((_eoddata1__SymbolHistoryPeriodResponse *)ptr)->soap_out(soap, "eoddata1:SymbolHistoryPeriodResponse", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__SymbolHistoryPeriod:
		return ((_eoddata1__SymbolHistoryPeriod *)ptr)->soap_out(soap, "eoddata1:SymbolHistoryPeriod", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__CountryListResponse:
		return ((_eoddata1__CountryListResponse *)ptr)->soap_out(soap, "eoddata1:CountryListResponse", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__CountryList:
		return ((_eoddata1__CountryList *)ptr)->soap_out(soap, "eoddata1:CountryList", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__SplitListBySymbolResponse:
		return ((_eoddata1__SplitListBySymbolResponse *)ptr)->soap_out(soap, "eoddata1:SplitListBySymbolResponse", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__SplitListBySymbol:
		return ((_eoddata1__SplitListBySymbol *)ptr)->soap_out(soap, "eoddata1:SplitListBySymbol", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__SplitListByExchangeResponse:
		return ((_eoddata1__SplitListByExchangeResponse *)ptr)->soap_out(soap, "eoddata1:SplitListByExchangeResponse", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__SplitListByExchange:
		return ((_eoddata1__SplitListByExchange *)ptr)->soap_out(soap, "eoddata1:SplitListByExchange", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__ExchangeMonthsResponse:
		return ((_eoddata1__ExchangeMonthsResponse *)ptr)->soap_out(soap, "eoddata1:ExchangeMonthsResponse", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__ExchangeMonths:
		return ((_eoddata1__ExchangeMonths *)ptr)->soap_out(soap, "eoddata1:ExchangeMonths", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__SymbolChartResponse:
		return ((_eoddata1__SymbolChartResponse *)ptr)->soap_out(soap, "eoddata1:SymbolChartResponse", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__SymbolChart:
		return ((_eoddata1__SymbolChart *)ptr)->soap_out(soap, "eoddata1:SymbolChart", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__Top10LossesResponse:
		return ((_eoddata1__Top10LossesResponse *)ptr)->soap_out(soap, "eoddata1:Top10LossesResponse", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__Top10Losses:
		return ((_eoddata1__Top10Losses *)ptr)->soap_out(soap, "eoddata1:Top10Losses", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__Top10GainsResponse:
		return ((_eoddata1__Top10GainsResponse *)ptr)->soap_out(soap, "eoddata1:Top10GainsResponse", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__Top10Gains:
		return ((_eoddata1__Top10Gains *)ptr)->soap_out(soap, "eoddata1:Top10Gains", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__SymbolHistoryResponse:
		return ((_eoddata1__SymbolHistoryResponse *)ptr)->soap_out(soap, "eoddata1:SymbolHistoryResponse", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__SymbolHistory:
		return ((_eoddata1__SymbolHistory *)ptr)->soap_out(soap, "eoddata1:SymbolHistory", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__QuoteListByDate2Response:
		return ((_eoddata1__QuoteListByDate2Response *)ptr)->soap_out(soap, "eoddata1:QuoteListByDate2Response", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__QuoteListByDate2:
		return ((_eoddata1__QuoteListByDate2 *)ptr)->soap_out(soap, "eoddata1:QuoteListByDate2", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__QuoteListByDateResponse:
		return ((_eoddata1__QuoteListByDateResponse *)ptr)->soap_out(soap, "eoddata1:QuoteListByDateResponse", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__QuoteListByDate:
		return ((_eoddata1__QuoteListByDate *)ptr)->soap_out(soap, "eoddata1:QuoteListByDate", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__TechnicalListResponse:
		return ((_eoddata1__TechnicalListResponse *)ptr)->soap_out(soap, "eoddata1:TechnicalListResponse", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__TechnicalList:
		return ((_eoddata1__TechnicalList *)ptr)->soap_out(soap, "eoddata1:TechnicalList", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__FundamentalListResponse:
		return ((_eoddata1__FundamentalListResponse *)ptr)->soap_out(soap, "eoddata1:FundamentalListResponse", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__FundamentalList:
		return ((_eoddata1__FundamentalList *)ptr)->soap_out(soap, "eoddata1:FundamentalList", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__NewsListBySymbolResponse:
		return ((_eoddata1__NewsListBySymbolResponse *)ptr)->soap_out(soap, "eoddata1:NewsListBySymbolResponse", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__NewsListBySymbol:
		return ((_eoddata1__NewsListBySymbol *)ptr)->soap_out(soap, "eoddata1:NewsListBySymbol", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__NewsListResponse:
		return ((_eoddata1__NewsListResponse *)ptr)->soap_out(soap, "eoddata1:NewsListResponse", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__NewsList:
		return ((_eoddata1__NewsList *)ptr)->soap_out(soap, "eoddata1:NewsList", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__QuoteListResponse:
		return ((_eoddata1__QuoteListResponse *)ptr)->soap_out(soap, "eoddata1:QuoteListResponse", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__QuoteList:
		return ((_eoddata1__QuoteList *)ptr)->soap_out(soap, "eoddata1:QuoteList", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__SymbolGetResponse:
		return ((_eoddata1__SymbolGetResponse *)ptr)->soap_out(soap, "eoddata1:SymbolGetResponse", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__SymbolGet:
		return ((_eoddata1__SymbolGet *)ptr)->soap_out(soap, "eoddata1:SymbolGet", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__QuoteList2Response:
		return ((_eoddata1__QuoteList2Response *)ptr)->soap_out(soap, "eoddata1:QuoteList2Response", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__QuoteList2:
		return ((_eoddata1__QuoteList2 *)ptr)->soap_out(soap, "eoddata1:QuoteList2", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__QuoteGetResponse:
		return ((_eoddata1__QuoteGetResponse *)ptr)->soap_out(soap, "eoddata1:QuoteGetResponse", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__QuoteGet:
		return ((_eoddata1__QuoteGet *)ptr)->soap_out(soap, "eoddata1:QuoteGet", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__SymbolList2Response:
		return ((_eoddata1__SymbolList2Response *)ptr)->soap_out(soap, "eoddata1:SymbolList2Response", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__SymbolList2:
		return ((_eoddata1__SymbolList2 *)ptr)->soap_out(soap, "eoddata1:SymbolList2", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__SymbolListResponse:
		return ((_eoddata1__SymbolListResponse *)ptr)->soap_out(soap, "eoddata1:SymbolListResponse", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__SymbolList:
		return ((_eoddata1__SymbolList *)ptr)->soap_out(soap, "eoddata1:SymbolList", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__ExchangeGetResponse:
		return ((_eoddata1__ExchangeGetResponse *)ptr)->soap_out(soap, "eoddata1:ExchangeGetResponse", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__ExchangeGet:
		return ((_eoddata1__ExchangeGet *)ptr)->soap_out(soap, "eoddata1:ExchangeGet", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__ExchangeListResponse:
		return ((_eoddata1__ExchangeListResponse *)ptr)->soap_out(soap, "eoddata1:ExchangeListResponse", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__ExchangeList:
		return ((_eoddata1__ExchangeList *)ptr)->soap_out(soap, "eoddata1:ExchangeList", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__MembershipResponse:
		return ((_eoddata1__MembershipResponse *)ptr)->soap_out(soap, "eoddata1:MembershipResponse", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__Membership:
		return ((_eoddata1__Membership *)ptr)->soap_out(soap, "eoddata1:Membership", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__Login2Response:
		return ((_eoddata1__Login2Response *)ptr)->soap_out(soap, "eoddata1:Login2Response", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__Login2:
		return ((_eoddata1__Login2 *)ptr)->soap_out(soap, "eoddata1:Login2", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__LoginResponse:
		return ((_eoddata1__LoginResponse *)ptr)->soap_out(soap, "eoddata1:LoginResponse", id, NULL);
	case SOAP_TYPE_eoddata__eoddata1__Login:
		return ((_eoddata1__Login *)ptr)->soap_out(soap, "eoddata1:Login", id, NULL);
	case SOAP_TYPE_eoddata_eoddata1__DATAFORMAT_USCORECOLUMN:
		return ((eoddata1__DATAFORMAT_USCORECOLUMN *)ptr)->soap_out(soap, tag, id, "eoddata1:DATAFORMAT_COLUMN");
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN:
		return ((eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN *)ptr)->soap_out(soap, tag, id, "eoddata1:ArrayOfDATAFORMAT_COLUMN");
	case SOAP_TYPE_eoddata_eoddata1__DATAFORMAT:
		return ((eoddata1__DATAFORMAT *)ptr)->soap_out(soap, tag, id, "eoddata1:DATAFORMAT");
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfDATAFORMAT:
		return ((eoddata1__ArrayOfDATAFORMAT *)ptr)->soap_out(soap, tag, id, "eoddata1:ArrayOfDATAFORMAT");
	case SOAP_TYPE_eoddata_eoddata1__NEWS:
		return ((eoddata1__NEWS *)ptr)->soap_out(soap, tag, id, "eoddata1:NEWS");
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfNEWS:
		return ((eoddata1__ArrayOfNEWS *)ptr)->soap_out(soap, tag, id, "eoddata1:ArrayOfNEWS");
	case SOAP_TYPE_eoddata_eoddata1__SYMBOLCHANGE:
		return ((eoddata1__SYMBOLCHANGE *)ptr)->soap_out(soap, tag, id, "eoddata1:SYMBOLCHANGE");
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfSYMBOLCHANGE:
		return ((eoddata1__ArrayOfSYMBOLCHANGE *)ptr)->soap_out(soap, tag, id, "eoddata1:ArrayOfSYMBOLCHANGE");
	case SOAP_TYPE_eoddata_eoddata1__TECHNICAL:
		return ((eoddata1__TECHNICAL *)ptr)->soap_out(soap, tag, id, "eoddata1:TECHNICAL");
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfTECHNICAL:
		return ((eoddata1__ArrayOfTECHNICAL *)ptr)->soap_out(soap, tag, id, "eoddata1:ArrayOfTECHNICAL");
	case SOAP_TYPE_eoddata_eoddata1__FUNDAMENTAL:
		return ((eoddata1__FUNDAMENTAL *)ptr)->soap_out(soap, tag, id, "eoddata1:FUNDAMENTAL");
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfFUNDAMENTAL:
		return ((eoddata1__ArrayOfFUNDAMENTAL *)ptr)->soap_out(soap, tag, id, "eoddata1:ArrayOfFUNDAMENTAL");
	case SOAP_TYPE_eoddata_eoddata1__CountryBase:
		return ((eoddata1__CountryBase *)ptr)->soap_out(soap, tag, id, "eoddata1:CountryBase");
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfCountryBase:
		return ((eoddata1__ArrayOfCountryBase *)ptr)->soap_out(soap, tag, id, "eoddata1:ArrayOfCountryBase");
	case SOAP_TYPE_eoddata_eoddata1__SPLIT:
		return ((eoddata1__SPLIT *)ptr)->soap_out(soap, tag, id, "eoddata1:SPLIT");
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfSPLIT:
		return ((eoddata1__ArrayOfSPLIT *)ptr)->soap_out(soap, tag, id, "eoddata1:ArrayOfSPLIT");
	case SOAP_TYPE_eoddata_eoddata1__QUOTE2:
		return ((eoddata1__QUOTE2 *)ptr)->soap_out(soap, tag, id, "eoddata1:QUOTE2");
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfQUOTE2:
		return ((eoddata1__ArrayOfQUOTE2 *)ptr)->soap_out(soap, tag, id, "eoddata1:ArrayOfQUOTE2");
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfQUOTE:
		return ((eoddata1__ArrayOfQUOTE *)ptr)->soap_out(soap, tag, id, "eoddata1:ArrayOfQUOTE");
	case SOAP_TYPE_eoddata_eoddata1__QUOTE:
		return ((eoddata1__QUOTE *)ptr)->soap_out(soap, tag, id, "eoddata1:QUOTE");
	case SOAP_TYPE_eoddata_eoddata1__SYMBOL2:
		return ((eoddata1__SYMBOL2 *)ptr)->soap_out(soap, tag, id, "eoddata1:SYMBOL2");
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfSYMBOL2:
		return ((eoddata1__ArrayOfSYMBOL2 *)ptr)->soap_out(soap, tag, id, "eoddata1:ArrayOfSYMBOL2");
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfSYMBOL:
		return ((eoddata1__ArrayOfSYMBOL *)ptr)->soap_out(soap, tag, id, "eoddata1:ArrayOfSYMBOL");
	case SOAP_TYPE_eoddata_eoddata1__SYMBOL:
		return ((eoddata1__SYMBOL *)ptr)->soap_out(soap, tag, id, "eoddata1:SYMBOL");
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfEXCHANGE:
		return ((eoddata1__ArrayOfEXCHANGE *)ptr)->soap_out(soap, tag, id, "eoddata1:ArrayOfEXCHANGE");
	case SOAP_TYPE_eoddata_eoddata1__EXCHANGE:
		return ((eoddata1__EXCHANGE *)ptr)->soap_out(soap, tag, id, "eoddata1:EXCHANGE");
	case SOAP_TYPE_eoddata_eoddata1__RESPONSE:
		return ((eoddata1__RESPONSE *)ptr)->soap_out(soap, tag, id, "eoddata1:RESPONSE");
	case SOAP_TYPE_eoddata_eoddata1__LOGINRESPONSE:
		return ((eoddata1__LOGINRESPONSE *)ptr)->soap_out(soap, tag, id, "eoddata1:LOGINRESPONSE");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__ValidateAccess:
		return soap_out_PointerTo_eoddata1__ValidateAccess(soap, tag, id, (_eoddata1__ValidateAccess *const*)ptr, "eoddata1:ValidateAccess");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__UpdateDataFormat:
		return soap_out_PointerTo_eoddata1__UpdateDataFormat(soap, tag, id, (_eoddata1__UpdateDataFormat *const*)ptr, "eoddata1:UpdateDataFormat");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__DataFormats:
		return soap_out_PointerTo_eoddata1__DataFormats(soap, tag, id, (_eoddata1__DataFormats *const*)ptr, "eoddata1:DataFormats");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__DataClientLatestVersion:
		return soap_out_PointerTo_eoddata1__DataClientLatestVersion(soap, tag, id, (_eoddata1__DataClientLatestVersion *const*)ptr, "eoddata1:DataClientLatestVersion");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__SymbolChangesByExchange:
		return soap_out_PointerTo_eoddata1__SymbolChangesByExchange(soap, tag, id, (_eoddata1__SymbolChangesByExchange *const*)ptr, "eoddata1:SymbolChangesByExchange");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__QuoteListByDatePeriod2:
		return soap_out_PointerTo_eoddata1__QuoteListByDatePeriod2(soap, tag, id, (_eoddata1__QuoteListByDatePeriod2 *const*)ptr, "eoddata1:QuoteListByDatePeriod2");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__QuoteListByDatePeriod:
		return soap_out_PointerTo_eoddata1__QuoteListByDatePeriod(soap, tag, id, (_eoddata1__QuoteListByDatePeriod *const*)ptr, "eoddata1:QuoteListByDatePeriod");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__SymbolHistoryPeriodByDateRange:
		return soap_out_PointerTo_eoddata1__SymbolHistoryPeriodByDateRange(soap, tag, id, (_eoddata1__SymbolHistoryPeriodByDateRange *const*)ptr, "eoddata1:SymbolHistoryPeriodByDateRange");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__SymbolHistoryPeriod:
		return soap_out_PointerTo_eoddata1__SymbolHistoryPeriod(soap, tag, id, (_eoddata1__SymbolHistoryPeriod *const*)ptr, "eoddata1:SymbolHistoryPeriod");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__CountryList:
		return soap_out_PointerTo_eoddata1__CountryList(soap, tag, id, (_eoddata1__CountryList *const*)ptr, "eoddata1:CountryList");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__SplitListBySymbol:
		return soap_out_PointerTo_eoddata1__SplitListBySymbol(soap, tag, id, (_eoddata1__SplitListBySymbol *const*)ptr, "eoddata1:SplitListBySymbol");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__SplitListByExchange:
		return soap_out_PointerTo_eoddata1__SplitListByExchange(soap, tag, id, (_eoddata1__SplitListByExchange *const*)ptr, "eoddata1:SplitListByExchange");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__ExchangeMonths:
		return soap_out_PointerTo_eoddata1__ExchangeMonths(soap, tag, id, (_eoddata1__ExchangeMonths *const*)ptr, "eoddata1:ExchangeMonths");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__SymbolChart:
		return soap_out_PointerTo_eoddata1__SymbolChart(soap, tag, id, (_eoddata1__SymbolChart *const*)ptr, "eoddata1:SymbolChart");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__Top10Losses:
		return soap_out_PointerTo_eoddata1__Top10Losses(soap, tag, id, (_eoddata1__Top10Losses *const*)ptr, "eoddata1:Top10Losses");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__Top10Gains:
		return soap_out_PointerTo_eoddata1__Top10Gains(soap, tag, id, (_eoddata1__Top10Gains *const*)ptr, "eoddata1:Top10Gains");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__SymbolHistory:
		return soap_out_PointerTo_eoddata1__SymbolHistory(soap, tag, id, (_eoddata1__SymbolHistory *const*)ptr, "eoddata1:SymbolHistory");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__QuoteListByDate2:
		return soap_out_PointerTo_eoddata1__QuoteListByDate2(soap, tag, id, (_eoddata1__QuoteListByDate2 *const*)ptr, "eoddata1:QuoteListByDate2");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__QuoteListByDate:
		return soap_out_PointerTo_eoddata1__QuoteListByDate(soap, tag, id, (_eoddata1__QuoteListByDate *const*)ptr, "eoddata1:QuoteListByDate");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__TechnicalList:
		return soap_out_PointerTo_eoddata1__TechnicalList(soap, tag, id, (_eoddata1__TechnicalList *const*)ptr, "eoddata1:TechnicalList");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__FundamentalList:
		return soap_out_PointerTo_eoddata1__FundamentalList(soap, tag, id, (_eoddata1__FundamentalList *const*)ptr, "eoddata1:FundamentalList");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__NewsListBySymbol:
		return soap_out_PointerTo_eoddata1__NewsListBySymbol(soap, tag, id, (_eoddata1__NewsListBySymbol *const*)ptr, "eoddata1:NewsListBySymbol");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__NewsList:
		return soap_out_PointerTo_eoddata1__NewsList(soap, tag, id, (_eoddata1__NewsList *const*)ptr, "eoddata1:NewsList");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__QuoteList:
		return soap_out_PointerTo_eoddata1__QuoteList(soap, tag, id, (_eoddata1__QuoteList *const*)ptr, "eoddata1:QuoteList");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__SymbolGet:
		return soap_out_PointerTo_eoddata1__SymbolGet(soap, tag, id, (_eoddata1__SymbolGet *const*)ptr, "eoddata1:SymbolGet");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__QuoteList2:
		return soap_out_PointerTo_eoddata1__QuoteList2(soap, tag, id, (_eoddata1__QuoteList2 *const*)ptr, "eoddata1:QuoteList2");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__QuoteGet:
		return soap_out_PointerTo_eoddata1__QuoteGet(soap, tag, id, (_eoddata1__QuoteGet *const*)ptr, "eoddata1:QuoteGet");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__SymbolList2:
		return soap_out_PointerTo_eoddata1__SymbolList2(soap, tag, id, (_eoddata1__SymbolList2 *const*)ptr, "eoddata1:SymbolList2");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__SymbolList:
		return soap_out_PointerTo_eoddata1__SymbolList(soap, tag, id, (_eoddata1__SymbolList *const*)ptr, "eoddata1:SymbolList");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__ExchangeGet:
		return soap_out_PointerTo_eoddata1__ExchangeGet(soap, tag, id, (_eoddata1__ExchangeGet *const*)ptr, "eoddata1:ExchangeGet");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__ExchangeList:
		return soap_out_PointerTo_eoddata1__ExchangeList(soap, tag, id, (_eoddata1__ExchangeList *const*)ptr, "eoddata1:ExchangeList");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__Membership:
		return soap_out_PointerTo_eoddata1__Membership(soap, tag, id, (_eoddata1__Membership *const*)ptr, "eoddata1:Membership");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__Login2:
		return soap_out_PointerTo_eoddata1__Login2(soap, tag, id, (_eoddata1__Login2 *const*)ptr, "eoddata1:Login2");
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__Login:
		return soap_out_PointerTo_eoddata1__Login(soap, tag, id, (_eoddata1__Login *const*)ptr, "eoddata1:Login");
	case SOAP_TYPE_eoddata_PointerToeoddata1__RESPONSE:
		return soap_out_PointerToeoddata1__RESPONSE(soap, tag, id, (eoddata1__RESPONSE *const*)ptr, "eoddata1:RESPONSE");
	case SOAP_TYPE_eoddata_PointerToeoddata1__LOGINRESPONSE:
		return soap_out_PointerToeoddata1__LOGINRESPONSE(soap, tag, id, (eoddata1__LOGINRESPONSE *const*)ptr, "eoddata1:LOGINRESPONSE");
	case SOAP_TYPE_eoddata_PointerToeoddata1__DATAFORMAT_USCORECOLUMN:
		return soap_out_PointerToeoddata1__DATAFORMAT_USCORECOLUMN(soap, tag, id, (eoddata1__DATAFORMAT_USCORECOLUMN *const*)ptr, "eoddata1:DATAFORMAT_COLUMN");
	case SOAP_TYPE_eoddata_PointerToeoddata1__ArrayOfDATAFORMAT_USCORECOLUMN:
		return soap_out_PointerToeoddata1__ArrayOfDATAFORMAT_USCORECOLUMN(soap, tag, id, (eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN *const*)ptr, "eoddata1:ArrayOfDATAFORMAT_COLUMN");
	case SOAP_TYPE_eoddata_PointerToeoddata1__DATAFORMAT:
		return soap_out_PointerToeoddata1__DATAFORMAT(soap, tag, id, (eoddata1__DATAFORMAT *const*)ptr, "eoddata1:DATAFORMAT");
	case SOAP_TYPE_eoddata_PointerToeoddata1__NEWS:
		return soap_out_PointerToeoddata1__NEWS(soap, tag, id, (eoddata1__NEWS *const*)ptr, "eoddata1:NEWS");
	case SOAP_TYPE_eoddata_PointerToeoddata1__SYMBOLCHANGE:
		return soap_out_PointerToeoddata1__SYMBOLCHANGE(soap, tag, id, (eoddata1__SYMBOLCHANGE *const*)ptr, "eoddata1:SYMBOLCHANGE");
	case SOAP_TYPE_eoddata_PointerToeoddata1__TECHNICAL:
		return soap_out_PointerToeoddata1__TECHNICAL(soap, tag, id, (eoddata1__TECHNICAL *const*)ptr, "eoddata1:TECHNICAL");
	case SOAP_TYPE_eoddata_PointerToeoddata1__FUNDAMENTAL:
		return soap_out_PointerToeoddata1__FUNDAMENTAL(soap, tag, id, (eoddata1__FUNDAMENTAL *const*)ptr, "eoddata1:FUNDAMENTAL");
	case SOAP_TYPE_eoddata_PointerToeoddata1__CountryBase:
		return soap_out_PointerToeoddata1__CountryBase(soap, tag, id, (eoddata1__CountryBase *const*)ptr, "eoddata1:CountryBase");
	case SOAP_TYPE_eoddata_PointerToeoddata1__SPLIT:
		return soap_out_PointerToeoddata1__SPLIT(soap, tag, id, (eoddata1__SPLIT *const*)ptr, "eoddata1:SPLIT");
	case SOAP_TYPE_eoddata_PointerToeoddata1__QUOTE2:
		return soap_out_PointerToeoddata1__QUOTE2(soap, tag, id, (eoddata1__QUOTE2 *const*)ptr, "eoddata1:QUOTE2");
	case SOAP_TYPE_eoddata_PointerToeoddata1__SYMBOL2:
		return soap_out_PointerToeoddata1__SYMBOL2(soap, tag, id, (eoddata1__SYMBOL2 *const*)ptr, "eoddata1:SYMBOL2");
	case SOAP_TYPE_eoddata_PointerToeoddata1__ArrayOfDATAFORMAT:
		return soap_out_PointerToeoddata1__ArrayOfDATAFORMAT(soap, tag, id, (eoddata1__ArrayOfDATAFORMAT *const*)ptr, "eoddata1:ArrayOfDATAFORMAT");
	case SOAP_TYPE_eoddata_PointerToeoddata1__ArrayOfNEWS:
		return soap_out_PointerToeoddata1__ArrayOfNEWS(soap, tag, id, (eoddata1__ArrayOfNEWS *const*)ptr, "eoddata1:ArrayOfNEWS");
	case SOAP_TYPE_eoddata_PointerToeoddata1__ArrayOfSYMBOLCHANGE:
		return soap_out_PointerToeoddata1__ArrayOfSYMBOLCHANGE(soap, tag, id, (eoddata1__ArrayOfSYMBOLCHANGE *const*)ptr, "eoddata1:ArrayOfSYMBOLCHANGE");
	case SOAP_TYPE_eoddata_PointerToeoddata1__ArrayOfTECHNICAL:
		return soap_out_PointerToeoddata1__ArrayOfTECHNICAL(soap, tag, id, (eoddata1__ArrayOfTECHNICAL *const*)ptr, "eoddata1:ArrayOfTECHNICAL");
	case SOAP_TYPE_eoddata_PointerToeoddata1__ArrayOfFUNDAMENTAL:
		return soap_out_PointerToeoddata1__ArrayOfFUNDAMENTAL(soap, tag, id, (eoddata1__ArrayOfFUNDAMENTAL *const*)ptr, "eoddata1:ArrayOfFUNDAMENTAL");
	case SOAP_TYPE_eoddata_PointerToeoddata1__ArrayOfCountryBase:
		return soap_out_PointerToeoddata1__ArrayOfCountryBase(soap, tag, id, (eoddata1__ArrayOfCountryBase *const*)ptr, "eoddata1:ArrayOfCountryBase");
	case SOAP_TYPE_eoddata_PointerToeoddata1__ArrayOfSPLIT:
		return soap_out_PointerToeoddata1__ArrayOfSPLIT(soap, tag, id, (eoddata1__ArrayOfSPLIT *const*)ptr, "eoddata1:ArrayOfSPLIT");
	case SOAP_TYPE_eoddata_PointerToeoddata1__ArrayOfQUOTE2:
		return soap_out_PointerToeoddata1__ArrayOfQUOTE2(soap, tag, id, (eoddata1__ArrayOfQUOTE2 *const*)ptr, "eoddata1:ArrayOfQUOTE2");
	case SOAP_TYPE_eoddata_PointerToeoddata1__ArrayOfQUOTE:
		return soap_out_PointerToeoddata1__ArrayOfQUOTE(soap, tag, id, (eoddata1__ArrayOfQUOTE *const*)ptr, "eoddata1:ArrayOfQUOTE");
	case SOAP_TYPE_eoddata_PointerToeoddata1__QUOTE:
		return soap_out_PointerToeoddata1__QUOTE(soap, tag, id, (eoddata1__QUOTE *const*)ptr, "eoddata1:QUOTE");
	case SOAP_TYPE_eoddata_PointerToeoddata1__ArrayOfSYMBOL2:
		return soap_out_PointerToeoddata1__ArrayOfSYMBOL2(soap, tag, id, (eoddata1__ArrayOfSYMBOL2 *const*)ptr, "eoddata1:ArrayOfSYMBOL2");
	case SOAP_TYPE_eoddata_PointerToeoddata1__ArrayOfSYMBOL:
		return soap_out_PointerToeoddata1__ArrayOfSYMBOL(soap, tag, id, (eoddata1__ArrayOfSYMBOL *const*)ptr, "eoddata1:ArrayOfSYMBOL");
	case SOAP_TYPE_eoddata_PointerToeoddata1__SYMBOL:
		return soap_out_PointerToeoddata1__SYMBOL(soap, tag, id, (eoddata1__SYMBOL *const*)ptr, "eoddata1:SYMBOL");
	case SOAP_TYPE_eoddata_PointerToeoddata1__ArrayOfEXCHANGE:
		return soap_out_PointerToeoddata1__ArrayOfEXCHANGE(soap, tag, id, (eoddata1__ArrayOfEXCHANGE *const*)ptr, "eoddata1:ArrayOfEXCHANGE");
	case SOAP_TYPE_eoddata_PointerToeoddata1__EXCHANGE:
		return soap_out_PointerToeoddata1__EXCHANGE(soap, tag, id, (eoddata1__EXCHANGE *const*)ptr, "eoddata1:EXCHANGE");
	case SOAP_TYPE_eoddata_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE_eoddata__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_eoddata_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_eoddata_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_eoddata__eoddata1__ValidateAccessResponse:
		((_eoddata1__ValidateAccessResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__ValidateAccess:
		((_eoddata1__ValidateAccess *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__UpdateDataFormatResponse:
		((_eoddata1__UpdateDataFormatResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__UpdateDataFormat:
		((_eoddata1__UpdateDataFormat *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__DataFormatsResponse:
		((_eoddata1__DataFormatsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__DataFormats:
		((_eoddata1__DataFormats *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__DataClientLatestVersionResponse:
		((_eoddata1__DataClientLatestVersionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__DataClientLatestVersion:
		((_eoddata1__DataClientLatestVersion *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__SymbolChangesByExchangeResponse:
		((_eoddata1__SymbolChangesByExchangeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__SymbolChangesByExchange:
		((_eoddata1__SymbolChangesByExchange *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__QuoteListByDatePeriod2Response:
		((_eoddata1__QuoteListByDatePeriod2Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__QuoteListByDatePeriod2:
		((_eoddata1__QuoteListByDatePeriod2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__QuoteListByDatePeriodResponse:
		((_eoddata1__QuoteListByDatePeriodResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__QuoteListByDatePeriod:
		((_eoddata1__QuoteListByDatePeriod *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__SymbolHistoryPeriodByDateRangeResponse:
		((_eoddata1__SymbolHistoryPeriodByDateRangeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__SymbolHistoryPeriodByDateRange:
		((_eoddata1__SymbolHistoryPeriodByDateRange *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__SymbolHistoryPeriodResponse:
		((_eoddata1__SymbolHistoryPeriodResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__SymbolHistoryPeriod:
		((_eoddata1__SymbolHistoryPeriod *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__CountryListResponse:
		((_eoddata1__CountryListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__CountryList:
		((_eoddata1__CountryList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__SplitListBySymbolResponse:
		((_eoddata1__SplitListBySymbolResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__SplitListBySymbol:
		((_eoddata1__SplitListBySymbol *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__SplitListByExchangeResponse:
		((_eoddata1__SplitListByExchangeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__SplitListByExchange:
		((_eoddata1__SplitListByExchange *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__ExchangeMonthsResponse:
		((_eoddata1__ExchangeMonthsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__ExchangeMonths:
		((_eoddata1__ExchangeMonths *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__SymbolChartResponse:
		((_eoddata1__SymbolChartResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__SymbolChart:
		((_eoddata1__SymbolChart *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__Top10LossesResponse:
		((_eoddata1__Top10LossesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__Top10Losses:
		((_eoddata1__Top10Losses *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__Top10GainsResponse:
		((_eoddata1__Top10GainsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__Top10Gains:
		((_eoddata1__Top10Gains *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__SymbolHistoryResponse:
		((_eoddata1__SymbolHistoryResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__SymbolHistory:
		((_eoddata1__SymbolHistory *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__QuoteListByDate2Response:
		((_eoddata1__QuoteListByDate2Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__QuoteListByDate2:
		((_eoddata1__QuoteListByDate2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__QuoteListByDateResponse:
		((_eoddata1__QuoteListByDateResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__QuoteListByDate:
		((_eoddata1__QuoteListByDate *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__TechnicalListResponse:
		((_eoddata1__TechnicalListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__TechnicalList:
		((_eoddata1__TechnicalList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__FundamentalListResponse:
		((_eoddata1__FundamentalListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__FundamentalList:
		((_eoddata1__FundamentalList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__NewsListBySymbolResponse:
		((_eoddata1__NewsListBySymbolResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__NewsListBySymbol:
		((_eoddata1__NewsListBySymbol *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__NewsListResponse:
		((_eoddata1__NewsListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__NewsList:
		((_eoddata1__NewsList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__QuoteListResponse:
		((_eoddata1__QuoteListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__QuoteList:
		((_eoddata1__QuoteList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__SymbolGetResponse:
		((_eoddata1__SymbolGetResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__SymbolGet:
		((_eoddata1__SymbolGet *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__QuoteList2Response:
		((_eoddata1__QuoteList2Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__QuoteList2:
		((_eoddata1__QuoteList2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__QuoteGetResponse:
		((_eoddata1__QuoteGetResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__QuoteGet:
		((_eoddata1__QuoteGet *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__SymbolList2Response:
		((_eoddata1__SymbolList2Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__SymbolList2:
		((_eoddata1__SymbolList2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__SymbolListResponse:
		((_eoddata1__SymbolListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__SymbolList:
		((_eoddata1__SymbolList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__ExchangeGetResponse:
		((_eoddata1__ExchangeGetResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__ExchangeGet:
		((_eoddata1__ExchangeGet *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__ExchangeListResponse:
		((_eoddata1__ExchangeListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__ExchangeList:
		((_eoddata1__ExchangeList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__MembershipResponse:
		((_eoddata1__MembershipResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__Membership:
		((_eoddata1__Membership *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__Login2Response:
		((_eoddata1__Login2Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__Login2:
		((_eoddata1__Login2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__LoginResponse:
		((_eoddata1__LoginResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata__eoddata1__Login:
		((_eoddata1__Login *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata_eoddata1__DATAFORMAT_USCORECOLUMN:
		((eoddata1__DATAFORMAT_USCORECOLUMN *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN:
		((eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata_eoddata1__DATAFORMAT:
		((eoddata1__DATAFORMAT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfDATAFORMAT:
		((eoddata1__ArrayOfDATAFORMAT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata_eoddata1__NEWS:
		((eoddata1__NEWS *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfNEWS:
		((eoddata1__ArrayOfNEWS *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata_eoddata1__SYMBOLCHANGE:
		((eoddata1__SYMBOLCHANGE *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfSYMBOLCHANGE:
		((eoddata1__ArrayOfSYMBOLCHANGE *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata_eoddata1__TECHNICAL:
		((eoddata1__TECHNICAL *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfTECHNICAL:
		((eoddata1__ArrayOfTECHNICAL *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata_eoddata1__FUNDAMENTAL:
		((eoddata1__FUNDAMENTAL *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfFUNDAMENTAL:
		((eoddata1__ArrayOfFUNDAMENTAL *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata_eoddata1__CountryBase:
		((eoddata1__CountryBase *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfCountryBase:
		((eoddata1__ArrayOfCountryBase *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata_eoddata1__SPLIT:
		((eoddata1__SPLIT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfSPLIT:
		((eoddata1__ArrayOfSPLIT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata_eoddata1__QUOTE2:
		((eoddata1__QUOTE2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfQUOTE2:
		((eoddata1__ArrayOfQUOTE2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfQUOTE:
		((eoddata1__ArrayOfQUOTE *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata_eoddata1__QUOTE:
		((eoddata1__QUOTE *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata_eoddata1__SYMBOL2:
		((eoddata1__SYMBOL2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfSYMBOL2:
		((eoddata1__ArrayOfSYMBOL2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfSYMBOL:
		((eoddata1__ArrayOfSYMBOL *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata_eoddata1__SYMBOL:
		((eoddata1__SYMBOL *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfEXCHANGE:
		((eoddata1__ArrayOfEXCHANGE *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata_eoddata1__EXCHANGE:
		((eoddata1__EXCHANGE *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata_eoddata1__RESPONSE:
		((eoddata1__RESPONSE *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata_eoddata1__LOGINRESPONSE:
		((eoddata1__LOGINRESPONSE *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_eoddata___eoddata1__ValidateAccess_:
		soap_serialize___eoddata1__ValidateAccess_(soap, (const struct __eoddata1__ValidateAccess_ *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__UpdateDataFormat_:
		soap_serialize___eoddata1__UpdateDataFormat_(soap, (const struct __eoddata1__UpdateDataFormat_ *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__DataFormats_:
		soap_serialize___eoddata1__DataFormats_(soap, (const struct __eoddata1__DataFormats_ *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__DataClientLatestVersion_:
		soap_serialize___eoddata1__DataClientLatestVersion_(soap, (const struct __eoddata1__DataClientLatestVersion_ *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__SymbolChangesByExchange_:
		soap_serialize___eoddata1__SymbolChangesByExchange_(soap, (const struct __eoddata1__SymbolChangesByExchange_ *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__QuoteListByDatePeriod2_:
		soap_serialize___eoddata1__QuoteListByDatePeriod2_(soap, (const struct __eoddata1__QuoteListByDatePeriod2_ *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__QuoteListByDatePeriod_:
		soap_serialize___eoddata1__QuoteListByDatePeriod_(soap, (const struct __eoddata1__QuoteListByDatePeriod_ *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__SymbolHistoryPeriodByDateRange_:
		soap_serialize___eoddata1__SymbolHistoryPeriodByDateRange_(soap, (const struct __eoddata1__SymbolHistoryPeriodByDateRange_ *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__SymbolHistoryPeriod_:
		soap_serialize___eoddata1__SymbolHistoryPeriod_(soap, (const struct __eoddata1__SymbolHistoryPeriod_ *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__CountryList_:
		soap_serialize___eoddata1__CountryList_(soap, (const struct __eoddata1__CountryList_ *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__SplitListBySymbol_:
		soap_serialize___eoddata1__SplitListBySymbol_(soap, (const struct __eoddata1__SplitListBySymbol_ *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__SplitListByExchange_:
		soap_serialize___eoddata1__SplitListByExchange_(soap, (const struct __eoddata1__SplitListByExchange_ *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__ExchangeMonths_:
		soap_serialize___eoddata1__ExchangeMonths_(soap, (const struct __eoddata1__ExchangeMonths_ *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__SymbolChart_:
		soap_serialize___eoddata1__SymbolChart_(soap, (const struct __eoddata1__SymbolChart_ *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__Top10Losses_:
		soap_serialize___eoddata1__Top10Losses_(soap, (const struct __eoddata1__Top10Losses_ *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__Top10Gains_:
		soap_serialize___eoddata1__Top10Gains_(soap, (const struct __eoddata1__Top10Gains_ *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__SymbolHistory_:
		soap_serialize___eoddata1__SymbolHistory_(soap, (const struct __eoddata1__SymbolHistory_ *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__QuoteListByDate2_:
		soap_serialize___eoddata1__QuoteListByDate2_(soap, (const struct __eoddata1__QuoteListByDate2_ *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__QuoteListByDate_:
		soap_serialize___eoddata1__QuoteListByDate_(soap, (const struct __eoddata1__QuoteListByDate_ *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__TechnicalList_:
		soap_serialize___eoddata1__TechnicalList_(soap, (const struct __eoddata1__TechnicalList_ *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__FundamentalList_:
		soap_serialize___eoddata1__FundamentalList_(soap, (const struct __eoddata1__FundamentalList_ *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__NewsListBySymbol_:
		soap_serialize___eoddata1__NewsListBySymbol_(soap, (const struct __eoddata1__NewsListBySymbol_ *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__NewsList_:
		soap_serialize___eoddata1__NewsList_(soap, (const struct __eoddata1__NewsList_ *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__QuoteList_:
		soap_serialize___eoddata1__QuoteList_(soap, (const struct __eoddata1__QuoteList_ *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__SymbolGet_:
		soap_serialize___eoddata1__SymbolGet_(soap, (const struct __eoddata1__SymbolGet_ *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__QuoteList2_:
		soap_serialize___eoddata1__QuoteList2_(soap, (const struct __eoddata1__QuoteList2_ *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__QuoteGet_:
		soap_serialize___eoddata1__QuoteGet_(soap, (const struct __eoddata1__QuoteGet_ *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__SymbolList2_:
		soap_serialize___eoddata1__SymbolList2_(soap, (const struct __eoddata1__SymbolList2_ *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__SymbolList_:
		soap_serialize___eoddata1__SymbolList_(soap, (const struct __eoddata1__SymbolList_ *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__ExchangeGet_:
		soap_serialize___eoddata1__ExchangeGet_(soap, (const struct __eoddata1__ExchangeGet_ *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__ExchangeList_:
		soap_serialize___eoddata1__ExchangeList_(soap, (const struct __eoddata1__ExchangeList_ *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__Membership_:
		soap_serialize___eoddata1__Membership_(soap, (const struct __eoddata1__Membership_ *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__Login2_:
		soap_serialize___eoddata1__Login2_(soap, (const struct __eoddata1__Login2_ *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__Login_:
		soap_serialize___eoddata1__Login_(soap, (const struct __eoddata1__Login_ *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__ValidateAccess:
		soap_serialize___eoddata1__ValidateAccess(soap, (const struct __eoddata1__ValidateAccess *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__UpdateDataFormat:
		soap_serialize___eoddata1__UpdateDataFormat(soap, (const struct __eoddata1__UpdateDataFormat *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__DataFormats:
		soap_serialize___eoddata1__DataFormats(soap, (const struct __eoddata1__DataFormats *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__DataClientLatestVersion:
		soap_serialize___eoddata1__DataClientLatestVersion(soap, (const struct __eoddata1__DataClientLatestVersion *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__SymbolChangesByExchange:
		soap_serialize___eoddata1__SymbolChangesByExchange(soap, (const struct __eoddata1__SymbolChangesByExchange *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__QuoteListByDatePeriod2:
		soap_serialize___eoddata1__QuoteListByDatePeriod2(soap, (const struct __eoddata1__QuoteListByDatePeriod2 *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__QuoteListByDatePeriod:
		soap_serialize___eoddata1__QuoteListByDatePeriod(soap, (const struct __eoddata1__QuoteListByDatePeriod *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__SymbolHistoryPeriodByDateRange:
		soap_serialize___eoddata1__SymbolHistoryPeriodByDateRange(soap, (const struct __eoddata1__SymbolHistoryPeriodByDateRange *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__SymbolHistoryPeriod:
		soap_serialize___eoddata1__SymbolHistoryPeriod(soap, (const struct __eoddata1__SymbolHistoryPeriod *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__CountryList:
		soap_serialize___eoddata1__CountryList(soap, (const struct __eoddata1__CountryList *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__SplitListBySymbol:
		soap_serialize___eoddata1__SplitListBySymbol(soap, (const struct __eoddata1__SplitListBySymbol *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__SplitListByExchange:
		soap_serialize___eoddata1__SplitListByExchange(soap, (const struct __eoddata1__SplitListByExchange *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__ExchangeMonths:
		soap_serialize___eoddata1__ExchangeMonths(soap, (const struct __eoddata1__ExchangeMonths *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__SymbolChart:
		soap_serialize___eoddata1__SymbolChart(soap, (const struct __eoddata1__SymbolChart *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__Top10Losses:
		soap_serialize___eoddata1__Top10Losses(soap, (const struct __eoddata1__Top10Losses *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__Top10Gains:
		soap_serialize___eoddata1__Top10Gains(soap, (const struct __eoddata1__Top10Gains *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__SymbolHistory:
		soap_serialize___eoddata1__SymbolHistory(soap, (const struct __eoddata1__SymbolHistory *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__QuoteListByDate2:
		soap_serialize___eoddata1__QuoteListByDate2(soap, (const struct __eoddata1__QuoteListByDate2 *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__QuoteListByDate:
		soap_serialize___eoddata1__QuoteListByDate(soap, (const struct __eoddata1__QuoteListByDate *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__TechnicalList:
		soap_serialize___eoddata1__TechnicalList(soap, (const struct __eoddata1__TechnicalList *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__FundamentalList:
		soap_serialize___eoddata1__FundamentalList(soap, (const struct __eoddata1__FundamentalList *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__NewsListBySymbol:
		soap_serialize___eoddata1__NewsListBySymbol(soap, (const struct __eoddata1__NewsListBySymbol *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__NewsList:
		soap_serialize___eoddata1__NewsList(soap, (const struct __eoddata1__NewsList *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__QuoteList:
		soap_serialize___eoddata1__QuoteList(soap, (const struct __eoddata1__QuoteList *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__SymbolGet:
		soap_serialize___eoddata1__SymbolGet(soap, (const struct __eoddata1__SymbolGet *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__QuoteList2:
		soap_serialize___eoddata1__QuoteList2(soap, (const struct __eoddata1__QuoteList2 *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__QuoteGet:
		soap_serialize___eoddata1__QuoteGet(soap, (const struct __eoddata1__QuoteGet *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__SymbolList2:
		soap_serialize___eoddata1__SymbolList2(soap, (const struct __eoddata1__SymbolList2 *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__SymbolList:
		soap_serialize___eoddata1__SymbolList(soap, (const struct __eoddata1__SymbolList *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__ExchangeGet:
		soap_serialize___eoddata1__ExchangeGet(soap, (const struct __eoddata1__ExchangeGet *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__ExchangeList:
		soap_serialize___eoddata1__ExchangeList(soap, (const struct __eoddata1__ExchangeList *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__Membership:
		soap_serialize___eoddata1__Membership(soap, (const struct __eoddata1__Membership *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__Login2:
		soap_serialize___eoddata1__Login2(soap, (const struct __eoddata1__Login2 *)ptr);
		break;
	case SOAP_TYPE_eoddata___eoddata1__Login:
		soap_serialize___eoddata1__Login(soap, (const struct __eoddata1__Login *)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__ValidateAccess:
		soap_serialize_PointerTo_eoddata1__ValidateAccess(soap, (_eoddata1__ValidateAccess *const*)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__UpdateDataFormat:
		soap_serialize_PointerTo_eoddata1__UpdateDataFormat(soap, (_eoddata1__UpdateDataFormat *const*)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__DataFormats:
		soap_serialize_PointerTo_eoddata1__DataFormats(soap, (_eoddata1__DataFormats *const*)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__DataClientLatestVersion:
		soap_serialize_PointerTo_eoddata1__DataClientLatestVersion(soap, (_eoddata1__DataClientLatestVersion *const*)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__SymbolChangesByExchange:
		soap_serialize_PointerTo_eoddata1__SymbolChangesByExchange(soap, (_eoddata1__SymbolChangesByExchange *const*)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__QuoteListByDatePeriod2:
		soap_serialize_PointerTo_eoddata1__QuoteListByDatePeriod2(soap, (_eoddata1__QuoteListByDatePeriod2 *const*)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__QuoteListByDatePeriod:
		soap_serialize_PointerTo_eoddata1__QuoteListByDatePeriod(soap, (_eoddata1__QuoteListByDatePeriod *const*)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__SymbolHistoryPeriodByDateRange:
		soap_serialize_PointerTo_eoddata1__SymbolHistoryPeriodByDateRange(soap, (_eoddata1__SymbolHistoryPeriodByDateRange *const*)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__SymbolHistoryPeriod:
		soap_serialize_PointerTo_eoddata1__SymbolHistoryPeriod(soap, (_eoddata1__SymbolHistoryPeriod *const*)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__CountryList:
		soap_serialize_PointerTo_eoddata1__CountryList(soap, (_eoddata1__CountryList *const*)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__SplitListBySymbol:
		soap_serialize_PointerTo_eoddata1__SplitListBySymbol(soap, (_eoddata1__SplitListBySymbol *const*)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__SplitListByExchange:
		soap_serialize_PointerTo_eoddata1__SplitListByExchange(soap, (_eoddata1__SplitListByExchange *const*)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__ExchangeMonths:
		soap_serialize_PointerTo_eoddata1__ExchangeMonths(soap, (_eoddata1__ExchangeMonths *const*)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__SymbolChart:
		soap_serialize_PointerTo_eoddata1__SymbolChart(soap, (_eoddata1__SymbolChart *const*)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__Top10Losses:
		soap_serialize_PointerTo_eoddata1__Top10Losses(soap, (_eoddata1__Top10Losses *const*)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__Top10Gains:
		soap_serialize_PointerTo_eoddata1__Top10Gains(soap, (_eoddata1__Top10Gains *const*)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__SymbolHistory:
		soap_serialize_PointerTo_eoddata1__SymbolHistory(soap, (_eoddata1__SymbolHistory *const*)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__QuoteListByDate2:
		soap_serialize_PointerTo_eoddata1__QuoteListByDate2(soap, (_eoddata1__QuoteListByDate2 *const*)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__QuoteListByDate:
		soap_serialize_PointerTo_eoddata1__QuoteListByDate(soap, (_eoddata1__QuoteListByDate *const*)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__TechnicalList:
		soap_serialize_PointerTo_eoddata1__TechnicalList(soap, (_eoddata1__TechnicalList *const*)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__FundamentalList:
		soap_serialize_PointerTo_eoddata1__FundamentalList(soap, (_eoddata1__FundamentalList *const*)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__NewsListBySymbol:
		soap_serialize_PointerTo_eoddata1__NewsListBySymbol(soap, (_eoddata1__NewsListBySymbol *const*)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__NewsList:
		soap_serialize_PointerTo_eoddata1__NewsList(soap, (_eoddata1__NewsList *const*)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__QuoteList:
		soap_serialize_PointerTo_eoddata1__QuoteList(soap, (_eoddata1__QuoteList *const*)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__SymbolGet:
		soap_serialize_PointerTo_eoddata1__SymbolGet(soap, (_eoddata1__SymbolGet *const*)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__QuoteList2:
		soap_serialize_PointerTo_eoddata1__QuoteList2(soap, (_eoddata1__QuoteList2 *const*)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__QuoteGet:
		soap_serialize_PointerTo_eoddata1__QuoteGet(soap, (_eoddata1__QuoteGet *const*)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__SymbolList2:
		soap_serialize_PointerTo_eoddata1__SymbolList2(soap, (_eoddata1__SymbolList2 *const*)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__SymbolList:
		soap_serialize_PointerTo_eoddata1__SymbolList(soap, (_eoddata1__SymbolList *const*)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__ExchangeGet:
		soap_serialize_PointerTo_eoddata1__ExchangeGet(soap, (_eoddata1__ExchangeGet *const*)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__ExchangeList:
		soap_serialize_PointerTo_eoddata1__ExchangeList(soap, (_eoddata1__ExchangeList *const*)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__Membership:
		soap_serialize_PointerTo_eoddata1__Membership(soap, (_eoddata1__Membership *const*)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__Login2:
		soap_serialize_PointerTo_eoddata1__Login2(soap, (_eoddata1__Login2 *const*)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerTo_eoddata1__Login:
		soap_serialize_PointerTo_eoddata1__Login(soap, (_eoddata1__Login *const*)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerToeoddata1__RESPONSE:
		soap_serialize_PointerToeoddata1__RESPONSE(soap, (eoddata1__RESPONSE *const*)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerToeoddata1__LOGINRESPONSE:
		soap_serialize_PointerToeoddata1__LOGINRESPONSE(soap, (eoddata1__LOGINRESPONSE *const*)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerToeoddata1__DATAFORMAT_USCORECOLUMN:
		soap_serialize_PointerToeoddata1__DATAFORMAT_USCORECOLUMN(soap, (eoddata1__DATAFORMAT_USCORECOLUMN *const*)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerToeoddata1__ArrayOfDATAFORMAT_USCORECOLUMN:
		soap_serialize_PointerToeoddata1__ArrayOfDATAFORMAT_USCORECOLUMN(soap, (eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN *const*)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerToeoddata1__DATAFORMAT:
		soap_serialize_PointerToeoddata1__DATAFORMAT(soap, (eoddata1__DATAFORMAT *const*)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerToeoddata1__NEWS:
		soap_serialize_PointerToeoddata1__NEWS(soap, (eoddata1__NEWS *const*)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerToeoddata1__SYMBOLCHANGE:
		soap_serialize_PointerToeoddata1__SYMBOLCHANGE(soap, (eoddata1__SYMBOLCHANGE *const*)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerToeoddata1__TECHNICAL:
		soap_serialize_PointerToeoddata1__TECHNICAL(soap, (eoddata1__TECHNICAL *const*)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerToeoddata1__FUNDAMENTAL:
		soap_serialize_PointerToeoddata1__FUNDAMENTAL(soap, (eoddata1__FUNDAMENTAL *const*)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerToeoddata1__CountryBase:
		soap_serialize_PointerToeoddata1__CountryBase(soap, (eoddata1__CountryBase *const*)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerToeoddata1__SPLIT:
		soap_serialize_PointerToeoddata1__SPLIT(soap, (eoddata1__SPLIT *const*)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerToeoddata1__QUOTE2:
		soap_serialize_PointerToeoddata1__QUOTE2(soap, (eoddata1__QUOTE2 *const*)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerToeoddata1__SYMBOL2:
		soap_serialize_PointerToeoddata1__SYMBOL2(soap, (eoddata1__SYMBOL2 *const*)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerToeoddata1__ArrayOfDATAFORMAT:
		soap_serialize_PointerToeoddata1__ArrayOfDATAFORMAT(soap, (eoddata1__ArrayOfDATAFORMAT *const*)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerToeoddata1__ArrayOfNEWS:
		soap_serialize_PointerToeoddata1__ArrayOfNEWS(soap, (eoddata1__ArrayOfNEWS *const*)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerToeoddata1__ArrayOfSYMBOLCHANGE:
		soap_serialize_PointerToeoddata1__ArrayOfSYMBOLCHANGE(soap, (eoddata1__ArrayOfSYMBOLCHANGE *const*)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerToeoddata1__ArrayOfTECHNICAL:
		soap_serialize_PointerToeoddata1__ArrayOfTECHNICAL(soap, (eoddata1__ArrayOfTECHNICAL *const*)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerToeoddata1__ArrayOfFUNDAMENTAL:
		soap_serialize_PointerToeoddata1__ArrayOfFUNDAMENTAL(soap, (eoddata1__ArrayOfFUNDAMENTAL *const*)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerToeoddata1__ArrayOfCountryBase:
		soap_serialize_PointerToeoddata1__ArrayOfCountryBase(soap, (eoddata1__ArrayOfCountryBase *const*)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerToeoddata1__ArrayOfSPLIT:
		soap_serialize_PointerToeoddata1__ArrayOfSPLIT(soap, (eoddata1__ArrayOfSPLIT *const*)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerToeoddata1__ArrayOfQUOTE2:
		soap_serialize_PointerToeoddata1__ArrayOfQUOTE2(soap, (eoddata1__ArrayOfQUOTE2 *const*)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerToeoddata1__ArrayOfQUOTE:
		soap_serialize_PointerToeoddata1__ArrayOfQUOTE(soap, (eoddata1__ArrayOfQUOTE *const*)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerToeoddata1__QUOTE:
		soap_serialize_PointerToeoddata1__QUOTE(soap, (eoddata1__QUOTE *const*)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerToeoddata1__ArrayOfSYMBOL2:
		soap_serialize_PointerToeoddata1__ArrayOfSYMBOL2(soap, (eoddata1__ArrayOfSYMBOL2 *const*)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerToeoddata1__ArrayOfSYMBOL:
		soap_serialize_PointerToeoddata1__ArrayOfSYMBOL(soap, (eoddata1__ArrayOfSYMBOL *const*)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerToeoddata1__SYMBOL:
		soap_serialize_PointerToeoddata1__SYMBOL(soap, (eoddata1__SYMBOL *const*)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerToeoddata1__ArrayOfEXCHANGE:
		soap_serialize_PointerToeoddata1__ArrayOfEXCHANGE(soap, (eoddata1__ArrayOfEXCHANGE *const*)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerToeoddata1__EXCHANGE:
		soap_serialize_PointerToeoddata1__EXCHANGE(soap, (eoddata1__EXCHANGE *const*)ptr);
		break;
	case SOAP_TYPE_eoddata_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_eoddata__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_eoddata_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 eoddata_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_eoddata_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata_eoddata1__LOGINRESPONSE:
		return (void*)soap_instantiate_eoddata1__LOGINRESPONSE(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata_eoddata1__RESPONSE:
		return (void*)soap_instantiate_eoddata1__RESPONSE(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata_eoddata1__EXCHANGE:
		return (void*)soap_instantiate_eoddata1__EXCHANGE(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfEXCHANGE:
		return (void*)soap_instantiate_eoddata1__ArrayOfEXCHANGE(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata_eoddata1__SYMBOL:
		return (void*)soap_instantiate_eoddata1__SYMBOL(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfSYMBOL:
		return (void*)soap_instantiate_eoddata1__ArrayOfSYMBOL(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfSYMBOL2:
		return (void*)soap_instantiate_eoddata1__ArrayOfSYMBOL2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata_eoddata1__SYMBOL2:
		return (void*)soap_instantiate_eoddata1__SYMBOL2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata_eoddata1__QUOTE:
		return (void*)soap_instantiate_eoddata1__QUOTE(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfQUOTE:
		return (void*)soap_instantiate_eoddata1__ArrayOfQUOTE(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfQUOTE2:
		return (void*)soap_instantiate_eoddata1__ArrayOfQUOTE2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata_eoddata1__QUOTE2:
		return (void*)soap_instantiate_eoddata1__QUOTE2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfSPLIT:
		return (void*)soap_instantiate_eoddata1__ArrayOfSPLIT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata_eoddata1__SPLIT:
		return (void*)soap_instantiate_eoddata1__SPLIT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfCountryBase:
		return (void*)soap_instantiate_eoddata1__ArrayOfCountryBase(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata_eoddata1__CountryBase:
		return (void*)soap_instantiate_eoddata1__CountryBase(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfFUNDAMENTAL:
		return (void*)soap_instantiate_eoddata1__ArrayOfFUNDAMENTAL(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata_eoddata1__FUNDAMENTAL:
		return (void*)soap_instantiate_eoddata1__FUNDAMENTAL(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfTECHNICAL:
		return (void*)soap_instantiate_eoddata1__ArrayOfTECHNICAL(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata_eoddata1__TECHNICAL:
		return (void*)soap_instantiate_eoddata1__TECHNICAL(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfSYMBOLCHANGE:
		return (void*)soap_instantiate_eoddata1__ArrayOfSYMBOLCHANGE(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata_eoddata1__SYMBOLCHANGE:
		return (void*)soap_instantiate_eoddata1__SYMBOLCHANGE(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfNEWS:
		return (void*)soap_instantiate_eoddata1__ArrayOfNEWS(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata_eoddata1__NEWS:
		return (void*)soap_instantiate_eoddata1__NEWS(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfDATAFORMAT:
		return (void*)soap_instantiate_eoddata1__ArrayOfDATAFORMAT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata_eoddata1__DATAFORMAT:
		return (void*)soap_instantiate_eoddata1__DATAFORMAT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN:
		return (void*)soap_instantiate_eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata_eoddata1__DATAFORMAT_USCORECOLUMN:
		return (void*)soap_instantiate_eoddata1__DATAFORMAT_USCORECOLUMN(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__Login:
		return (void*)soap_instantiate__eoddata1__Login(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__LoginResponse:
		return (void*)soap_instantiate__eoddata1__LoginResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__Login2:
		return (void*)soap_instantiate__eoddata1__Login2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__Login2Response:
		return (void*)soap_instantiate__eoddata1__Login2Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__Membership:
		return (void*)soap_instantiate__eoddata1__Membership(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__MembershipResponse:
		return (void*)soap_instantiate__eoddata1__MembershipResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__ExchangeList:
		return (void*)soap_instantiate__eoddata1__ExchangeList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__ExchangeListResponse:
		return (void*)soap_instantiate__eoddata1__ExchangeListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__ExchangeGet:
		return (void*)soap_instantiate__eoddata1__ExchangeGet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__ExchangeGetResponse:
		return (void*)soap_instantiate__eoddata1__ExchangeGetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__SymbolList:
		return (void*)soap_instantiate__eoddata1__SymbolList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__SymbolListResponse:
		return (void*)soap_instantiate__eoddata1__SymbolListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__SymbolList2:
		return (void*)soap_instantiate__eoddata1__SymbolList2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__SymbolList2Response:
		return (void*)soap_instantiate__eoddata1__SymbolList2Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__QuoteGet:
		return (void*)soap_instantiate__eoddata1__QuoteGet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__QuoteGetResponse:
		return (void*)soap_instantiate__eoddata1__QuoteGetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__QuoteList2:
		return (void*)soap_instantiate__eoddata1__QuoteList2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__QuoteList2Response:
		return (void*)soap_instantiate__eoddata1__QuoteList2Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__SymbolGet:
		return (void*)soap_instantiate__eoddata1__SymbolGet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__SymbolGetResponse:
		return (void*)soap_instantiate__eoddata1__SymbolGetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__QuoteList:
		return (void*)soap_instantiate__eoddata1__QuoteList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__QuoteListResponse:
		return (void*)soap_instantiate__eoddata1__QuoteListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__NewsList:
		return (void*)soap_instantiate__eoddata1__NewsList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__NewsListResponse:
		return (void*)soap_instantiate__eoddata1__NewsListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__NewsListBySymbol:
		return (void*)soap_instantiate__eoddata1__NewsListBySymbol(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__NewsListBySymbolResponse:
		return (void*)soap_instantiate__eoddata1__NewsListBySymbolResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__FundamentalList:
		return (void*)soap_instantiate__eoddata1__FundamentalList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__FundamentalListResponse:
		return (void*)soap_instantiate__eoddata1__FundamentalListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__TechnicalList:
		return (void*)soap_instantiate__eoddata1__TechnicalList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__TechnicalListResponse:
		return (void*)soap_instantiate__eoddata1__TechnicalListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__QuoteListByDate:
		return (void*)soap_instantiate__eoddata1__QuoteListByDate(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__QuoteListByDateResponse:
		return (void*)soap_instantiate__eoddata1__QuoteListByDateResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__QuoteListByDate2:
		return (void*)soap_instantiate__eoddata1__QuoteListByDate2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__QuoteListByDate2Response:
		return (void*)soap_instantiate__eoddata1__QuoteListByDate2Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__SymbolHistory:
		return (void*)soap_instantiate__eoddata1__SymbolHistory(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__SymbolHistoryResponse:
		return (void*)soap_instantiate__eoddata1__SymbolHistoryResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__Top10Gains:
		return (void*)soap_instantiate__eoddata1__Top10Gains(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__Top10GainsResponse:
		return (void*)soap_instantiate__eoddata1__Top10GainsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__Top10Losses:
		return (void*)soap_instantiate__eoddata1__Top10Losses(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__Top10LossesResponse:
		return (void*)soap_instantiate__eoddata1__Top10LossesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__SymbolChart:
		return (void*)soap_instantiate__eoddata1__SymbolChart(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__SymbolChartResponse:
		return (void*)soap_instantiate__eoddata1__SymbolChartResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__ExchangeMonths:
		return (void*)soap_instantiate__eoddata1__ExchangeMonths(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__ExchangeMonthsResponse:
		return (void*)soap_instantiate__eoddata1__ExchangeMonthsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__SplitListByExchange:
		return (void*)soap_instantiate__eoddata1__SplitListByExchange(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__SplitListByExchangeResponse:
		return (void*)soap_instantiate__eoddata1__SplitListByExchangeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__SplitListBySymbol:
		return (void*)soap_instantiate__eoddata1__SplitListBySymbol(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__SplitListBySymbolResponse:
		return (void*)soap_instantiate__eoddata1__SplitListBySymbolResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__CountryList:
		return (void*)soap_instantiate__eoddata1__CountryList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__CountryListResponse:
		return (void*)soap_instantiate__eoddata1__CountryListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__SymbolHistoryPeriod:
		return (void*)soap_instantiate__eoddata1__SymbolHistoryPeriod(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__SymbolHistoryPeriodResponse:
		return (void*)soap_instantiate__eoddata1__SymbolHistoryPeriodResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__SymbolHistoryPeriodByDateRange:
		return (void*)soap_instantiate__eoddata1__SymbolHistoryPeriodByDateRange(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__SymbolHistoryPeriodByDateRangeResponse:
		return (void*)soap_instantiate__eoddata1__SymbolHistoryPeriodByDateRangeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__QuoteListByDatePeriod:
		return (void*)soap_instantiate__eoddata1__QuoteListByDatePeriod(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__QuoteListByDatePeriodResponse:
		return (void*)soap_instantiate__eoddata1__QuoteListByDatePeriodResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__QuoteListByDatePeriod2:
		return (void*)soap_instantiate__eoddata1__QuoteListByDatePeriod2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__QuoteListByDatePeriod2Response:
		return (void*)soap_instantiate__eoddata1__QuoteListByDatePeriod2Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__SymbolChangesByExchange:
		return (void*)soap_instantiate__eoddata1__SymbolChangesByExchange(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__SymbolChangesByExchangeResponse:
		return (void*)soap_instantiate__eoddata1__SymbolChangesByExchangeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__DataClientLatestVersion:
		return (void*)soap_instantiate__eoddata1__DataClientLatestVersion(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__DataClientLatestVersionResponse:
		return (void*)soap_instantiate__eoddata1__DataClientLatestVersionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__DataFormats:
		return (void*)soap_instantiate__eoddata1__DataFormats(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__DataFormatsResponse:
		return (void*)soap_instantiate__eoddata1__DataFormatsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__UpdateDataFormat:
		return (void*)soap_instantiate__eoddata1__UpdateDataFormat(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__UpdateDataFormatResponse:
		return (void*)soap_instantiate__eoddata1__UpdateDataFormatResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__ValidateAccess:
		return (void*)soap_instantiate__eoddata1__ValidateAccess(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata__eoddata1__ValidateAccessResponse:
		return (void*)soap_instantiate__eoddata1__ValidateAccessResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__Login:
		return (void*)soap_instantiate___eoddata1__Login(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__Login2:
		return (void*)soap_instantiate___eoddata1__Login2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__Membership:
		return (void*)soap_instantiate___eoddata1__Membership(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__ExchangeList:
		return (void*)soap_instantiate___eoddata1__ExchangeList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__ExchangeGet:
		return (void*)soap_instantiate___eoddata1__ExchangeGet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__SymbolList:
		return (void*)soap_instantiate___eoddata1__SymbolList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__SymbolList2:
		return (void*)soap_instantiate___eoddata1__SymbolList2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__QuoteGet:
		return (void*)soap_instantiate___eoddata1__QuoteGet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__QuoteList2:
		return (void*)soap_instantiate___eoddata1__QuoteList2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__SymbolGet:
		return (void*)soap_instantiate___eoddata1__SymbolGet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__QuoteList:
		return (void*)soap_instantiate___eoddata1__QuoteList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__NewsList:
		return (void*)soap_instantiate___eoddata1__NewsList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__NewsListBySymbol:
		return (void*)soap_instantiate___eoddata1__NewsListBySymbol(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__FundamentalList:
		return (void*)soap_instantiate___eoddata1__FundamentalList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__TechnicalList:
		return (void*)soap_instantiate___eoddata1__TechnicalList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__QuoteListByDate:
		return (void*)soap_instantiate___eoddata1__QuoteListByDate(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__QuoteListByDate2:
		return (void*)soap_instantiate___eoddata1__QuoteListByDate2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__SymbolHistory:
		return (void*)soap_instantiate___eoddata1__SymbolHistory(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__Top10Gains:
		return (void*)soap_instantiate___eoddata1__Top10Gains(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__Top10Losses:
		return (void*)soap_instantiate___eoddata1__Top10Losses(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__SymbolChart:
		return (void*)soap_instantiate___eoddata1__SymbolChart(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__ExchangeMonths:
		return (void*)soap_instantiate___eoddata1__ExchangeMonths(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__SplitListByExchange:
		return (void*)soap_instantiate___eoddata1__SplitListByExchange(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__SplitListBySymbol:
		return (void*)soap_instantiate___eoddata1__SplitListBySymbol(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__CountryList:
		return (void*)soap_instantiate___eoddata1__CountryList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__SymbolHistoryPeriod:
		return (void*)soap_instantiate___eoddata1__SymbolHistoryPeriod(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__SymbolHistoryPeriodByDateRange:
		return (void*)soap_instantiate___eoddata1__SymbolHistoryPeriodByDateRange(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__QuoteListByDatePeriod:
		return (void*)soap_instantiate___eoddata1__QuoteListByDatePeriod(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__QuoteListByDatePeriod2:
		return (void*)soap_instantiate___eoddata1__QuoteListByDatePeriod2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__SymbolChangesByExchange:
		return (void*)soap_instantiate___eoddata1__SymbolChangesByExchange(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__DataClientLatestVersion:
		return (void*)soap_instantiate___eoddata1__DataClientLatestVersion(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__DataFormats:
		return (void*)soap_instantiate___eoddata1__DataFormats(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__UpdateDataFormat:
		return (void*)soap_instantiate___eoddata1__UpdateDataFormat(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__ValidateAccess:
		return (void*)soap_instantiate___eoddata1__ValidateAccess(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__Login_:
		return (void*)soap_instantiate___eoddata1__Login_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__Login2_:
		return (void*)soap_instantiate___eoddata1__Login2_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__Membership_:
		return (void*)soap_instantiate___eoddata1__Membership_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__ExchangeList_:
		return (void*)soap_instantiate___eoddata1__ExchangeList_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__ExchangeGet_:
		return (void*)soap_instantiate___eoddata1__ExchangeGet_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__SymbolList_:
		return (void*)soap_instantiate___eoddata1__SymbolList_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__SymbolList2_:
		return (void*)soap_instantiate___eoddata1__SymbolList2_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__QuoteGet_:
		return (void*)soap_instantiate___eoddata1__QuoteGet_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__QuoteList2_:
		return (void*)soap_instantiate___eoddata1__QuoteList2_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__SymbolGet_:
		return (void*)soap_instantiate___eoddata1__SymbolGet_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__QuoteList_:
		return (void*)soap_instantiate___eoddata1__QuoteList_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__NewsList_:
		return (void*)soap_instantiate___eoddata1__NewsList_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__NewsListBySymbol_:
		return (void*)soap_instantiate___eoddata1__NewsListBySymbol_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__FundamentalList_:
		return (void*)soap_instantiate___eoddata1__FundamentalList_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__TechnicalList_:
		return (void*)soap_instantiate___eoddata1__TechnicalList_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__QuoteListByDate_:
		return (void*)soap_instantiate___eoddata1__QuoteListByDate_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__QuoteListByDate2_:
		return (void*)soap_instantiate___eoddata1__QuoteListByDate2_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__SymbolHistory_:
		return (void*)soap_instantiate___eoddata1__SymbolHistory_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__Top10Gains_:
		return (void*)soap_instantiate___eoddata1__Top10Gains_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__Top10Losses_:
		return (void*)soap_instantiate___eoddata1__Top10Losses_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__SymbolChart_:
		return (void*)soap_instantiate___eoddata1__SymbolChart_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__ExchangeMonths_:
		return (void*)soap_instantiate___eoddata1__ExchangeMonths_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__SplitListByExchange_:
		return (void*)soap_instantiate___eoddata1__SplitListByExchange_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__SplitListBySymbol_:
		return (void*)soap_instantiate___eoddata1__SplitListBySymbol_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__CountryList_:
		return (void*)soap_instantiate___eoddata1__CountryList_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__SymbolHistoryPeriod_:
		return (void*)soap_instantiate___eoddata1__SymbolHistoryPeriod_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__SymbolHistoryPeriodByDateRange_:
		return (void*)soap_instantiate___eoddata1__SymbolHistoryPeriodByDateRange_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__QuoteListByDatePeriod_:
		return (void*)soap_instantiate___eoddata1__QuoteListByDatePeriod_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__QuoteListByDatePeriod2_:
		return (void*)soap_instantiate___eoddata1__QuoteListByDatePeriod2_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__SymbolChangesByExchange_:
		return (void*)soap_instantiate___eoddata1__SymbolChangesByExchange_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__DataClientLatestVersion_:
		return (void*)soap_instantiate___eoddata1__DataClientLatestVersion_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__DataFormats_:
		return (void*)soap_instantiate___eoddata1__DataFormats_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__UpdateDataFormat_:
		return (void*)soap_instantiate___eoddata1__UpdateDataFormat_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata___eoddata1__ValidateAccess_:
		return (void*)soap_instantiate___eoddata1__ValidateAccess_(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_eoddata_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_eoddata_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_eoddata_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_eoddata_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_eoddata_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__DATAFORMAT_USCORECOLUMN:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToeoddata1__DATAFORMAT_USCORECOLUMN(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__DATAFORMAT:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToeoddata1__DATAFORMAT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__NEWS:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToeoddata1__NEWS(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__SYMBOLCHANGE:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToeoddata1__SYMBOLCHANGE(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__TECHNICAL:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToeoddata1__TECHNICAL(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__FUNDAMENTAL:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToeoddata1__FUNDAMENTAL(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__CountryBase:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToeoddata1__CountryBase(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__SPLIT:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToeoddata1__SPLIT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__QUOTE2:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToeoddata1__QUOTE2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__QUOTE:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToeoddata1__QUOTE(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__SYMBOL2:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToeoddata1__SYMBOL2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__SYMBOL:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToeoddata1__SYMBOL(soap, -1, type, arrayType, n);
	case SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__EXCHANGE:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToeoddata1__EXCHANGE(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 eoddata_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_eoddata_std__string:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::string*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::string*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata_eoddata1__LOGINRESPONSE:
		if (p->size < 0)
			SOAP_DELETE(static_cast<eoddata1__LOGINRESPONSE*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<eoddata1__LOGINRESPONSE*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata_eoddata1__RESPONSE:
		if (p->size < 0)
			SOAP_DELETE(static_cast<eoddata1__RESPONSE*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<eoddata1__RESPONSE*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata_eoddata1__EXCHANGE:
		if (p->size < 0)
			SOAP_DELETE(static_cast<eoddata1__EXCHANGE*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<eoddata1__EXCHANGE*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfEXCHANGE:
		if (p->size < 0)
			SOAP_DELETE(static_cast<eoddata1__ArrayOfEXCHANGE*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<eoddata1__ArrayOfEXCHANGE*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata_eoddata1__SYMBOL:
		if (p->size < 0)
			SOAP_DELETE(static_cast<eoddata1__SYMBOL*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<eoddata1__SYMBOL*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfSYMBOL:
		if (p->size < 0)
			SOAP_DELETE(static_cast<eoddata1__ArrayOfSYMBOL*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<eoddata1__ArrayOfSYMBOL*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfSYMBOL2:
		if (p->size < 0)
			SOAP_DELETE(static_cast<eoddata1__ArrayOfSYMBOL2*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<eoddata1__ArrayOfSYMBOL2*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata_eoddata1__SYMBOL2:
		if (p->size < 0)
			SOAP_DELETE(static_cast<eoddata1__SYMBOL2*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<eoddata1__SYMBOL2*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata_eoddata1__QUOTE:
		if (p->size < 0)
			SOAP_DELETE(static_cast<eoddata1__QUOTE*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<eoddata1__QUOTE*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfQUOTE:
		if (p->size < 0)
			SOAP_DELETE(static_cast<eoddata1__ArrayOfQUOTE*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<eoddata1__ArrayOfQUOTE*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfQUOTE2:
		if (p->size < 0)
			SOAP_DELETE(static_cast<eoddata1__ArrayOfQUOTE2*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<eoddata1__ArrayOfQUOTE2*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata_eoddata1__QUOTE2:
		if (p->size < 0)
			SOAP_DELETE(static_cast<eoddata1__QUOTE2*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<eoddata1__QUOTE2*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfSPLIT:
		if (p->size < 0)
			SOAP_DELETE(static_cast<eoddata1__ArrayOfSPLIT*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<eoddata1__ArrayOfSPLIT*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata_eoddata1__SPLIT:
		if (p->size < 0)
			SOAP_DELETE(static_cast<eoddata1__SPLIT*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<eoddata1__SPLIT*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfCountryBase:
		if (p->size < 0)
			SOAP_DELETE(static_cast<eoddata1__ArrayOfCountryBase*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<eoddata1__ArrayOfCountryBase*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata_eoddata1__CountryBase:
		if (p->size < 0)
			SOAP_DELETE(static_cast<eoddata1__CountryBase*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<eoddata1__CountryBase*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfFUNDAMENTAL:
		if (p->size < 0)
			SOAP_DELETE(static_cast<eoddata1__ArrayOfFUNDAMENTAL*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<eoddata1__ArrayOfFUNDAMENTAL*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata_eoddata1__FUNDAMENTAL:
		if (p->size < 0)
			SOAP_DELETE(static_cast<eoddata1__FUNDAMENTAL*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<eoddata1__FUNDAMENTAL*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfTECHNICAL:
		if (p->size < 0)
			SOAP_DELETE(static_cast<eoddata1__ArrayOfTECHNICAL*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<eoddata1__ArrayOfTECHNICAL*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata_eoddata1__TECHNICAL:
		if (p->size < 0)
			SOAP_DELETE(static_cast<eoddata1__TECHNICAL*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<eoddata1__TECHNICAL*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfSYMBOLCHANGE:
		if (p->size < 0)
			SOAP_DELETE(static_cast<eoddata1__ArrayOfSYMBOLCHANGE*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<eoddata1__ArrayOfSYMBOLCHANGE*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata_eoddata1__SYMBOLCHANGE:
		if (p->size < 0)
			SOAP_DELETE(static_cast<eoddata1__SYMBOLCHANGE*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<eoddata1__SYMBOLCHANGE*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfNEWS:
		if (p->size < 0)
			SOAP_DELETE(static_cast<eoddata1__ArrayOfNEWS*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<eoddata1__ArrayOfNEWS*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata_eoddata1__NEWS:
		if (p->size < 0)
			SOAP_DELETE(static_cast<eoddata1__NEWS*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<eoddata1__NEWS*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfDATAFORMAT:
		if (p->size < 0)
			SOAP_DELETE(static_cast<eoddata1__ArrayOfDATAFORMAT*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<eoddata1__ArrayOfDATAFORMAT*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata_eoddata1__DATAFORMAT:
		if (p->size < 0)
			SOAP_DELETE(static_cast<eoddata1__DATAFORMAT*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<eoddata1__DATAFORMAT*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN:
		if (p->size < 0)
			SOAP_DELETE(static_cast<eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata_eoddata1__DATAFORMAT_USCORECOLUMN:
		if (p->size < 0)
			SOAP_DELETE(static_cast<eoddata1__DATAFORMAT_USCORECOLUMN*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<eoddata1__DATAFORMAT_USCORECOLUMN*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__Login:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__Login*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__Login*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__LoginResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__LoginResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__LoginResponse*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__Login2:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__Login2*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__Login2*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__Login2Response:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__Login2Response*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__Login2Response*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__Membership:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__Membership*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__Membership*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__MembershipResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__MembershipResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__MembershipResponse*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__ExchangeList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__ExchangeList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__ExchangeList*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__ExchangeListResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__ExchangeListResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__ExchangeListResponse*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__ExchangeGet:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__ExchangeGet*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__ExchangeGet*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__ExchangeGetResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__ExchangeGetResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__ExchangeGetResponse*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__SymbolList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__SymbolList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__SymbolList*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__SymbolListResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__SymbolListResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__SymbolListResponse*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__SymbolList2:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__SymbolList2*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__SymbolList2*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__SymbolList2Response:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__SymbolList2Response*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__SymbolList2Response*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__QuoteGet:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__QuoteGet*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__QuoteGet*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__QuoteGetResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__QuoteGetResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__QuoteGetResponse*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__QuoteList2:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__QuoteList2*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__QuoteList2*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__QuoteList2Response:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__QuoteList2Response*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__QuoteList2Response*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__SymbolGet:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__SymbolGet*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__SymbolGet*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__SymbolGetResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__SymbolGetResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__SymbolGetResponse*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__QuoteList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__QuoteList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__QuoteList*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__QuoteListResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__QuoteListResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__QuoteListResponse*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__NewsList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__NewsList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__NewsList*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__NewsListResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__NewsListResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__NewsListResponse*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__NewsListBySymbol:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__NewsListBySymbol*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__NewsListBySymbol*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__NewsListBySymbolResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__NewsListBySymbolResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__NewsListBySymbolResponse*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__FundamentalList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__FundamentalList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__FundamentalList*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__FundamentalListResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__FundamentalListResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__FundamentalListResponse*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__TechnicalList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__TechnicalList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__TechnicalList*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__TechnicalListResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__TechnicalListResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__TechnicalListResponse*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__QuoteListByDate:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__QuoteListByDate*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__QuoteListByDate*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__QuoteListByDateResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__QuoteListByDateResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__QuoteListByDateResponse*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__QuoteListByDate2:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__QuoteListByDate2*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__QuoteListByDate2*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__QuoteListByDate2Response:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__QuoteListByDate2Response*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__QuoteListByDate2Response*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__SymbolHistory:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__SymbolHistory*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__SymbolHistory*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__SymbolHistoryResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__SymbolHistoryResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__SymbolHistoryResponse*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__Top10Gains:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__Top10Gains*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__Top10Gains*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__Top10GainsResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__Top10GainsResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__Top10GainsResponse*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__Top10Losses:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__Top10Losses*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__Top10Losses*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__Top10LossesResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__Top10LossesResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__Top10LossesResponse*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__SymbolChart:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__SymbolChart*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__SymbolChart*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__SymbolChartResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__SymbolChartResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__SymbolChartResponse*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__ExchangeMonths:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__ExchangeMonths*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__ExchangeMonths*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__ExchangeMonthsResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__ExchangeMonthsResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__ExchangeMonthsResponse*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__SplitListByExchange:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__SplitListByExchange*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__SplitListByExchange*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__SplitListByExchangeResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__SplitListByExchangeResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__SplitListByExchangeResponse*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__SplitListBySymbol:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__SplitListBySymbol*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__SplitListBySymbol*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__SplitListBySymbolResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__SplitListBySymbolResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__SplitListBySymbolResponse*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__CountryList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__CountryList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__CountryList*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__CountryListResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__CountryListResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__CountryListResponse*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__SymbolHistoryPeriod:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__SymbolHistoryPeriod*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__SymbolHistoryPeriod*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__SymbolHistoryPeriodResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__SymbolHistoryPeriodResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__SymbolHistoryPeriodResponse*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__SymbolHistoryPeriodByDateRange:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__SymbolHistoryPeriodByDateRange*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__SymbolHistoryPeriodByDateRange*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__SymbolHistoryPeriodByDateRangeResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__SymbolHistoryPeriodByDateRangeResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__SymbolHistoryPeriodByDateRangeResponse*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__QuoteListByDatePeriod:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__QuoteListByDatePeriod*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__QuoteListByDatePeriod*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__QuoteListByDatePeriodResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__QuoteListByDatePeriodResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__QuoteListByDatePeriodResponse*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__QuoteListByDatePeriod2:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__QuoteListByDatePeriod2*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__QuoteListByDatePeriod2*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__QuoteListByDatePeriod2Response:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__QuoteListByDatePeriod2Response*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__QuoteListByDatePeriod2Response*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__SymbolChangesByExchange:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__SymbolChangesByExchange*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__SymbolChangesByExchange*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__SymbolChangesByExchangeResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__SymbolChangesByExchangeResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__SymbolChangesByExchangeResponse*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__DataClientLatestVersion:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__DataClientLatestVersion*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__DataClientLatestVersion*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__DataClientLatestVersionResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__DataClientLatestVersionResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__DataClientLatestVersionResponse*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__DataFormats:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__DataFormats*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__DataFormats*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__DataFormatsResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__DataFormatsResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__DataFormatsResponse*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__UpdateDataFormat:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__UpdateDataFormat*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__UpdateDataFormat*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__UpdateDataFormatResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__UpdateDataFormatResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__UpdateDataFormatResponse*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__ValidateAccess:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__ValidateAccess*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__ValidateAccess*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata__eoddata1__ValidateAccessResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_eoddata1__ValidateAccessResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_eoddata1__ValidateAccessResponse*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__Login:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__Login*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__Login*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__Login2:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__Login2*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__Login2*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__Membership:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__Membership*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__Membership*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__ExchangeList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__ExchangeList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__ExchangeList*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__ExchangeGet:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__ExchangeGet*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__ExchangeGet*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__SymbolList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__SymbolList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__SymbolList*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__SymbolList2:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__SymbolList2*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__SymbolList2*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__QuoteGet:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__QuoteGet*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__QuoteGet*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__QuoteList2:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__QuoteList2*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__QuoteList2*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__SymbolGet:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__SymbolGet*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__SymbolGet*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__QuoteList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__QuoteList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__QuoteList*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__NewsList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__NewsList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__NewsList*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__NewsListBySymbol:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__NewsListBySymbol*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__NewsListBySymbol*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__FundamentalList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__FundamentalList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__FundamentalList*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__TechnicalList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__TechnicalList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__TechnicalList*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__QuoteListByDate:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__QuoteListByDate*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__QuoteListByDate*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__QuoteListByDate2:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__QuoteListByDate2*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__QuoteListByDate2*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__SymbolHistory:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__SymbolHistory*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__SymbolHistory*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__Top10Gains:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__Top10Gains*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__Top10Gains*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__Top10Losses:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__Top10Losses*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__Top10Losses*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__SymbolChart:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__SymbolChart*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__SymbolChart*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__ExchangeMonths:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__ExchangeMonths*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__ExchangeMonths*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__SplitListByExchange:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__SplitListByExchange*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__SplitListByExchange*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__SplitListBySymbol:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__SplitListBySymbol*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__SplitListBySymbol*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__CountryList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__CountryList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__CountryList*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__SymbolHistoryPeriod:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__SymbolHistoryPeriod*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__SymbolHistoryPeriod*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__SymbolHistoryPeriodByDateRange:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__SymbolHistoryPeriodByDateRange*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__SymbolHistoryPeriodByDateRange*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__QuoteListByDatePeriod:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__QuoteListByDatePeriod*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__QuoteListByDatePeriod*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__QuoteListByDatePeriod2:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__QuoteListByDatePeriod2*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__QuoteListByDatePeriod2*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__SymbolChangesByExchange:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__SymbolChangesByExchange*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__SymbolChangesByExchange*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__DataClientLatestVersion:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__DataClientLatestVersion*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__DataClientLatestVersion*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__DataFormats:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__DataFormats*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__DataFormats*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__UpdateDataFormat:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__UpdateDataFormat*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__UpdateDataFormat*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__ValidateAccess:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__ValidateAccess*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__ValidateAccess*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__Login_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__Login_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__Login_*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__Login2_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__Login2_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__Login2_*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__Membership_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__Membership_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__Membership_*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__ExchangeList_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__ExchangeList_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__ExchangeList_*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__ExchangeGet_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__ExchangeGet_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__ExchangeGet_*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__SymbolList_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__SymbolList_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__SymbolList_*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__SymbolList2_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__SymbolList2_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__SymbolList2_*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__QuoteGet_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__QuoteGet_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__QuoteGet_*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__QuoteList2_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__QuoteList2_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__QuoteList2_*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__SymbolGet_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__SymbolGet_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__SymbolGet_*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__QuoteList_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__QuoteList_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__QuoteList_*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__NewsList_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__NewsList_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__NewsList_*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__NewsListBySymbol_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__NewsListBySymbol_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__NewsListBySymbol_*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__FundamentalList_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__FundamentalList_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__FundamentalList_*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__TechnicalList_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__TechnicalList_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__TechnicalList_*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__QuoteListByDate_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__QuoteListByDate_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__QuoteListByDate_*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__QuoteListByDate2_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__QuoteListByDate2_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__QuoteListByDate2_*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__SymbolHistory_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__SymbolHistory_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__SymbolHistory_*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__Top10Gains_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__Top10Gains_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__Top10Gains_*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__Top10Losses_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__Top10Losses_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__Top10Losses_*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__SymbolChart_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__SymbolChart_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__SymbolChart_*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__ExchangeMonths_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__ExchangeMonths_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__ExchangeMonths_*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__SplitListByExchange_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__SplitListByExchange_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__SplitListByExchange_*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__SplitListBySymbol_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__SplitListBySymbol_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__SplitListBySymbol_*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__CountryList_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__CountryList_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__CountryList_*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__SymbolHistoryPeriod_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__SymbolHistoryPeriod_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__SymbolHistoryPeriod_*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__SymbolHistoryPeriodByDateRange_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__SymbolHistoryPeriodByDateRange_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__SymbolHistoryPeriodByDateRange_*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__QuoteListByDatePeriod_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__QuoteListByDatePeriod_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__QuoteListByDatePeriod_*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__QuoteListByDatePeriod2_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__QuoteListByDatePeriod2_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__QuoteListByDatePeriod2_*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__SymbolChangesByExchange_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__SymbolChangesByExchange_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__SymbolChangesByExchange_*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__DataClientLatestVersion_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__DataClientLatestVersion_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__DataClientLatestVersion_*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__DataFormats_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__DataFormats_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__DataFormats_*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__UpdateDataFormat_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__UpdateDataFormat_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__UpdateDataFormat_*>(p->ptr));
		break;
	case SOAP_TYPE_eoddata___eoddata1__ValidateAccess_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __eoddata1__ValidateAccess_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __eoddata1__ValidateAccess_*>(p->ptr));
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_eoddata_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Header*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Header*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_eoddata_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Code*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Code*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_eoddata_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Detail*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Detail*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_eoddata_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Reason*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Reason*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_eoddata_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Fault*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Fault*>(p->ptr));
		break;
#endif
	case SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__DATAFORMAT_USCORECOLUMN:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<eoddata1__DATAFORMAT_USCORECOLUMN *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<eoddata1__DATAFORMAT_USCORECOLUMN *> *>(p->ptr));
		break;
	case SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__DATAFORMAT:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<eoddata1__DATAFORMAT *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<eoddata1__DATAFORMAT *> *>(p->ptr));
		break;
	case SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__NEWS:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<eoddata1__NEWS *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<eoddata1__NEWS *> *>(p->ptr));
		break;
	case SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__SYMBOLCHANGE:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<eoddata1__SYMBOLCHANGE *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<eoddata1__SYMBOLCHANGE *> *>(p->ptr));
		break;
	case SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__TECHNICAL:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<eoddata1__TECHNICAL *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<eoddata1__TECHNICAL *> *>(p->ptr));
		break;
	case SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__FUNDAMENTAL:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<eoddata1__FUNDAMENTAL *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<eoddata1__FUNDAMENTAL *> *>(p->ptr));
		break;
	case SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__CountryBase:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<eoddata1__CountryBase *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<eoddata1__CountryBase *> *>(p->ptr));
		break;
	case SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__SPLIT:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<eoddata1__SPLIT *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<eoddata1__SPLIT *> *>(p->ptr));
		break;
	case SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__QUOTE2:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<eoddata1__QUOTE2 *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<eoddata1__QUOTE2 *> *>(p->ptr));
		break;
	case SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__QUOTE:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<eoddata1__QUOTE *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<eoddata1__QUOTE *> *>(p->ptr));
		break;
	case SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__SYMBOL2:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<eoddata1__SYMBOL2 *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<eoddata1__SYMBOL2 *> *>(p->ptr));
		break;
	case SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__SYMBOL:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<eoddata1__SYMBOL *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<eoddata1__SYMBOL *> *>(p->ptr));
		break;
	case SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__EXCHANGE:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<eoddata1__EXCHANGE *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<eoddata1__EXCHANGE *> *>(p->ptr));
		break;
	default:
		return SOAP_ERR;
	}
	return SOAP_OK;
}

#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 int SOAP_FMAC4 eoddata_fbase(int t, int b)
{
	do
	{	switch (t)
		{
		default: return 0;
		}
	}
	while (t != b);
	return 1;
}
#ifdef WIN32
#pragma warning(pop)
#endif

#ifndef WITH_NOIDREF
#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 void SOAP_FMAC4 eoddata_finsert(struct soap *soap, int t, int tt, void *p, size_t index, const void *q, void **x)
{
	(void)soap; (void)t; (void)p; (void)index; (void)q; (void)x; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__DATAFORMAT_USCORECOLUMN:
		if (t == SOAP_TYPE_eoddata_eoddata1__DATAFORMAT_USCORECOLUMN)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<eoddata1__DATAFORMAT_USCORECOLUMN *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<eoddata1__DATAFORMAT_USCORECOLUMN *> *)p)[index] = *(eoddata1__DATAFORMAT_USCORECOLUMN **)q;
		}
		break;
	case SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__DATAFORMAT:
		if (t == SOAP_TYPE_eoddata_eoddata1__DATAFORMAT)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<eoddata1__DATAFORMAT *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<eoddata1__DATAFORMAT *> *)p)[index] = *(eoddata1__DATAFORMAT **)q;
		}
		break;
	case SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__NEWS:
		if (t == SOAP_TYPE_eoddata_eoddata1__NEWS)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<eoddata1__NEWS *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<eoddata1__NEWS *> *)p)[index] = *(eoddata1__NEWS **)q;
		}
		break;
	case SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__SYMBOLCHANGE:
		if (t == SOAP_TYPE_eoddata_eoddata1__SYMBOLCHANGE)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<eoddata1__SYMBOLCHANGE *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<eoddata1__SYMBOLCHANGE *> *)p)[index] = *(eoddata1__SYMBOLCHANGE **)q;
		}
		break;
	case SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__TECHNICAL:
		if (t == SOAP_TYPE_eoddata_eoddata1__TECHNICAL)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<eoddata1__TECHNICAL *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<eoddata1__TECHNICAL *> *)p)[index] = *(eoddata1__TECHNICAL **)q;
		}
		break;
	case SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__FUNDAMENTAL:
		if (t == SOAP_TYPE_eoddata_eoddata1__FUNDAMENTAL)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<eoddata1__FUNDAMENTAL *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<eoddata1__FUNDAMENTAL *> *)p)[index] = *(eoddata1__FUNDAMENTAL **)q;
		}
		break;
	case SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__CountryBase:
		if (t == SOAP_TYPE_eoddata_eoddata1__CountryBase)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<eoddata1__CountryBase *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<eoddata1__CountryBase *> *)p)[index] = *(eoddata1__CountryBase **)q;
		}
		break;
	case SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__SPLIT:
		if (t == SOAP_TYPE_eoddata_eoddata1__SPLIT)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<eoddata1__SPLIT *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<eoddata1__SPLIT *> *)p)[index] = *(eoddata1__SPLIT **)q;
		}
		break;
	case SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__QUOTE2:
		if (t == SOAP_TYPE_eoddata_eoddata1__QUOTE2)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<eoddata1__QUOTE2 *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<eoddata1__QUOTE2 *> *)p)[index] = *(eoddata1__QUOTE2 **)q;
		}
		break;
	case SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__QUOTE:
		if (t == SOAP_TYPE_eoddata_eoddata1__QUOTE)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<eoddata1__QUOTE *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<eoddata1__QUOTE *> *)p)[index] = *(eoddata1__QUOTE **)q;
		}
		break;
	case SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__SYMBOL2:
		if (t == SOAP_TYPE_eoddata_eoddata1__SYMBOL2)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<eoddata1__SYMBOL2 *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<eoddata1__SYMBOL2 *> *)p)[index] = *(eoddata1__SYMBOL2 **)q;
		}
		break;
	case SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__SYMBOL:
		if (t == SOAP_TYPE_eoddata_eoddata1__SYMBOL)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<eoddata1__SYMBOL *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<eoddata1__SYMBOL *> *)p)[index] = *(eoddata1__SYMBOL **)q;
		}
		break;
	case SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__EXCHANGE:
		if (t == SOAP_TYPE_eoddata_eoddata1__EXCHANGE)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<eoddata1__EXCHANGE *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<eoddata1__EXCHANGE *> *)p)[index] = *(eoddata1__EXCHANGE **)q;
		}
		break;
	case SOAP_TYPE_eoddata_std__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_eoddata_eoddata1__LOGINRESPONSE:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy eoddata1__LOGINRESPONSE type=%d location=%p object=%p\n", t, p, q));
		*(eoddata1__LOGINRESPONSE*)p = *(eoddata1__LOGINRESPONSE*)q;
		break;
	case SOAP_TYPE_eoddata_eoddata1__RESPONSE:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy eoddata1__RESPONSE type=%d location=%p object=%p\n", t, p, q));
		*(eoddata1__RESPONSE*)p = *(eoddata1__RESPONSE*)q;
		break;
	case SOAP_TYPE_eoddata_eoddata1__EXCHANGE:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy eoddata1__EXCHANGE type=%d location=%p object=%p\n", t, p, q));
		*(eoddata1__EXCHANGE*)p = *(eoddata1__EXCHANGE*)q;
		break;
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfEXCHANGE:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy eoddata1__ArrayOfEXCHANGE type=%d location=%p object=%p\n", t, p, q));
		*(eoddata1__ArrayOfEXCHANGE*)p = *(eoddata1__ArrayOfEXCHANGE*)q;
		break;
	case SOAP_TYPE_eoddata_eoddata1__SYMBOL:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy eoddata1__SYMBOL type=%d location=%p object=%p\n", t, p, q));
		*(eoddata1__SYMBOL*)p = *(eoddata1__SYMBOL*)q;
		break;
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfSYMBOL:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy eoddata1__ArrayOfSYMBOL type=%d location=%p object=%p\n", t, p, q));
		*(eoddata1__ArrayOfSYMBOL*)p = *(eoddata1__ArrayOfSYMBOL*)q;
		break;
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfSYMBOL2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy eoddata1__ArrayOfSYMBOL2 type=%d location=%p object=%p\n", t, p, q));
		*(eoddata1__ArrayOfSYMBOL2*)p = *(eoddata1__ArrayOfSYMBOL2*)q;
		break;
	case SOAP_TYPE_eoddata_eoddata1__SYMBOL2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy eoddata1__SYMBOL2 type=%d location=%p object=%p\n", t, p, q));
		*(eoddata1__SYMBOL2*)p = *(eoddata1__SYMBOL2*)q;
		break;
	case SOAP_TYPE_eoddata_eoddata1__QUOTE:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy eoddata1__QUOTE type=%d location=%p object=%p\n", t, p, q));
		*(eoddata1__QUOTE*)p = *(eoddata1__QUOTE*)q;
		break;
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfQUOTE:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy eoddata1__ArrayOfQUOTE type=%d location=%p object=%p\n", t, p, q));
		*(eoddata1__ArrayOfQUOTE*)p = *(eoddata1__ArrayOfQUOTE*)q;
		break;
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfQUOTE2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy eoddata1__ArrayOfQUOTE2 type=%d location=%p object=%p\n", t, p, q));
		*(eoddata1__ArrayOfQUOTE2*)p = *(eoddata1__ArrayOfQUOTE2*)q;
		break;
	case SOAP_TYPE_eoddata_eoddata1__QUOTE2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy eoddata1__QUOTE2 type=%d location=%p object=%p\n", t, p, q));
		*(eoddata1__QUOTE2*)p = *(eoddata1__QUOTE2*)q;
		break;
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfSPLIT:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy eoddata1__ArrayOfSPLIT type=%d location=%p object=%p\n", t, p, q));
		*(eoddata1__ArrayOfSPLIT*)p = *(eoddata1__ArrayOfSPLIT*)q;
		break;
	case SOAP_TYPE_eoddata_eoddata1__SPLIT:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy eoddata1__SPLIT type=%d location=%p object=%p\n", t, p, q));
		*(eoddata1__SPLIT*)p = *(eoddata1__SPLIT*)q;
		break;
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfCountryBase:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy eoddata1__ArrayOfCountryBase type=%d location=%p object=%p\n", t, p, q));
		*(eoddata1__ArrayOfCountryBase*)p = *(eoddata1__ArrayOfCountryBase*)q;
		break;
	case SOAP_TYPE_eoddata_eoddata1__CountryBase:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy eoddata1__CountryBase type=%d location=%p object=%p\n", t, p, q));
		*(eoddata1__CountryBase*)p = *(eoddata1__CountryBase*)q;
		break;
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfFUNDAMENTAL:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy eoddata1__ArrayOfFUNDAMENTAL type=%d location=%p object=%p\n", t, p, q));
		*(eoddata1__ArrayOfFUNDAMENTAL*)p = *(eoddata1__ArrayOfFUNDAMENTAL*)q;
		break;
	case SOAP_TYPE_eoddata_eoddata1__FUNDAMENTAL:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy eoddata1__FUNDAMENTAL type=%d location=%p object=%p\n", t, p, q));
		*(eoddata1__FUNDAMENTAL*)p = *(eoddata1__FUNDAMENTAL*)q;
		break;
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfTECHNICAL:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy eoddata1__ArrayOfTECHNICAL type=%d location=%p object=%p\n", t, p, q));
		*(eoddata1__ArrayOfTECHNICAL*)p = *(eoddata1__ArrayOfTECHNICAL*)q;
		break;
	case SOAP_TYPE_eoddata_eoddata1__TECHNICAL:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy eoddata1__TECHNICAL type=%d location=%p object=%p\n", t, p, q));
		*(eoddata1__TECHNICAL*)p = *(eoddata1__TECHNICAL*)q;
		break;
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfSYMBOLCHANGE:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy eoddata1__ArrayOfSYMBOLCHANGE type=%d location=%p object=%p\n", t, p, q));
		*(eoddata1__ArrayOfSYMBOLCHANGE*)p = *(eoddata1__ArrayOfSYMBOLCHANGE*)q;
		break;
	case SOAP_TYPE_eoddata_eoddata1__SYMBOLCHANGE:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy eoddata1__SYMBOLCHANGE type=%d location=%p object=%p\n", t, p, q));
		*(eoddata1__SYMBOLCHANGE*)p = *(eoddata1__SYMBOLCHANGE*)q;
		break;
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfNEWS:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy eoddata1__ArrayOfNEWS type=%d location=%p object=%p\n", t, p, q));
		*(eoddata1__ArrayOfNEWS*)p = *(eoddata1__ArrayOfNEWS*)q;
		break;
	case SOAP_TYPE_eoddata_eoddata1__NEWS:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy eoddata1__NEWS type=%d location=%p object=%p\n", t, p, q));
		*(eoddata1__NEWS*)p = *(eoddata1__NEWS*)q;
		break;
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfDATAFORMAT:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy eoddata1__ArrayOfDATAFORMAT type=%d location=%p object=%p\n", t, p, q));
		*(eoddata1__ArrayOfDATAFORMAT*)p = *(eoddata1__ArrayOfDATAFORMAT*)q;
		break;
	case SOAP_TYPE_eoddata_eoddata1__DATAFORMAT:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy eoddata1__DATAFORMAT type=%d location=%p object=%p\n", t, p, q));
		*(eoddata1__DATAFORMAT*)p = *(eoddata1__DATAFORMAT*)q;
		break;
	case SOAP_TYPE_eoddata_eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN type=%d location=%p object=%p\n", t, p, q));
		*(eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN*)p = *(eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN*)q;
		break;
	case SOAP_TYPE_eoddata_eoddata1__DATAFORMAT_USCORECOLUMN:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy eoddata1__DATAFORMAT_USCORECOLUMN type=%d location=%p object=%p\n", t, p, q));
		*(eoddata1__DATAFORMAT_USCORECOLUMN*)p = *(eoddata1__DATAFORMAT_USCORECOLUMN*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__Login:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__Login type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__Login*)p = *(_eoddata1__Login*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__LoginResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__LoginResponse type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__LoginResponse*)p = *(_eoddata1__LoginResponse*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__Login2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__Login2 type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__Login2*)p = *(_eoddata1__Login2*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__Login2Response:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__Login2Response type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__Login2Response*)p = *(_eoddata1__Login2Response*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__Membership:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__Membership type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__Membership*)p = *(_eoddata1__Membership*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__MembershipResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__MembershipResponse type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__MembershipResponse*)p = *(_eoddata1__MembershipResponse*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__ExchangeList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__ExchangeList type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__ExchangeList*)p = *(_eoddata1__ExchangeList*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__ExchangeListResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__ExchangeListResponse type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__ExchangeListResponse*)p = *(_eoddata1__ExchangeListResponse*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__ExchangeGet:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__ExchangeGet type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__ExchangeGet*)p = *(_eoddata1__ExchangeGet*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__ExchangeGetResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__ExchangeGetResponse type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__ExchangeGetResponse*)p = *(_eoddata1__ExchangeGetResponse*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__SymbolList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__SymbolList type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__SymbolList*)p = *(_eoddata1__SymbolList*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__SymbolListResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__SymbolListResponse type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__SymbolListResponse*)p = *(_eoddata1__SymbolListResponse*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__SymbolList2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__SymbolList2 type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__SymbolList2*)p = *(_eoddata1__SymbolList2*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__SymbolList2Response:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__SymbolList2Response type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__SymbolList2Response*)p = *(_eoddata1__SymbolList2Response*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__QuoteGet:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__QuoteGet type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__QuoteGet*)p = *(_eoddata1__QuoteGet*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__QuoteGetResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__QuoteGetResponse type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__QuoteGetResponse*)p = *(_eoddata1__QuoteGetResponse*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__QuoteList2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__QuoteList2 type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__QuoteList2*)p = *(_eoddata1__QuoteList2*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__QuoteList2Response:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__QuoteList2Response type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__QuoteList2Response*)p = *(_eoddata1__QuoteList2Response*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__SymbolGet:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__SymbolGet type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__SymbolGet*)p = *(_eoddata1__SymbolGet*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__SymbolGetResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__SymbolGetResponse type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__SymbolGetResponse*)p = *(_eoddata1__SymbolGetResponse*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__QuoteList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__QuoteList type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__QuoteList*)p = *(_eoddata1__QuoteList*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__QuoteListResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__QuoteListResponse type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__QuoteListResponse*)p = *(_eoddata1__QuoteListResponse*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__NewsList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__NewsList type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__NewsList*)p = *(_eoddata1__NewsList*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__NewsListResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__NewsListResponse type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__NewsListResponse*)p = *(_eoddata1__NewsListResponse*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__NewsListBySymbol:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__NewsListBySymbol type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__NewsListBySymbol*)p = *(_eoddata1__NewsListBySymbol*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__NewsListBySymbolResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__NewsListBySymbolResponse type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__NewsListBySymbolResponse*)p = *(_eoddata1__NewsListBySymbolResponse*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__FundamentalList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__FundamentalList type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__FundamentalList*)p = *(_eoddata1__FundamentalList*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__FundamentalListResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__FundamentalListResponse type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__FundamentalListResponse*)p = *(_eoddata1__FundamentalListResponse*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__TechnicalList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__TechnicalList type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__TechnicalList*)p = *(_eoddata1__TechnicalList*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__TechnicalListResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__TechnicalListResponse type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__TechnicalListResponse*)p = *(_eoddata1__TechnicalListResponse*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__QuoteListByDate:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__QuoteListByDate type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__QuoteListByDate*)p = *(_eoddata1__QuoteListByDate*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__QuoteListByDateResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__QuoteListByDateResponse type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__QuoteListByDateResponse*)p = *(_eoddata1__QuoteListByDateResponse*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__QuoteListByDate2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__QuoteListByDate2 type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__QuoteListByDate2*)p = *(_eoddata1__QuoteListByDate2*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__QuoteListByDate2Response:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__QuoteListByDate2Response type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__QuoteListByDate2Response*)p = *(_eoddata1__QuoteListByDate2Response*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__SymbolHistory:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__SymbolHistory type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__SymbolHistory*)p = *(_eoddata1__SymbolHistory*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__SymbolHistoryResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__SymbolHistoryResponse type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__SymbolHistoryResponse*)p = *(_eoddata1__SymbolHistoryResponse*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__Top10Gains:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__Top10Gains type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__Top10Gains*)p = *(_eoddata1__Top10Gains*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__Top10GainsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__Top10GainsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__Top10GainsResponse*)p = *(_eoddata1__Top10GainsResponse*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__Top10Losses:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__Top10Losses type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__Top10Losses*)p = *(_eoddata1__Top10Losses*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__Top10LossesResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__Top10LossesResponse type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__Top10LossesResponse*)p = *(_eoddata1__Top10LossesResponse*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__SymbolChart:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__SymbolChart type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__SymbolChart*)p = *(_eoddata1__SymbolChart*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__SymbolChartResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__SymbolChartResponse type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__SymbolChartResponse*)p = *(_eoddata1__SymbolChartResponse*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__ExchangeMonths:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__ExchangeMonths type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__ExchangeMonths*)p = *(_eoddata1__ExchangeMonths*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__ExchangeMonthsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__ExchangeMonthsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__ExchangeMonthsResponse*)p = *(_eoddata1__ExchangeMonthsResponse*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__SplitListByExchange:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__SplitListByExchange type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__SplitListByExchange*)p = *(_eoddata1__SplitListByExchange*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__SplitListByExchangeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__SplitListByExchangeResponse type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__SplitListByExchangeResponse*)p = *(_eoddata1__SplitListByExchangeResponse*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__SplitListBySymbol:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__SplitListBySymbol type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__SplitListBySymbol*)p = *(_eoddata1__SplitListBySymbol*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__SplitListBySymbolResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__SplitListBySymbolResponse type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__SplitListBySymbolResponse*)p = *(_eoddata1__SplitListBySymbolResponse*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__CountryList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__CountryList type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__CountryList*)p = *(_eoddata1__CountryList*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__CountryListResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__CountryListResponse type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__CountryListResponse*)p = *(_eoddata1__CountryListResponse*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__SymbolHistoryPeriod:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__SymbolHistoryPeriod type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__SymbolHistoryPeriod*)p = *(_eoddata1__SymbolHistoryPeriod*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__SymbolHistoryPeriodResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__SymbolHistoryPeriodResponse type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__SymbolHistoryPeriodResponse*)p = *(_eoddata1__SymbolHistoryPeriodResponse*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__SymbolHistoryPeriodByDateRange:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__SymbolHistoryPeriodByDateRange type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__SymbolHistoryPeriodByDateRange*)p = *(_eoddata1__SymbolHistoryPeriodByDateRange*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__SymbolHistoryPeriodByDateRangeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__SymbolHistoryPeriodByDateRangeResponse type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__SymbolHistoryPeriodByDateRangeResponse*)p = *(_eoddata1__SymbolHistoryPeriodByDateRangeResponse*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__QuoteListByDatePeriod:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__QuoteListByDatePeriod type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__QuoteListByDatePeriod*)p = *(_eoddata1__QuoteListByDatePeriod*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__QuoteListByDatePeriodResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__QuoteListByDatePeriodResponse type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__QuoteListByDatePeriodResponse*)p = *(_eoddata1__QuoteListByDatePeriodResponse*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__QuoteListByDatePeriod2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__QuoteListByDatePeriod2 type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__QuoteListByDatePeriod2*)p = *(_eoddata1__QuoteListByDatePeriod2*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__QuoteListByDatePeriod2Response:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__QuoteListByDatePeriod2Response type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__QuoteListByDatePeriod2Response*)p = *(_eoddata1__QuoteListByDatePeriod2Response*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__SymbolChangesByExchange:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__SymbolChangesByExchange type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__SymbolChangesByExchange*)p = *(_eoddata1__SymbolChangesByExchange*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__SymbolChangesByExchangeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__SymbolChangesByExchangeResponse type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__SymbolChangesByExchangeResponse*)p = *(_eoddata1__SymbolChangesByExchangeResponse*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__DataClientLatestVersion:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__DataClientLatestVersion type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__DataClientLatestVersion*)p = *(_eoddata1__DataClientLatestVersion*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__DataClientLatestVersionResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__DataClientLatestVersionResponse type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__DataClientLatestVersionResponse*)p = *(_eoddata1__DataClientLatestVersionResponse*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__DataFormats:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__DataFormats type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__DataFormats*)p = *(_eoddata1__DataFormats*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__DataFormatsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__DataFormatsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__DataFormatsResponse*)p = *(_eoddata1__DataFormatsResponse*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__UpdateDataFormat:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__UpdateDataFormat type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__UpdateDataFormat*)p = *(_eoddata1__UpdateDataFormat*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__UpdateDataFormatResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__UpdateDataFormatResponse type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__UpdateDataFormatResponse*)p = *(_eoddata1__UpdateDataFormatResponse*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__ValidateAccess:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__ValidateAccess type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__ValidateAccess*)p = *(_eoddata1__ValidateAccess*)q;
		break;
	case SOAP_TYPE_eoddata__eoddata1__ValidateAccessResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _eoddata1__ValidateAccessResponse type=%d location=%p object=%p\n", t, p, q));
		*(_eoddata1__ValidateAccessResponse*)p = *(_eoddata1__ValidateAccessResponse*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__Login:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__Login type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__Login*)p = *(struct __eoddata1__Login*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__Login2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__Login2 type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__Login2*)p = *(struct __eoddata1__Login2*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__Membership:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__Membership type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__Membership*)p = *(struct __eoddata1__Membership*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__ExchangeList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__ExchangeList type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__ExchangeList*)p = *(struct __eoddata1__ExchangeList*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__ExchangeGet:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__ExchangeGet type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__ExchangeGet*)p = *(struct __eoddata1__ExchangeGet*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__SymbolList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__SymbolList type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__SymbolList*)p = *(struct __eoddata1__SymbolList*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__SymbolList2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__SymbolList2 type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__SymbolList2*)p = *(struct __eoddata1__SymbolList2*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__QuoteGet:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__QuoteGet type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__QuoteGet*)p = *(struct __eoddata1__QuoteGet*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__QuoteList2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__QuoteList2 type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__QuoteList2*)p = *(struct __eoddata1__QuoteList2*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__SymbolGet:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__SymbolGet type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__SymbolGet*)p = *(struct __eoddata1__SymbolGet*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__QuoteList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__QuoteList type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__QuoteList*)p = *(struct __eoddata1__QuoteList*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__NewsList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__NewsList type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__NewsList*)p = *(struct __eoddata1__NewsList*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__NewsListBySymbol:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__NewsListBySymbol type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__NewsListBySymbol*)p = *(struct __eoddata1__NewsListBySymbol*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__FundamentalList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__FundamentalList type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__FundamentalList*)p = *(struct __eoddata1__FundamentalList*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__TechnicalList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__TechnicalList type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__TechnicalList*)p = *(struct __eoddata1__TechnicalList*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__QuoteListByDate:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__QuoteListByDate type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__QuoteListByDate*)p = *(struct __eoddata1__QuoteListByDate*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__QuoteListByDate2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__QuoteListByDate2 type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__QuoteListByDate2*)p = *(struct __eoddata1__QuoteListByDate2*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__SymbolHistory:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__SymbolHistory type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__SymbolHistory*)p = *(struct __eoddata1__SymbolHistory*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__Top10Gains:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__Top10Gains type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__Top10Gains*)p = *(struct __eoddata1__Top10Gains*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__Top10Losses:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__Top10Losses type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__Top10Losses*)p = *(struct __eoddata1__Top10Losses*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__SymbolChart:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__SymbolChart type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__SymbolChart*)p = *(struct __eoddata1__SymbolChart*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__ExchangeMonths:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__ExchangeMonths type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__ExchangeMonths*)p = *(struct __eoddata1__ExchangeMonths*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__SplitListByExchange:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__SplitListByExchange type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__SplitListByExchange*)p = *(struct __eoddata1__SplitListByExchange*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__SplitListBySymbol:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__SplitListBySymbol type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__SplitListBySymbol*)p = *(struct __eoddata1__SplitListBySymbol*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__CountryList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__CountryList type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__CountryList*)p = *(struct __eoddata1__CountryList*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__SymbolHistoryPeriod:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__SymbolHistoryPeriod type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__SymbolHistoryPeriod*)p = *(struct __eoddata1__SymbolHistoryPeriod*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__SymbolHistoryPeriodByDateRange:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__SymbolHistoryPeriodByDateRange type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__SymbolHistoryPeriodByDateRange*)p = *(struct __eoddata1__SymbolHistoryPeriodByDateRange*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__QuoteListByDatePeriod:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__QuoteListByDatePeriod type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__QuoteListByDatePeriod*)p = *(struct __eoddata1__QuoteListByDatePeriod*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__QuoteListByDatePeriod2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__QuoteListByDatePeriod2 type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__QuoteListByDatePeriod2*)p = *(struct __eoddata1__QuoteListByDatePeriod2*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__SymbolChangesByExchange:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__SymbolChangesByExchange type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__SymbolChangesByExchange*)p = *(struct __eoddata1__SymbolChangesByExchange*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__DataClientLatestVersion:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__DataClientLatestVersion type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__DataClientLatestVersion*)p = *(struct __eoddata1__DataClientLatestVersion*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__DataFormats:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__DataFormats type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__DataFormats*)p = *(struct __eoddata1__DataFormats*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__UpdateDataFormat:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__UpdateDataFormat type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__UpdateDataFormat*)p = *(struct __eoddata1__UpdateDataFormat*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__ValidateAccess:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__ValidateAccess type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__ValidateAccess*)p = *(struct __eoddata1__ValidateAccess*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__Login_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__Login_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__Login_*)p = *(struct __eoddata1__Login_*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__Login2_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__Login2_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__Login2_*)p = *(struct __eoddata1__Login2_*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__Membership_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__Membership_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__Membership_*)p = *(struct __eoddata1__Membership_*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__ExchangeList_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__ExchangeList_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__ExchangeList_*)p = *(struct __eoddata1__ExchangeList_*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__ExchangeGet_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__ExchangeGet_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__ExchangeGet_*)p = *(struct __eoddata1__ExchangeGet_*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__SymbolList_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__SymbolList_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__SymbolList_*)p = *(struct __eoddata1__SymbolList_*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__SymbolList2_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__SymbolList2_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__SymbolList2_*)p = *(struct __eoddata1__SymbolList2_*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__QuoteGet_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__QuoteGet_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__QuoteGet_*)p = *(struct __eoddata1__QuoteGet_*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__QuoteList2_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__QuoteList2_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__QuoteList2_*)p = *(struct __eoddata1__QuoteList2_*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__SymbolGet_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__SymbolGet_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__SymbolGet_*)p = *(struct __eoddata1__SymbolGet_*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__QuoteList_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__QuoteList_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__QuoteList_*)p = *(struct __eoddata1__QuoteList_*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__NewsList_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__NewsList_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__NewsList_*)p = *(struct __eoddata1__NewsList_*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__NewsListBySymbol_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__NewsListBySymbol_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__NewsListBySymbol_*)p = *(struct __eoddata1__NewsListBySymbol_*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__FundamentalList_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__FundamentalList_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__FundamentalList_*)p = *(struct __eoddata1__FundamentalList_*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__TechnicalList_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__TechnicalList_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__TechnicalList_*)p = *(struct __eoddata1__TechnicalList_*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__QuoteListByDate_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__QuoteListByDate_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__QuoteListByDate_*)p = *(struct __eoddata1__QuoteListByDate_*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__QuoteListByDate2_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__QuoteListByDate2_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__QuoteListByDate2_*)p = *(struct __eoddata1__QuoteListByDate2_*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__SymbolHistory_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__SymbolHistory_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__SymbolHistory_*)p = *(struct __eoddata1__SymbolHistory_*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__Top10Gains_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__Top10Gains_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__Top10Gains_*)p = *(struct __eoddata1__Top10Gains_*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__Top10Losses_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__Top10Losses_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__Top10Losses_*)p = *(struct __eoddata1__Top10Losses_*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__SymbolChart_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__SymbolChart_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__SymbolChart_*)p = *(struct __eoddata1__SymbolChart_*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__ExchangeMonths_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__ExchangeMonths_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__ExchangeMonths_*)p = *(struct __eoddata1__ExchangeMonths_*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__SplitListByExchange_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__SplitListByExchange_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__SplitListByExchange_*)p = *(struct __eoddata1__SplitListByExchange_*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__SplitListBySymbol_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__SplitListBySymbol_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__SplitListBySymbol_*)p = *(struct __eoddata1__SplitListBySymbol_*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__CountryList_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__CountryList_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__CountryList_*)p = *(struct __eoddata1__CountryList_*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__SymbolHistoryPeriod_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__SymbolHistoryPeriod_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__SymbolHistoryPeriod_*)p = *(struct __eoddata1__SymbolHistoryPeriod_*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__SymbolHistoryPeriodByDateRange_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__SymbolHistoryPeriodByDateRange_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__SymbolHistoryPeriodByDateRange_*)p = *(struct __eoddata1__SymbolHistoryPeriodByDateRange_*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__QuoteListByDatePeriod_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__QuoteListByDatePeriod_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__QuoteListByDatePeriod_*)p = *(struct __eoddata1__QuoteListByDatePeriod_*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__QuoteListByDatePeriod2_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__QuoteListByDatePeriod2_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__QuoteListByDatePeriod2_*)p = *(struct __eoddata1__QuoteListByDatePeriod2_*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__SymbolChangesByExchange_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__SymbolChangesByExchange_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__SymbolChangesByExchange_*)p = *(struct __eoddata1__SymbolChangesByExchange_*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__DataClientLatestVersion_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__DataClientLatestVersion_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__DataClientLatestVersion_*)p = *(struct __eoddata1__DataClientLatestVersion_*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__DataFormats_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__DataFormats_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__DataFormats_*)p = *(struct __eoddata1__DataFormats_*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__UpdateDataFormat_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__UpdateDataFormat_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__UpdateDataFormat_*)p = *(struct __eoddata1__UpdateDataFormat_*)q;
		break;
	case SOAP_TYPE_eoddata___eoddata1__ValidateAccess_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __eoddata1__ValidateAccess_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __eoddata1__ValidateAccess_*)p = *(struct __eoddata1__ValidateAccess_*)q;
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_eoddata_SOAP_ENV__Header:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Header type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_eoddata_SOAP_ENV__Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Code type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_eoddata_SOAP_ENV__Detail:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Detail type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_eoddata_SOAP_ENV__Reason:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Reason type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_eoddata_SOAP_ENV__Fault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Fault type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
		break;
#endif
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type = %d in %d\n", t, tt));
	}
}
#ifdef WIN32
#pragma warning(pop)
#endif
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_eoddata_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	a = soap_inbyte(soap, tag, a, type, SOAP_TYPE_eoddata_byte);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	if (soap_out_byte(soap, tag?tag:"byte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_eoddata_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_eoddata_int);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_int(soap, tag?tag:"int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_LONG64(struct soap *soap, LONG64 *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_LONG64
	*a = SOAP_DEFAULT_LONG64;
#else
	*a = (LONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_eoddata_LONG64);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{
	a = soap_inLONG64(soap, tag, a, type, SOAP_TYPE_eoddata_LONG64);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	if (soap_out_LONG64(soap, tag?tag:"long", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_LONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_double(struct soap *soap, double *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_double
	*a = SOAP_DEFAULT_double;
#else
	*a = (double)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_eoddata_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{
	a = soap_indouble(soap, tag, a, type, SOAP_TYPE_eoddata_double);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	if (soap_out_double(soap, tag?tag:"double", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dateTime(struct soap *soap, time_t *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_dateTime
	*a = SOAP_DEFAULT_dateTime;
#else
	*a = (time_t)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dateTime(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_eoddata_dateTime);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_dateTime(struct soap *soap, const char *tag, time_t *a, const char *type)
{
	a = soap_indateTime(soap, tag, a, type, SOAP_TYPE_eoddata_dateTime);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dateTime(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	if (soap_out_dateTime(soap, tag?tag:"dateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_dateTime(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_dateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (LONG64)false, "false" },
	{ (LONG64)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_bool, n != 0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata_bool, sizeof(bool), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata_bool, SOAP_TYPE_eoddata_bool, sizeof(bool), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	if (soap_out_bool(soap, tag?tag:"boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_eoddata_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_eoddata_std__string, sizeof(std::string), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_eoddata_std__string, sizeof(std::string), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase), 0, SOAP_TYPE_eoddata_std__string, SOAP_TYPE_eoddata_std__string, sizeof(std::string), 0, eoddata_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::string *p;
	size_t k = sizeof(std::string);
	if (n < 0)
	{	p = SOAP_NEW(std::string);
	}
	else
	{	p = SOAP_NEW_ARRAY(std::string, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::string location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata_std__string, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_std__string(soap, tag?tag:"string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__ValidateAccessResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__ValidateAccessResponse::ValidateAccessResult = NULL;
	/* transient soap skipped */
}

void _eoddata1__ValidateAccessResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToeoddata1__RESPONSE(soap, &this->_eoddata1__ValidateAccessResponse::ValidateAccessResult);
#endif
}

int _eoddata1__ValidateAccessResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__ValidateAccessResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__ValidateAccessResponse(struct soap *soap, const char *tag, int id, const _eoddata1__ValidateAccessResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__ValidateAccessResponse), type))
		return soap->error;
	if (a->ValidateAccessResult)
		soap_element_result(soap, "eoddata1:ValidateAccessResult");
	if (soap_out_PointerToeoddata1__RESPONSE(soap, "eoddata1:ValidateAccessResult", -1, &a->_eoddata1__ValidateAccessResponse::ValidateAccessResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__ValidateAccessResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__ValidateAccessResponse(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__ValidateAccessResponse * SOAP_FMAC4 soap_in__eoddata1__ValidateAccessResponse(struct soap *soap, const char *tag, _eoddata1__ValidateAccessResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__ValidateAccessResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__ValidateAccessResponse, sizeof(_eoddata1__ValidateAccessResponse), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ValidateAccessResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ValidateAccessResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToeoddata1__RESPONSE(soap, "eoddata1:ValidateAccessResult", &a->_eoddata1__ValidateAccessResponse::ValidateAccessResult, "eoddata1:RESPONSE"))
				{	soap_flag_ValidateAccessResult1--;
					continue;
				}
			soap_check_result(soap, "eoddata1:ValidateAccessResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__ValidateAccessResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__ValidateAccessResponse, SOAP_TYPE_eoddata__eoddata1__ValidateAccessResponse, sizeof(_eoddata1__ValidateAccessResponse), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__ValidateAccessResponse * SOAP_FMAC2 soap_instantiate__eoddata1__ValidateAccessResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__ValidateAccessResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__ValidateAccessResponse *p;
	size_t k = sizeof(_eoddata1__ValidateAccessResponse);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__ValidateAccessResponse);
		if (p)
			((_eoddata1__ValidateAccessResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__ValidateAccessResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__ValidateAccessResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__ValidateAccessResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__ValidateAccessResponse, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__ValidateAccessResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:ValidateAccessResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__ValidateAccessResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__ValidateAccessResponse(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__ValidateAccessResponse * SOAP_FMAC4 soap_get__eoddata1__ValidateAccessResponse(struct soap *soap, _eoddata1__ValidateAccessResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__ValidateAccessResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__ValidateAccess::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__ValidateAccess::Token = NULL;
	this->_eoddata1__ValidateAccess::Exchange = NULL;
	this->_eoddata1__ValidateAccess::QuoteDate = NULL;
	this->_eoddata1__ValidateAccess::Period = NULL;
	/* transient soap skipped */
}

void _eoddata1__ValidateAccess::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__ValidateAccess::Token);
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__ValidateAccess::Exchange);
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__ValidateAccess::QuoteDate);
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__ValidateAccess::Period);
#endif
}

int _eoddata1__ValidateAccess::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__ValidateAccess(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__ValidateAccess(struct soap *soap, const char *tag, int id, const _eoddata1__ValidateAccess *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__ValidateAccess), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Token", -1, &a->_eoddata1__ValidateAccess::Token, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Exchange", -1, &a->_eoddata1__ValidateAccess::Exchange, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:QuoteDate", -1, &a->_eoddata1__ValidateAccess::QuoteDate, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Period", -1, &a->_eoddata1__ValidateAccess::Period, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__ValidateAccess::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__ValidateAccess(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__ValidateAccess * SOAP_FMAC4 soap_in__eoddata1__ValidateAccess(struct soap *soap, const char *tag, _eoddata1__ValidateAccess *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__ValidateAccess *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__ValidateAccess, sizeof(_eoddata1__ValidateAccess), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	size_t soap_flag_Exchange1 = 1;
	size_t soap_flag_QuoteDate1 = 1;
	size_t soap_flag_Period1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Token", &a->_eoddata1__ValidateAccess::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap_flag_Exchange1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Exchange", &a->_eoddata1__ValidateAccess::Exchange, "xsd:string"))
				{	soap_flag_Exchange1--;
					continue;
				}
			if (soap_flag_QuoteDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:QuoteDate", &a->_eoddata1__ValidateAccess::QuoteDate, "xsd:string"))
				{	soap_flag_QuoteDate1--;
					continue;
				}
			if (soap_flag_Period1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Period", &a->_eoddata1__ValidateAccess::Period, "xsd:string"))
				{	soap_flag_Period1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__ValidateAccess *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__ValidateAccess, SOAP_TYPE_eoddata__eoddata1__ValidateAccess, sizeof(_eoddata1__ValidateAccess), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__ValidateAccess * SOAP_FMAC2 soap_instantiate__eoddata1__ValidateAccess(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__ValidateAccess(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__ValidateAccess *p;
	size_t k = sizeof(_eoddata1__ValidateAccess);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__ValidateAccess);
		if (p)
			((_eoddata1__ValidateAccess*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__ValidateAccess, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__ValidateAccess*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__ValidateAccess location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__ValidateAccess, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__ValidateAccess::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:ValidateAccess", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__ValidateAccess::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__ValidateAccess(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__ValidateAccess * SOAP_FMAC4 soap_get__eoddata1__ValidateAccess(struct soap *soap, _eoddata1__ValidateAccess *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__ValidateAccess(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__UpdateDataFormatResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__UpdateDataFormatResponse::UpdateDataFormatResult = NULL;
	/* transient soap skipped */
}

void _eoddata1__UpdateDataFormatResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToeoddata1__RESPONSE(soap, &this->_eoddata1__UpdateDataFormatResponse::UpdateDataFormatResult);
#endif
}

int _eoddata1__UpdateDataFormatResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__UpdateDataFormatResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__UpdateDataFormatResponse(struct soap *soap, const char *tag, int id, const _eoddata1__UpdateDataFormatResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__UpdateDataFormatResponse), type))
		return soap->error;
	if (a->UpdateDataFormatResult)
		soap_element_result(soap, "eoddata1:UpdateDataFormatResult");
	if (soap_out_PointerToeoddata1__RESPONSE(soap, "eoddata1:UpdateDataFormatResult", -1, &a->_eoddata1__UpdateDataFormatResponse::UpdateDataFormatResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__UpdateDataFormatResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__UpdateDataFormatResponse(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__UpdateDataFormatResponse * SOAP_FMAC4 soap_in__eoddata1__UpdateDataFormatResponse(struct soap *soap, const char *tag, _eoddata1__UpdateDataFormatResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__UpdateDataFormatResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__UpdateDataFormatResponse, sizeof(_eoddata1__UpdateDataFormatResponse), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_UpdateDataFormatResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UpdateDataFormatResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToeoddata1__RESPONSE(soap, "eoddata1:UpdateDataFormatResult", &a->_eoddata1__UpdateDataFormatResponse::UpdateDataFormatResult, "eoddata1:RESPONSE"))
				{	soap_flag_UpdateDataFormatResult1--;
					continue;
				}
			soap_check_result(soap, "eoddata1:UpdateDataFormatResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__UpdateDataFormatResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__UpdateDataFormatResponse, SOAP_TYPE_eoddata__eoddata1__UpdateDataFormatResponse, sizeof(_eoddata1__UpdateDataFormatResponse), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__UpdateDataFormatResponse * SOAP_FMAC2 soap_instantiate__eoddata1__UpdateDataFormatResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__UpdateDataFormatResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__UpdateDataFormatResponse *p;
	size_t k = sizeof(_eoddata1__UpdateDataFormatResponse);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__UpdateDataFormatResponse);
		if (p)
			((_eoddata1__UpdateDataFormatResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__UpdateDataFormatResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__UpdateDataFormatResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__UpdateDataFormatResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__UpdateDataFormatResponse, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__UpdateDataFormatResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:UpdateDataFormatResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__UpdateDataFormatResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__UpdateDataFormatResponse(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__UpdateDataFormatResponse * SOAP_FMAC4 soap_get__eoddata1__UpdateDataFormatResponse(struct soap *soap, _eoddata1__UpdateDataFormatResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__UpdateDataFormatResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__UpdateDataFormat::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__UpdateDataFormat::Token = NULL;
	this->_eoddata1__UpdateDataFormat::DataFormat = NULL;
	soap_default_bool(soap, &this->_eoddata1__UpdateDataFormat::IncludeHeader);
	soap_default_bool(soap, &this->_eoddata1__UpdateDataFormat::IncludeSuffix);
	/* transient soap skipped */
}

void _eoddata1__UpdateDataFormat::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__UpdateDataFormat::Token);
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__UpdateDataFormat::DataFormat);
#endif
}

int _eoddata1__UpdateDataFormat::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__UpdateDataFormat(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__UpdateDataFormat(struct soap *soap, const char *tag, int id, const _eoddata1__UpdateDataFormat *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__UpdateDataFormat), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Token", -1, &a->_eoddata1__UpdateDataFormat::Token, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:DataFormat", -1, &a->_eoddata1__UpdateDataFormat::DataFormat, ""))
		return soap->error;
	if (soap_out_bool(soap, "eoddata1:IncludeHeader", -1, &a->_eoddata1__UpdateDataFormat::IncludeHeader, ""))
		return soap->error;
	if (soap_out_bool(soap, "eoddata1:IncludeSuffix", -1, &a->_eoddata1__UpdateDataFormat::IncludeSuffix, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__UpdateDataFormat::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__UpdateDataFormat(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__UpdateDataFormat * SOAP_FMAC4 soap_in__eoddata1__UpdateDataFormat(struct soap *soap, const char *tag, _eoddata1__UpdateDataFormat *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__UpdateDataFormat *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__UpdateDataFormat, sizeof(_eoddata1__UpdateDataFormat), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	size_t soap_flag_DataFormat1 = 1;
	size_t soap_flag_IncludeHeader1 = 1;
	size_t soap_flag_IncludeSuffix1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Token", &a->_eoddata1__UpdateDataFormat::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap_flag_DataFormat1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:DataFormat", &a->_eoddata1__UpdateDataFormat::DataFormat, "xsd:string"))
				{	soap_flag_DataFormat1--;
					continue;
				}
			if (soap_flag_IncludeHeader1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "eoddata1:IncludeHeader", &a->_eoddata1__UpdateDataFormat::IncludeHeader, "xsd:boolean"))
				{	soap_flag_IncludeHeader1--;
					continue;
				}
			if (soap_flag_IncludeSuffix1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "eoddata1:IncludeSuffix", &a->_eoddata1__UpdateDataFormat::IncludeSuffix, "xsd:boolean"))
				{	soap_flag_IncludeSuffix1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_IncludeHeader1 > 0 || soap_flag_IncludeSuffix1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_eoddata1__UpdateDataFormat *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__UpdateDataFormat, SOAP_TYPE_eoddata__eoddata1__UpdateDataFormat, sizeof(_eoddata1__UpdateDataFormat), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__UpdateDataFormat * SOAP_FMAC2 soap_instantiate__eoddata1__UpdateDataFormat(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__UpdateDataFormat(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__UpdateDataFormat *p;
	size_t k = sizeof(_eoddata1__UpdateDataFormat);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__UpdateDataFormat);
		if (p)
			((_eoddata1__UpdateDataFormat*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__UpdateDataFormat, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__UpdateDataFormat*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__UpdateDataFormat location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__UpdateDataFormat, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__UpdateDataFormat::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:UpdateDataFormat", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__UpdateDataFormat::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__UpdateDataFormat(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__UpdateDataFormat * SOAP_FMAC4 soap_get__eoddata1__UpdateDataFormat(struct soap *soap, _eoddata1__UpdateDataFormat *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__UpdateDataFormat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__DataFormatsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__DataFormatsResponse::DataFormatsResult = NULL;
	/* transient soap skipped */
}

void _eoddata1__DataFormatsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToeoddata1__RESPONSE(soap, &this->_eoddata1__DataFormatsResponse::DataFormatsResult);
#endif
}

int _eoddata1__DataFormatsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__DataFormatsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__DataFormatsResponse(struct soap *soap, const char *tag, int id, const _eoddata1__DataFormatsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__DataFormatsResponse), type))
		return soap->error;
	if (a->DataFormatsResult)
		soap_element_result(soap, "eoddata1:DataFormatsResult");
	if (soap_out_PointerToeoddata1__RESPONSE(soap, "eoddata1:DataFormatsResult", -1, &a->_eoddata1__DataFormatsResponse::DataFormatsResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__DataFormatsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__DataFormatsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__DataFormatsResponse * SOAP_FMAC4 soap_in__eoddata1__DataFormatsResponse(struct soap *soap, const char *tag, _eoddata1__DataFormatsResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__DataFormatsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__DataFormatsResponse, sizeof(_eoddata1__DataFormatsResponse), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_DataFormatsResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DataFormatsResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToeoddata1__RESPONSE(soap, "eoddata1:DataFormatsResult", &a->_eoddata1__DataFormatsResponse::DataFormatsResult, "eoddata1:RESPONSE"))
				{	soap_flag_DataFormatsResult1--;
					continue;
				}
			soap_check_result(soap, "eoddata1:DataFormatsResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__DataFormatsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__DataFormatsResponse, SOAP_TYPE_eoddata__eoddata1__DataFormatsResponse, sizeof(_eoddata1__DataFormatsResponse), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__DataFormatsResponse * SOAP_FMAC2 soap_instantiate__eoddata1__DataFormatsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__DataFormatsResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__DataFormatsResponse *p;
	size_t k = sizeof(_eoddata1__DataFormatsResponse);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__DataFormatsResponse);
		if (p)
			((_eoddata1__DataFormatsResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__DataFormatsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__DataFormatsResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__DataFormatsResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__DataFormatsResponse, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__DataFormatsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:DataFormatsResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__DataFormatsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__DataFormatsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__DataFormatsResponse * SOAP_FMAC4 soap_get__eoddata1__DataFormatsResponse(struct soap *soap, _eoddata1__DataFormatsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__DataFormatsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__DataFormats::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__DataFormats::Token = NULL;
	/* transient soap skipped */
}

void _eoddata1__DataFormats::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__DataFormats::Token);
#endif
}

int _eoddata1__DataFormats::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__DataFormats(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__DataFormats(struct soap *soap, const char *tag, int id, const _eoddata1__DataFormats *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__DataFormats), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Token", -1, &a->_eoddata1__DataFormats::Token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__DataFormats::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__DataFormats(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__DataFormats * SOAP_FMAC4 soap_in__eoddata1__DataFormats(struct soap *soap, const char *tag, _eoddata1__DataFormats *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__DataFormats *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__DataFormats, sizeof(_eoddata1__DataFormats), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Token", &a->_eoddata1__DataFormats::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__DataFormats *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__DataFormats, SOAP_TYPE_eoddata__eoddata1__DataFormats, sizeof(_eoddata1__DataFormats), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__DataFormats * SOAP_FMAC2 soap_instantiate__eoddata1__DataFormats(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__DataFormats(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__DataFormats *p;
	size_t k = sizeof(_eoddata1__DataFormats);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__DataFormats);
		if (p)
			((_eoddata1__DataFormats*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__DataFormats, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__DataFormats*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__DataFormats location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__DataFormats, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__DataFormats::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:DataFormats", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__DataFormats::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__DataFormats(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__DataFormats * SOAP_FMAC4 soap_get__eoddata1__DataFormats(struct soap *soap, _eoddata1__DataFormats *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__DataFormats(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__DataClientLatestVersionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__DataClientLatestVersionResponse::DataClientLatestVersionResult = NULL;
	/* transient soap skipped */
}

void _eoddata1__DataClientLatestVersionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToeoddata1__RESPONSE(soap, &this->_eoddata1__DataClientLatestVersionResponse::DataClientLatestVersionResult);
#endif
}

int _eoddata1__DataClientLatestVersionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__DataClientLatestVersionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__DataClientLatestVersionResponse(struct soap *soap, const char *tag, int id, const _eoddata1__DataClientLatestVersionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__DataClientLatestVersionResponse), type))
		return soap->error;
	if (a->DataClientLatestVersionResult)
		soap_element_result(soap, "eoddata1:DataClientLatestVersionResult");
	if (soap_out_PointerToeoddata1__RESPONSE(soap, "eoddata1:DataClientLatestVersionResult", -1, &a->_eoddata1__DataClientLatestVersionResponse::DataClientLatestVersionResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__DataClientLatestVersionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__DataClientLatestVersionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__DataClientLatestVersionResponse * SOAP_FMAC4 soap_in__eoddata1__DataClientLatestVersionResponse(struct soap *soap, const char *tag, _eoddata1__DataClientLatestVersionResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__DataClientLatestVersionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__DataClientLatestVersionResponse, sizeof(_eoddata1__DataClientLatestVersionResponse), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_DataClientLatestVersionResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DataClientLatestVersionResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToeoddata1__RESPONSE(soap, "eoddata1:DataClientLatestVersionResult", &a->_eoddata1__DataClientLatestVersionResponse::DataClientLatestVersionResult, "eoddata1:RESPONSE"))
				{	soap_flag_DataClientLatestVersionResult1--;
					continue;
				}
			soap_check_result(soap, "eoddata1:DataClientLatestVersionResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__DataClientLatestVersionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__DataClientLatestVersionResponse, SOAP_TYPE_eoddata__eoddata1__DataClientLatestVersionResponse, sizeof(_eoddata1__DataClientLatestVersionResponse), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__DataClientLatestVersionResponse * SOAP_FMAC2 soap_instantiate__eoddata1__DataClientLatestVersionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__DataClientLatestVersionResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__DataClientLatestVersionResponse *p;
	size_t k = sizeof(_eoddata1__DataClientLatestVersionResponse);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__DataClientLatestVersionResponse);
		if (p)
			((_eoddata1__DataClientLatestVersionResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__DataClientLatestVersionResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__DataClientLatestVersionResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__DataClientLatestVersionResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__DataClientLatestVersionResponse, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__DataClientLatestVersionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:DataClientLatestVersionResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__DataClientLatestVersionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__DataClientLatestVersionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__DataClientLatestVersionResponse * SOAP_FMAC4 soap_get__eoddata1__DataClientLatestVersionResponse(struct soap *soap, _eoddata1__DataClientLatestVersionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__DataClientLatestVersionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__DataClientLatestVersion::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__DataClientLatestVersion::Token = NULL;
	/* transient soap skipped */
}

void _eoddata1__DataClientLatestVersion::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__DataClientLatestVersion::Token);
#endif
}

int _eoddata1__DataClientLatestVersion::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__DataClientLatestVersion(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__DataClientLatestVersion(struct soap *soap, const char *tag, int id, const _eoddata1__DataClientLatestVersion *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__DataClientLatestVersion), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Token", -1, &a->_eoddata1__DataClientLatestVersion::Token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__DataClientLatestVersion::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__DataClientLatestVersion(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__DataClientLatestVersion * SOAP_FMAC4 soap_in__eoddata1__DataClientLatestVersion(struct soap *soap, const char *tag, _eoddata1__DataClientLatestVersion *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__DataClientLatestVersion *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__DataClientLatestVersion, sizeof(_eoddata1__DataClientLatestVersion), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Token", &a->_eoddata1__DataClientLatestVersion::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__DataClientLatestVersion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__DataClientLatestVersion, SOAP_TYPE_eoddata__eoddata1__DataClientLatestVersion, sizeof(_eoddata1__DataClientLatestVersion), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__DataClientLatestVersion * SOAP_FMAC2 soap_instantiate__eoddata1__DataClientLatestVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__DataClientLatestVersion(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__DataClientLatestVersion *p;
	size_t k = sizeof(_eoddata1__DataClientLatestVersion);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__DataClientLatestVersion);
		if (p)
			((_eoddata1__DataClientLatestVersion*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__DataClientLatestVersion, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__DataClientLatestVersion*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__DataClientLatestVersion location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__DataClientLatestVersion, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__DataClientLatestVersion::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:DataClientLatestVersion", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__DataClientLatestVersion::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__DataClientLatestVersion(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__DataClientLatestVersion * SOAP_FMAC4 soap_get__eoddata1__DataClientLatestVersion(struct soap *soap, _eoddata1__DataClientLatestVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__DataClientLatestVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__SymbolChangesByExchangeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__SymbolChangesByExchangeResponse::SymbolChangesByExchangeResult = NULL;
	/* transient soap skipped */
}

void _eoddata1__SymbolChangesByExchangeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToeoddata1__RESPONSE(soap, &this->_eoddata1__SymbolChangesByExchangeResponse::SymbolChangesByExchangeResult);
#endif
}

int _eoddata1__SymbolChangesByExchangeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__SymbolChangesByExchangeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__SymbolChangesByExchangeResponse(struct soap *soap, const char *tag, int id, const _eoddata1__SymbolChangesByExchangeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__SymbolChangesByExchangeResponse), type))
		return soap->error;
	if (a->SymbolChangesByExchangeResult)
		soap_element_result(soap, "eoddata1:SymbolChangesByExchangeResult");
	if (soap_out_PointerToeoddata1__RESPONSE(soap, "eoddata1:SymbolChangesByExchangeResult", -1, &a->_eoddata1__SymbolChangesByExchangeResponse::SymbolChangesByExchangeResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__SymbolChangesByExchangeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__SymbolChangesByExchangeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__SymbolChangesByExchangeResponse * SOAP_FMAC4 soap_in__eoddata1__SymbolChangesByExchangeResponse(struct soap *soap, const char *tag, _eoddata1__SymbolChangesByExchangeResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__SymbolChangesByExchangeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__SymbolChangesByExchangeResponse, sizeof(_eoddata1__SymbolChangesByExchangeResponse), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SymbolChangesByExchangeResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SymbolChangesByExchangeResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToeoddata1__RESPONSE(soap, "eoddata1:SymbolChangesByExchangeResult", &a->_eoddata1__SymbolChangesByExchangeResponse::SymbolChangesByExchangeResult, "eoddata1:RESPONSE"))
				{	soap_flag_SymbolChangesByExchangeResult1--;
					continue;
				}
			soap_check_result(soap, "eoddata1:SymbolChangesByExchangeResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__SymbolChangesByExchangeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__SymbolChangesByExchangeResponse, SOAP_TYPE_eoddata__eoddata1__SymbolChangesByExchangeResponse, sizeof(_eoddata1__SymbolChangesByExchangeResponse), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__SymbolChangesByExchangeResponse * SOAP_FMAC2 soap_instantiate__eoddata1__SymbolChangesByExchangeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__SymbolChangesByExchangeResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__SymbolChangesByExchangeResponse *p;
	size_t k = sizeof(_eoddata1__SymbolChangesByExchangeResponse);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__SymbolChangesByExchangeResponse);
		if (p)
			((_eoddata1__SymbolChangesByExchangeResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__SymbolChangesByExchangeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__SymbolChangesByExchangeResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__SymbolChangesByExchangeResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__SymbolChangesByExchangeResponse, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__SymbolChangesByExchangeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:SymbolChangesByExchangeResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__SymbolChangesByExchangeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__SymbolChangesByExchangeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__SymbolChangesByExchangeResponse * SOAP_FMAC4 soap_get__eoddata1__SymbolChangesByExchangeResponse(struct soap *soap, _eoddata1__SymbolChangesByExchangeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__SymbolChangesByExchangeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__SymbolChangesByExchange::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__SymbolChangesByExchange::Token = NULL;
	this->_eoddata1__SymbolChangesByExchange::Exchange = NULL;
	/* transient soap skipped */
}

void _eoddata1__SymbolChangesByExchange::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__SymbolChangesByExchange::Token);
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__SymbolChangesByExchange::Exchange);
#endif
}

int _eoddata1__SymbolChangesByExchange::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__SymbolChangesByExchange(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__SymbolChangesByExchange(struct soap *soap, const char *tag, int id, const _eoddata1__SymbolChangesByExchange *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__SymbolChangesByExchange), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Token", -1, &a->_eoddata1__SymbolChangesByExchange::Token, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Exchange", -1, &a->_eoddata1__SymbolChangesByExchange::Exchange, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__SymbolChangesByExchange::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__SymbolChangesByExchange(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__SymbolChangesByExchange * SOAP_FMAC4 soap_in__eoddata1__SymbolChangesByExchange(struct soap *soap, const char *tag, _eoddata1__SymbolChangesByExchange *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__SymbolChangesByExchange *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__SymbolChangesByExchange, sizeof(_eoddata1__SymbolChangesByExchange), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	size_t soap_flag_Exchange1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Token", &a->_eoddata1__SymbolChangesByExchange::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap_flag_Exchange1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Exchange", &a->_eoddata1__SymbolChangesByExchange::Exchange, "xsd:string"))
				{	soap_flag_Exchange1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__SymbolChangesByExchange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__SymbolChangesByExchange, SOAP_TYPE_eoddata__eoddata1__SymbolChangesByExchange, sizeof(_eoddata1__SymbolChangesByExchange), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__SymbolChangesByExchange * SOAP_FMAC2 soap_instantiate__eoddata1__SymbolChangesByExchange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__SymbolChangesByExchange(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__SymbolChangesByExchange *p;
	size_t k = sizeof(_eoddata1__SymbolChangesByExchange);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__SymbolChangesByExchange);
		if (p)
			((_eoddata1__SymbolChangesByExchange*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__SymbolChangesByExchange, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__SymbolChangesByExchange*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__SymbolChangesByExchange location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__SymbolChangesByExchange, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__SymbolChangesByExchange::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:SymbolChangesByExchange", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__SymbolChangesByExchange::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__SymbolChangesByExchange(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__SymbolChangesByExchange * SOAP_FMAC4 soap_get__eoddata1__SymbolChangesByExchange(struct soap *soap, _eoddata1__SymbolChangesByExchange *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__SymbolChangesByExchange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__QuoteListByDatePeriod2Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__QuoteListByDatePeriod2Response::QuoteListByDatePeriod2Result = NULL;
	/* transient soap skipped */
}

void _eoddata1__QuoteListByDatePeriod2Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToeoddata1__RESPONSE(soap, &this->_eoddata1__QuoteListByDatePeriod2Response::QuoteListByDatePeriod2Result);
#endif
}

int _eoddata1__QuoteListByDatePeriod2Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__QuoteListByDatePeriod2Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__QuoteListByDatePeriod2Response(struct soap *soap, const char *tag, int id, const _eoddata1__QuoteListByDatePeriod2Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__QuoteListByDatePeriod2Response), type))
		return soap->error;
	if (a->QuoteListByDatePeriod2Result)
		soap_element_result(soap, "eoddata1:QuoteListByDatePeriod2Result");
	if (soap_out_PointerToeoddata1__RESPONSE(soap, "eoddata1:QuoteListByDatePeriod2Result", -1, &a->_eoddata1__QuoteListByDatePeriod2Response::QuoteListByDatePeriod2Result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__QuoteListByDatePeriod2Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__QuoteListByDatePeriod2Response(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__QuoteListByDatePeriod2Response * SOAP_FMAC4 soap_in__eoddata1__QuoteListByDatePeriod2Response(struct soap *soap, const char *tag, _eoddata1__QuoteListByDatePeriod2Response *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__QuoteListByDatePeriod2Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__QuoteListByDatePeriod2Response, sizeof(_eoddata1__QuoteListByDatePeriod2Response), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_QuoteListByDatePeriod2Result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_QuoteListByDatePeriod2Result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToeoddata1__RESPONSE(soap, "eoddata1:QuoteListByDatePeriod2Result", &a->_eoddata1__QuoteListByDatePeriod2Response::QuoteListByDatePeriod2Result, "eoddata1:RESPONSE"))
				{	soap_flag_QuoteListByDatePeriod2Result1--;
					continue;
				}
			soap_check_result(soap, "eoddata1:QuoteListByDatePeriod2Result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__QuoteListByDatePeriod2Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__QuoteListByDatePeriod2Response, SOAP_TYPE_eoddata__eoddata1__QuoteListByDatePeriod2Response, sizeof(_eoddata1__QuoteListByDatePeriod2Response), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__QuoteListByDatePeriod2Response * SOAP_FMAC2 soap_instantiate__eoddata1__QuoteListByDatePeriod2Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__QuoteListByDatePeriod2Response(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__QuoteListByDatePeriod2Response *p;
	size_t k = sizeof(_eoddata1__QuoteListByDatePeriod2Response);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__QuoteListByDatePeriod2Response);
		if (p)
			((_eoddata1__QuoteListByDatePeriod2Response*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__QuoteListByDatePeriod2Response, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__QuoteListByDatePeriod2Response*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__QuoteListByDatePeriod2Response location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__QuoteListByDatePeriod2Response, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__QuoteListByDatePeriod2Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:QuoteListByDatePeriod2Response", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__QuoteListByDatePeriod2Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__QuoteListByDatePeriod2Response(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__QuoteListByDatePeriod2Response * SOAP_FMAC4 soap_get__eoddata1__QuoteListByDatePeriod2Response(struct soap *soap, _eoddata1__QuoteListByDatePeriod2Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__QuoteListByDatePeriod2Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__QuoteListByDatePeriod2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__QuoteListByDatePeriod2::Token = NULL;
	this->_eoddata1__QuoteListByDatePeriod2::Exchange = NULL;
	this->_eoddata1__QuoteListByDatePeriod2::QuoteDate = NULL;
	this->_eoddata1__QuoteListByDatePeriod2::Period = NULL;
	/* transient soap skipped */
}

void _eoddata1__QuoteListByDatePeriod2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__QuoteListByDatePeriod2::Token);
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__QuoteListByDatePeriod2::Exchange);
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__QuoteListByDatePeriod2::QuoteDate);
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__QuoteListByDatePeriod2::Period);
#endif
}

int _eoddata1__QuoteListByDatePeriod2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__QuoteListByDatePeriod2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__QuoteListByDatePeriod2(struct soap *soap, const char *tag, int id, const _eoddata1__QuoteListByDatePeriod2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__QuoteListByDatePeriod2), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Token", -1, &a->_eoddata1__QuoteListByDatePeriod2::Token, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Exchange", -1, &a->_eoddata1__QuoteListByDatePeriod2::Exchange, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:QuoteDate", -1, &a->_eoddata1__QuoteListByDatePeriod2::QuoteDate, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Period", -1, &a->_eoddata1__QuoteListByDatePeriod2::Period, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__QuoteListByDatePeriod2::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__QuoteListByDatePeriod2(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__QuoteListByDatePeriod2 * SOAP_FMAC4 soap_in__eoddata1__QuoteListByDatePeriod2(struct soap *soap, const char *tag, _eoddata1__QuoteListByDatePeriod2 *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__QuoteListByDatePeriod2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__QuoteListByDatePeriod2, sizeof(_eoddata1__QuoteListByDatePeriod2), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	size_t soap_flag_Exchange1 = 1;
	size_t soap_flag_QuoteDate1 = 1;
	size_t soap_flag_Period1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Token", &a->_eoddata1__QuoteListByDatePeriod2::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap_flag_Exchange1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Exchange", &a->_eoddata1__QuoteListByDatePeriod2::Exchange, "xsd:string"))
				{	soap_flag_Exchange1--;
					continue;
				}
			if (soap_flag_QuoteDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:QuoteDate", &a->_eoddata1__QuoteListByDatePeriod2::QuoteDate, "xsd:string"))
				{	soap_flag_QuoteDate1--;
					continue;
				}
			if (soap_flag_Period1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Period", &a->_eoddata1__QuoteListByDatePeriod2::Period, "xsd:string"))
				{	soap_flag_Period1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__QuoteListByDatePeriod2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__QuoteListByDatePeriod2, SOAP_TYPE_eoddata__eoddata1__QuoteListByDatePeriod2, sizeof(_eoddata1__QuoteListByDatePeriod2), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__QuoteListByDatePeriod2 * SOAP_FMAC2 soap_instantiate__eoddata1__QuoteListByDatePeriod2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__QuoteListByDatePeriod2(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__QuoteListByDatePeriod2 *p;
	size_t k = sizeof(_eoddata1__QuoteListByDatePeriod2);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__QuoteListByDatePeriod2);
		if (p)
			((_eoddata1__QuoteListByDatePeriod2*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__QuoteListByDatePeriod2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__QuoteListByDatePeriod2*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__QuoteListByDatePeriod2 location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__QuoteListByDatePeriod2, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__QuoteListByDatePeriod2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:QuoteListByDatePeriod2", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__QuoteListByDatePeriod2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__QuoteListByDatePeriod2(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__QuoteListByDatePeriod2 * SOAP_FMAC4 soap_get__eoddata1__QuoteListByDatePeriod2(struct soap *soap, _eoddata1__QuoteListByDatePeriod2 *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__QuoteListByDatePeriod2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__QuoteListByDatePeriodResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__QuoteListByDatePeriodResponse::QuoteListByDatePeriodResult = NULL;
	/* transient soap skipped */
}

void _eoddata1__QuoteListByDatePeriodResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToeoddata1__RESPONSE(soap, &this->_eoddata1__QuoteListByDatePeriodResponse::QuoteListByDatePeriodResult);
#endif
}

int _eoddata1__QuoteListByDatePeriodResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__QuoteListByDatePeriodResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__QuoteListByDatePeriodResponse(struct soap *soap, const char *tag, int id, const _eoddata1__QuoteListByDatePeriodResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__QuoteListByDatePeriodResponse), type))
		return soap->error;
	if (a->QuoteListByDatePeriodResult)
		soap_element_result(soap, "eoddata1:QuoteListByDatePeriodResult");
	if (soap_out_PointerToeoddata1__RESPONSE(soap, "eoddata1:QuoteListByDatePeriodResult", -1, &a->_eoddata1__QuoteListByDatePeriodResponse::QuoteListByDatePeriodResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__QuoteListByDatePeriodResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__QuoteListByDatePeriodResponse(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__QuoteListByDatePeriodResponse * SOAP_FMAC4 soap_in__eoddata1__QuoteListByDatePeriodResponse(struct soap *soap, const char *tag, _eoddata1__QuoteListByDatePeriodResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__QuoteListByDatePeriodResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__QuoteListByDatePeriodResponse, sizeof(_eoddata1__QuoteListByDatePeriodResponse), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_QuoteListByDatePeriodResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_QuoteListByDatePeriodResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToeoddata1__RESPONSE(soap, "eoddata1:QuoteListByDatePeriodResult", &a->_eoddata1__QuoteListByDatePeriodResponse::QuoteListByDatePeriodResult, "eoddata1:RESPONSE"))
				{	soap_flag_QuoteListByDatePeriodResult1--;
					continue;
				}
			soap_check_result(soap, "eoddata1:QuoteListByDatePeriodResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__QuoteListByDatePeriodResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__QuoteListByDatePeriodResponse, SOAP_TYPE_eoddata__eoddata1__QuoteListByDatePeriodResponse, sizeof(_eoddata1__QuoteListByDatePeriodResponse), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__QuoteListByDatePeriodResponse * SOAP_FMAC2 soap_instantiate__eoddata1__QuoteListByDatePeriodResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__QuoteListByDatePeriodResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__QuoteListByDatePeriodResponse *p;
	size_t k = sizeof(_eoddata1__QuoteListByDatePeriodResponse);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__QuoteListByDatePeriodResponse);
		if (p)
			((_eoddata1__QuoteListByDatePeriodResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__QuoteListByDatePeriodResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__QuoteListByDatePeriodResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__QuoteListByDatePeriodResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__QuoteListByDatePeriodResponse, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__QuoteListByDatePeriodResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:QuoteListByDatePeriodResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__QuoteListByDatePeriodResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__QuoteListByDatePeriodResponse(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__QuoteListByDatePeriodResponse * SOAP_FMAC4 soap_get__eoddata1__QuoteListByDatePeriodResponse(struct soap *soap, _eoddata1__QuoteListByDatePeriodResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__QuoteListByDatePeriodResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__QuoteListByDatePeriod::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__QuoteListByDatePeriod::Token = NULL;
	this->_eoddata1__QuoteListByDatePeriod::Exchange = NULL;
	this->_eoddata1__QuoteListByDatePeriod::QuoteDate = NULL;
	this->_eoddata1__QuoteListByDatePeriod::Period = NULL;
	/* transient soap skipped */
}

void _eoddata1__QuoteListByDatePeriod::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__QuoteListByDatePeriod::Token);
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__QuoteListByDatePeriod::Exchange);
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__QuoteListByDatePeriod::QuoteDate);
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__QuoteListByDatePeriod::Period);
#endif
}

int _eoddata1__QuoteListByDatePeriod::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__QuoteListByDatePeriod(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__QuoteListByDatePeriod(struct soap *soap, const char *tag, int id, const _eoddata1__QuoteListByDatePeriod *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__QuoteListByDatePeriod), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Token", -1, &a->_eoddata1__QuoteListByDatePeriod::Token, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Exchange", -1, &a->_eoddata1__QuoteListByDatePeriod::Exchange, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:QuoteDate", -1, &a->_eoddata1__QuoteListByDatePeriod::QuoteDate, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Period", -1, &a->_eoddata1__QuoteListByDatePeriod::Period, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__QuoteListByDatePeriod::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__QuoteListByDatePeriod(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__QuoteListByDatePeriod * SOAP_FMAC4 soap_in__eoddata1__QuoteListByDatePeriod(struct soap *soap, const char *tag, _eoddata1__QuoteListByDatePeriod *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__QuoteListByDatePeriod *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__QuoteListByDatePeriod, sizeof(_eoddata1__QuoteListByDatePeriod), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	size_t soap_flag_Exchange1 = 1;
	size_t soap_flag_QuoteDate1 = 1;
	size_t soap_flag_Period1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Token", &a->_eoddata1__QuoteListByDatePeriod::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap_flag_Exchange1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Exchange", &a->_eoddata1__QuoteListByDatePeriod::Exchange, "xsd:string"))
				{	soap_flag_Exchange1--;
					continue;
				}
			if (soap_flag_QuoteDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:QuoteDate", &a->_eoddata1__QuoteListByDatePeriod::QuoteDate, "xsd:string"))
				{	soap_flag_QuoteDate1--;
					continue;
				}
			if (soap_flag_Period1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Period", &a->_eoddata1__QuoteListByDatePeriod::Period, "xsd:string"))
				{	soap_flag_Period1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__QuoteListByDatePeriod *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__QuoteListByDatePeriod, SOAP_TYPE_eoddata__eoddata1__QuoteListByDatePeriod, sizeof(_eoddata1__QuoteListByDatePeriod), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__QuoteListByDatePeriod * SOAP_FMAC2 soap_instantiate__eoddata1__QuoteListByDatePeriod(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__QuoteListByDatePeriod(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__QuoteListByDatePeriod *p;
	size_t k = sizeof(_eoddata1__QuoteListByDatePeriod);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__QuoteListByDatePeriod);
		if (p)
			((_eoddata1__QuoteListByDatePeriod*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__QuoteListByDatePeriod, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__QuoteListByDatePeriod*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__QuoteListByDatePeriod location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__QuoteListByDatePeriod, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__QuoteListByDatePeriod::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:QuoteListByDatePeriod", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__QuoteListByDatePeriod::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__QuoteListByDatePeriod(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__QuoteListByDatePeriod * SOAP_FMAC4 soap_get__eoddata1__QuoteListByDatePeriod(struct soap *soap, _eoddata1__QuoteListByDatePeriod *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__QuoteListByDatePeriod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__SymbolHistoryPeriodByDateRangeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__SymbolHistoryPeriodByDateRangeResponse::SymbolHistoryPeriodByDateRangeResult = NULL;
	/* transient soap skipped */
}

void _eoddata1__SymbolHistoryPeriodByDateRangeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToeoddata1__RESPONSE(soap, &this->_eoddata1__SymbolHistoryPeriodByDateRangeResponse::SymbolHistoryPeriodByDateRangeResult);
#endif
}

int _eoddata1__SymbolHistoryPeriodByDateRangeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__SymbolHistoryPeriodByDateRangeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__SymbolHistoryPeriodByDateRangeResponse(struct soap *soap, const char *tag, int id, const _eoddata1__SymbolHistoryPeriodByDateRangeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__SymbolHistoryPeriodByDateRangeResponse), type))
		return soap->error;
	if (a->SymbolHistoryPeriodByDateRangeResult)
		soap_element_result(soap, "eoddata1:SymbolHistoryPeriodByDateRangeResult");
	if (soap_out_PointerToeoddata1__RESPONSE(soap, "eoddata1:SymbolHistoryPeriodByDateRangeResult", -1, &a->_eoddata1__SymbolHistoryPeriodByDateRangeResponse::SymbolHistoryPeriodByDateRangeResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__SymbolHistoryPeriodByDateRangeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__SymbolHistoryPeriodByDateRangeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__SymbolHistoryPeriodByDateRangeResponse * SOAP_FMAC4 soap_in__eoddata1__SymbolHistoryPeriodByDateRangeResponse(struct soap *soap, const char *tag, _eoddata1__SymbolHistoryPeriodByDateRangeResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__SymbolHistoryPeriodByDateRangeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__SymbolHistoryPeriodByDateRangeResponse, sizeof(_eoddata1__SymbolHistoryPeriodByDateRangeResponse), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SymbolHistoryPeriodByDateRangeResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SymbolHistoryPeriodByDateRangeResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToeoddata1__RESPONSE(soap, "eoddata1:SymbolHistoryPeriodByDateRangeResult", &a->_eoddata1__SymbolHistoryPeriodByDateRangeResponse::SymbolHistoryPeriodByDateRangeResult, "eoddata1:RESPONSE"))
				{	soap_flag_SymbolHistoryPeriodByDateRangeResult1--;
					continue;
				}
			soap_check_result(soap, "eoddata1:SymbolHistoryPeriodByDateRangeResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__SymbolHistoryPeriodByDateRangeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__SymbolHistoryPeriodByDateRangeResponse, SOAP_TYPE_eoddata__eoddata1__SymbolHistoryPeriodByDateRangeResponse, sizeof(_eoddata1__SymbolHistoryPeriodByDateRangeResponse), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__SymbolHistoryPeriodByDateRangeResponse * SOAP_FMAC2 soap_instantiate__eoddata1__SymbolHistoryPeriodByDateRangeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__SymbolHistoryPeriodByDateRangeResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__SymbolHistoryPeriodByDateRangeResponse *p;
	size_t k = sizeof(_eoddata1__SymbolHistoryPeriodByDateRangeResponse);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__SymbolHistoryPeriodByDateRangeResponse);
		if (p)
			((_eoddata1__SymbolHistoryPeriodByDateRangeResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__SymbolHistoryPeriodByDateRangeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__SymbolHistoryPeriodByDateRangeResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__SymbolHistoryPeriodByDateRangeResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__SymbolHistoryPeriodByDateRangeResponse, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__SymbolHistoryPeriodByDateRangeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:SymbolHistoryPeriodByDateRangeResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__SymbolHistoryPeriodByDateRangeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__SymbolHistoryPeriodByDateRangeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__SymbolHistoryPeriodByDateRangeResponse * SOAP_FMAC4 soap_get__eoddata1__SymbolHistoryPeriodByDateRangeResponse(struct soap *soap, _eoddata1__SymbolHistoryPeriodByDateRangeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__SymbolHistoryPeriodByDateRangeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__SymbolHistoryPeriodByDateRange::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__SymbolHistoryPeriodByDateRange::Token = NULL;
	this->_eoddata1__SymbolHistoryPeriodByDateRange::Exchange = NULL;
	this->_eoddata1__SymbolHistoryPeriodByDateRange::Symbol = NULL;
	this->_eoddata1__SymbolHistoryPeriodByDateRange::StartDate = NULL;
	this->_eoddata1__SymbolHistoryPeriodByDateRange::EndDate = NULL;
	this->_eoddata1__SymbolHistoryPeriodByDateRange::Period = NULL;
	/* transient soap skipped */
}

void _eoddata1__SymbolHistoryPeriodByDateRange::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__SymbolHistoryPeriodByDateRange::Token);
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__SymbolHistoryPeriodByDateRange::Exchange);
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__SymbolHistoryPeriodByDateRange::Symbol);
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__SymbolHistoryPeriodByDateRange::StartDate);
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__SymbolHistoryPeriodByDateRange::EndDate);
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__SymbolHistoryPeriodByDateRange::Period);
#endif
}

int _eoddata1__SymbolHistoryPeriodByDateRange::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__SymbolHistoryPeriodByDateRange(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__SymbolHistoryPeriodByDateRange(struct soap *soap, const char *tag, int id, const _eoddata1__SymbolHistoryPeriodByDateRange *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__SymbolHistoryPeriodByDateRange), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Token", -1, &a->_eoddata1__SymbolHistoryPeriodByDateRange::Token, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Exchange", -1, &a->_eoddata1__SymbolHistoryPeriodByDateRange::Exchange, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Symbol", -1, &a->_eoddata1__SymbolHistoryPeriodByDateRange::Symbol, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:StartDate", -1, &a->_eoddata1__SymbolHistoryPeriodByDateRange::StartDate, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:EndDate", -1, &a->_eoddata1__SymbolHistoryPeriodByDateRange::EndDate, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Period", -1, &a->_eoddata1__SymbolHistoryPeriodByDateRange::Period, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__SymbolHistoryPeriodByDateRange::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__SymbolHistoryPeriodByDateRange(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__SymbolHistoryPeriodByDateRange * SOAP_FMAC4 soap_in__eoddata1__SymbolHistoryPeriodByDateRange(struct soap *soap, const char *tag, _eoddata1__SymbolHistoryPeriodByDateRange *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__SymbolHistoryPeriodByDateRange *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__SymbolHistoryPeriodByDateRange, sizeof(_eoddata1__SymbolHistoryPeriodByDateRange), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	size_t soap_flag_Exchange1 = 1;
	size_t soap_flag_Symbol1 = 1;
	size_t soap_flag_StartDate1 = 1;
	size_t soap_flag_EndDate1 = 1;
	size_t soap_flag_Period1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Token", &a->_eoddata1__SymbolHistoryPeriodByDateRange::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap_flag_Exchange1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Exchange", &a->_eoddata1__SymbolHistoryPeriodByDateRange::Exchange, "xsd:string"))
				{	soap_flag_Exchange1--;
					continue;
				}
			if (soap_flag_Symbol1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Symbol", &a->_eoddata1__SymbolHistoryPeriodByDateRange::Symbol, "xsd:string"))
				{	soap_flag_Symbol1--;
					continue;
				}
			if (soap_flag_StartDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:StartDate", &a->_eoddata1__SymbolHistoryPeriodByDateRange::StartDate, "xsd:string"))
				{	soap_flag_StartDate1--;
					continue;
				}
			if (soap_flag_EndDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:EndDate", &a->_eoddata1__SymbolHistoryPeriodByDateRange::EndDate, "xsd:string"))
				{	soap_flag_EndDate1--;
					continue;
				}
			if (soap_flag_Period1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Period", &a->_eoddata1__SymbolHistoryPeriodByDateRange::Period, "xsd:string"))
				{	soap_flag_Period1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__SymbolHistoryPeriodByDateRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__SymbolHistoryPeriodByDateRange, SOAP_TYPE_eoddata__eoddata1__SymbolHistoryPeriodByDateRange, sizeof(_eoddata1__SymbolHistoryPeriodByDateRange), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__SymbolHistoryPeriodByDateRange * SOAP_FMAC2 soap_instantiate__eoddata1__SymbolHistoryPeriodByDateRange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__SymbolHistoryPeriodByDateRange(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__SymbolHistoryPeriodByDateRange *p;
	size_t k = sizeof(_eoddata1__SymbolHistoryPeriodByDateRange);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__SymbolHistoryPeriodByDateRange);
		if (p)
			((_eoddata1__SymbolHistoryPeriodByDateRange*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__SymbolHistoryPeriodByDateRange, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__SymbolHistoryPeriodByDateRange*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__SymbolHistoryPeriodByDateRange location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__SymbolHistoryPeriodByDateRange, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__SymbolHistoryPeriodByDateRange::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:SymbolHistoryPeriodByDateRange", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__SymbolHistoryPeriodByDateRange::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__SymbolHistoryPeriodByDateRange(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__SymbolHistoryPeriodByDateRange * SOAP_FMAC4 soap_get__eoddata1__SymbolHistoryPeriodByDateRange(struct soap *soap, _eoddata1__SymbolHistoryPeriodByDateRange *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__SymbolHistoryPeriodByDateRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__SymbolHistoryPeriodResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__SymbolHistoryPeriodResponse::SymbolHistoryPeriodResult = NULL;
	/* transient soap skipped */
}

void _eoddata1__SymbolHistoryPeriodResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToeoddata1__RESPONSE(soap, &this->_eoddata1__SymbolHistoryPeriodResponse::SymbolHistoryPeriodResult);
#endif
}

int _eoddata1__SymbolHistoryPeriodResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__SymbolHistoryPeriodResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__SymbolHistoryPeriodResponse(struct soap *soap, const char *tag, int id, const _eoddata1__SymbolHistoryPeriodResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__SymbolHistoryPeriodResponse), type))
		return soap->error;
	if (a->SymbolHistoryPeriodResult)
		soap_element_result(soap, "eoddata1:SymbolHistoryPeriodResult");
	if (soap_out_PointerToeoddata1__RESPONSE(soap, "eoddata1:SymbolHistoryPeriodResult", -1, &a->_eoddata1__SymbolHistoryPeriodResponse::SymbolHistoryPeriodResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__SymbolHistoryPeriodResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__SymbolHistoryPeriodResponse(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__SymbolHistoryPeriodResponse * SOAP_FMAC4 soap_in__eoddata1__SymbolHistoryPeriodResponse(struct soap *soap, const char *tag, _eoddata1__SymbolHistoryPeriodResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__SymbolHistoryPeriodResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__SymbolHistoryPeriodResponse, sizeof(_eoddata1__SymbolHistoryPeriodResponse), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SymbolHistoryPeriodResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SymbolHistoryPeriodResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToeoddata1__RESPONSE(soap, "eoddata1:SymbolHistoryPeriodResult", &a->_eoddata1__SymbolHistoryPeriodResponse::SymbolHistoryPeriodResult, "eoddata1:RESPONSE"))
				{	soap_flag_SymbolHistoryPeriodResult1--;
					continue;
				}
			soap_check_result(soap, "eoddata1:SymbolHistoryPeriodResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__SymbolHistoryPeriodResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__SymbolHistoryPeriodResponse, SOAP_TYPE_eoddata__eoddata1__SymbolHistoryPeriodResponse, sizeof(_eoddata1__SymbolHistoryPeriodResponse), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__SymbolHistoryPeriodResponse * SOAP_FMAC2 soap_instantiate__eoddata1__SymbolHistoryPeriodResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__SymbolHistoryPeriodResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__SymbolHistoryPeriodResponse *p;
	size_t k = sizeof(_eoddata1__SymbolHistoryPeriodResponse);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__SymbolHistoryPeriodResponse);
		if (p)
			((_eoddata1__SymbolHistoryPeriodResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__SymbolHistoryPeriodResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__SymbolHistoryPeriodResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__SymbolHistoryPeriodResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__SymbolHistoryPeriodResponse, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__SymbolHistoryPeriodResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:SymbolHistoryPeriodResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__SymbolHistoryPeriodResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__SymbolHistoryPeriodResponse(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__SymbolHistoryPeriodResponse * SOAP_FMAC4 soap_get__eoddata1__SymbolHistoryPeriodResponse(struct soap *soap, _eoddata1__SymbolHistoryPeriodResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__SymbolHistoryPeriodResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__SymbolHistoryPeriod::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__SymbolHistoryPeriod::Token = NULL;
	this->_eoddata1__SymbolHistoryPeriod::Exchange = NULL;
	this->_eoddata1__SymbolHistoryPeriod::Symbol = NULL;
	this->_eoddata1__SymbolHistoryPeriod::Date = NULL;
	this->_eoddata1__SymbolHistoryPeriod::Period = NULL;
	/* transient soap skipped */
}

void _eoddata1__SymbolHistoryPeriod::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__SymbolHistoryPeriod::Token);
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__SymbolHistoryPeriod::Exchange);
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__SymbolHistoryPeriod::Symbol);
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__SymbolHistoryPeriod::Date);
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__SymbolHistoryPeriod::Period);
#endif
}

int _eoddata1__SymbolHistoryPeriod::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__SymbolHistoryPeriod(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__SymbolHistoryPeriod(struct soap *soap, const char *tag, int id, const _eoddata1__SymbolHistoryPeriod *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__SymbolHistoryPeriod), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Token", -1, &a->_eoddata1__SymbolHistoryPeriod::Token, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Exchange", -1, &a->_eoddata1__SymbolHistoryPeriod::Exchange, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Symbol", -1, &a->_eoddata1__SymbolHistoryPeriod::Symbol, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Date", -1, &a->_eoddata1__SymbolHistoryPeriod::Date, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Period", -1, &a->_eoddata1__SymbolHistoryPeriod::Period, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__SymbolHistoryPeriod::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__SymbolHistoryPeriod(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__SymbolHistoryPeriod * SOAP_FMAC4 soap_in__eoddata1__SymbolHistoryPeriod(struct soap *soap, const char *tag, _eoddata1__SymbolHistoryPeriod *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__SymbolHistoryPeriod *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__SymbolHistoryPeriod, sizeof(_eoddata1__SymbolHistoryPeriod), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	size_t soap_flag_Exchange1 = 1;
	size_t soap_flag_Symbol1 = 1;
	size_t soap_flag_Date1 = 1;
	size_t soap_flag_Period1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Token", &a->_eoddata1__SymbolHistoryPeriod::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap_flag_Exchange1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Exchange", &a->_eoddata1__SymbolHistoryPeriod::Exchange, "xsd:string"))
				{	soap_flag_Exchange1--;
					continue;
				}
			if (soap_flag_Symbol1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Symbol", &a->_eoddata1__SymbolHistoryPeriod::Symbol, "xsd:string"))
				{	soap_flag_Symbol1--;
					continue;
				}
			if (soap_flag_Date1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Date", &a->_eoddata1__SymbolHistoryPeriod::Date, "xsd:string"))
				{	soap_flag_Date1--;
					continue;
				}
			if (soap_flag_Period1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Period", &a->_eoddata1__SymbolHistoryPeriod::Period, "xsd:string"))
				{	soap_flag_Period1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__SymbolHistoryPeriod *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__SymbolHistoryPeriod, SOAP_TYPE_eoddata__eoddata1__SymbolHistoryPeriod, sizeof(_eoddata1__SymbolHistoryPeriod), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__SymbolHistoryPeriod * SOAP_FMAC2 soap_instantiate__eoddata1__SymbolHistoryPeriod(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__SymbolHistoryPeriod(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__SymbolHistoryPeriod *p;
	size_t k = sizeof(_eoddata1__SymbolHistoryPeriod);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__SymbolHistoryPeriod);
		if (p)
			((_eoddata1__SymbolHistoryPeriod*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__SymbolHistoryPeriod, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__SymbolHistoryPeriod*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__SymbolHistoryPeriod location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__SymbolHistoryPeriod, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__SymbolHistoryPeriod::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:SymbolHistoryPeriod", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__SymbolHistoryPeriod::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__SymbolHistoryPeriod(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__SymbolHistoryPeriod * SOAP_FMAC4 soap_get__eoddata1__SymbolHistoryPeriod(struct soap *soap, _eoddata1__SymbolHistoryPeriod *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__SymbolHistoryPeriod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__CountryListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__CountryListResponse::CountryListResult = NULL;
	/* transient soap skipped */
}

void _eoddata1__CountryListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToeoddata1__RESPONSE(soap, &this->_eoddata1__CountryListResponse::CountryListResult);
#endif
}

int _eoddata1__CountryListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__CountryListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__CountryListResponse(struct soap *soap, const char *tag, int id, const _eoddata1__CountryListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__CountryListResponse), type))
		return soap->error;
	if (a->CountryListResult)
		soap_element_result(soap, "eoddata1:CountryListResult");
	if (soap_out_PointerToeoddata1__RESPONSE(soap, "eoddata1:CountryListResult", -1, &a->_eoddata1__CountryListResponse::CountryListResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__CountryListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__CountryListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__CountryListResponse * SOAP_FMAC4 soap_in__eoddata1__CountryListResponse(struct soap *soap, const char *tag, _eoddata1__CountryListResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__CountryListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__CountryListResponse, sizeof(_eoddata1__CountryListResponse), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CountryListResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CountryListResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToeoddata1__RESPONSE(soap, "eoddata1:CountryListResult", &a->_eoddata1__CountryListResponse::CountryListResult, "eoddata1:RESPONSE"))
				{	soap_flag_CountryListResult1--;
					continue;
				}
			soap_check_result(soap, "eoddata1:CountryListResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__CountryListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__CountryListResponse, SOAP_TYPE_eoddata__eoddata1__CountryListResponse, sizeof(_eoddata1__CountryListResponse), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__CountryListResponse * SOAP_FMAC2 soap_instantiate__eoddata1__CountryListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__CountryListResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__CountryListResponse *p;
	size_t k = sizeof(_eoddata1__CountryListResponse);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__CountryListResponse);
		if (p)
			((_eoddata1__CountryListResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__CountryListResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__CountryListResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__CountryListResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__CountryListResponse, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__CountryListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:CountryListResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__CountryListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__CountryListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__CountryListResponse * SOAP_FMAC4 soap_get__eoddata1__CountryListResponse(struct soap *soap, _eoddata1__CountryListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__CountryListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__CountryList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__CountryList::Token = NULL;
	/* transient soap skipped */
}

void _eoddata1__CountryList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__CountryList::Token);
#endif
}

int _eoddata1__CountryList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__CountryList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__CountryList(struct soap *soap, const char *tag, int id, const _eoddata1__CountryList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__CountryList), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Token", -1, &a->_eoddata1__CountryList::Token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__CountryList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__CountryList(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__CountryList * SOAP_FMAC4 soap_in__eoddata1__CountryList(struct soap *soap, const char *tag, _eoddata1__CountryList *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__CountryList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__CountryList, sizeof(_eoddata1__CountryList), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Token", &a->_eoddata1__CountryList::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__CountryList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__CountryList, SOAP_TYPE_eoddata__eoddata1__CountryList, sizeof(_eoddata1__CountryList), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__CountryList * SOAP_FMAC2 soap_instantiate__eoddata1__CountryList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__CountryList(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__CountryList *p;
	size_t k = sizeof(_eoddata1__CountryList);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__CountryList);
		if (p)
			((_eoddata1__CountryList*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__CountryList, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__CountryList*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__CountryList location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__CountryList, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__CountryList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:CountryList", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__CountryList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__CountryList(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__CountryList * SOAP_FMAC4 soap_get__eoddata1__CountryList(struct soap *soap, _eoddata1__CountryList *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__CountryList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__SplitListBySymbolResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__SplitListBySymbolResponse::SplitListBySymbolResult = NULL;
	/* transient soap skipped */
}

void _eoddata1__SplitListBySymbolResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToeoddata1__RESPONSE(soap, &this->_eoddata1__SplitListBySymbolResponse::SplitListBySymbolResult);
#endif
}

int _eoddata1__SplitListBySymbolResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__SplitListBySymbolResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__SplitListBySymbolResponse(struct soap *soap, const char *tag, int id, const _eoddata1__SplitListBySymbolResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__SplitListBySymbolResponse), type))
		return soap->error;
	if (a->SplitListBySymbolResult)
		soap_element_result(soap, "eoddata1:SplitListBySymbolResult");
	if (soap_out_PointerToeoddata1__RESPONSE(soap, "eoddata1:SplitListBySymbolResult", -1, &a->_eoddata1__SplitListBySymbolResponse::SplitListBySymbolResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__SplitListBySymbolResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__SplitListBySymbolResponse(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__SplitListBySymbolResponse * SOAP_FMAC4 soap_in__eoddata1__SplitListBySymbolResponse(struct soap *soap, const char *tag, _eoddata1__SplitListBySymbolResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__SplitListBySymbolResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__SplitListBySymbolResponse, sizeof(_eoddata1__SplitListBySymbolResponse), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SplitListBySymbolResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SplitListBySymbolResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToeoddata1__RESPONSE(soap, "eoddata1:SplitListBySymbolResult", &a->_eoddata1__SplitListBySymbolResponse::SplitListBySymbolResult, "eoddata1:RESPONSE"))
				{	soap_flag_SplitListBySymbolResult1--;
					continue;
				}
			soap_check_result(soap, "eoddata1:SplitListBySymbolResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__SplitListBySymbolResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__SplitListBySymbolResponse, SOAP_TYPE_eoddata__eoddata1__SplitListBySymbolResponse, sizeof(_eoddata1__SplitListBySymbolResponse), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__SplitListBySymbolResponse * SOAP_FMAC2 soap_instantiate__eoddata1__SplitListBySymbolResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__SplitListBySymbolResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__SplitListBySymbolResponse *p;
	size_t k = sizeof(_eoddata1__SplitListBySymbolResponse);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__SplitListBySymbolResponse);
		if (p)
			((_eoddata1__SplitListBySymbolResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__SplitListBySymbolResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__SplitListBySymbolResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__SplitListBySymbolResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__SplitListBySymbolResponse, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__SplitListBySymbolResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:SplitListBySymbolResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__SplitListBySymbolResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__SplitListBySymbolResponse(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__SplitListBySymbolResponse * SOAP_FMAC4 soap_get__eoddata1__SplitListBySymbolResponse(struct soap *soap, _eoddata1__SplitListBySymbolResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__SplitListBySymbolResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__SplitListBySymbol::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__SplitListBySymbol::Token = NULL;
	this->_eoddata1__SplitListBySymbol::Exchange = NULL;
	this->_eoddata1__SplitListBySymbol::Symbol = NULL;
	/* transient soap skipped */
}

void _eoddata1__SplitListBySymbol::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__SplitListBySymbol::Token);
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__SplitListBySymbol::Exchange);
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__SplitListBySymbol::Symbol);
#endif
}

int _eoddata1__SplitListBySymbol::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__SplitListBySymbol(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__SplitListBySymbol(struct soap *soap, const char *tag, int id, const _eoddata1__SplitListBySymbol *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__SplitListBySymbol), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Token", -1, &a->_eoddata1__SplitListBySymbol::Token, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Exchange", -1, &a->_eoddata1__SplitListBySymbol::Exchange, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Symbol", -1, &a->_eoddata1__SplitListBySymbol::Symbol, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__SplitListBySymbol::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__SplitListBySymbol(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__SplitListBySymbol * SOAP_FMAC4 soap_in__eoddata1__SplitListBySymbol(struct soap *soap, const char *tag, _eoddata1__SplitListBySymbol *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__SplitListBySymbol *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__SplitListBySymbol, sizeof(_eoddata1__SplitListBySymbol), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	size_t soap_flag_Exchange1 = 1;
	size_t soap_flag_Symbol1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Token", &a->_eoddata1__SplitListBySymbol::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap_flag_Exchange1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Exchange", &a->_eoddata1__SplitListBySymbol::Exchange, "xsd:string"))
				{	soap_flag_Exchange1--;
					continue;
				}
			if (soap_flag_Symbol1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Symbol", &a->_eoddata1__SplitListBySymbol::Symbol, "xsd:string"))
				{	soap_flag_Symbol1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__SplitListBySymbol *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__SplitListBySymbol, SOAP_TYPE_eoddata__eoddata1__SplitListBySymbol, sizeof(_eoddata1__SplitListBySymbol), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__SplitListBySymbol * SOAP_FMAC2 soap_instantiate__eoddata1__SplitListBySymbol(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__SplitListBySymbol(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__SplitListBySymbol *p;
	size_t k = sizeof(_eoddata1__SplitListBySymbol);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__SplitListBySymbol);
		if (p)
			((_eoddata1__SplitListBySymbol*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__SplitListBySymbol, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__SplitListBySymbol*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__SplitListBySymbol location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__SplitListBySymbol, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__SplitListBySymbol::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:SplitListBySymbol", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__SplitListBySymbol::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__SplitListBySymbol(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__SplitListBySymbol * SOAP_FMAC4 soap_get__eoddata1__SplitListBySymbol(struct soap *soap, _eoddata1__SplitListBySymbol *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__SplitListBySymbol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__SplitListByExchangeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__SplitListByExchangeResponse::SplitListByExchangeResult = NULL;
	/* transient soap skipped */
}

void _eoddata1__SplitListByExchangeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToeoddata1__RESPONSE(soap, &this->_eoddata1__SplitListByExchangeResponse::SplitListByExchangeResult);
#endif
}

int _eoddata1__SplitListByExchangeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__SplitListByExchangeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__SplitListByExchangeResponse(struct soap *soap, const char *tag, int id, const _eoddata1__SplitListByExchangeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__SplitListByExchangeResponse), type))
		return soap->error;
	if (a->SplitListByExchangeResult)
		soap_element_result(soap, "eoddata1:SplitListByExchangeResult");
	if (soap_out_PointerToeoddata1__RESPONSE(soap, "eoddata1:SplitListByExchangeResult", -1, &a->_eoddata1__SplitListByExchangeResponse::SplitListByExchangeResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__SplitListByExchangeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__SplitListByExchangeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__SplitListByExchangeResponse * SOAP_FMAC4 soap_in__eoddata1__SplitListByExchangeResponse(struct soap *soap, const char *tag, _eoddata1__SplitListByExchangeResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__SplitListByExchangeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__SplitListByExchangeResponse, sizeof(_eoddata1__SplitListByExchangeResponse), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SplitListByExchangeResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SplitListByExchangeResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToeoddata1__RESPONSE(soap, "eoddata1:SplitListByExchangeResult", &a->_eoddata1__SplitListByExchangeResponse::SplitListByExchangeResult, "eoddata1:RESPONSE"))
				{	soap_flag_SplitListByExchangeResult1--;
					continue;
				}
			soap_check_result(soap, "eoddata1:SplitListByExchangeResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__SplitListByExchangeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__SplitListByExchangeResponse, SOAP_TYPE_eoddata__eoddata1__SplitListByExchangeResponse, sizeof(_eoddata1__SplitListByExchangeResponse), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__SplitListByExchangeResponse * SOAP_FMAC2 soap_instantiate__eoddata1__SplitListByExchangeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__SplitListByExchangeResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__SplitListByExchangeResponse *p;
	size_t k = sizeof(_eoddata1__SplitListByExchangeResponse);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__SplitListByExchangeResponse);
		if (p)
			((_eoddata1__SplitListByExchangeResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__SplitListByExchangeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__SplitListByExchangeResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__SplitListByExchangeResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__SplitListByExchangeResponse, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__SplitListByExchangeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:SplitListByExchangeResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__SplitListByExchangeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__SplitListByExchangeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__SplitListByExchangeResponse * SOAP_FMAC4 soap_get__eoddata1__SplitListByExchangeResponse(struct soap *soap, _eoddata1__SplitListByExchangeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__SplitListByExchangeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__SplitListByExchange::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__SplitListByExchange::Token = NULL;
	this->_eoddata1__SplitListByExchange::Exchange = NULL;
	/* transient soap skipped */
}

void _eoddata1__SplitListByExchange::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__SplitListByExchange::Token);
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__SplitListByExchange::Exchange);
#endif
}

int _eoddata1__SplitListByExchange::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__SplitListByExchange(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__SplitListByExchange(struct soap *soap, const char *tag, int id, const _eoddata1__SplitListByExchange *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__SplitListByExchange), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Token", -1, &a->_eoddata1__SplitListByExchange::Token, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Exchange", -1, &a->_eoddata1__SplitListByExchange::Exchange, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__SplitListByExchange::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__SplitListByExchange(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__SplitListByExchange * SOAP_FMAC4 soap_in__eoddata1__SplitListByExchange(struct soap *soap, const char *tag, _eoddata1__SplitListByExchange *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__SplitListByExchange *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__SplitListByExchange, sizeof(_eoddata1__SplitListByExchange), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	size_t soap_flag_Exchange1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Token", &a->_eoddata1__SplitListByExchange::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap_flag_Exchange1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Exchange", &a->_eoddata1__SplitListByExchange::Exchange, "xsd:string"))
				{	soap_flag_Exchange1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__SplitListByExchange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__SplitListByExchange, SOAP_TYPE_eoddata__eoddata1__SplitListByExchange, sizeof(_eoddata1__SplitListByExchange), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__SplitListByExchange * SOAP_FMAC2 soap_instantiate__eoddata1__SplitListByExchange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__SplitListByExchange(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__SplitListByExchange *p;
	size_t k = sizeof(_eoddata1__SplitListByExchange);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__SplitListByExchange);
		if (p)
			((_eoddata1__SplitListByExchange*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__SplitListByExchange, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__SplitListByExchange*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__SplitListByExchange location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__SplitListByExchange, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__SplitListByExchange::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:SplitListByExchange", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__SplitListByExchange::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__SplitListByExchange(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__SplitListByExchange * SOAP_FMAC4 soap_get__eoddata1__SplitListByExchange(struct soap *soap, _eoddata1__SplitListByExchange *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__SplitListByExchange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__ExchangeMonthsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__ExchangeMonthsResponse::ExchangeMonthsResult = NULL;
	/* transient soap skipped */
}

void _eoddata1__ExchangeMonthsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToeoddata1__RESPONSE(soap, &this->_eoddata1__ExchangeMonthsResponse::ExchangeMonthsResult);
#endif
}

int _eoddata1__ExchangeMonthsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__ExchangeMonthsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__ExchangeMonthsResponse(struct soap *soap, const char *tag, int id, const _eoddata1__ExchangeMonthsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__ExchangeMonthsResponse), type))
		return soap->error;
	if (a->ExchangeMonthsResult)
		soap_element_result(soap, "eoddata1:ExchangeMonthsResult");
	if (soap_out_PointerToeoddata1__RESPONSE(soap, "eoddata1:ExchangeMonthsResult", -1, &a->_eoddata1__ExchangeMonthsResponse::ExchangeMonthsResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__ExchangeMonthsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__ExchangeMonthsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__ExchangeMonthsResponse * SOAP_FMAC4 soap_in__eoddata1__ExchangeMonthsResponse(struct soap *soap, const char *tag, _eoddata1__ExchangeMonthsResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__ExchangeMonthsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__ExchangeMonthsResponse, sizeof(_eoddata1__ExchangeMonthsResponse), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ExchangeMonthsResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ExchangeMonthsResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToeoddata1__RESPONSE(soap, "eoddata1:ExchangeMonthsResult", &a->_eoddata1__ExchangeMonthsResponse::ExchangeMonthsResult, "eoddata1:RESPONSE"))
				{	soap_flag_ExchangeMonthsResult1--;
					continue;
				}
			soap_check_result(soap, "eoddata1:ExchangeMonthsResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__ExchangeMonthsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__ExchangeMonthsResponse, SOAP_TYPE_eoddata__eoddata1__ExchangeMonthsResponse, sizeof(_eoddata1__ExchangeMonthsResponse), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__ExchangeMonthsResponse * SOAP_FMAC2 soap_instantiate__eoddata1__ExchangeMonthsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__ExchangeMonthsResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__ExchangeMonthsResponse *p;
	size_t k = sizeof(_eoddata1__ExchangeMonthsResponse);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__ExchangeMonthsResponse);
		if (p)
			((_eoddata1__ExchangeMonthsResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__ExchangeMonthsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__ExchangeMonthsResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__ExchangeMonthsResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__ExchangeMonthsResponse, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__ExchangeMonthsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:ExchangeMonthsResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__ExchangeMonthsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__ExchangeMonthsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__ExchangeMonthsResponse * SOAP_FMAC4 soap_get__eoddata1__ExchangeMonthsResponse(struct soap *soap, _eoddata1__ExchangeMonthsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__ExchangeMonthsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__ExchangeMonths::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__ExchangeMonths::Token = NULL;
	this->_eoddata1__ExchangeMonths::Exchange = NULL;
	/* transient soap skipped */
}

void _eoddata1__ExchangeMonths::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__ExchangeMonths::Token);
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__ExchangeMonths::Exchange);
#endif
}

int _eoddata1__ExchangeMonths::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__ExchangeMonths(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__ExchangeMonths(struct soap *soap, const char *tag, int id, const _eoddata1__ExchangeMonths *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__ExchangeMonths), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Token", -1, &a->_eoddata1__ExchangeMonths::Token, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Exchange", -1, &a->_eoddata1__ExchangeMonths::Exchange, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__ExchangeMonths::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__ExchangeMonths(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__ExchangeMonths * SOAP_FMAC4 soap_in__eoddata1__ExchangeMonths(struct soap *soap, const char *tag, _eoddata1__ExchangeMonths *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__ExchangeMonths *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__ExchangeMonths, sizeof(_eoddata1__ExchangeMonths), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	size_t soap_flag_Exchange1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Token", &a->_eoddata1__ExchangeMonths::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap_flag_Exchange1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Exchange", &a->_eoddata1__ExchangeMonths::Exchange, "xsd:string"))
				{	soap_flag_Exchange1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__ExchangeMonths *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__ExchangeMonths, SOAP_TYPE_eoddata__eoddata1__ExchangeMonths, sizeof(_eoddata1__ExchangeMonths), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__ExchangeMonths * SOAP_FMAC2 soap_instantiate__eoddata1__ExchangeMonths(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__ExchangeMonths(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__ExchangeMonths *p;
	size_t k = sizeof(_eoddata1__ExchangeMonths);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__ExchangeMonths);
		if (p)
			((_eoddata1__ExchangeMonths*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__ExchangeMonths, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__ExchangeMonths*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__ExchangeMonths location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__ExchangeMonths, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__ExchangeMonths::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:ExchangeMonths", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__ExchangeMonths::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__ExchangeMonths(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__ExchangeMonths * SOAP_FMAC4 soap_get__eoddata1__ExchangeMonths(struct soap *soap, _eoddata1__ExchangeMonths *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__ExchangeMonths(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__SymbolChartResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__SymbolChartResponse::SymbolChartResult = NULL;
	/* transient soap skipped */
}

void _eoddata1__SymbolChartResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToeoddata1__RESPONSE(soap, &this->_eoddata1__SymbolChartResponse::SymbolChartResult);
#endif
}

int _eoddata1__SymbolChartResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__SymbolChartResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__SymbolChartResponse(struct soap *soap, const char *tag, int id, const _eoddata1__SymbolChartResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__SymbolChartResponse), type))
		return soap->error;
	if (a->SymbolChartResult)
		soap_element_result(soap, "eoddata1:SymbolChartResult");
	if (soap_out_PointerToeoddata1__RESPONSE(soap, "eoddata1:SymbolChartResult", -1, &a->_eoddata1__SymbolChartResponse::SymbolChartResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__SymbolChartResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__SymbolChartResponse(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__SymbolChartResponse * SOAP_FMAC4 soap_in__eoddata1__SymbolChartResponse(struct soap *soap, const char *tag, _eoddata1__SymbolChartResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__SymbolChartResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__SymbolChartResponse, sizeof(_eoddata1__SymbolChartResponse), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SymbolChartResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SymbolChartResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToeoddata1__RESPONSE(soap, "eoddata1:SymbolChartResult", &a->_eoddata1__SymbolChartResponse::SymbolChartResult, "eoddata1:RESPONSE"))
				{	soap_flag_SymbolChartResult1--;
					continue;
				}
			soap_check_result(soap, "eoddata1:SymbolChartResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__SymbolChartResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__SymbolChartResponse, SOAP_TYPE_eoddata__eoddata1__SymbolChartResponse, sizeof(_eoddata1__SymbolChartResponse), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__SymbolChartResponse * SOAP_FMAC2 soap_instantiate__eoddata1__SymbolChartResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__SymbolChartResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__SymbolChartResponse *p;
	size_t k = sizeof(_eoddata1__SymbolChartResponse);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__SymbolChartResponse);
		if (p)
			((_eoddata1__SymbolChartResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__SymbolChartResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__SymbolChartResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__SymbolChartResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__SymbolChartResponse, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__SymbolChartResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:SymbolChartResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__SymbolChartResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__SymbolChartResponse(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__SymbolChartResponse * SOAP_FMAC4 soap_get__eoddata1__SymbolChartResponse(struct soap *soap, _eoddata1__SymbolChartResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__SymbolChartResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__SymbolChart::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__SymbolChart::Token = NULL;
	this->_eoddata1__SymbolChart::Exchange = NULL;
	this->_eoddata1__SymbolChart::Symbol = NULL;
	/* transient soap skipped */
}

void _eoddata1__SymbolChart::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__SymbolChart::Token);
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__SymbolChart::Exchange);
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__SymbolChart::Symbol);
#endif
}

int _eoddata1__SymbolChart::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__SymbolChart(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__SymbolChart(struct soap *soap, const char *tag, int id, const _eoddata1__SymbolChart *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__SymbolChart), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Token", -1, &a->_eoddata1__SymbolChart::Token, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Exchange", -1, &a->_eoddata1__SymbolChart::Exchange, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Symbol", -1, &a->_eoddata1__SymbolChart::Symbol, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__SymbolChart::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__SymbolChart(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__SymbolChart * SOAP_FMAC4 soap_in__eoddata1__SymbolChart(struct soap *soap, const char *tag, _eoddata1__SymbolChart *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__SymbolChart *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__SymbolChart, sizeof(_eoddata1__SymbolChart), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	size_t soap_flag_Exchange1 = 1;
	size_t soap_flag_Symbol1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Token", &a->_eoddata1__SymbolChart::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap_flag_Exchange1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Exchange", &a->_eoddata1__SymbolChart::Exchange, "xsd:string"))
				{	soap_flag_Exchange1--;
					continue;
				}
			if (soap_flag_Symbol1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Symbol", &a->_eoddata1__SymbolChart::Symbol, "xsd:string"))
				{	soap_flag_Symbol1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__SymbolChart *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__SymbolChart, SOAP_TYPE_eoddata__eoddata1__SymbolChart, sizeof(_eoddata1__SymbolChart), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__SymbolChart * SOAP_FMAC2 soap_instantiate__eoddata1__SymbolChart(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__SymbolChart(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__SymbolChart *p;
	size_t k = sizeof(_eoddata1__SymbolChart);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__SymbolChart);
		if (p)
			((_eoddata1__SymbolChart*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__SymbolChart, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__SymbolChart*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__SymbolChart location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__SymbolChart, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__SymbolChart::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:SymbolChart", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__SymbolChart::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__SymbolChart(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__SymbolChart * SOAP_FMAC4 soap_get__eoddata1__SymbolChart(struct soap *soap, _eoddata1__SymbolChart *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__SymbolChart(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__Top10LossesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__Top10LossesResponse::Top10LossesResult = NULL;
	/* transient soap skipped */
}

void _eoddata1__Top10LossesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToeoddata1__RESPONSE(soap, &this->_eoddata1__Top10LossesResponse::Top10LossesResult);
#endif
}

int _eoddata1__Top10LossesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__Top10LossesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__Top10LossesResponse(struct soap *soap, const char *tag, int id, const _eoddata1__Top10LossesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__Top10LossesResponse), type))
		return soap->error;
	if (a->Top10LossesResult)
		soap_element_result(soap, "eoddata1:Top10LossesResult");
	if (soap_out_PointerToeoddata1__RESPONSE(soap, "eoddata1:Top10LossesResult", -1, &a->_eoddata1__Top10LossesResponse::Top10LossesResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__Top10LossesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__Top10LossesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__Top10LossesResponse * SOAP_FMAC4 soap_in__eoddata1__Top10LossesResponse(struct soap *soap, const char *tag, _eoddata1__Top10LossesResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__Top10LossesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__Top10LossesResponse, sizeof(_eoddata1__Top10LossesResponse), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Top10LossesResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Top10LossesResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToeoddata1__RESPONSE(soap, "eoddata1:Top10LossesResult", &a->_eoddata1__Top10LossesResponse::Top10LossesResult, "eoddata1:RESPONSE"))
				{	soap_flag_Top10LossesResult1--;
					continue;
				}
			soap_check_result(soap, "eoddata1:Top10LossesResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__Top10LossesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__Top10LossesResponse, SOAP_TYPE_eoddata__eoddata1__Top10LossesResponse, sizeof(_eoddata1__Top10LossesResponse), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__Top10LossesResponse * SOAP_FMAC2 soap_instantiate__eoddata1__Top10LossesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__Top10LossesResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__Top10LossesResponse *p;
	size_t k = sizeof(_eoddata1__Top10LossesResponse);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__Top10LossesResponse);
		if (p)
			((_eoddata1__Top10LossesResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__Top10LossesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__Top10LossesResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__Top10LossesResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__Top10LossesResponse, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__Top10LossesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:Top10LossesResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__Top10LossesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__Top10LossesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__Top10LossesResponse * SOAP_FMAC4 soap_get__eoddata1__Top10LossesResponse(struct soap *soap, _eoddata1__Top10LossesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__Top10LossesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__Top10Losses::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__Top10Losses::Token = NULL;
	this->_eoddata1__Top10Losses::Exchange = NULL;
	/* transient soap skipped */
}

void _eoddata1__Top10Losses::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__Top10Losses::Token);
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__Top10Losses::Exchange);
#endif
}

int _eoddata1__Top10Losses::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__Top10Losses(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__Top10Losses(struct soap *soap, const char *tag, int id, const _eoddata1__Top10Losses *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__Top10Losses), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Token", -1, &a->_eoddata1__Top10Losses::Token, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Exchange", -1, &a->_eoddata1__Top10Losses::Exchange, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__Top10Losses::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__Top10Losses(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__Top10Losses * SOAP_FMAC4 soap_in__eoddata1__Top10Losses(struct soap *soap, const char *tag, _eoddata1__Top10Losses *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__Top10Losses *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__Top10Losses, sizeof(_eoddata1__Top10Losses), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	size_t soap_flag_Exchange1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Token", &a->_eoddata1__Top10Losses::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap_flag_Exchange1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Exchange", &a->_eoddata1__Top10Losses::Exchange, "xsd:string"))
				{	soap_flag_Exchange1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__Top10Losses *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__Top10Losses, SOAP_TYPE_eoddata__eoddata1__Top10Losses, sizeof(_eoddata1__Top10Losses), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__Top10Losses * SOAP_FMAC2 soap_instantiate__eoddata1__Top10Losses(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__Top10Losses(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__Top10Losses *p;
	size_t k = sizeof(_eoddata1__Top10Losses);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__Top10Losses);
		if (p)
			((_eoddata1__Top10Losses*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__Top10Losses, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__Top10Losses*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__Top10Losses location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__Top10Losses, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__Top10Losses::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:Top10Losses", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__Top10Losses::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__Top10Losses(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__Top10Losses * SOAP_FMAC4 soap_get__eoddata1__Top10Losses(struct soap *soap, _eoddata1__Top10Losses *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__Top10Losses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__Top10GainsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__Top10GainsResponse::Top10GainsResult = NULL;
	/* transient soap skipped */
}

void _eoddata1__Top10GainsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToeoddata1__RESPONSE(soap, &this->_eoddata1__Top10GainsResponse::Top10GainsResult);
#endif
}

int _eoddata1__Top10GainsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__Top10GainsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__Top10GainsResponse(struct soap *soap, const char *tag, int id, const _eoddata1__Top10GainsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__Top10GainsResponse), type))
		return soap->error;
	if (a->Top10GainsResult)
		soap_element_result(soap, "eoddata1:Top10GainsResult");
	if (soap_out_PointerToeoddata1__RESPONSE(soap, "eoddata1:Top10GainsResult", -1, &a->_eoddata1__Top10GainsResponse::Top10GainsResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__Top10GainsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__Top10GainsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__Top10GainsResponse * SOAP_FMAC4 soap_in__eoddata1__Top10GainsResponse(struct soap *soap, const char *tag, _eoddata1__Top10GainsResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__Top10GainsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__Top10GainsResponse, sizeof(_eoddata1__Top10GainsResponse), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Top10GainsResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Top10GainsResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToeoddata1__RESPONSE(soap, "eoddata1:Top10GainsResult", &a->_eoddata1__Top10GainsResponse::Top10GainsResult, "eoddata1:RESPONSE"))
				{	soap_flag_Top10GainsResult1--;
					continue;
				}
			soap_check_result(soap, "eoddata1:Top10GainsResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__Top10GainsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__Top10GainsResponse, SOAP_TYPE_eoddata__eoddata1__Top10GainsResponse, sizeof(_eoddata1__Top10GainsResponse), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__Top10GainsResponse * SOAP_FMAC2 soap_instantiate__eoddata1__Top10GainsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__Top10GainsResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__Top10GainsResponse *p;
	size_t k = sizeof(_eoddata1__Top10GainsResponse);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__Top10GainsResponse);
		if (p)
			((_eoddata1__Top10GainsResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__Top10GainsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__Top10GainsResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__Top10GainsResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__Top10GainsResponse, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__Top10GainsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:Top10GainsResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__Top10GainsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__Top10GainsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__Top10GainsResponse * SOAP_FMAC4 soap_get__eoddata1__Top10GainsResponse(struct soap *soap, _eoddata1__Top10GainsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__Top10GainsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__Top10Gains::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__Top10Gains::Token = NULL;
	this->_eoddata1__Top10Gains::Exchange = NULL;
	/* transient soap skipped */
}

void _eoddata1__Top10Gains::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__Top10Gains::Token);
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__Top10Gains::Exchange);
#endif
}

int _eoddata1__Top10Gains::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__Top10Gains(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__Top10Gains(struct soap *soap, const char *tag, int id, const _eoddata1__Top10Gains *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__Top10Gains), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Token", -1, &a->_eoddata1__Top10Gains::Token, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Exchange", -1, &a->_eoddata1__Top10Gains::Exchange, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__Top10Gains::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__Top10Gains(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__Top10Gains * SOAP_FMAC4 soap_in__eoddata1__Top10Gains(struct soap *soap, const char *tag, _eoddata1__Top10Gains *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__Top10Gains *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__Top10Gains, sizeof(_eoddata1__Top10Gains), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	size_t soap_flag_Exchange1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Token", &a->_eoddata1__Top10Gains::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap_flag_Exchange1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Exchange", &a->_eoddata1__Top10Gains::Exchange, "xsd:string"))
				{	soap_flag_Exchange1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__Top10Gains *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__Top10Gains, SOAP_TYPE_eoddata__eoddata1__Top10Gains, sizeof(_eoddata1__Top10Gains), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__Top10Gains * SOAP_FMAC2 soap_instantiate__eoddata1__Top10Gains(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__Top10Gains(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__Top10Gains *p;
	size_t k = sizeof(_eoddata1__Top10Gains);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__Top10Gains);
		if (p)
			((_eoddata1__Top10Gains*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__Top10Gains, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__Top10Gains*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__Top10Gains location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__Top10Gains, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__Top10Gains::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:Top10Gains", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__Top10Gains::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__Top10Gains(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__Top10Gains * SOAP_FMAC4 soap_get__eoddata1__Top10Gains(struct soap *soap, _eoddata1__Top10Gains *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__Top10Gains(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__SymbolHistoryResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__SymbolHistoryResponse::SymbolHistoryResult = NULL;
	/* transient soap skipped */
}

void _eoddata1__SymbolHistoryResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToeoddata1__RESPONSE(soap, &this->_eoddata1__SymbolHistoryResponse::SymbolHistoryResult);
#endif
}

int _eoddata1__SymbolHistoryResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__SymbolHistoryResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__SymbolHistoryResponse(struct soap *soap, const char *tag, int id, const _eoddata1__SymbolHistoryResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__SymbolHistoryResponse), type))
		return soap->error;
	if (a->SymbolHistoryResult)
		soap_element_result(soap, "eoddata1:SymbolHistoryResult");
	if (soap_out_PointerToeoddata1__RESPONSE(soap, "eoddata1:SymbolHistoryResult", -1, &a->_eoddata1__SymbolHistoryResponse::SymbolHistoryResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__SymbolHistoryResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__SymbolHistoryResponse(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__SymbolHistoryResponse * SOAP_FMAC4 soap_in__eoddata1__SymbolHistoryResponse(struct soap *soap, const char *tag, _eoddata1__SymbolHistoryResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__SymbolHistoryResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__SymbolHistoryResponse, sizeof(_eoddata1__SymbolHistoryResponse), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SymbolHistoryResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SymbolHistoryResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToeoddata1__RESPONSE(soap, "eoddata1:SymbolHistoryResult", &a->_eoddata1__SymbolHistoryResponse::SymbolHistoryResult, "eoddata1:RESPONSE"))
				{	soap_flag_SymbolHistoryResult1--;
					continue;
				}
			soap_check_result(soap, "eoddata1:SymbolHistoryResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__SymbolHistoryResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__SymbolHistoryResponse, SOAP_TYPE_eoddata__eoddata1__SymbolHistoryResponse, sizeof(_eoddata1__SymbolHistoryResponse), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__SymbolHistoryResponse * SOAP_FMAC2 soap_instantiate__eoddata1__SymbolHistoryResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__SymbolHistoryResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__SymbolHistoryResponse *p;
	size_t k = sizeof(_eoddata1__SymbolHistoryResponse);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__SymbolHistoryResponse);
		if (p)
			((_eoddata1__SymbolHistoryResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__SymbolHistoryResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__SymbolHistoryResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__SymbolHistoryResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__SymbolHistoryResponse, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__SymbolHistoryResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:SymbolHistoryResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__SymbolHistoryResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__SymbolHistoryResponse(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__SymbolHistoryResponse * SOAP_FMAC4 soap_get__eoddata1__SymbolHistoryResponse(struct soap *soap, _eoddata1__SymbolHistoryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__SymbolHistoryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__SymbolHistory::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__SymbolHistory::Token = NULL;
	this->_eoddata1__SymbolHistory::Exchange = NULL;
	this->_eoddata1__SymbolHistory::Symbol = NULL;
	this->_eoddata1__SymbolHistory::StartDate = NULL;
	/* transient soap skipped */
}

void _eoddata1__SymbolHistory::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__SymbolHistory::Token);
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__SymbolHistory::Exchange);
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__SymbolHistory::Symbol);
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__SymbolHistory::StartDate);
#endif
}

int _eoddata1__SymbolHistory::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__SymbolHistory(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__SymbolHistory(struct soap *soap, const char *tag, int id, const _eoddata1__SymbolHistory *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__SymbolHistory), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Token", -1, &a->_eoddata1__SymbolHistory::Token, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Exchange", -1, &a->_eoddata1__SymbolHistory::Exchange, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Symbol", -1, &a->_eoddata1__SymbolHistory::Symbol, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:StartDate", -1, &a->_eoddata1__SymbolHistory::StartDate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__SymbolHistory::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__SymbolHistory(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__SymbolHistory * SOAP_FMAC4 soap_in__eoddata1__SymbolHistory(struct soap *soap, const char *tag, _eoddata1__SymbolHistory *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__SymbolHistory *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__SymbolHistory, sizeof(_eoddata1__SymbolHistory), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	size_t soap_flag_Exchange1 = 1;
	size_t soap_flag_Symbol1 = 1;
	size_t soap_flag_StartDate1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Token", &a->_eoddata1__SymbolHistory::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap_flag_Exchange1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Exchange", &a->_eoddata1__SymbolHistory::Exchange, "xsd:string"))
				{	soap_flag_Exchange1--;
					continue;
				}
			if (soap_flag_Symbol1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Symbol", &a->_eoddata1__SymbolHistory::Symbol, "xsd:string"))
				{	soap_flag_Symbol1--;
					continue;
				}
			if (soap_flag_StartDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:StartDate", &a->_eoddata1__SymbolHistory::StartDate, "xsd:string"))
				{	soap_flag_StartDate1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__SymbolHistory *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__SymbolHistory, SOAP_TYPE_eoddata__eoddata1__SymbolHistory, sizeof(_eoddata1__SymbolHistory), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__SymbolHistory * SOAP_FMAC2 soap_instantiate__eoddata1__SymbolHistory(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__SymbolHistory(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__SymbolHistory *p;
	size_t k = sizeof(_eoddata1__SymbolHistory);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__SymbolHistory);
		if (p)
			((_eoddata1__SymbolHistory*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__SymbolHistory, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__SymbolHistory*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__SymbolHistory location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__SymbolHistory, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__SymbolHistory::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:SymbolHistory", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__SymbolHistory::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__SymbolHistory(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__SymbolHistory * SOAP_FMAC4 soap_get__eoddata1__SymbolHistory(struct soap *soap, _eoddata1__SymbolHistory *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__SymbolHistory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__QuoteListByDate2Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__QuoteListByDate2Response::QuoteListByDate2Result = NULL;
	/* transient soap skipped */
}

void _eoddata1__QuoteListByDate2Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToeoddata1__RESPONSE(soap, &this->_eoddata1__QuoteListByDate2Response::QuoteListByDate2Result);
#endif
}

int _eoddata1__QuoteListByDate2Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__QuoteListByDate2Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__QuoteListByDate2Response(struct soap *soap, const char *tag, int id, const _eoddata1__QuoteListByDate2Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__QuoteListByDate2Response), type))
		return soap->error;
	if (a->QuoteListByDate2Result)
		soap_element_result(soap, "eoddata1:QuoteListByDate2Result");
	if (soap_out_PointerToeoddata1__RESPONSE(soap, "eoddata1:QuoteListByDate2Result", -1, &a->_eoddata1__QuoteListByDate2Response::QuoteListByDate2Result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__QuoteListByDate2Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__QuoteListByDate2Response(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__QuoteListByDate2Response * SOAP_FMAC4 soap_in__eoddata1__QuoteListByDate2Response(struct soap *soap, const char *tag, _eoddata1__QuoteListByDate2Response *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__QuoteListByDate2Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__QuoteListByDate2Response, sizeof(_eoddata1__QuoteListByDate2Response), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_QuoteListByDate2Result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_QuoteListByDate2Result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToeoddata1__RESPONSE(soap, "eoddata1:QuoteListByDate2Result", &a->_eoddata1__QuoteListByDate2Response::QuoteListByDate2Result, "eoddata1:RESPONSE"))
				{	soap_flag_QuoteListByDate2Result1--;
					continue;
				}
			soap_check_result(soap, "eoddata1:QuoteListByDate2Result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__QuoteListByDate2Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__QuoteListByDate2Response, SOAP_TYPE_eoddata__eoddata1__QuoteListByDate2Response, sizeof(_eoddata1__QuoteListByDate2Response), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__QuoteListByDate2Response * SOAP_FMAC2 soap_instantiate__eoddata1__QuoteListByDate2Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__QuoteListByDate2Response(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__QuoteListByDate2Response *p;
	size_t k = sizeof(_eoddata1__QuoteListByDate2Response);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__QuoteListByDate2Response);
		if (p)
			((_eoddata1__QuoteListByDate2Response*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__QuoteListByDate2Response, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__QuoteListByDate2Response*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__QuoteListByDate2Response location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__QuoteListByDate2Response, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__QuoteListByDate2Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:QuoteListByDate2Response", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__QuoteListByDate2Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__QuoteListByDate2Response(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__QuoteListByDate2Response * SOAP_FMAC4 soap_get__eoddata1__QuoteListByDate2Response(struct soap *soap, _eoddata1__QuoteListByDate2Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__QuoteListByDate2Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__QuoteListByDate2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__QuoteListByDate2::Token = NULL;
	this->_eoddata1__QuoteListByDate2::Exchange = NULL;
	this->_eoddata1__QuoteListByDate2::QuoteDate = NULL;
	/* transient soap skipped */
}

void _eoddata1__QuoteListByDate2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__QuoteListByDate2::Token);
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__QuoteListByDate2::Exchange);
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__QuoteListByDate2::QuoteDate);
#endif
}

int _eoddata1__QuoteListByDate2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__QuoteListByDate2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__QuoteListByDate2(struct soap *soap, const char *tag, int id, const _eoddata1__QuoteListByDate2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__QuoteListByDate2), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Token", -1, &a->_eoddata1__QuoteListByDate2::Token, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Exchange", -1, &a->_eoddata1__QuoteListByDate2::Exchange, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:QuoteDate", -1, &a->_eoddata1__QuoteListByDate2::QuoteDate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__QuoteListByDate2::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__QuoteListByDate2(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__QuoteListByDate2 * SOAP_FMAC4 soap_in__eoddata1__QuoteListByDate2(struct soap *soap, const char *tag, _eoddata1__QuoteListByDate2 *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__QuoteListByDate2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__QuoteListByDate2, sizeof(_eoddata1__QuoteListByDate2), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	size_t soap_flag_Exchange1 = 1;
	size_t soap_flag_QuoteDate1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Token", &a->_eoddata1__QuoteListByDate2::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap_flag_Exchange1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Exchange", &a->_eoddata1__QuoteListByDate2::Exchange, "xsd:string"))
				{	soap_flag_Exchange1--;
					continue;
				}
			if (soap_flag_QuoteDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:QuoteDate", &a->_eoddata1__QuoteListByDate2::QuoteDate, "xsd:string"))
				{	soap_flag_QuoteDate1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__QuoteListByDate2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__QuoteListByDate2, SOAP_TYPE_eoddata__eoddata1__QuoteListByDate2, sizeof(_eoddata1__QuoteListByDate2), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__QuoteListByDate2 * SOAP_FMAC2 soap_instantiate__eoddata1__QuoteListByDate2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__QuoteListByDate2(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__QuoteListByDate2 *p;
	size_t k = sizeof(_eoddata1__QuoteListByDate2);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__QuoteListByDate2);
		if (p)
			((_eoddata1__QuoteListByDate2*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__QuoteListByDate2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__QuoteListByDate2*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__QuoteListByDate2 location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__QuoteListByDate2, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__QuoteListByDate2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:QuoteListByDate2", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__QuoteListByDate2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__QuoteListByDate2(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__QuoteListByDate2 * SOAP_FMAC4 soap_get__eoddata1__QuoteListByDate2(struct soap *soap, _eoddata1__QuoteListByDate2 *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__QuoteListByDate2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__QuoteListByDateResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__QuoteListByDateResponse::QuoteListByDateResult = NULL;
	/* transient soap skipped */
}

void _eoddata1__QuoteListByDateResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToeoddata1__RESPONSE(soap, &this->_eoddata1__QuoteListByDateResponse::QuoteListByDateResult);
#endif
}

int _eoddata1__QuoteListByDateResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__QuoteListByDateResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__QuoteListByDateResponse(struct soap *soap, const char *tag, int id, const _eoddata1__QuoteListByDateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__QuoteListByDateResponse), type))
		return soap->error;
	if (a->QuoteListByDateResult)
		soap_element_result(soap, "eoddata1:QuoteListByDateResult");
	if (soap_out_PointerToeoddata1__RESPONSE(soap, "eoddata1:QuoteListByDateResult", -1, &a->_eoddata1__QuoteListByDateResponse::QuoteListByDateResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__QuoteListByDateResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__QuoteListByDateResponse(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__QuoteListByDateResponse * SOAP_FMAC4 soap_in__eoddata1__QuoteListByDateResponse(struct soap *soap, const char *tag, _eoddata1__QuoteListByDateResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__QuoteListByDateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__QuoteListByDateResponse, sizeof(_eoddata1__QuoteListByDateResponse), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_QuoteListByDateResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_QuoteListByDateResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToeoddata1__RESPONSE(soap, "eoddata1:QuoteListByDateResult", &a->_eoddata1__QuoteListByDateResponse::QuoteListByDateResult, "eoddata1:RESPONSE"))
				{	soap_flag_QuoteListByDateResult1--;
					continue;
				}
			soap_check_result(soap, "eoddata1:QuoteListByDateResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__QuoteListByDateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__QuoteListByDateResponse, SOAP_TYPE_eoddata__eoddata1__QuoteListByDateResponse, sizeof(_eoddata1__QuoteListByDateResponse), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__QuoteListByDateResponse * SOAP_FMAC2 soap_instantiate__eoddata1__QuoteListByDateResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__QuoteListByDateResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__QuoteListByDateResponse *p;
	size_t k = sizeof(_eoddata1__QuoteListByDateResponse);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__QuoteListByDateResponse);
		if (p)
			((_eoddata1__QuoteListByDateResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__QuoteListByDateResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__QuoteListByDateResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__QuoteListByDateResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__QuoteListByDateResponse, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__QuoteListByDateResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:QuoteListByDateResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__QuoteListByDateResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__QuoteListByDateResponse(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__QuoteListByDateResponse * SOAP_FMAC4 soap_get__eoddata1__QuoteListByDateResponse(struct soap *soap, _eoddata1__QuoteListByDateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__QuoteListByDateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__QuoteListByDate::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__QuoteListByDate::Token = NULL;
	this->_eoddata1__QuoteListByDate::Exchange = NULL;
	this->_eoddata1__QuoteListByDate::QuoteDate = NULL;
	/* transient soap skipped */
}

void _eoddata1__QuoteListByDate::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__QuoteListByDate::Token);
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__QuoteListByDate::Exchange);
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__QuoteListByDate::QuoteDate);
#endif
}

int _eoddata1__QuoteListByDate::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__QuoteListByDate(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__QuoteListByDate(struct soap *soap, const char *tag, int id, const _eoddata1__QuoteListByDate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__QuoteListByDate), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Token", -1, &a->_eoddata1__QuoteListByDate::Token, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Exchange", -1, &a->_eoddata1__QuoteListByDate::Exchange, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:QuoteDate", -1, &a->_eoddata1__QuoteListByDate::QuoteDate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__QuoteListByDate::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__QuoteListByDate(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__QuoteListByDate * SOAP_FMAC4 soap_in__eoddata1__QuoteListByDate(struct soap *soap, const char *tag, _eoddata1__QuoteListByDate *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__QuoteListByDate *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__QuoteListByDate, sizeof(_eoddata1__QuoteListByDate), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	size_t soap_flag_Exchange1 = 1;
	size_t soap_flag_QuoteDate1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Token", &a->_eoddata1__QuoteListByDate::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap_flag_Exchange1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Exchange", &a->_eoddata1__QuoteListByDate::Exchange, "xsd:string"))
				{	soap_flag_Exchange1--;
					continue;
				}
			if (soap_flag_QuoteDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:QuoteDate", &a->_eoddata1__QuoteListByDate::QuoteDate, "xsd:string"))
				{	soap_flag_QuoteDate1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__QuoteListByDate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__QuoteListByDate, SOAP_TYPE_eoddata__eoddata1__QuoteListByDate, sizeof(_eoddata1__QuoteListByDate), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__QuoteListByDate * SOAP_FMAC2 soap_instantiate__eoddata1__QuoteListByDate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__QuoteListByDate(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__QuoteListByDate *p;
	size_t k = sizeof(_eoddata1__QuoteListByDate);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__QuoteListByDate);
		if (p)
			((_eoddata1__QuoteListByDate*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__QuoteListByDate, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__QuoteListByDate*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__QuoteListByDate location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__QuoteListByDate, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__QuoteListByDate::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:QuoteListByDate", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__QuoteListByDate::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__QuoteListByDate(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__QuoteListByDate * SOAP_FMAC4 soap_get__eoddata1__QuoteListByDate(struct soap *soap, _eoddata1__QuoteListByDate *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__QuoteListByDate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__TechnicalListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__TechnicalListResponse::TechnicalListResult = NULL;
	/* transient soap skipped */
}

void _eoddata1__TechnicalListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToeoddata1__RESPONSE(soap, &this->_eoddata1__TechnicalListResponse::TechnicalListResult);
#endif
}

int _eoddata1__TechnicalListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__TechnicalListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__TechnicalListResponse(struct soap *soap, const char *tag, int id, const _eoddata1__TechnicalListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__TechnicalListResponse), type))
		return soap->error;
	if (a->TechnicalListResult)
		soap_element_result(soap, "eoddata1:TechnicalListResult");
	if (soap_out_PointerToeoddata1__RESPONSE(soap, "eoddata1:TechnicalListResult", -1, &a->_eoddata1__TechnicalListResponse::TechnicalListResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__TechnicalListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__TechnicalListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__TechnicalListResponse * SOAP_FMAC4 soap_in__eoddata1__TechnicalListResponse(struct soap *soap, const char *tag, _eoddata1__TechnicalListResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__TechnicalListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__TechnicalListResponse, sizeof(_eoddata1__TechnicalListResponse), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_TechnicalListResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TechnicalListResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToeoddata1__RESPONSE(soap, "eoddata1:TechnicalListResult", &a->_eoddata1__TechnicalListResponse::TechnicalListResult, "eoddata1:RESPONSE"))
				{	soap_flag_TechnicalListResult1--;
					continue;
				}
			soap_check_result(soap, "eoddata1:TechnicalListResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__TechnicalListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__TechnicalListResponse, SOAP_TYPE_eoddata__eoddata1__TechnicalListResponse, sizeof(_eoddata1__TechnicalListResponse), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__TechnicalListResponse * SOAP_FMAC2 soap_instantiate__eoddata1__TechnicalListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__TechnicalListResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__TechnicalListResponse *p;
	size_t k = sizeof(_eoddata1__TechnicalListResponse);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__TechnicalListResponse);
		if (p)
			((_eoddata1__TechnicalListResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__TechnicalListResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__TechnicalListResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__TechnicalListResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__TechnicalListResponse, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__TechnicalListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:TechnicalListResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__TechnicalListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__TechnicalListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__TechnicalListResponse * SOAP_FMAC4 soap_get__eoddata1__TechnicalListResponse(struct soap *soap, _eoddata1__TechnicalListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__TechnicalListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__TechnicalList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__TechnicalList::Token = NULL;
	this->_eoddata1__TechnicalList::Exchange = NULL;
	/* transient soap skipped */
}

void _eoddata1__TechnicalList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__TechnicalList::Token);
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__TechnicalList::Exchange);
#endif
}

int _eoddata1__TechnicalList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__TechnicalList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__TechnicalList(struct soap *soap, const char *tag, int id, const _eoddata1__TechnicalList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__TechnicalList), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Token", -1, &a->_eoddata1__TechnicalList::Token, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Exchange", -1, &a->_eoddata1__TechnicalList::Exchange, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__TechnicalList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__TechnicalList(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__TechnicalList * SOAP_FMAC4 soap_in__eoddata1__TechnicalList(struct soap *soap, const char *tag, _eoddata1__TechnicalList *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__TechnicalList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__TechnicalList, sizeof(_eoddata1__TechnicalList), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	size_t soap_flag_Exchange1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Token", &a->_eoddata1__TechnicalList::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap_flag_Exchange1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Exchange", &a->_eoddata1__TechnicalList::Exchange, "xsd:string"))
				{	soap_flag_Exchange1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__TechnicalList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__TechnicalList, SOAP_TYPE_eoddata__eoddata1__TechnicalList, sizeof(_eoddata1__TechnicalList), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__TechnicalList * SOAP_FMAC2 soap_instantiate__eoddata1__TechnicalList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__TechnicalList(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__TechnicalList *p;
	size_t k = sizeof(_eoddata1__TechnicalList);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__TechnicalList);
		if (p)
			((_eoddata1__TechnicalList*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__TechnicalList, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__TechnicalList*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__TechnicalList location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__TechnicalList, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__TechnicalList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:TechnicalList", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__TechnicalList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__TechnicalList(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__TechnicalList * SOAP_FMAC4 soap_get__eoddata1__TechnicalList(struct soap *soap, _eoddata1__TechnicalList *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__TechnicalList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__FundamentalListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__FundamentalListResponse::FundamentalListResult = NULL;
	/* transient soap skipped */
}

void _eoddata1__FundamentalListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToeoddata1__RESPONSE(soap, &this->_eoddata1__FundamentalListResponse::FundamentalListResult);
#endif
}

int _eoddata1__FundamentalListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__FundamentalListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__FundamentalListResponse(struct soap *soap, const char *tag, int id, const _eoddata1__FundamentalListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__FundamentalListResponse), type))
		return soap->error;
	if (a->FundamentalListResult)
		soap_element_result(soap, "eoddata1:FundamentalListResult");
	if (soap_out_PointerToeoddata1__RESPONSE(soap, "eoddata1:FundamentalListResult", -1, &a->_eoddata1__FundamentalListResponse::FundamentalListResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__FundamentalListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__FundamentalListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__FundamentalListResponse * SOAP_FMAC4 soap_in__eoddata1__FundamentalListResponse(struct soap *soap, const char *tag, _eoddata1__FundamentalListResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__FundamentalListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__FundamentalListResponse, sizeof(_eoddata1__FundamentalListResponse), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FundamentalListResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FundamentalListResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToeoddata1__RESPONSE(soap, "eoddata1:FundamentalListResult", &a->_eoddata1__FundamentalListResponse::FundamentalListResult, "eoddata1:RESPONSE"))
				{	soap_flag_FundamentalListResult1--;
					continue;
				}
			soap_check_result(soap, "eoddata1:FundamentalListResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__FundamentalListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__FundamentalListResponse, SOAP_TYPE_eoddata__eoddata1__FundamentalListResponse, sizeof(_eoddata1__FundamentalListResponse), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__FundamentalListResponse * SOAP_FMAC2 soap_instantiate__eoddata1__FundamentalListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__FundamentalListResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__FundamentalListResponse *p;
	size_t k = sizeof(_eoddata1__FundamentalListResponse);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__FundamentalListResponse);
		if (p)
			((_eoddata1__FundamentalListResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__FundamentalListResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__FundamentalListResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__FundamentalListResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__FundamentalListResponse, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__FundamentalListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:FundamentalListResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__FundamentalListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__FundamentalListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__FundamentalListResponse * SOAP_FMAC4 soap_get__eoddata1__FundamentalListResponse(struct soap *soap, _eoddata1__FundamentalListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__FundamentalListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__FundamentalList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__FundamentalList::Token = NULL;
	this->_eoddata1__FundamentalList::Exchange = NULL;
	/* transient soap skipped */
}

void _eoddata1__FundamentalList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__FundamentalList::Token);
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__FundamentalList::Exchange);
#endif
}

int _eoddata1__FundamentalList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__FundamentalList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__FundamentalList(struct soap *soap, const char *tag, int id, const _eoddata1__FundamentalList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__FundamentalList), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Token", -1, &a->_eoddata1__FundamentalList::Token, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Exchange", -1, &a->_eoddata1__FundamentalList::Exchange, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__FundamentalList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__FundamentalList(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__FundamentalList * SOAP_FMAC4 soap_in__eoddata1__FundamentalList(struct soap *soap, const char *tag, _eoddata1__FundamentalList *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__FundamentalList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__FundamentalList, sizeof(_eoddata1__FundamentalList), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	size_t soap_flag_Exchange1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Token", &a->_eoddata1__FundamentalList::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap_flag_Exchange1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Exchange", &a->_eoddata1__FundamentalList::Exchange, "xsd:string"))
				{	soap_flag_Exchange1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__FundamentalList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__FundamentalList, SOAP_TYPE_eoddata__eoddata1__FundamentalList, sizeof(_eoddata1__FundamentalList), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__FundamentalList * SOAP_FMAC2 soap_instantiate__eoddata1__FundamentalList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__FundamentalList(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__FundamentalList *p;
	size_t k = sizeof(_eoddata1__FundamentalList);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__FundamentalList);
		if (p)
			((_eoddata1__FundamentalList*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__FundamentalList, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__FundamentalList*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__FundamentalList location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__FundamentalList, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__FundamentalList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:FundamentalList", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__FundamentalList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__FundamentalList(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__FundamentalList * SOAP_FMAC4 soap_get__eoddata1__FundamentalList(struct soap *soap, _eoddata1__FundamentalList *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__FundamentalList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__NewsListBySymbolResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__NewsListBySymbolResponse::NewsListBySymbolResult = NULL;
	/* transient soap skipped */
}

void _eoddata1__NewsListBySymbolResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToeoddata1__RESPONSE(soap, &this->_eoddata1__NewsListBySymbolResponse::NewsListBySymbolResult);
#endif
}

int _eoddata1__NewsListBySymbolResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__NewsListBySymbolResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__NewsListBySymbolResponse(struct soap *soap, const char *tag, int id, const _eoddata1__NewsListBySymbolResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__NewsListBySymbolResponse), type))
		return soap->error;
	if (a->NewsListBySymbolResult)
		soap_element_result(soap, "eoddata1:NewsListBySymbolResult");
	if (soap_out_PointerToeoddata1__RESPONSE(soap, "eoddata1:NewsListBySymbolResult", -1, &a->_eoddata1__NewsListBySymbolResponse::NewsListBySymbolResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__NewsListBySymbolResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__NewsListBySymbolResponse(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__NewsListBySymbolResponse * SOAP_FMAC4 soap_in__eoddata1__NewsListBySymbolResponse(struct soap *soap, const char *tag, _eoddata1__NewsListBySymbolResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__NewsListBySymbolResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__NewsListBySymbolResponse, sizeof(_eoddata1__NewsListBySymbolResponse), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_NewsListBySymbolResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_NewsListBySymbolResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToeoddata1__RESPONSE(soap, "eoddata1:NewsListBySymbolResult", &a->_eoddata1__NewsListBySymbolResponse::NewsListBySymbolResult, "eoddata1:RESPONSE"))
				{	soap_flag_NewsListBySymbolResult1--;
					continue;
				}
			soap_check_result(soap, "eoddata1:NewsListBySymbolResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__NewsListBySymbolResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__NewsListBySymbolResponse, SOAP_TYPE_eoddata__eoddata1__NewsListBySymbolResponse, sizeof(_eoddata1__NewsListBySymbolResponse), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__NewsListBySymbolResponse * SOAP_FMAC2 soap_instantiate__eoddata1__NewsListBySymbolResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__NewsListBySymbolResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__NewsListBySymbolResponse *p;
	size_t k = sizeof(_eoddata1__NewsListBySymbolResponse);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__NewsListBySymbolResponse);
		if (p)
			((_eoddata1__NewsListBySymbolResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__NewsListBySymbolResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__NewsListBySymbolResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__NewsListBySymbolResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__NewsListBySymbolResponse, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__NewsListBySymbolResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:NewsListBySymbolResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__NewsListBySymbolResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__NewsListBySymbolResponse(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__NewsListBySymbolResponse * SOAP_FMAC4 soap_get__eoddata1__NewsListBySymbolResponse(struct soap *soap, _eoddata1__NewsListBySymbolResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__NewsListBySymbolResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__NewsListBySymbol::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__NewsListBySymbol::token = NULL;
	this->_eoddata1__NewsListBySymbol::Exchange = NULL;
	this->_eoddata1__NewsListBySymbol::symbol = NULL;
	/* transient soap skipped */
}

void _eoddata1__NewsListBySymbol::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__NewsListBySymbol::token);
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__NewsListBySymbol::Exchange);
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__NewsListBySymbol::symbol);
#endif
}

int _eoddata1__NewsListBySymbol::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__NewsListBySymbol(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__NewsListBySymbol(struct soap *soap, const char *tag, int id, const _eoddata1__NewsListBySymbol *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__NewsListBySymbol), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:token", -1, &a->_eoddata1__NewsListBySymbol::token, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Exchange", -1, &a->_eoddata1__NewsListBySymbol::Exchange, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:symbol", -1, &a->_eoddata1__NewsListBySymbol::symbol, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__NewsListBySymbol::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__NewsListBySymbol(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__NewsListBySymbol * SOAP_FMAC4 soap_in__eoddata1__NewsListBySymbol(struct soap *soap, const char *tag, _eoddata1__NewsListBySymbol *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__NewsListBySymbol *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__NewsListBySymbol, sizeof(_eoddata1__NewsListBySymbol), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_token1 = 1;
	size_t soap_flag_Exchange1 = 1;
	size_t soap_flag_symbol1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:token", &a->_eoddata1__NewsListBySymbol::token, "xsd:string"))
				{	soap_flag_token1--;
					continue;
				}
			if (soap_flag_Exchange1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Exchange", &a->_eoddata1__NewsListBySymbol::Exchange, "xsd:string"))
				{	soap_flag_Exchange1--;
					continue;
				}
			if (soap_flag_symbol1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:symbol", &a->_eoddata1__NewsListBySymbol::symbol, "xsd:string"))
				{	soap_flag_symbol1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__NewsListBySymbol *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__NewsListBySymbol, SOAP_TYPE_eoddata__eoddata1__NewsListBySymbol, sizeof(_eoddata1__NewsListBySymbol), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__NewsListBySymbol * SOAP_FMAC2 soap_instantiate__eoddata1__NewsListBySymbol(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__NewsListBySymbol(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__NewsListBySymbol *p;
	size_t k = sizeof(_eoddata1__NewsListBySymbol);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__NewsListBySymbol);
		if (p)
			((_eoddata1__NewsListBySymbol*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__NewsListBySymbol, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__NewsListBySymbol*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__NewsListBySymbol location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__NewsListBySymbol, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__NewsListBySymbol::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:NewsListBySymbol", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__NewsListBySymbol::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__NewsListBySymbol(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__NewsListBySymbol * SOAP_FMAC4 soap_get__eoddata1__NewsListBySymbol(struct soap *soap, _eoddata1__NewsListBySymbol *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__NewsListBySymbol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__NewsListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__NewsListResponse::NewsListResult = NULL;
	/* transient soap skipped */
}

void _eoddata1__NewsListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToeoddata1__RESPONSE(soap, &this->_eoddata1__NewsListResponse::NewsListResult);
#endif
}

int _eoddata1__NewsListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__NewsListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__NewsListResponse(struct soap *soap, const char *tag, int id, const _eoddata1__NewsListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__NewsListResponse), type))
		return soap->error;
	if (a->NewsListResult)
		soap_element_result(soap, "eoddata1:NewsListResult");
	if (soap_out_PointerToeoddata1__RESPONSE(soap, "eoddata1:NewsListResult", -1, &a->_eoddata1__NewsListResponse::NewsListResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__NewsListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__NewsListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__NewsListResponse * SOAP_FMAC4 soap_in__eoddata1__NewsListResponse(struct soap *soap, const char *tag, _eoddata1__NewsListResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__NewsListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__NewsListResponse, sizeof(_eoddata1__NewsListResponse), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_NewsListResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_NewsListResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToeoddata1__RESPONSE(soap, "eoddata1:NewsListResult", &a->_eoddata1__NewsListResponse::NewsListResult, "eoddata1:RESPONSE"))
				{	soap_flag_NewsListResult1--;
					continue;
				}
			soap_check_result(soap, "eoddata1:NewsListResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__NewsListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__NewsListResponse, SOAP_TYPE_eoddata__eoddata1__NewsListResponse, sizeof(_eoddata1__NewsListResponse), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__NewsListResponse * SOAP_FMAC2 soap_instantiate__eoddata1__NewsListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__NewsListResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__NewsListResponse *p;
	size_t k = sizeof(_eoddata1__NewsListResponse);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__NewsListResponse);
		if (p)
			((_eoddata1__NewsListResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__NewsListResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__NewsListResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__NewsListResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__NewsListResponse, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__NewsListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:NewsListResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__NewsListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__NewsListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__NewsListResponse * SOAP_FMAC4 soap_get__eoddata1__NewsListResponse(struct soap *soap, _eoddata1__NewsListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__NewsListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__NewsList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__NewsList::Token = NULL;
	this->_eoddata1__NewsList::Exchange = NULL;
	/* transient soap skipped */
}

void _eoddata1__NewsList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__NewsList::Token);
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__NewsList::Exchange);
#endif
}

int _eoddata1__NewsList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__NewsList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__NewsList(struct soap *soap, const char *tag, int id, const _eoddata1__NewsList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__NewsList), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Token", -1, &a->_eoddata1__NewsList::Token, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Exchange", -1, &a->_eoddata1__NewsList::Exchange, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__NewsList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__NewsList(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__NewsList * SOAP_FMAC4 soap_in__eoddata1__NewsList(struct soap *soap, const char *tag, _eoddata1__NewsList *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__NewsList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__NewsList, sizeof(_eoddata1__NewsList), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	size_t soap_flag_Exchange1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Token", &a->_eoddata1__NewsList::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap_flag_Exchange1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Exchange", &a->_eoddata1__NewsList::Exchange, "xsd:string"))
				{	soap_flag_Exchange1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__NewsList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__NewsList, SOAP_TYPE_eoddata__eoddata1__NewsList, sizeof(_eoddata1__NewsList), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__NewsList * SOAP_FMAC2 soap_instantiate__eoddata1__NewsList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__NewsList(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__NewsList *p;
	size_t k = sizeof(_eoddata1__NewsList);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__NewsList);
		if (p)
			((_eoddata1__NewsList*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__NewsList, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__NewsList*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__NewsList location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__NewsList, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__NewsList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:NewsList", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__NewsList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__NewsList(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__NewsList * SOAP_FMAC4 soap_get__eoddata1__NewsList(struct soap *soap, _eoddata1__NewsList *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__NewsList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__QuoteListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__QuoteListResponse::QuoteListResult = NULL;
	/* transient soap skipped */
}

void _eoddata1__QuoteListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToeoddata1__RESPONSE(soap, &this->_eoddata1__QuoteListResponse::QuoteListResult);
#endif
}

int _eoddata1__QuoteListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__QuoteListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__QuoteListResponse(struct soap *soap, const char *tag, int id, const _eoddata1__QuoteListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__QuoteListResponse), type))
		return soap->error;
	if (a->QuoteListResult)
		soap_element_result(soap, "eoddata1:QuoteListResult");
	if (soap_out_PointerToeoddata1__RESPONSE(soap, "eoddata1:QuoteListResult", -1, &a->_eoddata1__QuoteListResponse::QuoteListResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__QuoteListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__QuoteListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__QuoteListResponse * SOAP_FMAC4 soap_in__eoddata1__QuoteListResponse(struct soap *soap, const char *tag, _eoddata1__QuoteListResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__QuoteListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__QuoteListResponse, sizeof(_eoddata1__QuoteListResponse), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_QuoteListResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_QuoteListResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToeoddata1__RESPONSE(soap, "eoddata1:QuoteListResult", &a->_eoddata1__QuoteListResponse::QuoteListResult, "eoddata1:RESPONSE"))
				{	soap_flag_QuoteListResult1--;
					continue;
				}
			soap_check_result(soap, "eoddata1:QuoteListResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__QuoteListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__QuoteListResponse, SOAP_TYPE_eoddata__eoddata1__QuoteListResponse, sizeof(_eoddata1__QuoteListResponse), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__QuoteListResponse * SOAP_FMAC2 soap_instantiate__eoddata1__QuoteListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__QuoteListResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__QuoteListResponse *p;
	size_t k = sizeof(_eoddata1__QuoteListResponse);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__QuoteListResponse);
		if (p)
			((_eoddata1__QuoteListResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__QuoteListResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__QuoteListResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__QuoteListResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__QuoteListResponse, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__QuoteListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:QuoteListResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__QuoteListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__QuoteListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__QuoteListResponse * SOAP_FMAC4 soap_get__eoddata1__QuoteListResponse(struct soap *soap, _eoddata1__QuoteListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__QuoteListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__QuoteList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__QuoteList::Token = NULL;
	this->_eoddata1__QuoteList::Exchange = NULL;
	/* transient soap skipped */
}

void _eoddata1__QuoteList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__QuoteList::Token);
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__QuoteList::Exchange);
#endif
}

int _eoddata1__QuoteList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__QuoteList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__QuoteList(struct soap *soap, const char *tag, int id, const _eoddata1__QuoteList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__QuoteList), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Token", -1, &a->_eoddata1__QuoteList::Token, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Exchange", -1, &a->_eoddata1__QuoteList::Exchange, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__QuoteList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__QuoteList(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__QuoteList * SOAP_FMAC4 soap_in__eoddata1__QuoteList(struct soap *soap, const char *tag, _eoddata1__QuoteList *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__QuoteList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__QuoteList, sizeof(_eoddata1__QuoteList), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	size_t soap_flag_Exchange1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Token", &a->_eoddata1__QuoteList::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap_flag_Exchange1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Exchange", &a->_eoddata1__QuoteList::Exchange, "xsd:string"))
				{	soap_flag_Exchange1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__QuoteList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__QuoteList, SOAP_TYPE_eoddata__eoddata1__QuoteList, sizeof(_eoddata1__QuoteList), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__QuoteList * SOAP_FMAC2 soap_instantiate__eoddata1__QuoteList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__QuoteList(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__QuoteList *p;
	size_t k = sizeof(_eoddata1__QuoteList);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__QuoteList);
		if (p)
			((_eoddata1__QuoteList*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__QuoteList, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__QuoteList*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__QuoteList location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__QuoteList, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__QuoteList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:QuoteList", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__QuoteList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__QuoteList(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__QuoteList * SOAP_FMAC4 soap_get__eoddata1__QuoteList(struct soap *soap, _eoddata1__QuoteList *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__QuoteList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__SymbolGetResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__SymbolGetResponse::SymbolGetResult = NULL;
	/* transient soap skipped */
}

void _eoddata1__SymbolGetResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToeoddata1__RESPONSE(soap, &this->_eoddata1__SymbolGetResponse::SymbolGetResult);
#endif
}

int _eoddata1__SymbolGetResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__SymbolGetResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__SymbolGetResponse(struct soap *soap, const char *tag, int id, const _eoddata1__SymbolGetResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__SymbolGetResponse), type))
		return soap->error;
	if (a->SymbolGetResult)
		soap_element_result(soap, "eoddata1:SymbolGetResult");
	if (soap_out_PointerToeoddata1__RESPONSE(soap, "eoddata1:SymbolGetResult", -1, &a->_eoddata1__SymbolGetResponse::SymbolGetResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__SymbolGetResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__SymbolGetResponse(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__SymbolGetResponse * SOAP_FMAC4 soap_in__eoddata1__SymbolGetResponse(struct soap *soap, const char *tag, _eoddata1__SymbolGetResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__SymbolGetResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__SymbolGetResponse, sizeof(_eoddata1__SymbolGetResponse), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SymbolGetResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SymbolGetResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToeoddata1__RESPONSE(soap, "eoddata1:SymbolGetResult", &a->_eoddata1__SymbolGetResponse::SymbolGetResult, "eoddata1:RESPONSE"))
				{	soap_flag_SymbolGetResult1--;
					continue;
				}
			soap_check_result(soap, "eoddata1:SymbolGetResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__SymbolGetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__SymbolGetResponse, SOAP_TYPE_eoddata__eoddata1__SymbolGetResponse, sizeof(_eoddata1__SymbolGetResponse), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__SymbolGetResponse * SOAP_FMAC2 soap_instantiate__eoddata1__SymbolGetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__SymbolGetResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__SymbolGetResponse *p;
	size_t k = sizeof(_eoddata1__SymbolGetResponse);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__SymbolGetResponse);
		if (p)
			((_eoddata1__SymbolGetResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__SymbolGetResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__SymbolGetResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__SymbolGetResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__SymbolGetResponse, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__SymbolGetResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:SymbolGetResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__SymbolGetResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__SymbolGetResponse(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__SymbolGetResponse * SOAP_FMAC4 soap_get__eoddata1__SymbolGetResponse(struct soap *soap, _eoddata1__SymbolGetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__SymbolGetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__SymbolGet::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__SymbolGet::Token = NULL;
	this->_eoddata1__SymbolGet::Exchange = NULL;
	this->_eoddata1__SymbolGet::Symbol = NULL;
	/* transient soap skipped */
}

void _eoddata1__SymbolGet::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__SymbolGet::Token);
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__SymbolGet::Exchange);
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__SymbolGet::Symbol);
#endif
}

int _eoddata1__SymbolGet::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__SymbolGet(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__SymbolGet(struct soap *soap, const char *tag, int id, const _eoddata1__SymbolGet *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__SymbolGet), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Token", -1, &a->_eoddata1__SymbolGet::Token, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Exchange", -1, &a->_eoddata1__SymbolGet::Exchange, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Symbol", -1, &a->_eoddata1__SymbolGet::Symbol, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__SymbolGet::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__SymbolGet(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__SymbolGet * SOAP_FMAC4 soap_in__eoddata1__SymbolGet(struct soap *soap, const char *tag, _eoddata1__SymbolGet *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__SymbolGet *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__SymbolGet, sizeof(_eoddata1__SymbolGet), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	size_t soap_flag_Exchange1 = 1;
	size_t soap_flag_Symbol1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Token", &a->_eoddata1__SymbolGet::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap_flag_Exchange1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Exchange", &a->_eoddata1__SymbolGet::Exchange, "xsd:string"))
				{	soap_flag_Exchange1--;
					continue;
				}
			if (soap_flag_Symbol1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Symbol", &a->_eoddata1__SymbolGet::Symbol, "xsd:string"))
				{	soap_flag_Symbol1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__SymbolGet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__SymbolGet, SOAP_TYPE_eoddata__eoddata1__SymbolGet, sizeof(_eoddata1__SymbolGet), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__SymbolGet * SOAP_FMAC2 soap_instantiate__eoddata1__SymbolGet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__SymbolGet(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__SymbolGet *p;
	size_t k = sizeof(_eoddata1__SymbolGet);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__SymbolGet);
		if (p)
			((_eoddata1__SymbolGet*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__SymbolGet, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__SymbolGet*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__SymbolGet location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__SymbolGet, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__SymbolGet::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:SymbolGet", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__SymbolGet::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__SymbolGet(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__SymbolGet * SOAP_FMAC4 soap_get__eoddata1__SymbolGet(struct soap *soap, _eoddata1__SymbolGet *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__SymbolGet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__QuoteList2Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__QuoteList2Response::QuoteList2Result = NULL;
	/* transient soap skipped */
}

void _eoddata1__QuoteList2Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToeoddata1__RESPONSE(soap, &this->_eoddata1__QuoteList2Response::QuoteList2Result);
#endif
}

int _eoddata1__QuoteList2Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__QuoteList2Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__QuoteList2Response(struct soap *soap, const char *tag, int id, const _eoddata1__QuoteList2Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__QuoteList2Response), type))
		return soap->error;
	if (a->QuoteList2Result)
		soap_element_result(soap, "eoddata1:QuoteList2Result");
	if (soap_out_PointerToeoddata1__RESPONSE(soap, "eoddata1:QuoteList2Result", -1, &a->_eoddata1__QuoteList2Response::QuoteList2Result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__QuoteList2Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__QuoteList2Response(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__QuoteList2Response * SOAP_FMAC4 soap_in__eoddata1__QuoteList2Response(struct soap *soap, const char *tag, _eoddata1__QuoteList2Response *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__QuoteList2Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__QuoteList2Response, sizeof(_eoddata1__QuoteList2Response), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_QuoteList2Result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_QuoteList2Result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToeoddata1__RESPONSE(soap, "eoddata1:QuoteList2Result", &a->_eoddata1__QuoteList2Response::QuoteList2Result, "eoddata1:RESPONSE"))
				{	soap_flag_QuoteList2Result1--;
					continue;
				}
			soap_check_result(soap, "eoddata1:QuoteList2Result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__QuoteList2Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__QuoteList2Response, SOAP_TYPE_eoddata__eoddata1__QuoteList2Response, sizeof(_eoddata1__QuoteList2Response), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__QuoteList2Response * SOAP_FMAC2 soap_instantiate__eoddata1__QuoteList2Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__QuoteList2Response(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__QuoteList2Response *p;
	size_t k = sizeof(_eoddata1__QuoteList2Response);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__QuoteList2Response);
		if (p)
			((_eoddata1__QuoteList2Response*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__QuoteList2Response, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__QuoteList2Response*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__QuoteList2Response location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__QuoteList2Response, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__QuoteList2Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:QuoteList2Response", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__QuoteList2Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__QuoteList2Response(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__QuoteList2Response * SOAP_FMAC4 soap_get__eoddata1__QuoteList2Response(struct soap *soap, _eoddata1__QuoteList2Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__QuoteList2Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__QuoteList2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__QuoteList2::Token = NULL;
	this->_eoddata1__QuoteList2::Exchange = NULL;
	this->_eoddata1__QuoteList2::Symbols = NULL;
	/* transient soap skipped */
}

void _eoddata1__QuoteList2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__QuoteList2::Token);
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__QuoteList2::Exchange);
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__QuoteList2::Symbols);
#endif
}

int _eoddata1__QuoteList2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__QuoteList2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__QuoteList2(struct soap *soap, const char *tag, int id, const _eoddata1__QuoteList2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__QuoteList2), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Token", -1, &a->_eoddata1__QuoteList2::Token, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Exchange", -1, &a->_eoddata1__QuoteList2::Exchange, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Symbols", -1, &a->_eoddata1__QuoteList2::Symbols, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__QuoteList2::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__QuoteList2(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__QuoteList2 * SOAP_FMAC4 soap_in__eoddata1__QuoteList2(struct soap *soap, const char *tag, _eoddata1__QuoteList2 *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__QuoteList2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__QuoteList2, sizeof(_eoddata1__QuoteList2), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	size_t soap_flag_Exchange1 = 1;
	size_t soap_flag_Symbols1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Token", &a->_eoddata1__QuoteList2::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap_flag_Exchange1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Exchange", &a->_eoddata1__QuoteList2::Exchange, "xsd:string"))
				{	soap_flag_Exchange1--;
					continue;
				}
			if (soap_flag_Symbols1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Symbols", &a->_eoddata1__QuoteList2::Symbols, "xsd:string"))
				{	soap_flag_Symbols1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__QuoteList2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__QuoteList2, SOAP_TYPE_eoddata__eoddata1__QuoteList2, sizeof(_eoddata1__QuoteList2), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__QuoteList2 * SOAP_FMAC2 soap_instantiate__eoddata1__QuoteList2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__QuoteList2(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__QuoteList2 *p;
	size_t k = sizeof(_eoddata1__QuoteList2);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__QuoteList2);
		if (p)
			((_eoddata1__QuoteList2*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__QuoteList2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__QuoteList2*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__QuoteList2 location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__QuoteList2, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__QuoteList2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:QuoteList2", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__QuoteList2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__QuoteList2(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__QuoteList2 * SOAP_FMAC4 soap_get__eoddata1__QuoteList2(struct soap *soap, _eoddata1__QuoteList2 *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__QuoteList2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__QuoteGetResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__QuoteGetResponse::QuoteGetResult = NULL;
	/* transient soap skipped */
}

void _eoddata1__QuoteGetResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToeoddata1__RESPONSE(soap, &this->_eoddata1__QuoteGetResponse::QuoteGetResult);
#endif
}

int _eoddata1__QuoteGetResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__QuoteGetResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__QuoteGetResponse(struct soap *soap, const char *tag, int id, const _eoddata1__QuoteGetResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__QuoteGetResponse), type))
		return soap->error;
	if (a->QuoteGetResult)
		soap_element_result(soap, "eoddata1:QuoteGetResult");
	if (soap_out_PointerToeoddata1__RESPONSE(soap, "eoddata1:QuoteGetResult", -1, &a->_eoddata1__QuoteGetResponse::QuoteGetResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__QuoteGetResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__QuoteGetResponse(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__QuoteGetResponse * SOAP_FMAC4 soap_in__eoddata1__QuoteGetResponse(struct soap *soap, const char *tag, _eoddata1__QuoteGetResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__QuoteGetResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__QuoteGetResponse, sizeof(_eoddata1__QuoteGetResponse), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_QuoteGetResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_QuoteGetResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToeoddata1__RESPONSE(soap, "eoddata1:QuoteGetResult", &a->_eoddata1__QuoteGetResponse::QuoteGetResult, "eoddata1:RESPONSE"))
				{	soap_flag_QuoteGetResult1--;
					continue;
				}
			soap_check_result(soap, "eoddata1:QuoteGetResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__QuoteGetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__QuoteGetResponse, SOAP_TYPE_eoddata__eoddata1__QuoteGetResponse, sizeof(_eoddata1__QuoteGetResponse), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__QuoteGetResponse * SOAP_FMAC2 soap_instantiate__eoddata1__QuoteGetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__QuoteGetResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__QuoteGetResponse *p;
	size_t k = sizeof(_eoddata1__QuoteGetResponse);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__QuoteGetResponse);
		if (p)
			((_eoddata1__QuoteGetResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__QuoteGetResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__QuoteGetResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__QuoteGetResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__QuoteGetResponse, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__QuoteGetResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:QuoteGetResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__QuoteGetResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__QuoteGetResponse(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__QuoteGetResponse * SOAP_FMAC4 soap_get__eoddata1__QuoteGetResponse(struct soap *soap, _eoddata1__QuoteGetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__QuoteGetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__QuoteGet::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__QuoteGet::Token = NULL;
	this->_eoddata1__QuoteGet::Exchange = NULL;
	this->_eoddata1__QuoteGet::Symbol = NULL;
	/* transient soap skipped */
}

void _eoddata1__QuoteGet::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__QuoteGet::Token);
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__QuoteGet::Exchange);
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__QuoteGet::Symbol);
#endif
}

int _eoddata1__QuoteGet::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__QuoteGet(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__QuoteGet(struct soap *soap, const char *tag, int id, const _eoddata1__QuoteGet *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__QuoteGet), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Token", -1, &a->_eoddata1__QuoteGet::Token, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Exchange", -1, &a->_eoddata1__QuoteGet::Exchange, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Symbol", -1, &a->_eoddata1__QuoteGet::Symbol, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__QuoteGet::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__QuoteGet(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__QuoteGet * SOAP_FMAC4 soap_in__eoddata1__QuoteGet(struct soap *soap, const char *tag, _eoddata1__QuoteGet *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__QuoteGet *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__QuoteGet, sizeof(_eoddata1__QuoteGet), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	size_t soap_flag_Exchange1 = 1;
	size_t soap_flag_Symbol1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Token", &a->_eoddata1__QuoteGet::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap_flag_Exchange1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Exchange", &a->_eoddata1__QuoteGet::Exchange, "xsd:string"))
				{	soap_flag_Exchange1--;
					continue;
				}
			if (soap_flag_Symbol1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Symbol", &a->_eoddata1__QuoteGet::Symbol, "xsd:string"))
				{	soap_flag_Symbol1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__QuoteGet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__QuoteGet, SOAP_TYPE_eoddata__eoddata1__QuoteGet, sizeof(_eoddata1__QuoteGet), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__QuoteGet * SOAP_FMAC2 soap_instantiate__eoddata1__QuoteGet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__QuoteGet(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__QuoteGet *p;
	size_t k = sizeof(_eoddata1__QuoteGet);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__QuoteGet);
		if (p)
			((_eoddata1__QuoteGet*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__QuoteGet, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__QuoteGet*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__QuoteGet location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__QuoteGet, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__QuoteGet::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:QuoteGet", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__QuoteGet::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__QuoteGet(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__QuoteGet * SOAP_FMAC4 soap_get__eoddata1__QuoteGet(struct soap *soap, _eoddata1__QuoteGet *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__QuoteGet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__SymbolList2Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__SymbolList2Response::SymbolList2Result = NULL;
	/* transient soap skipped */
}

void _eoddata1__SymbolList2Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToeoddata1__RESPONSE(soap, &this->_eoddata1__SymbolList2Response::SymbolList2Result);
#endif
}

int _eoddata1__SymbolList2Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__SymbolList2Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__SymbolList2Response(struct soap *soap, const char *tag, int id, const _eoddata1__SymbolList2Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__SymbolList2Response), type))
		return soap->error;
	if (a->SymbolList2Result)
		soap_element_result(soap, "eoddata1:SymbolList2Result");
	if (soap_out_PointerToeoddata1__RESPONSE(soap, "eoddata1:SymbolList2Result", -1, &a->_eoddata1__SymbolList2Response::SymbolList2Result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__SymbolList2Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__SymbolList2Response(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__SymbolList2Response * SOAP_FMAC4 soap_in__eoddata1__SymbolList2Response(struct soap *soap, const char *tag, _eoddata1__SymbolList2Response *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__SymbolList2Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__SymbolList2Response, sizeof(_eoddata1__SymbolList2Response), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SymbolList2Result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SymbolList2Result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToeoddata1__RESPONSE(soap, "eoddata1:SymbolList2Result", &a->_eoddata1__SymbolList2Response::SymbolList2Result, "eoddata1:RESPONSE"))
				{	soap_flag_SymbolList2Result1--;
					continue;
				}
			soap_check_result(soap, "eoddata1:SymbolList2Result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__SymbolList2Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__SymbolList2Response, SOAP_TYPE_eoddata__eoddata1__SymbolList2Response, sizeof(_eoddata1__SymbolList2Response), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__SymbolList2Response * SOAP_FMAC2 soap_instantiate__eoddata1__SymbolList2Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__SymbolList2Response(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__SymbolList2Response *p;
	size_t k = sizeof(_eoddata1__SymbolList2Response);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__SymbolList2Response);
		if (p)
			((_eoddata1__SymbolList2Response*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__SymbolList2Response, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__SymbolList2Response*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__SymbolList2Response location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__SymbolList2Response, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__SymbolList2Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:SymbolList2Response", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__SymbolList2Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__SymbolList2Response(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__SymbolList2Response * SOAP_FMAC4 soap_get__eoddata1__SymbolList2Response(struct soap *soap, _eoddata1__SymbolList2Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__SymbolList2Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__SymbolList2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__SymbolList2::Token = NULL;
	this->_eoddata1__SymbolList2::Exchange = NULL;
	/* transient soap skipped */
}

void _eoddata1__SymbolList2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__SymbolList2::Token);
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__SymbolList2::Exchange);
#endif
}

int _eoddata1__SymbolList2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__SymbolList2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__SymbolList2(struct soap *soap, const char *tag, int id, const _eoddata1__SymbolList2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__SymbolList2), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Token", -1, &a->_eoddata1__SymbolList2::Token, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Exchange", -1, &a->_eoddata1__SymbolList2::Exchange, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__SymbolList2::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__SymbolList2(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__SymbolList2 * SOAP_FMAC4 soap_in__eoddata1__SymbolList2(struct soap *soap, const char *tag, _eoddata1__SymbolList2 *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__SymbolList2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__SymbolList2, sizeof(_eoddata1__SymbolList2), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	size_t soap_flag_Exchange1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Token", &a->_eoddata1__SymbolList2::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap_flag_Exchange1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Exchange", &a->_eoddata1__SymbolList2::Exchange, "xsd:string"))
				{	soap_flag_Exchange1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__SymbolList2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__SymbolList2, SOAP_TYPE_eoddata__eoddata1__SymbolList2, sizeof(_eoddata1__SymbolList2), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__SymbolList2 * SOAP_FMAC2 soap_instantiate__eoddata1__SymbolList2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__SymbolList2(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__SymbolList2 *p;
	size_t k = sizeof(_eoddata1__SymbolList2);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__SymbolList2);
		if (p)
			((_eoddata1__SymbolList2*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__SymbolList2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__SymbolList2*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__SymbolList2 location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__SymbolList2, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__SymbolList2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:SymbolList2", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__SymbolList2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__SymbolList2(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__SymbolList2 * SOAP_FMAC4 soap_get__eoddata1__SymbolList2(struct soap *soap, _eoddata1__SymbolList2 *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__SymbolList2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__SymbolListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__SymbolListResponse::SymbolListResult = NULL;
	/* transient soap skipped */
}

void _eoddata1__SymbolListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToeoddata1__RESPONSE(soap, &this->_eoddata1__SymbolListResponse::SymbolListResult);
#endif
}

int _eoddata1__SymbolListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__SymbolListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__SymbolListResponse(struct soap *soap, const char *tag, int id, const _eoddata1__SymbolListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__SymbolListResponse), type))
		return soap->error;
	if (a->SymbolListResult)
		soap_element_result(soap, "eoddata1:SymbolListResult");
	if (soap_out_PointerToeoddata1__RESPONSE(soap, "eoddata1:SymbolListResult", -1, &a->_eoddata1__SymbolListResponse::SymbolListResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__SymbolListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__SymbolListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__SymbolListResponse * SOAP_FMAC4 soap_in__eoddata1__SymbolListResponse(struct soap *soap, const char *tag, _eoddata1__SymbolListResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__SymbolListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__SymbolListResponse, sizeof(_eoddata1__SymbolListResponse), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SymbolListResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SymbolListResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToeoddata1__RESPONSE(soap, "eoddata1:SymbolListResult", &a->_eoddata1__SymbolListResponse::SymbolListResult, "eoddata1:RESPONSE"))
				{	soap_flag_SymbolListResult1--;
					continue;
				}
			soap_check_result(soap, "eoddata1:SymbolListResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__SymbolListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__SymbolListResponse, SOAP_TYPE_eoddata__eoddata1__SymbolListResponse, sizeof(_eoddata1__SymbolListResponse), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__SymbolListResponse * SOAP_FMAC2 soap_instantiate__eoddata1__SymbolListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__SymbolListResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__SymbolListResponse *p;
	size_t k = sizeof(_eoddata1__SymbolListResponse);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__SymbolListResponse);
		if (p)
			((_eoddata1__SymbolListResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__SymbolListResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__SymbolListResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__SymbolListResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__SymbolListResponse, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__SymbolListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:SymbolListResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__SymbolListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__SymbolListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__SymbolListResponse * SOAP_FMAC4 soap_get__eoddata1__SymbolListResponse(struct soap *soap, _eoddata1__SymbolListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__SymbolListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__SymbolList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__SymbolList::Token = NULL;
	this->_eoddata1__SymbolList::Exchange = NULL;
	/* transient soap skipped */
}

void _eoddata1__SymbolList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__SymbolList::Token);
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__SymbolList::Exchange);
#endif
}

int _eoddata1__SymbolList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__SymbolList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__SymbolList(struct soap *soap, const char *tag, int id, const _eoddata1__SymbolList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__SymbolList), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Token", -1, &a->_eoddata1__SymbolList::Token, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Exchange", -1, &a->_eoddata1__SymbolList::Exchange, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__SymbolList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__SymbolList(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__SymbolList * SOAP_FMAC4 soap_in__eoddata1__SymbolList(struct soap *soap, const char *tag, _eoddata1__SymbolList *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__SymbolList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__SymbolList, sizeof(_eoddata1__SymbolList), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	size_t soap_flag_Exchange1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Token", &a->_eoddata1__SymbolList::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap_flag_Exchange1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Exchange", &a->_eoddata1__SymbolList::Exchange, "xsd:string"))
				{	soap_flag_Exchange1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__SymbolList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__SymbolList, SOAP_TYPE_eoddata__eoddata1__SymbolList, sizeof(_eoddata1__SymbolList), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__SymbolList * SOAP_FMAC2 soap_instantiate__eoddata1__SymbolList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__SymbolList(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__SymbolList *p;
	size_t k = sizeof(_eoddata1__SymbolList);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__SymbolList);
		if (p)
			((_eoddata1__SymbolList*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__SymbolList, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__SymbolList*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__SymbolList location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__SymbolList, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__SymbolList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:SymbolList", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__SymbolList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__SymbolList(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__SymbolList * SOAP_FMAC4 soap_get__eoddata1__SymbolList(struct soap *soap, _eoddata1__SymbolList *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__SymbolList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__ExchangeGetResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__ExchangeGetResponse::ExchangeGetResult = NULL;
	/* transient soap skipped */
}

void _eoddata1__ExchangeGetResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToeoddata1__RESPONSE(soap, &this->_eoddata1__ExchangeGetResponse::ExchangeGetResult);
#endif
}

int _eoddata1__ExchangeGetResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__ExchangeGetResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__ExchangeGetResponse(struct soap *soap, const char *tag, int id, const _eoddata1__ExchangeGetResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__ExchangeGetResponse), type))
		return soap->error;
	if (a->ExchangeGetResult)
		soap_element_result(soap, "eoddata1:ExchangeGetResult");
	if (soap_out_PointerToeoddata1__RESPONSE(soap, "eoddata1:ExchangeGetResult", -1, &a->_eoddata1__ExchangeGetResponse::ExchangeGetResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__ExchangeGetResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__ExchangeGetResponse(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__ExchangeGetResponse * SOAP_FMAC4 soap_in__eoddata1__ExchangeGetResponse(struct soap *soap, const char *tag, _eoddata1__ExchangeGetResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__ExchangeGetResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__ExchangeGetResponse, sizeof(_eoddata1__ExchangeGetResponse), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ExchangeGetResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ExchangeGetResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToeoddata1__RESPONSE(soap, "eoddata1:ExchangeGetResult", &a->_eoddata1__ExchangeGetResponse::ExchangeGetResult, "eoddata1:RESPONSE"))
				{	soap_flag_ExchangeGetResult1--;
					continue;
				}
			soap_check_result(soap, "eoddata1:ExchangeGetResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__ExchangeGetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__ExchangeGetResponse, SOAP_TYPE_eoddata__eoddata1__ExchangeGetResponse, sizeof(_eoddata1__ExchangeGetResponse), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__ExchangeGetResponse * SOAP_FMAC2 soap_instantiate__eoddata1__ExchangeGetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__ExchangeGetResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__ExchangeGetResponse *p;
	size_t k = sizeof(_eoddata1__ExchangeGetResponse);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__ExchangeGetResponse);
		if (p)
			((_eoddata1__ExchangeGetResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__ExchangeGetResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__ExchangeGetResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__ExchangeGetResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__ExchangeGetResponse, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__ExchangeGetResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:ExchangeGetResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__ExchangeGetResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__ExchangeGetResponse(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__ExchangeGetResponse * SOAP_FMAC4 soap_get__eoddata1__ExchangeGetResponse(struct soap *soap, _eoddata1__ExchangeGetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__ExchangeGetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__ExchangeGet::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__ExchangeGet::Token = NULL;
	this->_eoddata1__ExchangeGet::Exchange = NULL;
	/* transient soap skipped */
}

void _eoddata1__ExchangeGet::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__ExchangeGet::Token);
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__ExchangeGet::Exchange);
#endif
}

int _eoddata1__ExchangeGet::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__ExchangeGet(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__ExchangeGet(struct soap *soap, const char *tag, int id, const _eoddata1__ExchangeGet *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__ExchangeGet), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Token", -1, &a->_eoddata1__ExchangeGet::Token, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Exchange", -1, &a->_eoddata1__ExchangeGet::Exchange, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__ExchangeGet::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__ExchangeGet(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__ExchangeGet * SOAP_FMAC4 soap_in__eoddata1__ExchangeGet(struct soap *soap, const char *tag, _eoddata1__ExchangeGet *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__ExchangeGet *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__ExchangeGet, sizeof(_eoddata1__ExchangeGet), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	size_t soap_flag_Exchange1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Token", &a->_eoddata1__ExchangeGet::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap_flag_Exchange1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Exchange", &a->_eoddata1__ExchangeGet::Exchange, "xsd:string"))
				{	soap_flag_Exchange1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__ExchangeGet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__ExchangeGet, SOAP_TYPE_eoddata__eoddata1__ExchangeGet, sizeof(_eoddata1__ExchangeGet), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__ExchangeGet * SOAP_FMAC2 soap_instantiate__eoddata1__ExchangeGet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__ExchangeGet(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__ExchangeGet *p;
	size_t k = sizeof(_eoddata1__ExchangeGet);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__ExchangeGet);
		if (p)
			((_eoddata1__ExchangeGet*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__ExchangeGet, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__ExchangeGet*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__ExchangeGet location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__ExchangeGet, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__ExchangeGet::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:ExchangeGet", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__ExchangeGet::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__ExchangeGet(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__ExchangeGet * SOAP_FMAC4 soap_get__eoddata1__ExchangeGet(struct soap *soap, _eoddata1__ExchangeGet *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__ExchangeGet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__ExchangeListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__ExchangeListResponse::ExchangeListResult = NULL;
	/* transient soap skipped */
}

void _eoddata1__ExchangeListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToeoddata1__RESPONSE(soap, &this->_eoddata1__ExchangeListResponse::ExchangeListResult);
#endif
}

int _eoddata1__ExchangeListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__ExchangeListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__ExchangeListResponse(struct soap *soap, const char *tag, int id, const _eoddata1__ExchangeListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__ExchangeListResponse), type))
		return soap->error;
	if (a->ExchangeListResult)
		soap_element_result(soap, "eoddata1:ExchangeListResult");
	if (soap_out_PointerToeoddata1__RESPONSE(soap, "eoddata1:ExchangeListResult", -1, &a->_eoddata1__ExchangeListResponse::ExchangeListResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__ExchangeListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__ExchangeListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__ExchangeListResponse * SOAP_FMAC4 soap_in__eoddata1__ExchangeListResponse(struct soap *soap, const char *tag, _eoddata1__ExchangeListResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__ExchangeListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__ExchangeListResponse, sizeof(_eoddata1__ExchangeListResponse), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ExchangeListResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ExchangeListResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToeoddata1__RESPONSE(soap, "eoddata1:ExchangeListResult", &a->_eoddata1__ExchangeListResponse::ExchangeListResult, "eoddata1:RESPONSE"))
				{	soap_flag_ExchangeListResult1--;
					continue;
				}
			soap_check_result(soap, "eoddata1:ExchangeListResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__ExchangeListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__ExchangeListResponse, SOAP_TYPE_eoddata__eoddata1__ExchangeListResponse, sizeof(_eoddata1__ExchangeListResponse), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__ExchangeListResponse * SOAP_FMAC2 soap_instantiate__eoddata1__ExchangeListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__ExchangeListResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__ExchangeListResponse *p;
	size_t k = sizeof(_eoddata1__ExchangeListResponse);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__ExchangeListResponse);
		if (p)
			((_eoddata1__ExchangeListResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__ExchangeListResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__ExchangeListResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__ExchangeListResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__ExchangeListResponse, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__ExchangeListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:ExchangeListResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__ExchangeListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__ExchangeListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__ExchangeListResponse * SOAP_FMAC4 soap_get__eoddata1__ExchangeListResponse(struct soap *soap, _eoddata1__ExchangeListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__ExchangeListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__ExchangeList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__ExchangeList::Token = NULL;
	/* transient soap skipped */
}

void _eoddata1__ExchangeList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__ExchangeList::Token);
#endif
}

int _eoddata1__ExchangeList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__ExchangeList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__ExchangeList(struct soap *soap, const char *tag, int id, const _eoddata1__ExchangeList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__ExchangeList), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Token", -1, &a->_eoddata1__ExchangeList::Token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__ExchangeList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__ExchangeList(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__ExchangeList * SOAP_FMAC4 soap_in__eoddata1__ExchangeList(struct soap *soap, const char *tag, _eoddata1__ExchangeList *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__ExchangeList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__ExchangeList, sizeof(_eoddata1__ExchangeList), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Token", &a->_eoddata1__ExchangeList::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__ExchangeList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__ExchangeList, SOAP_TYPE_eoddata__eoddata1__ExchangeList, sizeof(_eoddata1__ExchangeList), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__ExchangeList * SOAP_FMAC2 soap_instantiate__eoddata1__ExchangeList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__ExchangeList(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__ExchangeList *p;
	size_t k = sizeof(_eoddata1__ExchangeList);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__ExchangeList);
		if (p)
			((_eoddata1__ExchangeList*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__ExchangeList, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__ExchangeList*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__ExchangeList location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__ExchangeList, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__ExchangeList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:ExchangeList", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__ExchangeList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__ExchangeList(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__ExchangeList * SOAP_FMAC4 soap_get__eoddata1__ExchangeList(struct soap *soap, _eoddata1__ExchangeList *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__ExchangeList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__MembershipResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__MembershipResponse::MembershipResult = NULL;
	/* transient soap skipped */
}

void _eoddata1__MembershipResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToeoddata1__RESPONSE(soap, &this->_eoddata1__MembershipResponse::MembershipResult);
#endif
}

int _eoddata1__MembershipResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__MembershipResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__MembershipResponse(struct soap *soap, const char *tag, int id, const _eoddata1__MembershipResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__MembershipResponse), type))
		return soap->error;
	if (a->MembershipResult)
		soap_element_result(soap, "eoddata1:MembershipResult");
	if (soap_out_PointerToeoddata1__RESPONSE(soap, "eoddata1:MembershipResult", -1, &a->_eoddata1__MembershipResponse::MembershipResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__MembershipResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__MembershipResponse(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__MembershipResponse * SOAP_FMAC4 soap_in__eoddata1__MembershipResponse(struct soap *soap, const char *tag, _eoddata1__MembershipResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__MembershipResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__MembershipResponse, sizeof(_eoddata1__MembershipResponse), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_MembershipResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MembershipResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToeoddata1__RESPONSE(soap, "eoddata1:MembershipResult", &a->_eoddata1__MembershipResponse::MembershipResult, "eoddata1:RESPONSE"))
				{	soap_flag_MembershipResult1--;
					continue;
				}
			soap_check_result(soap, "eoddata1:MembershipResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__MembershipResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__MembershipResponse, SOAP_TYPE_eoddata__eoddata1__MembershipResponse, sizeof(_eoddata1__MembershipResponse), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__MembershipResponse * SOAP_FMAC2 soap_instantiate__eoddata1__MembershipResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__MembershipResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__MembershipResponse *p;
	size_t k = sizeof(_eoddata1__MembershipResponse);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__MembershipResponse);
		if (p)
			((_eoddata1__MembershipResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__MembershipResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__MembershipResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__MembershipResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__MembershipResponse, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__MembershipResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:MembershipResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__MembershipResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__MembershipResponse(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__MembershipResponse * SOAP_FMAC4 soap_get__eoddata1__MembershipResponse(struct soap *soap, _eoddata1__MembershipResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__MembershipResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__Membership::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__Membership::Token = NULL;
	/* transient soap skipped */
}

void _eoddata1__Membership::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__Membership::Token);
#endif
}

int _eoddata1__Membership::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__Membership(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__Membership(struct soap *soap, const char *tag, int id, const _eoddata1__Membership *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__Membership), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Token", -1, &a->_eoddata1__Membership::Token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__Membership::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__Membership(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__Membership * SOAP_FMAC4 soap_in__eoddata1__Membership(struct soap *soap, const char *tag, _eoddata1__Membership *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__Membership *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__Membership, sizeof(_eoddata1__Membership), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Token", &a->_eoddata1__Membership::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__Membership *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__Membership, SOAP_TYPE_eoddata__eoddata1__Membership, sizeof(_eoddata1__Membership), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__Membership * SOAP_FMAC2 soap_instantiate__eoddata1__Membership(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__Membership(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__Membership *p;
	size_t k = sizeof(_eoddata1__Membership);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__Membership);
		if (p)
			((_eoddata1__Membership*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__Membership, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__Membership*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__Membership location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__Membership, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__Membership::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:Membership", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__Membership::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__Membership(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__Membership * SOAP_FMAC4 soap_get__eoddata1__Membership(struct soap *soap, _eoddata1__Membership *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__Membership(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__Login2Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__Login2Response::Login2Result = NULL;
	/* transient soap skipped */
}

void _eoddata1__Login2Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToeoddata1__LOGINRESPONSE(soap, &this->_eoddata1__Login2Response::Login2Result);
#endif
}

int _eoddata1__Login2Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__Login2Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__Login2Response(struct soap *soap, const char *tag, int id, const _eoddata1__Login2Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__Login2Response), type))
		return soap->error;
	if (a->Login2Result)
		soap_element_result(soap, "eoddata1:Login2Result");
	if (soap_out_PointerToeoddata1__LOGINRESPONSE(soap, "eoddata1:Login2Result", -1, &a->_eoddata1__Login2Response::Login2Result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__Login2Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__Login2Response(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__Login2Response * SOAP_FMAC4 soap_in__eoddata1__Login2Response(struct soap *soap, const char *tag, _eoddata1__Login2Response *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__Login2Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__Login2Response, sizeof(_eoddata1__Login2Response), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Login2Result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Login2Result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToeoddata1__LOGINRESPONSE(soap, "eoddata1:Login2Result", &a->_eoddata1__Login2Response::Login2Result, "eoddata1:LOGINRESPONSE"))
				{	soap_flag_Login2Result1--;
					continue;
				}
			soap_check_result(soap, "eoddata1:Login2Result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__Login2Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__Login2Response, SOAP_TYPE_eoddata__eoddata1__Login2Response, sizeof(_eoddata1__Login2Response), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__Login2Response * SOAP_FMAC2 soap_instantiate__eoddata1__Login2Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__Login2Response(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__Login2Response *p;
	size_t k = sizeof(_eoddata1__Login2Response);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__Login2Response);
		if (p)
			((_eoddata1__Login2Response*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__Login2Response, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__Login2Response*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__Login2Response location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__Login2Response, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__Login2Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:Login2Response", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__Login2Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__Login2Response(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__Login2Response * SOAP_FMAC4 soap_get__eoddata1__Login2Response(struct soap *soap, _eoddata1__Login2Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__Login2Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__Login2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__Login2::Username = NULL;
	this->_eoddata1__Login2::Password = NULL;
	this->_eoddata1__Login2::Version = NULL;
	/* transient soap skipped */
}

void _eoddata1__Login2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__Login2::Username);
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__Login2::Password);
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__Login2::Version);
#endif
}

int _eoddata1__Login2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__Login2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__Login2(struct soap *soap, const char *tag, int id, const _eoddata1__Login2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__Login2), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Username", -1, &a->_eoddata1__Login2::Username, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Password", -1, &a->_eoddata1__Login2::Password, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Version", -1, &a->_eoddata1__Login2::Version, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__Login2::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__Login2(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__Login2 * SOAP_FMAC4 soap_in__eoddata1__Login2(struct soap *soap, const char *tag, _eoddata1__Login2 *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__Login2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__Login2, sizeof(_eoddata1__Login2), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Username1 = 1;
	size_t soap_flag_Password1 = 1;
	size_t soap_flag_Version1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Username1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Username", &a->_eoddata1__Login2::Username, "xsd:string"))
				{	soap_flag_Username1--;
					continue;
				}
			if (soap_flag_Password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Password", &a->_eoddata1__Login2::Password, "xsd:string"))
				{	soap_flag_Password1--;
					continue;
				}
			if (soap_flag_Version1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Version", &a->_eoddata1__Login2::Version, "xsd:string"))
				{	soap_flag_Version1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__Login2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__Login2, SOAP_TYPE_eoddata__eoddata1__Login2, sizeof(_eoddata1__Login2), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__Login2 * SOAP_FMAC2 soap_instantiate__eoddata1__Login2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__Login2(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__Login2 *p;
	size_t k = sizeof(_eoddata1__Login2);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__Login2);
		if (p)
			((_eoddata1__Login2*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__Login2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__Login2*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__Login2 location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__Login2, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__Login2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:Login2", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__Login2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__Login2(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__Login2 * SOAP_FMAC4 soap_get__eoddata1__Login2(struct soap *soap, _eoddata1__Login2 *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__Login2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__LoginResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__LoginResponse::LoginResult = NULL;
	/* transient soap skipped */
}

void _eoddata1__LoginResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToeoddata1__LOGINRESPONSE(soap, &this->_eoddata1__LoginResponse::LoginResult);
#endif
}

int _eoddata1__LoginResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__LoginResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__LoginResponse(struct soap *soap, const char *tag, int id, const _eoddata1__LoginResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__LoginResponse), type))
		return soap->error;
	if (a->LoginResult)
		soap_element_result(soap, "eoddata1:LoginResult");
	if (soap_out_PointerToeoddata1__LOGINRESPONSE(soap, "eoddata1:LoginResult", -1, &a->_eoddata1__LoginResponse::LoginResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__LoginResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__LoginResponse(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__LoginResponse * SOAP_FMAC4 soap_in__eoddata1__LoginResponse(struct soap *soap, const char *tag, _eoddata1__LoginResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__LoginResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__LoginResponse, sizeof(_eoddata1__LoginResponse), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_LoginResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LoginResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToeoddata1__LOGINRESPONSE(soap, "eoddata1:LoginResult", &a->_eoddata1__LoginResponse::LoginResult, "eoddata1:LOGINRESPONSE"))
				{	soap_flag_LoginResult1--;
					continue;
				}
			soap_check_result(soap, "eoddata1:LoginResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__LoginResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__LoginResponse, SOAP_TYPE_eoddata__eoddata1__LoginResponse, sizeof(_eoddata1__LoginResponse), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__LoginResponse * SOAP_FMAC2 soap_instantiate__eoddata1__LoginResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__LoginResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__LoginResponse *p;
	size_t k = sizeof(_eoddata1__LoginResponse);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__LoginResponse);
		if (p)
			((_eoddata1__LoginResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__LoginResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__LoginResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__LoginResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__LoginResponse, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__LoginResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:LoginResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__LoginResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__LoginResponse(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__LoginResponse * SOAP_FMAC4 soap_get__eoddata1__LoginResponse(struct soap *soap, _eoddata1__LoginResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__LoginResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _eoddata1__Login::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_eoddata1__Login::Username = NULL;
	this->_eoddata1__Login::Password = NULL;
	/* transient soap skipped */
}

void _eoddata1__Login::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__Login::Username);
	soap_serialize_PointerTostd__string(soap, &this->_eoddata1__Login::Password);
#endif
}

int _eoddata1__Login::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__eoddata1__Login(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__eoddata1__Login(struct soap *soap, const char *tag, int id, const _eoddata1__Login *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata__eoddata1__Login), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Username", -1, &a->_eoddata1__Login::Username, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:Password", -1, &a->_eoddata1__Login::Password, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_eoddata1__Login::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__eoddata1__Login(soap, tag, this, type);
}

SOAP_FMAC3 _eoddata1__Login * SOAP_FMAC4 soap_in__eoddata1__Login(struct soap *soap, const char *tag, _eoddata1__Login *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_eoddata1__Login *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata__eoddata1__Login, sizeof(_eoddata1__Login), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Username1 = 1;
	size_t soap_flag_Password1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Username1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Username", &a->_eoddata1__Login::Username, "xsd:string"))
				{	soap_flag_Username1--;
					continue;
				}
			if (soap_flag_Password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:Password", &a->_eoddata1__Login::Password, "xsd:string"))
				{	soap_flag_Password1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_eoddata1__Login *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata__eoddata1__Login, SOAP_TYPE_eoddata__eoddata1__Login, sizeof(_eoddata1__Login), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _eoddata1__Login * SOAP_FMAC2 soap_instantiate__eoddata1__Login(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__eoddata1__Login(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_eoddata1__Login *p;
	size_t k = sizeof(_eoddata1__Login);
	if (n < 0)
	{	p = SOAP_NEW(_eoddata1__Login);
		if (p)
			((_eoddata1__Login*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_eoddata1__Login, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_eoddata1__Login*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _eoddata1__Login location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata__eoddata1__Login, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int _eoddata1__Login::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:Login", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_eoddata1__Login::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__eoddata1__Login(soap, this, tag, type);
}

SOAP_FMAC3 _eoddata1__Login * SOAP_FMAC4 soap_get__eoddata1__Login(struct soap *soap, _eoddata1__Login *p, const char *tag, const char *type)
{
	if ((p = soap_in__eoddata1__Login(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void eoddata1__DATAFORMAT_USCORECOLUMN::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->eoddata1__DATAFORMAT_USCORECOLUMN::SortOrder);
	this->eoddata1__DATAFORMAT_USCORECOLUMN::Code = NULL;
	this->eoddata1__DATAFORMAT_USCORECOLUMN::DataFormat = NULL;
	this->eoddata1__DATAFORMAT_USCORECOLUMN::ColumnCode = NULL;
	this->eoddata1__DATAFORMAT_USCORECOLUMN::ColumnName = NULL;
	soap_default_int(soap, &this->eoddata1__DATAFORMAT_USCORECOLUMN::ColumnTypeId);
	this->eoddata1__DATAFORMAT_USCORECOLUMN::ColumnType = NULL;
	this->eoddata1__DATAFORMAT_USCORECOLUMN::Header = NULL;
	/* transient soap skipped */
}

void eoddata1__DATAFORMAT_USCORECOLUMN::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int eoddata1__DATAFORMAT_USCORECOLUMN::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_eoddata1__DATAFORMAT_USCORECOLUMN(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_eoddata1__DATAFORMAT_USCORECOLUMN(struct soap *soap, const char *tag, int id, const eoddata1__DATAFORMAT_USCORECOLUMN *a, const char *type)
{
	soap_set_attr(soap, "SortOrder", soap_int2s(soap, ((eoddata1__DATAFORMAT_USCORECOLUMN*)a)->SortOrder), 1);
	if (((eoddata1__DATAFORMAT_USCORECOLUMN*)a)->Code)
		soap_set_attr(soap, "Code", ((eoddata1__DATAFORMAT_USCORECOLUMN*)a)->Code->c_str(), 1);
	if (((eoddata1__DATAFORMAT_USCORECOLUMN*)a)->DataFormat)
		soap_set_attr(soap, "DataFormat", ((eoddata1__DATAFORMAT_USCORECOLUMN*)a)->DataFormat->c_str(), 1);
	if (((eoddata1__DATAFORMAT_USCORECOLUMN*)a)->ColumnCode)
		soap_set_attr(soap, "ColumnCode", ((eoddata1__DATAFORMAT_USCORECOLUMN*)a)->ColumnCode->c_str(), 1);
	if (((eoddata1__DATAFORMAT_USCORECOLUMN*)a)->ColumnName)
		soap_set_attr(soap, "ColumnName", ((eoddata1__DATAFORMAT_USCORECOLUMN*)a)->ColumnName->c_str(), 1);
	soap_set_attr(soap, "ColumnTypeId", soap_int2s(soap, ((eoddata1__DATAFORMAT_USCORECOLUMN*)a)->ColumnTypeId), 1);
	if (((eoddata1__DATAFORMAT_USCORECOLUMN*)a)->ColumnType)
		soap_set_attr(soap, "ColumnType", ((eoddata1__DATAFORMAT_USCORECOLUMN*)a)->ColumnType->c_str(), 1);
	if (((eoddata1__DATAFORMAT_USCORECOLUMN*)a)->Header)
		soap_set_attr(soap, "Header", ((eoddata1__DATAFORMAT_USCORECOLUMN*)a)->Header->c_str(), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata_eoddata1__DATAFORMAT_USCORECOLUMN), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *eoddata1__DATAFORMAT_USCORECOLUMN::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_eoddata1__DATAFORMAT_USCORECOLUMN(soap, tag, this, type);
}

SOAP_FMAC3 eoddata1__DATAFORMAT_USCORECOLUMN * SOAP_FMAC4 soap_in_eoddata1__DATAFORMAT_USCORECOLUMN(struct soap *soap, const char *tag, eoddata1__DATAFORMAT_USCORECOLUMN *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (eoddata1__DATAFORMAT_USCORECOLUMN *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata_eoddata1__DATAFORMAT_USCORECOLUMN, sizeof(eoddata1__DATAFORMAT_USCORECOLUMN), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2int(soap, soap_attr_value(soap, "SortOrder", 1), &((eoddata1__DATAFORMAT_USCORECOLUMN*)a)->SortOrder))
		return NULL;
	{	const char *t = soap_attr_value(soap, "Code", 0);
		if (t)
		{
			if (!(((eoddata1__DATAFORMAT_USCORECOLUMN*)a)->Code = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__DATAFORMAT_USCORECOLUMN*)a)->Code, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "DataFormat", 0);
		if (t)
		{
			if (!(((eoddata1__DATAFORMAT_USCORECOLUMN*)a)->DataFormat = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__DATAFORMAT_USCORECOLUMN*)a)->DataFormat, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "ColumnCode", 0);
		if (t)
		{
			if (!(((eoddata1__DATAFORMAT_USCORECOLUMN*)a)->ColumnCode = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__DATAFORMAT_USCORECOLUMN*)a)->ColumnCode, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "ColumnName", 0);
		if (t)
		{
			if (!(((eoddata1__DATAFORMAT_USCORECOLUMN*)a)->ColumnName = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__DATAFORMAT_USCORECOLUMN*)a)->ColumnName, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2int(soap, soap_attr_value(soap, "ColumnTypeId", 1), &((eoddata1__DATAFORMAT_USCORECOLUMN*)a)->ColumnTypeId))
		return NULL;
	{	const char *t = soap_attr_value(soap, "ColumnType", 0);
		if (t)
		{
			if (!(((eoddata1__DATAFORMAT_USCORECOLUMN*)a)->ColumnType = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__DATAFORMAT_USCORECOLUMN*)a)->ColumnType, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Header", 0);
		if (t)
		{
			if (!(((eoddata1__DATAFORMAT_USCORECOLUMN*)a)->Header = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__DATAFORMAT_USCORECOLUMN*)a)->Header, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (eoddata1__DATAFORMAT_USCORECOLUMN *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata_eoddata1__DATAFORMAT_USCORECOLUMN, SOAP_TYPE_eoddata_eoddata1__DATAFORMAT_USCORECOLUMN, sizeof(eoddata1__DATAFORMAT_USCORECOLUMN), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 eoddata1__DATAFORMAT_USCORECOLUMN * SOAP_FMAC2 soap_instantiate_eoddata1__DATAFORMAT_USCORECOLUMN(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_eoddata1__DATAFORMAT_USCORECOLUMN(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	eoddata1__DATAFORMAT_USCORECOLUMN *p;
	size_t k = sizeof(eoddata1__DATAFORMAT_USCORECOLUMN);
	if (n < 0)
	{	p = SOAP_NEW(eoddata1__DATAFORMAT_USCORECOLUMN);
		if (p)
			((eoddata1__DATAFORMAT_USCORECOLUMN*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(eoddata1__DATAFORMAT_USCORECOLUMN, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((eoddata1__DATAFORMAT_USCORECOLUMN*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated eoddata1__DATAFORMAT_USCORECOLUMN location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata_eoddata1__DATAFORMAT_USCORECOLUMN, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int eoddata1__DATAFORMAT_USCORECOLUMN::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:DATAFORMAT_COLUMN", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *eoddata1__DATAFORMAT_USCORECOLUMN::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_eoddata1__DATAFORMAT_USCORECOLUMN(soap, this, tag, type);
}

SOAP_FMAC3 eoddata1__DATAFORMAT_USCORECOLUMN * SOAP_FMAC4 soap_get_eoddata1__DATAFORMAT_USCORECOLUMN(struct soap *soap, eoddata1__DATAFORMAT_USCORECOLUMN *p, const char *tag, const char *type)
{
	if ((p = soap_in_eoddata1__DATAFORMAT_USCORECOLUMN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToeoddata1__DATAFORMAT_USCORECOLUMN(soap, &this->eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN::DATAFORMAT_USCORECOLUMN);
	/* transient soap skipped */
}

void eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerToeoddata1__DATAFORMAT_USCORECOLUMN(soap, &this->eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN::DATAFORMAT_USCORECOLUMN);
#endif
}

int eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN(struct soap *soap, const char *tag, int id, const eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata_eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToeoddata1__DATAFORMAT_USCORECOLUMN(soap, "eoddata1:DATAFORMAT_COLUMN", -1, &a->eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN::DATAFORMAT_USCORECOLUMN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN(soap, tag, this, type);
}

SOAP_FMAC3 eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN * SOAP_FMAC4 soap_in_eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN(struct soap *soap, const char *tag, eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata_eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN, sizeof(eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerToeoddata1__DATAFORMAT_USCORECOLUMN(soap, "eoddata1:DATAFORMAT_COLUMN", &a->eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN::DATAFORMAT_USCORECOLUMN, "eoddata1:DATAFORMAT_COLUMN"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata_eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN, SOAP_TYPE_eoddata_eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN, sizeof(eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN * SOAP_FMAC2 soap_instantiate_eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN *p;
	size_t k = sizeof(eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN);
	if (n < 0)
	{	p = SOAP_NEW(eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN);
		if (p)
			((eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata_eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:ArrayOfDATAFORMAT_COLUMN", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN(soap, this, tag, type);
}

SOAP_FMAC3 eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN * SOAP_FMAC4 soap_get_eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN(struct soap *soap, eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN *p, const char *tag, const char *type)
{
	if ((p = soap_in_eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void eoddata1__DATAFORMAT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->eoddata1__DATAFORMAT::COLUMNS = NULL;
	this->eoddata1__DATAFORMAT::Code = NULL;
	this->eoddata1__DATAFORMAT::Name = NULL;
	this->eoddata1__DATAFORMAT::Header = NULL;
	this->eoddata1__DATAFORMAT::DateFormat = NULL;
	this->eoddata1__DATAFORMAT::Extension = NULL;
	soap_default_bool(soap, &this->eoddata1__DATAFORMAT::IncludeSuffix);
	soap_default_bool(soap, &this->eoddata1__DATAFORMAT::TabColumnSeperator);
	this->eoddata1__DATAFORMAT::ColumnSeperator = NULL;
	this->eoddata1__DATAFORMAT::TextQualifier = NULL;
	this->eoddata1__DATAFORMAT::FilenamePrefix = NULL;
	soap_default_bool(soap, &this->eoddata1__DATAFORMAT::FilenameExchangeCode);
	soap_default_bool(soap, &this->eoddata1__DATAFORMAT::FilenameDate);
	soap_default_bool(soap, &this->eoddata1__DATAFORMAT::IncludeHeaderRow);
	this->eoddata1__DATAFORMAT::HourFormat = NULL;
	this->eoddata1__DATAFORMAT::DateTimeSeperator = NULL;
	this->eoddata1__DATAFORMAT::ExchangeFilenameFormatDate = NULL;
	this->eoddata1__DATAFORMAT::ExchangeFilenameFormatDateRange = NULL;
	this->eoddata1__DATAFORMAT::SymbolFilenameFormatDate = NULL;
	this->eoddata1__DATAFORMAT::SymbolFilenameFormatDateRange = NULL;
	/* transient soap skipped */
}

void eoddata1__DATAFORMAT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToeoddata1__ArrayOfDATAFORMAT_USCORECOLUMN(soap, &this->eoddata1__DATAFORMAT::COLUMNS);
#endif
}

int eoddata1__DATAFORMAT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_eoddata1__DATAFORMAT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_eoddata1__DATAFORMAT(struct soap *soap, const char *tag, int id, const eoddata1__DATAFORMAT *a, const char *type)
{
	if (((eoddata1__DATAFORMAT*)a)->Code)
		soap_set_attr(soap, "Code", ((eoddata1__DATAFORMAT*)a)->Code->c_str(), 1);
	if (((eoddata1__DATAFORMAT*)a)->Name)
		soap_set_attr(soap, "Name", ((eoddata1__DATAFORMAT*)a)->Name->c_str(), 1);
	if (((eoddata1__DATAFORMAT*)a)->Header)
		soap_set_attr(soap, "Header", ((eoddata1__DATAFORMAT*)a)->Header->c_str(), 1);
	if (((eoddata1__DATAFORMAT*)a)->DateFormat)
		soap_set_attr(soap, "DateFormat", ((eoddata1__DATAFORMAT*)a)->DateFormat->c_str(), 1);
	if (((eoddata1__DATAFORMAT*)a)->Extension)
		soap_set_attr(soap, "Extension", ((eoddata1__DATAFORMAT*)a)->Extension->c_str(), 1);
	soap_set_attr(soap, "IncludeSuffix", soap_bool2s(soap, ((eoddata1__DATAFORMAT*)a)->IncludeSuffix), 1);
	soap_set_attr(soap, "TabColumnSeperator", soap_bool2s(soap, ((eoddata1__DATAFORMAT*)a)->TabColumnSeperator), 1);
	if (((eoddata1__DATAFORMAT*)a)->ColumnSeperator)
		soap_set_attr(soap, "ColumnSeperator", ((eoddata1__DATAFORMAT*)a)->ColumnSeperator->c_str(), 1);
	if (((eoddata1__DATAFORMAT*)a)->TextQualifier)
		soap_set_attr(soap, "TextQualifier", ((eoddata1__DATAFORMAT*)a)->TextQualifier->c_str(), 1);
	if (((eoddata1__DATAFORMAT*)a)->FilenamePrefix)
		soap_set_attr(soap, "FilenamePrefix", ((eoddata1__DATAFORMAT*)a)->FilenamePrefix->c_str(), 1);
	soap_set_attr(soap, "FilenameExchangeCode", soap_bool2s(soap, ((eoddata1__DATAFORMAT*)a)->FilenameExchangeCode), 1);
	soap_set_attr(soap, "FilenameDate", soap_bool2s(soap, ((eoddata1__DATAFORMAT*)a)->FilenameDate), 1);
	soap_set_attr(soap, "IncludeHeaderRow", soap_bool2s(soap, ((eoddata1__DATAFORMAT*)a)->IncludeHeaderRow), 1);
	if (((eoddata1__DATAFORMAT*)a)->HourFormat)
		soap_set_attr(soap, "HourFormat", ((eoddata1__DATAFORMAT*)a)->HourFormat->c_str(), 1);
	if (((eoddata1__DATAFORMAT*)a)->DateTimeSeperator)
		soap_set_attr(soap, "DateTimeSeperator", ((eoddata1__DATAFORMAT*)a)->DateTimeSeperator->c_str(), 1);
	if (((eoddata1__DATAFORMAT*)a)->ExchangeFilenameFormatDate)
		soap_set_attr(soap, "ExchangeFilenameFormatDate", ((eoddata1__DATAFORMAT*)a)->ExchangeFilenameFormatDate->c_str(), 1);
	if (((eoddata1__DATAFORMAT*)a)->ExchangeFilenameFormatDateRange)
		soap_set_attr(soap, "ExchangeFilenameFormatDateRange", ((eoddata1__DATAFORMAT*)a)->ExchangeFilenameFormatDateRange->c_str(), 1);
	if (((eoddata1__DATAFORMAT*)a)->SymbolFilenameFormatDate)
		soap_set_attr(soap, "SymbolFilenameFormatDate", ((eoddata1__DATAFORMAT*)a)->SymbolFilenameFormatDate->c_str(), 1);
	if (((eoddata1__DATAFORMAT*)a)->SymbolFilenameFormatDateRange)
		soap_set_attr(soap, "SymbolFilenameFormatDateRange", ((eoddata1__DATAFORMAT*)a)->SymbolFilenameFormatDateRange->c_str(), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata_eoddata1__DATAFORMAT), type))
		return soap->error;
	if (soap_out_PointerToeoddata1__ArrayOfDATAFORMAT_USCORECOLUMN(soap, "eoddata1:COLUMNS", -1, &a->eoddata1__DATAFORMAT::COLUMNS, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *eoddata1__DATAFORMAT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_eoddata1__DATAFORMAT(soap, tag, this, type);
}

SOAP_FMAC3 eoddata1__DATAFORMAT * SOAP_FMAC4 soap_in_eoddata1__DATAFORMAT(struct soap *soap, const char *tag, eoddata1__DATAFORMAT *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (eoddata1__DATAFORMAT *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata_eoddata1__DATAFORMAT, sizeof(eoddata1__DATAFORMAT), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	{	const char *t = soap_attr_value(soap, "Code", 0);
		if (t)
		{
			if (!(((eoddata1__DATAFORMAT*)a)->Code = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__DATAFORMAT*)a)->Code, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Name", 0);
		if (t)
		{
			if (!(((eoddata1__DATAFORMAT*)a)->Name = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__DATAFORMAT*)a)->Name, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Header", 0);
		if (t)
		{
			if (!(((eoddata1__DATAFORMAT*)a)->Header = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__DATAFORMAT*)a)->Header, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "DateFormat", 0);
		if (t)
		{
			if (!(((eoddata1__DATAFORMAT*)a)->DateFormat = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__DATAFORMAT*)a)->DateFormat, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Extension", 0);
		if (t)
		{
			if (!(((eoddata1__DATAFORMAT*)a)->Extension = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__DATAFORMAT*)a)->Extension, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2bool(soap, soap_attr_value(soap, "IncludeSuffix", 1), &((eoddata1__DATAFORMAT*)a)->IncludeSuffix))
		return NULL;
	if (soap_s2bool(soap, soap_attr_value(soap, "TabColumnSeperator", 1), &((eoddata1__DATAFORMAT*)a)->TabColumnSeperator))
		return NULL;
	{	const char *t = soap_attr_value(soap, "ColumnSeperator", 0);
		if (t)
		{
			if (!(((eoddata1__DATAFORMAT*)a)->ColumnSeperator = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__DATAFORMAT*)a)->ColumnSeperator, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "TextQualifier", 0);
		if (t)
		{
			if (!(((eoddata1__DATAFORMAT*)a)->TextQualifier = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__DATAFORMAT*)a)->TextQualifier, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "FilenamePrefix", 0);
		if (t)
		{
			if (!(((eoddata1__DATAFORMAT*)a)->FilenamePrefix = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__DATAFORMAT*)a)->FilenamePrefix, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2bool(soap, soap_attr_value(soap, "FilenameExchangeCode", 1), &((eoddata1__DATAFORMAT*)a)->FilenameExchangeCode))
		return NULL;
	if (soap_s2bool(soap, soap_attr_value(soap, "FilenameDate", 1), &((eoddata1__DATAFORMAT*)a)->FilenameDate))
		return NULL;
	if (soap_s2bool(soap, soap_attr_value(soap, "IncludeHeaderRow", 1), &((eoddata1__DATAFORMAT*)a)->IncludeHeaderRow))
		return NULL;
	{	const char *t = soap_attr_value(soap, "HourFormat", 0);
		if (t)
		{
			if (!(((eoddata1__DATAFORMAT*)a)->HourFormat = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__DATAFORMAT*)a)->HourFormat, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "DateTimeSeperator", 0);
		if (t)
		{
			if (!(((eoddata1__DATAFORMAT*)a)->DateTimeSeperator = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__DATAFORMAT*)a)->DateTimeSeperator, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "ExchangeFilenameFormatDate", 0);
		if (t)
		{
			if (!(((eoddata1__DATAFORMAT*)a)->ExchangeFilenameFormatDate = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__DATAFORMAT*)a)->ExchangeFilenameFormatDate, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "ExchangeFilenameFormatDateRange", 0);
		if (t)
		{
			if (!(((eoddata1__DATAFORMAT*)a)->ExchangeFilenameFormatDateRange = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__DATAFORMAT*)a)->ExchangeFilenameFormatDateRange, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "SymbolFilenameFormatDate", 0);
		if (t)
		{
			if (!(((eoddata1__DATAFORMAT*)a)->SymbolFilenameFormatDate = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__DATAFORMAT*)a)->SymbolFilenameFormatDate, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "SymbolFilenameFormatDateRange", 0);
		if (t)
		{
			if (!(((eoddata1__DATAFORMAT*)a)->SymbolFilenameFormatDateRange = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__DATAFORMAT*)a)->SymbolFilenameFormatDateRange, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_COLUMNS1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_COLUMNS1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToeoddata1__ArrayOfDATAFORMAT_USCORECOLUMN(soap, "eoddata1:COLUMNS", &a->eoddata1__DATAFORMAT::COLUMNS, "eoddata1:ArrayOfDATAFORMAT_COLUMN"))
				{	soap_flag_COLUMNS1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (eoddata1__DATAFORMAT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata_eoddata1__DATAFORMAT, SOAP_TYPE_eoddata_eoddata1__DATAFORMAT, sizeof(eoddata1__DATAFORMAT), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 eoddata1__DATAFORMAT * SOAP_FMAC2 soap_instantiate_eoddata1__DATAFORMAT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_eoddata1__DATAFORMAT(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	eoddata1__DATAFORMAT *p;
	size_t k = sizeof(eoddata1__DATAFORMAT);
	if (n < 0)
	{	p = SOAP_NEW(eoddata1__DATAFORMAT);
		if (p)
			((eoddata1__DATAFORMAT*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(eoddata1__DATAFORMAT, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((eoddata1__DATAFORMAT*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated eoddata1__DATAFORMAT location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata_eoddata1__DATAFORMAT, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int eoddata1__DATAFORMAT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:DATAFORMAT", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *eoddata1__DATAFORMAT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_eoddata1__DATAFORMAT(soap, this, tag, type);
}

SOAP_FMAC3 eoddata1__DATAFORMAT * SOAP_FMAC4 soap_get_eoddata1__DATAFORMAT(struct soap *soap, eoddata1__DATAFORMAT *p, const char *tag, const char *type)
{
	if ((p = soap_in_eoddata1__DATAFORMAT(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void eoddata1__ArrayOfDATAFORMAT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToeoddata1__DATAFORMAT(soap, &this->eoddata1__ArrayOfDATAFORMAT::DATAFORMAT);
	/* transient soap skipped */
}

void eoddata1__ArrayOfDATAFORMAT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerToeoddata1__DATAFORMAT(soap, &this->eoddata1__ArrayOfDATAFORMAT::DATAFORMAT);
#endif
}

int eoddata1__ArrayOfDATAFORMAT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_eoddata1__ArrayOfDATAFORMAT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_eoddata1__ArrayOfDATAFORMAT(struct soap *soap, const char *tag, int id, const eoddata1__ArrayOfDATAFORMAT *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata_eoddata1__ArrayOfDATAFORMAT), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToeoddata1__DATAFORMAT(soap, "eoddata1:DATAFORMAT", -1, &a->eoddata1__ArrayOfDATAFORMAT::DATAFORMAT, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *eoddata1__ArrayOfDATAFORMAT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_eoddata1__ArrayOfDATAFORMAT(soap, tag, this, type);
}

SOAP_FMAC3 eoddata1__ArrayOfDATAFORMAT * SOAP_FMAC4 soap_in_eoddata1__ArrayOfDATAFORMAT(struct soap *soap, const char *tag, eoddata1__ArrayOfDATAFORMAT *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (eoddata1__ArrayOfDATAFORMAT *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata_eoddata1__ArrayOfDATAFORMAT, sizeof(eoddata1__ArrayOfDATAFORMAT), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerToeoddata1__DATAFORMAT(soap, "eoddata1:DATAFORMAT", &a->eoddata1__ArrayOfDATAFORMAT::DATAFORMAT, "eoddata1:DATAFORMAT"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (eoddata1__ArrayOfDATAFORMAT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata_eoddata1__ArrayOfDATAFORMAT, SOAP_TYPE_eoddata_eoddata1__ArrayOfDATAFORMAT, sizeof(eoddata1__ArrayOfDATAFORMAT), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 eoddata1__ArrayOfDATAFORMAT * SOAP_FMAC2 soap_instantiate_eoddata1__ArrayOfDATAFORMAT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_eoddata1__ArrayOfDATAFORMAT(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	eoddata1__ArrayOfDATAFORMAT *p;
	size_t k = sizeof(eoddata1__ArrayOfDATAFORMAT);
	if (n < 0)
	{	p = SOAP_NEW(eoddata1__ArrayOfDATAFORMAT);
		if (p)
			((eoddata1__ArrayOfDATAFORMAT*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(eoddata1__ArrayOfDATAFORMAT, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((eoddata1__ArrayOfDATAFORMAT*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated eoddata1__ArrayOfDATAFORMAT location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata_eoddata1__ArrayOfDATAFORMAT, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int eoddata1__ArrayOfDATAFORMAT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:ArrayOfDATAFORMAT", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *eoddata1__ArrayOfDATAFORMAT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_eoddata1__ArrayOfDATAFORMAT(soap, this, tag, type);
}

SOAP_FMAC3 eoddata1__ArrayOfDATAFORMAT * SOAP_FMAC4 soap_get_eoddata1__ArrayOfDATAFORMAT(struct soap *soap, eoddata1__ArrayOfDATAFORMAT *p, const char *tag, const char *type)
{
	if ((p = soap_in_eoddata1__ArrayOfDATAFORMAT(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void eoddata1__NEWS::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->eoddata1__NEWS::Exchange = NULL;
	this->eoddata1__NEWS::Symbol = NULL;
	soap_default_LONG64(soap, &this->eoddata1__NEWS::Id);
	this->eoddata1__NEWS::SourceKey = NULL;
	soap_default_dateTime(soap, &this->eoddata1__NEWS::DateTime);
	this->eoddata1__NEWS::Headline = NULL;
	this->eoddata1__NEWS::Introduction = NULL;
	this->eoddata1__NEWS::Story = NULL;
	this->eoddata1__NEWS::Caption = NULL;
	soap_default_int(soap, &this->eoddata1__NEWS::Views);
	/* transient soap skipped */
}

void eoddata1__NEWS::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int eoddata1__NEWS::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_eoddata1__NEWS(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_eoddata1__NEWS(struct soap *soap, const char *tag, int id, const eoddata1__NEWS *a, const char *type)
{
	if (((eoddata1__NEWS*)a)->Exchange)
		soap_set_attr(soap, "Exchange", ((eoddata1__NEWS*)a)->Exchange->c_str(), 1);
	if (((eoddata1__NEWS*)a)->Symbol)
		soap_set_attr(soap, "Symbol", ((eoddata1__NEWS*)a)->Symbol->c_str(), 1);
	soap_set_attr(soap, "Id", soap_LONG642s(soap, ((eoddata1__NEWS*)a)->Id), 1);
	if (((eoddata1__NEWS*)a)->SourceKey)
		soap_set_attr(soap, "SourceKey", ((eoddata1__NEWS*)a)->SourceKey->c_str(), 1);
	soap_set_attr(soap, "DateTime", soap_dateTime2s(soap, ((eoddata1__NEWS*)a)->DateTime), 1);
	if (((eoddata1__NEWS*)a)->Headline)
		soap_set_attr(soap, "Headline", ((eoddata1__NEWS*)a)->Headline->c_str(), 1);
	if (((eoddata1__NEWS*)a)->Introduction)
		soap_set_attr(soap, "Introduction", ((eoddata1__NEWS*)a)->Introduction->c_str(), 1);
	if (((eoddata1__NEWS*)a)->Story)
		soap_set_attr(soap, "Story", ((eoddata1__NEWS*)a)->Story->c_str(), 1);
	if (((eoddata1__NEWS*)a)->Caption)
		soap_set_attr(soap, "Caption", ((eoddata1__NEWS*)a)->Caption->c_str(), 1);
	soap_set_attr(soap, "Views", soap_int2s(soap, ((eoddata1__NEWS*)a)->Views), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata_eoddata1__NEWS), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *eoddata1__NEWS::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_eoddata1__NEWS(soap, tag, this, type);
}

SOAP_FMAC3 eoddata1__NEWS * SOAP_FMAC4 soap_in_eoddata1__NEWS(struct soap *soap, const char *tag, eoddata1__NEWS *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (eoddata1__NEWS *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata_eoddata1__NEWS, sizeof(eoddata1__NEWS), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	{	const char *t = soap_attr_value(soap, "Exchange", 0);
		if (t)
		{
			if (!(((eoddata1__NEWS*)a)->Exchange = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__NEWS*)a)->Exchange, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Symbol", 0);
		if (t)
		{
			if (!(((eoddata1__NEWS*)a)->Symbol = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__NEWS*)a)->Symbol, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2LONG64(soap, soap_attr_value(soap, "Id", 1), &((eoddata1__NEWS*)a)->Id))
		return NULL;
	{	const char *t = soap_attr_value(soap, "SourceKey", 0);
		if (t)
		{
			if (!(((eoddata1__NEWS*)a)->SourceKey = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__NEWS*)a)->SourceKey, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2dateTime(soap, soap_attr_value(soap, "DateTime", 1), &((eoddata1__NEWS*)a)->DateTime))
		return NULL;
	{	const char *t = soap_attr_value(soap, "Headline", 0);
		if (t)
		{
			if (!(((eoddata1__NEWS*)a)->Headline = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__NEWS*)a)->Headline, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Introduction", 0);
		if (t)
		{
			if (!(((eoddata1__NEWS*)a)->Introduction = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__NEWS*)a)->Introduction, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Story", 0);
		if (t)
		{
			if (!(((eoddata1__NEWS*)a)->Story = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__NEWS*)a)->Story, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Caption", 0);
		if (t)
		{
			if (!(((eoddata1__NEWS*)a)->Caption = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__NEWS*)a)->Caption, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2int(soap, soap_attr_value(soap, "Views", 1), &((eoddata1__NEWS*)a)->Views))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (eoddata1__NEWS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata_eoddata1__NEWS, SOAP_TYPE_eoddata_eoddata1__NEWS, sizeof(eoddata1__NEWS), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 eoddata1__NEWS * SOAP_FMAC2 soap_instantiate_eoddata1__NEWS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_eoddata1__NEWS(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	eoddata1__NEWS *p;
	size_t k = sizeof(eoddata1__NEWS);
	if (n < 0)
	{	p = SOAP_NEW(eoddata1__NEWS);
		if (p)
			((eoddata1__NEWS*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(eoddata1__NEWS, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((eoddata1__NEWS*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated eoddata1__NEWS location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata_eoddata1__NEWS, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int eoddata1__NEWS::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:NEWS", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *eoddata1__NEWS::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_eoddata1__NEWS(soap, this, tag, type);
}

SOAP_FMAC3 eoddata1__NEWS * SOAP_FMAC4 soap_get_eoddata1__NEWS(struct soap *soap, eoddata1__NEWS *p, const char *tag, const char *type)
{
	if ((p = soap_in_eoddata1__NEWS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void eoddata1__ArrayOfNEWS::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToeoddata1__NEWS(soap, &this->eoddata1__ArrayOfNEWS::NEWS);
	/* transient soap skipped */
}

void eoddata1__ArrayOfNEWS::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerToeoddata1__NEWS(soap, &this->eoddata1__ArrayOfNEWS::NEWS);
#endif
}

int eoddata1__ArrayOfNEWS::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_eoddata1__ArrayOfNEWS(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_eoddata1__ArrayOfNEWS(struct soap *soap, const char *tag, int id, const eoddata1__ArrayOfNEWS *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata_eoddata1__ArrayOfNEWS), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToeoddata1__NEWS(soap, "eoddata1:NEWS", -1, &a->eoddata1__ArrayOfNEWS::NEWS, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *eoddata1__ArrayOfNEWS::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_eoddata1__ArrayOfNEWS(soap, tag, this, type);
}

SOAP_FMAC3 eoddata1__ArrayOfNEWS * SOAP_FMAC4 soap_in_eoddata1__ArrayOfNEWS(struct soap *soap, const char *tag, eoddata1__ArrayOfNEWS *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (eoddata1__ArrayOfNEWS *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata_eoddata1__ArrayOfNEWS, sizeof(eoddata1__ArrayOfNEWS), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerToeoddata1__NEWS(soap, "eoddata1:NEWS", &a->eoddata1__ArrayOfNEWS::NEWS, "eoddata1:NEWS"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (eoddata1__ArrayOfNEWS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata_eoddata1__ArrayOfNEWS, SOAP_TYPE_eoddata_eoddata1__ArrayOfNEWS, sizeof(eoddata1__ArrayOfNEWS), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 eoddata1__ArrayOfNEWS * SOAP_FMAC2 soap_instantiate_eoddata1__ArrayOfNEWS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_eoddata1__ArrayOfNEWS(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	eoddata1__ArrayOfNEWS *p;
	size_t k = sizeof(eoddata1__ArrayOfNEWS);
	if (n < 0)
	{	p = SOAP_NEW(eoddata1__ArrayOfNEWS);
		if (p)
			((eoddata1__ArrayOfNEWS*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(eoddata1__ArrayOfNEWS, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((eoddata1__ArrayOfNEWS*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated eoddata1__ArrayOfNEWS location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata_eoddata1__ArrayOfNEWS, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int eoddata1__ArrayOfNEWS::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:ArrayOfNEWS", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *eoddata1__ArrayOfNEWS::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_eoddata1__ArrayOfNEWS(soap, this, tag, type);
}

SOAP_FMAC3 eoddata1__ArrayOfNEWS * SOAP_FMAC4 soap_get_eoddata1__ArrayOfNEWS(struct soap *soap, eoddata1__ArrayOfNEWS *p, const char *tag, const char *type)
{
	if ((p = soap_in_eoddata1__ArrayOfNEWS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void eoddata1__SYMBOLCHANGE::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_dateTime(soap, &this->eoddata1__SYMBOLCHANGE::DateTime);
	this->eoddata1__SYMBOLCHANGE::OldSymbol = NULL;
	this->eoddata1__SYMBOLCHANGE::NewSymbol = NULL;
	this->eoddata1__SYMBOLCHANGE::ExchangeCode = NULL;
	this->eoddata1__SYMBOLCHANGE::NewExchangeCode = NULL;
	/* transient soap skipped */
}

void eoddata1__SYMBOLCHANGE::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int eoddata1__SYMBOLCHANGE::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_eoddata1__SYMBOLCHANGE(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_eoddata1__SYMBOLCHANGE(struct soap *soap, const char *tag, int id, const eoddata1__SYMBOLCHANGE *a, const char *type)
{
	soap_set_attr(soap, "DateTime", soap_dateTime2s(soap, ((eoddata1__SYMBOLCHANGE*)a)->DateTime), 1);
	if (((eoddata1__SYMBOLCHANGE*)a)->OldSymbol)
		soap_set_attr(soap, "OldSymbol", ((eoddata1__SYMBOLCHANGE*)a)->OldSymbol->c_str(), 1);
	if (((eoddata1__SYMBOLCHANGE*)a)->NewSymbol)
		soap_set_attr(soap, "NewSymbol", ((eoddata1__SYMBOLCHANGE*)a)->NewSymbol->c_str(), 1);
	if (((eoddata1__SYMBOLCHANGE*)a)->ExchangeCode)
		soap_set_attr(soap, "ExchangeCode", ((eoddata1__SYMBOLCHANGE*)a)->ExchangeCode->c_str(), 1);
	if (((eoddata1__SYMBOLCHANGE*)a)->NewExchangeCode)
		soap_set_attr(soap, "NewExchangeCode", ((eoddata1__SYMBOLCHANGE*)a)->NewExchangeCode->c_str(), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata_eoddata1__SYMBOLCHANGE), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *eoddata1__SYMBOLCHANGE::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_eoddata1__SYMBOLCHANGE(soap, tag, this, type);
}

SOAP_FMAC3 eoddata1__SYMBOLCHANGE * SOAP_FMAC4 soap_in_eoddata1__SYMBOLCHANGE(struct soap *soap, const char *tag, eoddata1__SYMBOLCHANGE *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (eoddata1__SYMBOLCHANGE *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata_eoddata1__SYMBOLCHANGE, sizeof(eoddata1__SYMBOLCHANGE), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2dateTime(soap, soap_attr_value(soap, "DateTime", 1), &((eoddata1__SYMBOLCHANGE*)a)->DateTime))
		return NULL;
	{	const char *t = soap_attr_value(soap, "OldSymbol", 0);
		if (t)
		{
			if (!(((eoddata1__SYMBOLCHANGE*)a)->OldSymbol = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__SYMBOLCHANGE*)a)->OldSymbol, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "NewSymbol", 0);
		if (t)
		{
			if (!(((eoddata1__SYMBOLCHANGE*)a)->NewSymbol = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__SYMBOLCHANGE*)a)->NewSymbol, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "ExchangeCode", 0);
		if (t)
		{
			if (!(((eoddata1__SYMBOLCHANGE*)a)->ExchangeCode = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__SYMBOLCHANGE*)a)->ExchangeCode, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "NewExchangeCode", 0);
		if (t)
		{
			if (!(((eoddata1__SYMBOLCHANGE*)a)->NewExchangeCode = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__SYMBOLCHANGE*)a)->NewExchangeCode, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (eoddata1__SYMBOLCHANGE *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata_eoddata1__SYMBOLCHANGE, SOAP_TYPE_eoddata_eoddata1__SYMBOLCHANGE, sizeof(eoddata1__SYMBOLCHANGE), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 eoddata1__SYMBOLCHANGE * SOAP_FMAC2 soap_instantiate_eoddata1__SYMBOLCHANGE(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_eoddata1__SYMBOLCHANGE(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	eoddata1__SYMBOLCHANGE *p;
	size_t k = sizeof(eoddata1__SYMBOLCHANGE);
	if (n < 0)
	{	p = SOAP_NEW(eoddata1__SYMBOLCHANGE);
		if (p)
			((eoddata1__SYMBOLCHANGE*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(eoddata1__SYMBOLCHANGE, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((eoddata1__SYMBOLCHANGE*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated eoddata1__SYMBOLCHANGE location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata_eoddata1__SYMBOLCHANGE, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int eoddata1__SYMBOLCHANGE::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:SYMBOLCHANGE", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *eoddata1__SYMBOLCHANGE::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_eoddata1__SYMBOLCHANGE(soap, this, tag, type);
}

SOAP_FMAC3 eoddata1__SYMBOLCHANGE * SOAP_FMAC4 soap_get_eoddata1__SYMBOLCHANGE(struct soap *soap, eoddata1__SYMBOLCHANGE *p, const char *tag, const char *type)
{
	if ((p = soap_in_eoddata1__SYMBOLCHANGE(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void eoddata1__ArrayOfSYMBOLCHANGE::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToeoddata1__SYMBOLCHANGE(soap, &this->eoddata1__ArrayOfSYMBOLCHANGE::SYMBOLCHANGE);
	/* transient soap skipped */
}

void eoddata1__ArrayOfSYMBOLCHANGE::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerToeoddata1__SYMBOLCHANGE(soap, &this->eoddata1__ArrayOfSYMBOLCHANGE::SYMBOLCHANGE);
#endif
}

int eoddata1__ArrayOfSYMBOLCHANGE::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_eoddata1__ArrayOfSYMBOLCHANGE(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_eoddata1__ArrayOfSYMBOLCHANGE(struct soap *soap, const char *tag, int id, const eoddata1__ArrayOfSYMBOLCHANGE *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata_eoddata1__ArrayOfSYMBOLCHANGE), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToeoddata1__SYMBOLCHANGE(soap, "eoddata1:SYMBOLCHANGE", -1, &a->eoddata1__ArrayOfSYMBOLCHANGE::SYMBOLCHANGE, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *eoddata1__ArrayOfSYMBOLCHANGE::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_eoddata1__ArrayOfSYMBOLCHANGE(soap, tag, this, type);
}

SOAP_FMAC3 eoddata1__ArrayOfSYMBOLCHANGE * SOAP_FMAC4 soap_in_eoddata1__ArrayOfSYMBOLCHANGE(struct soap *soap, const char *tag, eoddata1__ArrayOfSYMBOLCHANGE *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (eoddata1__ArrayOfSYMBOLCHANGE *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata_eoddata1__ArrayOfSYMBOLCHANGE, sizeof(eoddata1__ArrayOfSYMBOLCHANGE), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerToeoddata1__SYMBOLCHANGE(soap, "eoddata1:SYMBOLCHANGE", &a->eoddata1__ArrayOfSYMBOLCHANGE::SYMBOLCHANGE, "eoddata1:SYMBOLCHANGE"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (eoddata1__ArrayOfSYMBOLCHANGE *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata_eoddata1__ArrayOfSYMBOLCHANGE, SOAP_TYPE_eoddata_eoddata1__ArrayOfSYMBOLCHANGE, sizeof(eoddata1__ArrayOfSYMBOLCHANGE), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 eoddata1__ArrayOfSYMBOLCHANGE * SOAP_FMAC2 soap_instantiate_eoddata1__ArrayOfSYMBOLCHANGE(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_eoddata1__ArrayOfSYMBOLCHANGE(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	eoddata1__ArrayOfSYMBOLCHANGE *p;
	size_t k = sizeof(eoddata1__ArrayOfSYMBOLCHANGE);
	if (n < 0)
	{	p = SOAP_NEW(eoddata1__ArrayOfSYMBOLCHANGE);
		if (p)
			((eoddata1__ArrayOfSYMBOLCHANGE*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(eoddata1__ArrayOfSYMBOLCHANGE, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((eoddata1__ArrayOfSYMBOLCHANGE*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated eoddata1__ArrayOfSYMBOLCHANGE location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata_eoddata1__ArrayOfSYMBOLCHANGE, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int eoddata1__ArrayOfSYMBOLCHANGE::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:ArrayOfSYMBOLCHANGE", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *eoddata1__ArrayOfSYMBOLCHANGE::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_eoddata1__ArrayOfSYMBOLCHANGE(soap, this, tag, type);
}

SOAP_FMAC3 eoddata1__ArrayOfSYMBOLCHANGE * SOAP_FMAC4 soap_get_eoddata1__ArrayOfSYMBOLCHANGE(struct soap *soap, eoddata1__ArrayOfSYMBOLCHANGE *p, const char *tag, const char *type)
{
	if ((p = soap_in_eoddata1__ArrayOfSYMBOLCHANGE(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void eoddata1__TECHNICAL::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->eoddata1__TECHNICAL::Symbol = NULL;
	this->eoddata1__TECHNICAL::Name = NULL;
	this->eoddata1__TECHNICAL::Description = NULL;
	soap_default_dateTime(soap, &this->eoddata1__TECHNICAL::DateTime);
	soap_default_double(soap, &this->eoddata1__TECHNICAL::Previous);
	soap_default_double(soap, &this->eoddata1__TECHNICAL::Change);
	soap_default_int(soap, &this->eoddata1__TECHNICAL::MA1);
	soap_default_int(soap, &this->eoddata1__TECHNICAL::MA2);
	soap_default_int(soap, &this->eoddata1__TECHNICAL::MA5);
	soap_default_int(soap, &this->eoddata1__TECHNICAL::MA20);
	soap_default_int(soap, &this->eoddata1__TECHNICAL::MA50);
	soap_default_int(soap, &this->eoddata1__TECHNICAL::MA100);
	soap_default_int(soap, &this->eoddata1__TECHNICAL::MA200);
	soap_default_double(soap, &this->eoddata1__TECHNICAL::MAPercent);
	soap_default_double(soap, &this->eoddata1__TECHNICAL::MAReturn);
	soap_default_LONG64(soap, &this->eoddata1__TECHNICAL::VolumeChange);
	soap_default_double(soap, &this->eoddata1__TECHNICAL::ThreeMonthChange);
	soap_default_double(soap, &this->eoddata1__TECHNICAL::SixMonthChange);
	soap_default_double(soap, &this->eoddata1__TECHNICAL::WeekHigh);
	soap_default_double(soap, &this->eoddata1__TECHNICAL::WeekLow);
	soap_default_double(soap, &this->eoddata1__TECHNICAL::WeekChange);
	soap_default_double(soap, &this->eoddata1__TECHNICAL::AvgWeekChange);
	soap_default_double(soap, &this->eoddata1__TECHNICAL::AvgWeekVolume);
	soap_default_double(soap, &this->eoddata1__TECHNICAL::WeekVolume);
	soap_default_double(soap, &this->eoddata1__TECHNICAL::MonthHigh);
	soap_default_double(soap, &this->eoddata1__TECHNICAL::MonthLow);
	soap_default_double(soap, &this->eoddata1__TECHNICAL::MonthChange);
	soap_default_double(soap, &this->eoddata1__TECHNICAL::AvgMonthChange);
	soap_default_double(soap, &this->eoddata1__TECHNICAL::AvgMonthVolume);
	soap_default_double(soap, &this->eoddata1__TECHNICAL::MonthVolume);
	soap_default_double(soap, &this->eoddata1__TECHNICAL::YearHigh);
	soap_default_double(soap, &this->eoddata1__TECHNICAL::YearLow);
	soap_default_double(soap, &this->eoddata1__TECHNICAL::YearChange);
	soap_default_double(soap, &this->eoddata1__TECHNICAL::AvgYearChange);
	soap_default_double(soap, &this->eoddata1__TECHNICAL::AvgYearVolume);
	soap_default_double(soap, &this->eoddata1__TECHNICAL::YTDChange);
	soap_default_double(soap, &this->eoddata1__TECHNICAL::RSI14);
	soap_default_double(soap, &this->eoddata1__TECHNICAL::STO9);
	soap_default_double(soap, &this->eoddata1__TECHNICAL::WPR14);
	soap_default_double(soap, &this->eoddata1__TECHNICAL::MTM14);
	soap_default_double(soap, &this->eoddata1__TECHNICAL::ROC14);
	soap_default_LONG64(soap, &this->eoddata1__TECHNICAL::PTC);
	soap_default_double(soap, &this->eoddata1__TECHNICAL::SAR);
	soap_default_double(soap, &this->eoddata1__TECHNICAL::Volatility);
	soap_default_double(soap, &this->eoddata1__TECHNICAL::Liquidity);
	/* transient soap skipped */
}

void eoddata1__TECHNICAL::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int eoddata1__TECHNICAL::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_eoddata1__TECHNICAL(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_eoddata1__TECHNICAL(struct soap *soap, const char *tag, int id, const eoddata1__TECHNICAL *a, const char *type)
{
	if (((eoddata1__TECHNICAL*)a)->Symbol)
		soap_set_attr(soap, "Symbol", ((eoddata1__TECHNICAL*)a)->Symbol->c_str(), 1);
	if (((eoddata1__TECHNICAL*)a)->Name)
		soap_set_attr(soap, "Name", ((eoddata1__TECHNICAL*)a)->Name->c_str(), 1);
	if (((eoddata1__TECHNICAL*)a)->Description)
		soap_set_attr(soap, "Description", ((eoddata1__TECHNICAL*)a)->Description->c_str(), 1);
	soap_set_attr(soap, "DateTime", soap_dateTime2s(soap, ((eoddata1__TECHNICAL*)a)->DateTime), 1);
	soap_set_attr(soap, "Previous", soap_double2s(soap, ((eoddata1__TECHNICAL*)a)->Previous), 1);
	soap_set_attr(soap, "Change", soap_double2s(soap, ((eoddata1__TECHNICAL*)a)->Change), 1);
	soap_set_attr(soap, "MA1", soap_int2s(soap, ((eoddata1__TECHNICAL*)a)->MA1), 1);
	soap_set_attr(soap, "MA2", soap_int2s(soap, ((eoddata1__TECHNICAL*)a)->MA2), 1);
	soap_set_attr(soap, "MA5", soap_int2s(soap, ((eoddata1__TECHNICAL*)a)->MA5), 1);
	soap_set_attr(soap, "MA20", soap_int2s(soap, ((eoddata1__TECHNICAL*)a)->MA20), 1);
	soap_set_attr(soap, "MA50", soap_int2s(soap, ((eoddata1__TECHNICAL*)a)->MA50), 1);
	soap_set_attr(soap, "MA100", soap_int2s(soap, ((eoddata1__TECHNICAL*)a)->MA100), 1);
	soap_set_attr(soap, "MA200", soap_int2s(soap, ((eoddata1__TECHNICAL*)a)->MA200), 1);
	soap_set_attr(soap, "MAPercent", soap_double2s(soap, ((eoddata1__TECHNICAL*)a)->MAPercent), 1);
	soap_set_attr(soap, "MAReturn", soap_double2s(soap, ((eoddata1__TECHNICAL*)a)->MAReturn), 1);
	soap_set_attr(soap, "VolumeChange", soap_LONG642s(soap, ((eoddata1__TECHNICAL*)a)->VolumeChange), 1);
	soap_set_attr(soap, "ThreeMonthChange", soap_double2s(soap, ((eoddata1__TECHNICAL*)a)->ThreeMonthChange), 1);
	soap_set_attr(soap, "SixMonthChange", soap_double2s(soap, ((eoddata1__TECHNICAL*)a)->SixMonthChange), 1);
	soap_set_attr(soap, "WeekHigh", soap_double2s(soap, ((eoddata1__TECHNICAL*)a)->WeekHigh), 1);
	soap_set_attr(soap, "WeekLow", soap_double2s(soap, ((eoddata1__TECHNICAL*)a)->WeekLow), 1);
	soap_set_attr(soap, "WeekChange", soap_double2s(soap, ((eoddata1__TECHNICAL*)a)->WeekChange), 1);
	soap_set_attr(soap, "AvgWeekChange", soap_double2s(soap, ((eoddata1__TECHNICAL*)a)->AvgWeekChange), 1);
	soap_set_attr(soap, "AvgWeekVolume", soap_double2s(soap, ((eoddata1__TECHNICAL*)a)->AvgWeekVolume), 1);
	soap_set_attr(soap, "WeekVolume", soap_double2s(soap, ((eoddata1__TECHNICAL*)a)->WeekVolume), 1);
	soap_set_attr(soap, "MonthHigh", soap_double2s(soap, ((eoddata1__TECHNICAL*)a)->MonthHigh), 1);
	soap_set_attr(soap, "MonthLow", soap_double2s(soap, ((eoddata1__TECHNICAL*)a)->MonthLow), 1);
	soap_set_attr(soap, "MonthChange", soap_double2s(soap, ((eoddata1__TECHNICAL*)a)->MonthChange), 1);
	soap_set_attr(soap, "AvgMonthChange", soap_double2s(soap, ((eoddata1__TECHNICAL*)a)->AvgMonthChange), 1);
	soap_set_attr(soap, "AvgMonthVolume", soap_double2s(soap, ((eoddata1__TECHNICAL*)a)->AvgMonthVolume), 1);
	soap_set_attr(soap, "MonthVolume", soap_double2s(soap, ((eoddata1__TECHNICAL*)a)->MonthVolume), 1);
	soap_set_attr(soap, "YearHigh", soap_double2s(soap, ((eoddata1__TECHNICAL*)a)->YearHigh), 1);
	soap_set_attr(soap, "YearLow", soap_double2s(soap, ((eoddata1__TECHNICAL*)a)->YearLow), 1);
	soap_set_attr(soap, "YearChange", soap_double2s(soap, ((eoddata1__TECHNICAL*)a)->YearChange), 1);
	soap_set_attr(soap, "AvgYearChange", soap_double2s(soap, ((eoddata1__TECHNICAL*)a)->AvgYearChange), 1);
	soap_set_attr(soap, "AvgYearVolume", soap_double2s(soap, ((eoddata1__TECHNICAL*)a)->AvgYearVolume), 1);
	soap_set_attr(soap, "YTDChange", soap_double2s(soap, ((eoddata1__TECHNICAL*)a)->YTDChange), 1);
	soap_set_attr(soap, "RSI14", soap_double2s(soap, ((eoddata1__TECHNICAL*)a)->RSI14), 1);
	soap_set_attr(soap, "STO9", soap_double2s(soap, ((eoddata1__TECHNICAL*)a)->STO9), 1);
	soap_set_attr(soap, "WPR14", soap_double2s(soap, ((eoddata1__TECHNICAL*)a)->WPR14), 1);
	soap_set_attr(soap, "MTM14", soap_double2s(soap, ((eoddata1__TECHNICAL*)a)->MTM14), 1);
	soap_set_attr(soap, "ROC14", soap_double2s(soap, ((eoddata1__TECHNICAL*)a)->ROC14), 1);
	soap_set_attr(soap, "PTC", soap_LONG642s(soap, ((eoddata1__TECHNICAL*)a)->PTC), 1);
	soap_set_attr(soap, "SAR", soap_double2s(soap, ((eoddata1__TECHNICAL*)a)->SAR), 1);
	soap_set_attr(soap, "Volatility", soap_double2s(soap, ((eoddata1__TECHNICAL*)a)->Volatility), 1);
	soap_set_attr(soap, "Liquidity", soap_double2s(soap, ((eoddata1__TECHNICAL*)a)->Liquidity), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata_eoddata1__TECHNICAL), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *eoddata1__TECHNICAL::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_eoddata1__TECHNICAL(soap, tag, this, type);
}

SOAP_FMAC3 eoddata1__TECHNICAL * SOAP_FMAC4 soap_in_eoddata1__TECHNICAL(struct soap *soap, const char *tag, eoddata1__TECHNICAL *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (eoddata1__TECHNICAL *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata_eoddata1__TECHNICAL, sizeof(eoddata1__TECHNICAL), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	{	const char *t = soap_attr_value(soap, "Symbol", 0);
		if (t)
		{
			if (!(((eoddata1__TECHNICAL*)a)->Symbol = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__TECHNICAL*)a)->Symbol, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Name", 0);
		if (t)
		{
			if (!(((eoddata1__TECHNICAL*)a)->Name = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__TECHNICAL*)a)->Name, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Description", 0);
		if (t)
		{
			if (!(((eoddata1__TECHNICAL*)a)->Description = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__TECHNICAL*)a)->Description, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2dateTime(soap, soap_attr_value(soap, "DateTime", 1), &((eoddata1__TECHNICAL*)a)->DateTime))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "Previous", 1), &((eoddata1__TECHNICAL*)a)->Previous))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "Change", 1), &((eoddata1__TECHNICAL*)a)->Change))
		return NULL;
	if (soap_s2int(soap, soap_attr_value(soap, "MA1", 1), &((eoddata1__TECHNICAL*)a)->MA1))
		return NULL;
	if (soap_s2int(soap, soap_attr_value(soap, "MA2", 1), &((eoddata1__TECHNICAL*)a)->MA2))
		return NULL;
	if (soap_s2int(soap, soap_attr_value(soap, "MA5", 1), &((eoddata1__TECHNICAL*)a)->MA5))
		return NULL;
	if (soap_s2int(soap, soap_attr_value(soap, "MA20", 1), &((eoddata1__TECHNICAL*)a)->MA20))
		return NULL;
	if (soap_s2int(soap, soap_attr_value(soap, "MA50", 1), &((eoddata1__TECHNICAL*)a)->MA50))
		return NULL;
	if (soap_s2int(soap, soap_attr_value(soap, "MA100", 1), &((eoddata1__TECHNICAL*)a)->MA100))
		return NULL;
	if (soap_s2int(soap, soap_attr_value(soap, "MA200", 1), &((eoddata1__TECHNICAL*)a)->MA200))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "MAPercent", 1), &((eoddata1__TECHNICAL*)a)->MAPercent))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "MAReturn", 1), &((eoddata1__TECHNICAL*)a)->MAReturn))
		return NULL;
	if (soap_s2LONG64(soap, soap_attr_value(soap, "VolumeChange", 1), &((eoddata1__TECHNICAL*)a)->VolumeChange))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "ThreeMonthChange", 1), &((eoddata1__TECHNICAL*)a)->ThreeMonthChange))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "SixMonthChange", 1), &((eoddata1__TECHNICAL*)a)->SixMonthChange))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "WeekHigh", 1), &((eoddata1__TECHNICAL*)a)->WeekHigh))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "WeekLow", 1), &((eoddata1__TECHNICAL*)a)->WeekLow))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "WeekChange", 1), &((eoddata1__TECHNICAL*)a)->WeekChange))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "AvgWeekChange", 1), &((eoddata1__TECHNICAL*)a)->AvgWeekChange))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "AvgWeekVolume", 1), &((eoddata1__TECHNICAL*)a)->AvgWeekVolume))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "WeekVolume", 1), &((eoddata1__TECHNICAL*)a)->WeekVolume))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "MonthHigh", 1), &((eoddata1__TECHNICAL*)a)->MonthHigh))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "MonthLow", 1), &((eoddata1__TECHNICAL*)a)->MonthLow))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "MonthChange", 1), &((eoddata1__TECHNICAL*)a)->MonthChange))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "AvgMonthChange", 1), &((eoddata1__TECHNICAL*)a)->AvgMonthChange))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "AvgMonthVolume", 1), &((eoddata1__TECHNICAL*)a)->AvgMonthVolume))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "MonthVolume", 1), &((eoddata1__TECHNICAL*)a)->MonthVolume))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "YearHigh", 1), &((eoddata1__TECHNICAL*)a)->YearHigh))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "YearLow", 1), &((eoddata1__TECHNICAL*)a)->YearLow))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "YearChange", 1), &((eoddata1__TECHNICAL*)a)->YearChange))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "AvgYearChange", 1), &((eoddata1__TECHNICAL*)a)->AvgYearChange))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "AvgYearVolume", 1), &((eoddata1__TECHNICAL*)a)->AvgYearVolume))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "YTDChange", 1), &((eoddata1__TECHNICAL*)a)->YTDChange))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "RSI14", 1), &((eoddata1__TECHNICAL*)a)->RSI14))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "STO9", 1), &((eoddata1__TECHNICAL*)a)->STO9))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "WPR14", 1), &((eoddata1__TECHNICAL*)a)->WPR14))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "MTM14", 1), &((eoddata1__TECHNICAL*)a)->MTM14))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "ROC14", 1), &((eoddata1__TECHNICAL*)a)->ROC14))
		return NULL;
	if (soap_s2LONG64(soap, soap_attr_value(soap, "PTC", 1), &((eoddata1__TECHNICAL*)a)->PTC))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "SAR", 1), &((eoddata1__TECHNICAL*)a)->SAR))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "Volatility", 1), &((eoddata1__TECHNICAL*)a)->Volatility))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "Liquidity", 1), &((eoddata1__TECHNICAL*)a)->Liquidity))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (eoddata1__TECHNICAL *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata_eoddata1__TECHNICAL, SOAP_TYPE_eoddata_eoddata1__TECHNICAL, sizeof(eoddata1__TECHNICAL), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 eoddata1__TECHNICAL * SOAP_FMAC2 soap_instantiate_eoddata1__TECHNICAL(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_eoddata1__TECHNICAL(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	eoddata1__TECHNICAL *p;
	size_t k = sizeof(eoddata1__TECHNICAL);
	if (n < 0)
	{	p = SOAP_NEW(eoddata1__TECHNICAL);
		if (p)
			((eoddata1__TECHNICAL*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(eoddata1__TECHNICAL, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((eoddata1__TECHNICAL*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated eoddata1__TECHNICAL location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata_eoddata1__TECHNICAL, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int eoddata1__TECHNICAL::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:TECHNICAL", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *eoddata1__TECHNICAL::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_eoddata1__TECHNICAL(soap, this, tag, type);
}

SOAP_FMAC3 eoddata1__TECHNICAL * SOAP_FMAC4 soap_get_eoddata1__TECHNICAL(struct soap *soap, eoddata1__TECHNICAL *p, const char *tag, const char *type)
{
	if ((p = soap_in_eoddata1__TECHNICAL(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void eoddata1__ArrayOfTECHNICAL::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToeoddata1__TECHNICAL(soap, &this->eoddata1__ArrayOfTECHNICAL::TECHNICAL);
	/* transient soap skipped */
}

void eoddata1__ArrayOfTECHNICAL::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerToeoddata1__TECHNICAL(soap, &this->eoddata1__ArrayOfTECHNICAL::TECHNICAL);
#endif
}

int eoddata1__ArrayOfTECHNICAL::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_eoddata1__ArrayOfTECHNICAL(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_eoddata1__ArrayOfTECHNICAL(struct soap *soap, const char *tag, int id, const eoddata1__ArrayOfTECHNICAL *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata_eoddata1__ArrayOfTECHNICAL), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToeoddata1__TECHNICAL(soap, "eoddata1:TECHNICAL", -1, &a->eoddata1__ArrayOfTECHNICAL::TECHNICAL, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *eoddata1__ArrayOfTECHNICAL::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_eoddata1__ArrayOfTECHNICAL(soap, tag, this, type);
}

SOAP_FMAC3 eoddata1__ArrayOfTECHNICAL * SOAP_FMAC4 soap_in_eoddata1__ArrayOfTECHNICAL(struct soap *soap, const char *tag, eoddata1__ArrayOfTECHNICAL *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (eoddata1__ArrayOfTECHNICAL *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata_eoddata1__ArrayOfTECHNICAL, sizeof(eoddata1__ArrayOfTECHNICAL), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerToeoddata1__TECHNICAL(soap, "eoddata1:TECHNICAL", &a->eoddata1__ArrayOfTECHNICAL::TECHNICAL, "eoddata1:TECHNICAL"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (eoddata1__ArrayOfTECHNICAL *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata_eoddata1__ArrayOfTECHNICAL, SOAP_TYPE_eoddata_eoddata1__ArrayOfTECHNICAL, sizeof(eoddata1__ArrayOfTECHNICAL), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 eoddata1__ArrayOfTECHNICAL * SOAP_FMAC2 soap_instantiate_eoddata1__ArrayOfTECHNICAL(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_eoddata1__ArrayOfTECHNICAL(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	eoddata1__ArrayOfTECHNICAL *p;
	size_t k = sizeof(eoddata1__ArrayOfTECHNICAL);
	if (n < 0)
	{	p = SOAP_NEW(eoddata1__ArrayOfTECHNICAL);
		if (p)
			((eoddata1__ArrayOfTECHNICAL*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(eoddata1__ArrayOfTECHNICAL, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((eoddata1__ArrayOfTECHNICAL*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated eoddata1__ArrayOfTECHNICAL location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata_eoddata1__ArrayOfTECHNICAL, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int eoddata1__ArrayOfTECHNICAL::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:ArrayOfTECHNICAL", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *eoddata1__ArrayOfTECHNICAL::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_eoddata1__ArrayOfTECHNICAL(soap, this, tag, type);
}

SOAP_FMAC3 eoddata1__ArrayOfTECHNICAL * SOAP_FMAC4 soap_get_eoddata1__ArrayOfTECHNICAL(struct soap *soap, eoddata1__ArrayOfTECHNICAL *p, const char *tag, const char *type)
{
	if ((p = soap_in_eoddata1__ArrayOfTECHNICAL(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void eoddata1__FUNDAMENTAL::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->eoddata1__FUNDAMENTAL::Symbol = NULL;
	this->eoddata1__FUNDAMENTAL::Name = NULL;
	this->eoddata1__FUNDAMENTAL::Description = NULL;
	soap_default_dateTime(soap, &this->eoddata1__FUNDAMENTAL::DateTime);
	this->eoddata1__FUNDAMENTAL::Industry = NULL;
	this->eoddata1__FUNDAMENTAL::Sector = NULL;
	soap_default_LONG64(soap, &this->eoddata1__FUNDAMENTAL::Shares);
	soap_default_LONG64(soap, &this->eoddata1__FUNDAMENTAL::MarketCap);
	soap_default_double(soap, &this->eoddata1__FUNDAMENTAL::PE);
	soap_default_double(soap, &this->eoddata1__FUNDAMENTAL::EPS);
	soap_default_double(soap, &this->eoddata1__FUNDAMENTAL::NTA);
	soap_default_double(soap, &this->eoddata1__FUNDAMENTAL::DivYield);
	soap_default_double(soap, &this->eoddata1__FUNDAMENTAL::Dividend);
	soap_default_dateTime(soap, &this->eoddata1__FUNDAMENTAL::DividendDate);
	soap_default_double(soap, &this->eoddata1__FUNDAMENTAL::DPS);
	soap_default_double(soap, &this->eoddata1__FUNDAMENTAL::ImputationCredits);
	soap_default_double(soap, &this->eoddata1__FUNDAMENTAL::EBITDA);
	soap_default_double(soap, &this->eoddata1__FUNDAMENTAL::PEG);
	soap_default_double(soap, &this->eoddata1__FUNDAMENTAL::PtS);
	soap_default_double(soap, &this->eoddata1__FUNDAMENTAL::PtB);
	soap_default_double(soap, &this->eoddata1__FUNDAMENTAL::Yield);
	/* transient soap skipped */
}

void eoddata1__FUNDAMENTAL::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int eoddata1__FUNDAMENTAL::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_eoddata1__FUNDAMENTAL(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_eoddata1__FUNDAMENTAL(struct soap *soap, const char *tag, int id, const eoddata1__FUNDAMENTAL *a, const char *type)
{
	if (((eoddata1__FUNDAMENTAL*)a)->Symbol)
		soap_set_attr(soap, "Symbol", ((eoddata1__FUNDAMENTAL*)a)->Symbol->c_str(), 1);
	if (((eoddata1__FUNDAMENTAL*)a)->Name)
		soap_set_attr(soap, "Name", ((eoddata1__FUNDAMENTAL*)a)->Name->c_str(), 1);
	if (((eoddata1__FUNDAMENTAL*)a)->Description)
		soap_set_attr(soap, "Description", ((eoddata1__FUNDAMENTAL*)a)->Description->c_str(), 1);
	soap_set_attr(soap, "DateTime", soap_dateTime2s(soap, ((eoddata1__FUNDAMENTAL*)a)->DateTime), 1);
	if (((eoddata1__FUNDAMENTAL*)a)->Industry)
		soap_set_attr(soap, "Industry", ((eoddata1__FUNDAMENTAL*)a)->Industry->c_str(), 1);
	if (((eoddata1__FUNDAMENTAL*)a)->Sector)
		soap_set_attr(soap, "Sector", ((eoddata1__FUNDAMENTAL*)a)->Sector->c_str(), 1);
	soap_set_attr(soap, "Shares", soap_LONG642s(soap, ((eoddata1__FUNDAMENTAL*)a)->Shares), 1);
	soap_set_attr(soap, "MarketCap", soap_LONG642s(soap, ((eoddata1__FUNDAMENTAL*)a)->MarketCap), 1);
	soap_set_attr(soap, "PE", soap_double2s(soap, ((eoddata1__FUNDAMENTAL*)a)->PE), 1);
	soap_set_attr(soap, "EPS", soap_double2s(soap, ((eoddata1__FUNDAMENTAL*)a)->EPS), 1);
	soap_set_attr(soap, "NTA", soap_double2s(soap, ((eoddata1__FUNDAMENTAL*)a)->NTA), 1);
	soap_set_attr(soap, "DivYield", soap_double2s(soap, ((eoddata1__FUNDAMENTAL*)a)->DivYield), 1);
	soap_set_attr(soap, "Dividend", soap_double2s(soap, ((eoddata1__FUNDAMENTAL*)a)->Dividend), 1);
	soap_set_attr(soap, "DividendDate", soap_dateTime2s(soap, ((eoddata1__FUNDAMENTAL*)a)->DividendDate), 1);
	soap_set_attr(soap, "DPS", soap_double2s(soap, ((eoddata1__FUNDAMENTAL*)a)->DPS), 1);
	soap_set_attr(soap, "ImputationCredits", soap_double2s(soap, ((eoddata1__FUNDAMENTAL*)a)->ImputationCredits), 1);
	soap_set_attr(soap, "EBITDA", soap_double2s(soap, ((eoddata1__FUNDAMENTAL*)a)->EBITDA), 1);
	soap_set_attr(soap, "PEG", soap_double2s(soap, ((eoddata1__FUNDAMENTAL*)a)->PEG), 1);
	soap_set_attr(soap, "PtS", soap_double2s(soap, ((eoddata1__FUNDAMENTAL*)a)->PtS), 1);
	soap_set_attr(soap, "PtB", soap_double2s(soap, ((eoddata1__FUNDAMENTAL*)a)->PtB), 1);
	soap_set_attr(soap, "Yield", soap_double2s(soap, ((eoddata1__FUNDAMENTAL*)a)->Yield), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata_eoddata1__FUNDAMENTAL), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *eoddata1__FUNDAMENTAL::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_eoddata1__FUNDAMENTAL(soap, tag, this, type);
}

SOAP_FMAC3 eoddata1__FUNDAMENTAL * SOAP_FMAC4 soap_in_eoddata1__FUNDAMENTAL(struct soap *soap, const char *tag, eoddata1__FUNDAMENTAL *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (eoddata1__FUNDAMENTAL *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata_eoddata1__FUNDAMENTAL, sizeof(eoddata1__FUNDAMENTAL), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	{	const char *t = soap_attr_value(soap, "Symbol", 0);
		if (t)
		{
			if (!(((eoddata1__FUNDAMENTAL*)a)->Symbol = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__FUNDAMENTAL*)a)->Symbol, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Name", 0);
		if (t)
		{
			if (!(((eoddata1__FUNDAMENTAL*)a)->Name = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__FUNDAMENTAL*)a)->Name, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Description", 0);
		if (t)
		{
			if (!(((eoddata1__FUNDAMENTAL*)a)->Description = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__FUNDAMENTAL*)a)->Description, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2dateTime(soap, soap_attr_value(soap, "DateTime", 1), &((eoddata1__FUNDAMENTAL*)a)->DateTime))
		return NULL;
	{	const char *t = soap_attr_value(soap, "Industry", 0);
		if (t)
		{
			if (!(((eoddata1__FUNDAMENTAL*)a)->Industry = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__FUNDAMENTAL*)a)->Industry, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Sector", 0);
		if (t)
		{
			if (!(((eoddata1__FUNDAMENTAL*)a)->Sector = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__FUNDAMENTAL*)a)->Sector, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2LONG64(soap, soap_attr_value(soap, "Shares", 1), &((eoddata1__FUNDAMENTAL*)a)->Shares))
		return NULL;
	if (soap_s2LONG64(soap, soap_attr_value(soap, "MarketCap", 1), &((eoddata1__FUNDAMENTAL*)a)->MarketCap))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "PE", 1), &((eoddata1__FUNDAMENTAL*)a)->PE))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "EPS", 1), &((eoddata1__FUNDAMENTAL*)a)->EPS))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "NTA", 1), &((eoddata1__FUNDAMENTAL*)a)->NTA))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "DivYield", 1), &((eoddata1__FUNDAMENTAL*)a)->DivYield))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "Dividend", 1), &((eoddata1__FUNDAMENTAL*)a)->Dividend))
		return NULL;
	if (soap_s2dateTime(soap, soap_attr_value(soap, "DividendDate", 1), &((eoddata1__FUNDAMENTAL*)a)->DividendDate))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "DPS", 1), &((eoddata1__FUNDAMENTAL*)a)->DPS))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "ImputationCredits", 1), &((eoddata1__FUNDAMENTAL*)a)->ImputationCredits))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "EBITDA", 1), &((eoddata1__FUNDAMENTAL*)a)->EBITDA))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "PEG", 1), &((eoddata1__FUNDAMENTAL*)a)->PEG))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "PtS", 1), &((eoddata1__FUNDAMENTAL*)a)->PtS))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "PtB", 1), &((eoddata1__FUNDAMENTAL*)a)->PtB))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "Yield", 1), &((eoddata1__FUNDAMENTAL*)a)->Yield))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (eoddata1__FUNDAMENTAL *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata_eoddata1__FUNDAMENTAL, SOAP_TYPE_eoddata_eoddata1__FUNDAMENTAL, sizeof(eoddata1__FUNDAMENTAL), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 eoddata1__FUNDAMENTAL * SOAP_FMAC2 soap_instantiate_eoddata1__FUNDAMENTAL(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_eoddata1__FUNDAMENTAL(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	eoddata1__FUNDAMENTAL *p;
	size_t k = sizeof(eoddata1__FUNDAMENTAL);
	if (n < 0)
	{	p = SOAP_NEW(eoddata1__FUNDAMENTAL);
		if (p)
			((eoddata1__FUNDAMENTAL*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(eoddata1__FUNDAMENTAL, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((eoddata1__FUNDAMENTAL*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated eoddata1__FUNDAMENTAL location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata_eoddata1__FUNDAMENTAL, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int eoddata1__FUNDAMENTAL::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:FUNDAMENTAL", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *eoddata1__FUNDAMENTAL::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_eoddata1__FUNDAMENTAL(soap, this, tag, type);
}

SOAP_FMAC3 eoddata1__FUNDAMENTAL * SOAP_FMAC4 soap_get_eoddata1__FUNDAMENTAL(struct soap *soap, eoddata1__FUNDAMENTAL *p, const char *tag, const char *type)
{
	if ((p = soap_in_eoddata1__FUNDAMENTAL(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void eoddata1__ArrayOfFUNDAMENTAL::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToeoddata1__FUNDAMENTAL(soap, &this->eoddata1__ArrayOfFUNDAMENTAL::FUNDAMENTAL);
	/* transient soap skipped */
}

void eoddata1__ArrayOfFUNDAMENTAL::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerToeoddata1__FUNDAMENTAL(soap, &this->eoddata1__ArrayOfFUNDAMENTAL::FUNDAMENTAL);
#endif
}

int eoddata1__ArrayOfFUNDAMENTAL::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_eoddata1__ArrayOfFUNDAMENTAL(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_eoddata1__ArrayOfFUNDAMENTAL(struct soap *soap, const char *tag, int id, const eoddata1__ArrayOfFUNDAMENTAL *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata_eoddata1__ArrayOfFUNDAMENTAL), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToeoddata1__FUNDAMENTAL(soap, "eoddata1:FUNDAMENTAL", -1, &a->eoddata1__ArrayOfFUNDAMENTAL::FUNDAMENTAL, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *eoddata1__ArrayOfFUNDAMENTAL::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_eoddata1__ArrayOfFUNDAMENTAL(soap, tag, this, type);
}

SOAP_FMAC3 eoddata1__ArrayOfFUNDAMENTAL * SOAP_FMAC4 soap_in_eoddata1__ArrayOfFUNDAMENTAL(struct soap *soap, const char *tag, eoddata1__ArrayOfFUNDAMENTAL *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (eoddata1__ArrayOfFUNDAMENTAL *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata_eoddata1__ArrayOfFUNDAMENTAL, sizeof(eoddata1__ArrayOfFUNDAMENTAL), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerToeoddata1__FUNDAMENTAL(soap, "eoddata1:FUNDAMENTAL", &a->eoddata1__ArrayOfFUNDAMENTAL::FUNDAMENTAL, "eoddata1:FUNDAMENTAL"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (eoddata1__ArrayOfFUNDAMENTAL *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata_eoddata1__ArrayOfFUNDAMENTAL, SOAP_TYPE_eoddata_eoddata1__ArrayOfFUNDAMENTAL, sizeof(eoddata1__ArrayOfFUNDAMENTAL), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 eoddata1__ArrayOfFUNDAMENTAL * SOAP_FMAC2 soap_instantiate_eoddata1__ArrayOfFUNDAMENTAL(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_eoddata1__ArrayOfFUNDAMENTAL(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	eoddata1__ArrayOfFUNDAMENTAL *p;
	size_t k = sizeof(eoddata1__ArrayOfFUNDAMENTAL);
	if (n < 0)
	{	p = SOAP_NEW(eoddata1__ArrayOfFUNDAMENTAL);
		if (p)
			((eoddata1__ArrayOfFUNDAMENTAL*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(eoddata1__ArrayOfFUNDAMENTAL, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((eoddata1__ArrayOfFUNDAMENTAL*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated eoddata1__ArrayOfFUNDAMENTAL location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata_eoddata1__ArrayOfFUNDAMENTAL, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int eoddata1__ArrayOfFUNDAMENTAL::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:ArrayOfFUNDAMENTAL", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *eoddata1__ArrayOfFUNDAMENTAL::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_eoddata1__ArrayOfFUNDAMENTAL(soap, this, tag, type);
}

SOAP_FMAC3 eoddata1__ArrayOfFUNDAMENTAL * SOAP_FMAC4 soap_get_eoddata1__ArrayOfFUNDAMENTAL(struct soap *soap, eoddata1__ArrayOfFUNDAMENTAL *p, const char *tag, const char *type)
{
	if ((p = soap_in_eoddata1__ArrayOfFUNDAMENTAL(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void eoddata1__CountryBase::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->eoddata1__CountryBase::Code = NULL;
	this->eoddata1__CountryBase::Name = NULL;
	/* transient soap skipped */
}

void eoddata1__CountryBase::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int eoddata1__CountryBase::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_eoddata1__CountryBase(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_eoddata1__CountryBase(struct soap *soap, const char *tag, int id, const eoddata1__CountryBase *a, const char *type)
{
	if (((eoddata1__CountryBase*)a)->Code)
		soap_set_attr(soap, "Code", ((eoddata1__CountryBase*)a)->Code->c_str(), 1);
	if (((eoddata1__CountryBase*)a)->Name)
		soap_set_attr(soap, "Name", ((eoddata1__CountryBase*)a)->Name->c_str(), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata_eoddata1__CountryBase), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *eoddata1__CountryBase::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_eoddata1__CountryBase(soap, tag, this, type);
}

SOAP_FMAC3 eoddata1__CountryBase * SOAP_FMAC4 soap_in_eoddata1__CountryBase(struct soap *soap, const char *tag, eoddata1__CountryBase *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (eoddata1__CountryBase *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata_eoddata1__CountryBase, sizeof(eoddata1__CountryBase), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	{	const char *t = soap_attr_value(soap, "Code", 0);
		if (t)
		{
			if (!(((eoddata1__CountryBase*)a)->Code = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__CountryBase*)a)->Code, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Name", 0);
		if (t)
		{
			if (!(((eoddata1__CountryBase*)a)->Name = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__CountryBase*)a)->Name, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (eoddata1__CountryBase *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata_eoddata1__CountryBase, SOAP_TYPE_eoddata_eoddata1__CountryBase, sizeof(eoddata1__CountryBase), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 eoddata1__CountryBase * SOAP_FMAC2 soap_instantiate_eoddata1__CountryBase(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_eoddata1__CountryBase(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	eoddata1__CountryBase *p;
	size_t k = sizeof(eoddata1__CountryBase);
	if (n < 0)
	{	p = SOAP_NEW(eoddata1__CountryBase);
		if (p)
			((eoddata1__CountryBase*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(eoddata1__CountryBase, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((eoddata1__CountryBase*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated eoddata1__CountryBase location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata_eoddata1__CountryBase, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int eoddata1__CountryBase::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:CountryBase", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *eoddata1__CountryBase::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_eoddata1__CountryBase(soap, this, tag, type);
}

SOAP_FMAC3 eoddata1__CountryBase * SOAP_FMAC4 soap_get_eoddata1__CountryBase(struct soap *soap, eoddata1__CountryBase *p, const char *tag, const char *type)
{
	if ((p = soap_in_eoddata1__CountryBase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void eoddata1__ArrayOfCountryBase::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToeoddata1__CountryBase(soap, &this->eoddata1__ArrayOfCountryBase::CountryBase);
	/* transient soap skipped */
}

void eoddata1__ArrayOfCountryBase::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerToeoddata1__CountryBase(soap, &this->eoddata1__ArrayOfCountryBase::CountryBase);
#endif
}

int eoddata1__ArrayOfCountryBase::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_eoddata1__ArrayOfCountryBase(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_eoddata1__ArrayOfCountryBase(struct soap *soap, const char *tag, int id, const eoddata1__ArrayOfCountryBase *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata_eoddata1__ArrayOfCountryBase), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToeoddata1__CountryBase(soap, "eoddata1:CountryBase", -1, &a->eoddata1__ArrayOfCountryBase::CountryBase, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *eoddata1__ArrayOfCountryBase::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_eoddata1__ArrayOfCountryBase(soap, tag, this, type);
}

SOAP_FMAC3 eoddata1__ArrayOfCountryBase * SOAP_FMAC4 soap_in_eoddata1__ArrayOfCountryBase(struct soap *soap, const char *tag, eoddata1__ArrayOfCountryBase *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (eoddata1__ArrayOfCountryBase *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata_eoddata1__ArrayOfCountryBase, sizeof(eoddata1__ArrayOfCountryBase), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerToeoddata1__CountryBase(soap, "eoddata1:CountryBase", &a->eoddata1__ArrayOfCountryBase::CountryBase, "eoddata1:CountryBase"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (eoddata1__ArrayOfCountryBase *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata_eoddata1__ArrayOfCountryBase, SOAP_TYPE_eoddata_eoddata1__ArrayOfCountryBase, sizeof(eoddata1__ArrayOfCountryBase), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 eoddata1__ArrayOfCountryBase * SOAP_FMAC2 soap_instantiate_eoddata1__ArrayOfCountryBase(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_eoddata1__ArrayOfCountryBase(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	eoddata1__ArrayOfCountryBase *p;
	size_t k = sizeof(eoddata1__ArrayOfCountryBase);
	if (n < 0)
	{	p = SOAP_NEW(eoddata1__ArrayOfCountryBase);
		if (p)
			((eoddata1__ArrayOfCountryBase*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(eoddata1__ArrayOfCountryBase, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((eoddata1__ArrayOfCountryBase*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated eoddata1__ArrayOfCountryBase location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata_eoddata1__ArrayOfCountryBase, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int eoddata1__ArrayOfCountryBase::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:ArrayOfCountryBase", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *eoddata1__ArrayOfCountryBase::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_eoddata1__ArrayOfCountryBase(soap, this, tag, type);
}

SOAP_FMAC3 eoddata1__ArrayOfCountryBase * SOAP_FMAC4 soap_get_eoddata1__ArrayOfCountryBase(struct soap *soap, eoddata1__ArrayOfCountryBase *p, const char *tag, const char *type)
{
	if ((p = soap_in_eoddata1__ArrayOfCountryBase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void eoddata1__SPLIT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->eoddata1__SPLIT::Exchange = NULL;
	this->eoddata1__SPLIT::Symbol = NULL;
	soap_default_dateTime(soap, &this->eoddata1__SPLIT::DateTime);
	this->eoddata1__SPLIT::Ratio = NULL;
	/* transient soap skipped */
}

void eoddata1__SPLIT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int eoddata1__SPLIT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_eoddata1__SPLIT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_eoddata1__SPLIT(struct soap *soap, const char *tag, int id, const eoddata1__SPLIT *a, const char *type)
{
	if (((eoddata1__SPLIT*)a)->Exchange)
		soap_set_attr(soap, "Exchange", ((eoddata1__SPLIT*)a)->Exchange->c_str(), 1);
	if (((eoddata1__SPLIT*)a)->Symbol)
		soap_set_attr(soap, "Symbol", ((eoddata1__SPLIT*)a)->Symbol->c_str(), 1);
	soap_set_attr(soap, "DateTime", soap_dateTime2s(soap, ((eoddata1__SPLIT*)a)->DateTime), 1);
	if (((eoddata1__SPLIT*)a)->Ratio)
		soap_set_attr(soap, "Ratio", ((eoddata1__SPLIT*)a)->Ratio->c_str(), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata_eoddata1__SPLIT), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *eoddata1__SPLIT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_eoddata1__SPLIT(soap, tag, this, type);
}

SOAP_FMAC3 eoddata1__SPLIT * SOAP_FMAC4 soap_in_eoddata1__SPLIT(struct soap *soap, const char *tag, eoddata1__SPLIT *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (eoddata1__SPLIT *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata_eoddata1__SPLIT, sizeof(eoddata1__SPLIT), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	{	const char *t = soap_attr_value(soap, "Exchange", 0);
		if (t)
		{
			if (!(((eoddata1__SPLIT*)a)->Exchange = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__SPLIT*)a)->Exchange, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Symbol", 0);
		if (t)
		{
			if (!(((eoddata1__SPLIT*)a)->Symbol = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__SPLIT*)a)->Symbol, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2dateTime(soap, soap_attr_value(soap, "DateTime", 1), &((eoddata1__SPLIT*)a)->DateTime))
		return NULL;
	{	const char *t = soap_attr_value(soap, "Ratio", 0);
		if (t)
		{
			if (!(((eoddata1__SPLIT*)a)->Ratio = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__SPLIT*)a)->Ratio, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (eoddata1__SPLIT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata_eoddata1__SPLIT, SOAP_TYPE_eoddata_eoddata1__SPLIT, sizeof(eoddata1__SPLIT), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 eoddata1__SPLIT * SOAP_FMAC2 soap_instantiate_eoddata1__SPLIT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_eoddata1__SPLIT(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	eoddata1__SPLIT *p;
	size_t k = sizeof(eoddata1__SPLIT);
	if (n < 0)
	{	p = SOAP_NEW(eoddata1__SPLIT);
		if (p)
			((eoddata1__SPLIT*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(eoddata1__SPLIT, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((eoddata1__SPLIT*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated eoddata1__SPLIT location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata_eoddata1__SPLIT, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int eoddata1__SPLIT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:SPLIT", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *eoddata1__SPLIT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_eoddata1__SPLIT(soap, this, tag, type);
}

SOAP_FMAC3 eoddata1__SPLIT * SOAP_FMAC4 soap_get_eoddata1__SPLIT(struct soap *soap, eoddata1__SPLIT *p, const char *tag, const char *type)
{
	if ((p = soap_in_eoddata1__SPLIT(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void eoddata1__ArrayOfSPLIT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToeoddata1__SPLIT(soap, &this->eoddata1__ArrayOfSPLIT::SPLIT);
	/* transient soap skipped */
}

void eoddata1__ArrayOfSPLIT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerToeoddata1__SPLIT(soap, &this->eoddata1__ArrayOfSPLIT::SPLIT);
#endif
}

int eoddata1__ArrayOfSPLIT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_eoddata1__ArrayOfSPLIT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_eoddata1__ArrayOfSPLIT(struct soap *soap, const char *tag, int id, const eoddata1__ArrayOfSPLIT *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata_eoddata1__ArrayOfSPLIT), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToeoddata1__SPLIT(soap, "eoddata1:SPLIT", -1, &a->eoddata1__ArrayOfSPLIT::SPLIT, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *eoddata1__ArrayOfSPLIT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_eoddata1__ArrayOfSPLIT(soap, tag, this, type);
}

SOAP_FMAC3 eoddata1__ArrayOfSPLIT * SOAP_FMAC4 soap_in_eoddata1__ArrayOfSPLIT(struct soap *soap, const char *tag, eoddata1__ArrayOfSPLIT *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (eoddata1__ArrayOfSPLIT *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata_eoddata1__ArrayOfSPLIT, sizeof(eoddata1__ArrayOfSPLIT), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerToeoddata1__SPLIT(soap, "eoddata1:SPLIT", &a->eoddata1__ArrayOfSPLIT::SPLIT, "eoddata1:SPLIT"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (eoddata1__ArrayOfSPLIT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata_eoddata1__ArrayOfSPLIT, SOAP_TYPE_eoddata_eoddata1__ArrayOfSPLIT, sizeof(eoddata1__ArrayOfSPLIT), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 eoddata1__ArrayOfSPLIT * SOAP_FMAC2 soap_instantiate_eoddata1__ArrayOfSPLIT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_eoddata1__ArrayOfSPLIT(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	eoddata1__ArrayOfSPLIT *p;
	size_t k = sizeof(eoddata1__ArrayOfSPLIT);
	if (n < 0)
	{	p = SOAP_NEW(eoddata1__ArrayOfSPLIT);
		if (p)
			((eoddata1__ArrayOfSPLIT*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(eoddata1__ArrayOfSPLIT, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((eoddata1__ArrayOfSPLIT*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated eoddata1__ArrayOfSPLIT location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata_eoddata1__ArrayOfSPLIT, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int eoddata1__ArrayOfSPLIT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:ArrayOfSPLIT", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *eoddata1__ArrayOfSPLIT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_eoddata1__ArrayOfSPLIT(soap, this, tag, type);
}

SOAP_FMAC3 eoddata1__ArrayOfSPLIT * SOAP_FMAC4 soap_get_eoddata1__ArrayOfSPLIT(struct soap *soap, eoddata1__ArrayOfSPLIT *p, const char *tag, const char *type)
{
	if ((p = soap_in_eoddata1__ArrayOfSPLIT(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void eoddata1__QUOTE2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->eoddata1__QUOTE2::s = NULL;
	soap_default_dateTime(soap, &this->eoddata1__QUOTE2::d);
	soap_default_double(soap, &this->eoddata1__QUOTE2::o);
	soap_default_double(soap, &this->eoddata1__QUOTE2::h);
	soap_default_double(soap, &this->eoddata1__QUOTE2::l);
	soap_default_double(soap, &this->eoddata1__QUOTE2::c);
	soap_default_LONG64(soap, &this->eoddata1__QUOTE2::v);
	soap_default_LONG64(soap, &this->eoddata1__QUOTE2::i);
	soap_default_double(soap, &this->eoddata1__QUOTE2::b);
	soap_default_double(soap, &this->eoddata1__QUOTE2::a);
	/* transient soap skipped */
}

void eoddata1__QUOTE2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int eoddata1__QUOTE2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_eoddata1__QUOTE2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_eoddata1__QUOTE2(struct soap *soap, const char *tag, int id, const eoddata1__QUOTE2 *a, const char *type)
{
	if (((eoddata1__QUOTE2*)a)->s)
		soap_set_attr(soap, "s", ((eoddata1__QUOTE2*)a)->s->c_str(), 1);
	soap_set_attr(soap, "d", soap_dateTime2s(soap, ((eoddata1__QUOTE2*)a)->d), 1);
	soap_set_attr(soap, "o", soap_double2s(soap, ((eoddata1__QUOTE2*)a)->o), 1);
	soap_set_attr(soap, "h", soap_double2s(soap, ((eoddata1__QUOTE2*)a)->h), 1);
	soap_set_attr(soap, "l", soap_double2s(soap, ((eoddata1__QUOTE2*)a)->l), 1);
	soap_set_attr(soap, "c", soap_double2s(soap, ((eoddata1__QUOTE2*)a)->c), 1);
	soap_set_attr(soap, "v", soap_LONG642s(soap, ((eoddata1__QUOTE2*)a)->v), 1);
	soap_set_attr(soap, "i", soap_LONG642s(soap, ((eoddata1__QUOTE2*)a)->i), 1);
	soap_set_attr(soap, "b", soap_double2s(soap, ((eoddata1__QUOTE2*)a)->b), 1);
	soap_set_attr(soap, "a", soap_double2s(soap, ((eoddata1__QUOTE2*)a)->a), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata_eoddata1__QUOTE2), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *eoddata1__QUOTE2::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_eoddata1__QUOTE2(soap, tag, this, type);
}

SOAP_FMAC3 eoddata1__QUOTE2 * SOAP_FMAC4 soap_in_eoddata1__QUOTE2(struct soap *soap, const char *tag, eoddata1__QUOTE2 *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (eoddata1__QUOTE2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata_eoddata1__QUOTE2, sizeof(eoddata1__QUOTE2), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	{	const char *t = soap_attr_value(soap, "s", 0);
		if (t)
		{
			if (!(((eoddata1__QUOTE2*)a)->s = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__QUOTE2*)a)->s, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2dateTime(soap, soap_attr_value(soap, "d", 1), &((eoddata1__QUOTE2*)a)->d))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "o", 1), &((eoddata1__QUOTE2*)a)->o))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "h", 1), &((eoddata1__QUOTE2*)a)->h))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "l", 1), &((eoddata1__QUOTE2*)a)->l))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "c", 1), &((eoddata1__QUOTE2*)a)->c))
		return NULL;
	if (soap_s2LONG64(soap, soap_attr_value(soap, "v", 1), &((eoddata1__QUOTE2*)a)->v))
		return NULL;
	if (soap_s2LONG64(soap, soap_attr_value(soap, "i", 1), &((eoddata1__QUOTE2*)a)->i))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "b", 1), &((eoddata1__QUOTE2*)a)->b))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "a", 1), &((eoddata1__QUOTE2*)a)->a))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (eoddata1__QUOTE2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata_eoddata1__QUOTE2, SOAP_TYPE_eoddata_eoddata1__QUOTE2, sizeof(eoddata1__QUOTE2), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 eoddata1__QUOTE2 * SOAP_FMAC2 soap_instantiate_eoddata1__QUOTE2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_eoddata1__QUOTE2(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	eoddata1__QUOTE2 *p;
	size_t k = sizeof(eoddata1__QUOTE2);
	if (n < 0)
	{	p = SOAP_NEW(eoddata1__QUOTE2);
		if (p)
			((eoddata1__QUOTE2*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(eoddata1__QUOTE2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((eoddata1__QUOTE2*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated eoddata1__QUOTE2 location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata_eoddata1__QUOTE2, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int eoddata1__QUOTE2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:QUOTE2", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *eoddata1__QUOTE2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_eoddata1__QUOTE2(soap, this, tag, type);
}

SOAP_FMAC3 eoddata1__QUOTE2 * SOAP_FMAC4 soap_get_eoddata1__QUOTE2(struct soap *soap, eoddata1__QUOTE2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_eoddata1__QUOTE2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void eoddata1__ArrayOfQUOTE2::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToeoddata1__QUOTE2(soap, &this->eoddata1__ArrayOfQUOTE2::QUOTE2);
	/* transient soap skipped */
}

void eoddata1__ArrayOfQUOTE2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerToeoddata1__QUOTE2(soap, &this->eoddata1__ArrayOfQUOTE2::QUOTE2);
#endif
}

int eoddata1__ArrayOfQUOTE2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_eoddata1__ArrayOfQUOTE2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_eoddata1__ArrayOfQUOTE2(struct soap *soap, const char *tag, int id, const eoddata1__ArrayOfQUOTE2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata_eoddata1__ArrayOfQUOTE2), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToeoddata1__QUOTE2(soap, "eoddata1:QUOTE2", -1, &a->eoddata1__ArrayOfQUOTE2::QUOTE2, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *eoddata1__ArrayOfQUOTE2::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_eoddata1__ArrayOfQUOTE2(soap, tag, this, type);
}

SOAP_FMAC3 eoddata1__ArrayOfQUOTE2 * SOAP_FMAC4 soap_in_eoddata1__ArrayOfQUOTE2(struct soap *soap, const char *tag, eoddata1__ArrayOfQUOTE2 *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (eoddata1__ArrayOfQUOTE2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata_eoddata1__ArrayOfQUOTE2, sizeof(eoddata1__ArrayOfQUOTE2), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerToeoddata1__QUOTE2(soap, "eoddata1:QUOTE2", &a->eoddata1__ArrayOfQUOTE2::QUOTE2, "eoddata1:QUOTE2"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (eoddata1__ArrayOfQUOTE2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata_eoddata1__ArrayOfQUOTE2, SOAP_TYPE_eoddata_eoddata1__ArrayOfQUOTE2, sizeof(eoddata1__ArrayOfQUOTE2), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 eoddata1__ArrayOfQUOTE2 * SOAP_FMAC2 soap_instantiate_eoddata1__ArrayOfQUOTE2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_eoddata1__ArrayOfQUOTE2(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	eoddata1__ArrayOfQUOTE2 *p;
	size_t k = sizeof(eoddata1__ArrayOfQUOTE2);
	if (n < 0)
	{	p = SOAP_NEW(eoddata1__ArrayOfQUOTE2);
		if (p)
			((eoddata1__ArrayOfQUOTE2*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(eoddata1__ArrayOfQUOTE2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((eoddata1__ArrayOfQUOTE2*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated eoddata1__ArrayOfQUOTE2 location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata_eoddata1__ArrayOfQUOTE2, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int eoddata1__ArrayOfQUOTE2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:ArrayOfQUOTE2", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *eoddata1__ArrayOfQUOTE2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_eoddata1__ArrayOfQUOTE2(soap, this, tag, type);
}

SOAP_FMAC3 eoddata1__ArrayOfQUOTE2 * SOAP_FMAC4 soap_get_eoddata1__ArrayOfQUOTE2(struct soap *soap, eoddata1__ArrayOfQUOTE2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_eoddata1__ArrayOfQUOTE2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void eoddata1__ArrayOfQUOTE::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToeoddata1__QUOTE(soap, &this->eoddata1__ArrayOfQUOTE::QUOTE);
	/* transient soap skipped */
}

void eoddata1__ArrayOfQUOTE::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerToeoddata1__QUOTE(soap, &this->eoddata1__ArrayOfQUOTE::QUOTE);
#endif
}

int eoddata1__ArrayOfQUOTE::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_eoddata1__ArrayOfQUOTE(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_eoddata1__ArrayOfQUOTE(struct soap *soap, const char *tag, int id, const eoddata1__ArrayOfQUOTE *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata_eoddata1__ArrayOfQUOTE), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToeoddata1__QUOTE(soap, "eoddata1:QUOTE", -1, &a->eoddata1__ArrayOfQUOTE::QUOTE, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *eoddata1__ArrayOfQUOTE::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_eoddata1__ArrayOfQUOTE(soap, tag, this, type);
}

SOAP_FMAC3 eoddata1__ArrayOfQUOTE * SOAP_FMAC4 soap_in_eoddata1__ArrayOfQUOTE(struct soap *soap, const char *tag, eoddata1__ArrayOfQUOTE *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (eoddata1__ArrayOfQUOTE *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata_eoddata1__ArrayOfQUOTE, sizeof(eoddata1__ArrayOfQUOTE), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerToeoddata1__QUOTE(soap, "eoddata1:QUOTE", &a->eoddata1__ArrayOfQUOTE::QUOTE, "eoddata1:QUOTE"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (eoddata1__ArrayOfQUOTE *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata_eoddata1__ArrayOfQUOTE, SOAP_TYPE_eoddata_eoddata1__ArrayOfQUOTE, sizeof(eoddata1__ArrayOfQUOTE), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 eoddata1__ArrayOfQUOTE * SOAP_FMAC2 soap_instantiate_eoddata1__ArrayOfQUOTE(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_eoddata1__ArrayOfQUOTE(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	eoddata1__ArrayOfQUOTE *p;
	size_t k = sizeof(eoddata1__ArrayOfQUOTE);
	if (n < 0)
	{	p = SOAP_NEW(eoddata1__ArrayOfQUOTE);
		if (p)
			((eoddata1__ArrayOfQUOTE*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(eoddata1__ArrayOfQUOTE, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((eoddata1__ArrayOfQUOTE*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated eoddata1__ArrayOfQUOTE location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata_eoddata1__ArrayOfQUOTE, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int eoddata1__ArrayOfQUOTE::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:ArrayOfQUOTE", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *eoddata1__ArrayOfQUOTE::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_eoddata1__ArrayOfQUOTE(soap, this, tag, type);
}

SOAP_FMAC3 eoddata1__ArrayOfQUOTE * SOAP_FMAC4 soap_get_eoddata1__ArrayOfQUOTE(struct soap *soap, eoddata1__ArrayOfQUOTE *p, const char *tag, const char *type)
{
	if ((p = soap_in_eoddata1__ArrayOfQUOTE(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void eoddata1__QUOTE::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->eoddata1__QUOTE::Symbol = NULL;
	this->eoddata1__QUOTE::Description = NULL;
	this->eoddata1__QUOTE::Name = NULL;
	soap_default_dateTime(soap, &this->eoddata1__QUOTE::DateTime);
	soap_default_double(soap, &this->eoddata1__QUOTE::Open);
	soap_default_double(soap, &this->eoddata1__QUOTE::High);
	soap_default_double(soap, &this->eoddata1__QUOTE::Low);
	soap_default_double(soap, &this->eoddata1__QUOTE::Close);
	soap_default_LONG64(soap, &this->eoddata1__QUOTE::Volume);
	soap_default_LONG64(soap, &this->eoddata1__QUOTE::OpenInterest);
	soap_default_double(soap, &this->eoddata1__QUOTE::Previous);
	soap_default_double(soap, &this->eoddata1__QUOTE::Change);
	soap_default_double(soap, &this->eoddata1__QUOTE::Bid);
	soap_default_double(soap, &this->eoddata1__QUOTE::Ask);
	soap_default_double(soap, &this->eoddata1__QUOTE::PreviousClose);
	soap_default_double(soap, &this->eoddata1__QUOTE::NextOpen);
	soap_default_dateTime(soap, &this->eoddata1__QUOTE::Modified);
	/* transient soap skipped */
}

void eoddata1__QUOTE::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int eoddata1__QUOTE::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_eoddata1__QUOTE(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_eoddata1__QUOTE(struct soap *soap, const char *tag, int id, const eoddata1__QUOTE *a, const char *type)
{
	if (((eoddata1__QUOTE*)a)->Symbol)
		soap_set_attr(soap, "Symbol", ((eoddata1__QUOTE*)a)->Symbol->c_str(), 1);
	if (((eoddata1__QUOTE*)a)->Description)
		soap_set_attr(soap, "Description", ((eoddata1__QUOTE*)a)->Description->c_str(), 1);
	if (((eoddata1__QUOTE*)a)->Name)
		soap_set_attr(soap, "Name", ((eoddata1__QUOTE*)a)->Name->c_str(), 1);
	soap_set_attr(soap, "DateTime", soap_dateTime2s(soap, ((eoddata1__QUOTE*)a)->DateTime), 1);
	soap_set_attr(soap, "Open", soap_double2s(soap, ((eoddata1__QUOTE*)a)->Open), 1);
	soap_set_attr(soap, "High", soap_double2s(soap, ((eoddata1__QUOTE*)a)->High), 1);
	soap_set_attr(soap, "Low", soap_double2s(soap, ((eoddata1__QUOTE*)a)->Low), 1);
	soap_set_attr(soap, "Close", soap_double2s(soap, ((eoddata1__QUOTE*)a)->Close), 1);
	soap_set_attr(soap, "Volume", soap_LONG642s(soap, ((eoddata1__QUOTE*)a)->Volume), 1);
	soap_set_attr(soap, "OpenInterest", soap_LONG642s(soap, ((eoddata1__QUOTE*)a)->OpenInterest), 1);
	soap_set_attr(soap, "Previous", soap_double2s(soap, ((eoddata1__QUOTE*)a)->Previous), 1);
	soap_set_attr(soap, "Change", soap_double2s(soap, ((eoddata1__QUOTE*)a)->Change), 1);
	soap_set_attr(soap, "Bid", soap_double2s(soap, ((eoddata1__QUOTE*)a)->Bid), 1);
	soap_set_attr(soap, "Ask", soap_double2s(soap, ((eoddata1__QUOTE*)a)->Ask), 1);
	soap_set_attr(soap, "PreviousClose", soap_double2s(soap, ((eoddata1__QUOTE*)a)->PreviousClose), 1);
	soap_set_attr(soap, "NextOpen", soap_double2s(soap, ((eoddata1__QUOTE*)a)->NextOpen), 1);
	soap_set_attr(soap, "Modified", soap_dateTime2s(soap, ((eoddata1__QUOTE*)a)->Modified), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata_eoddata1__QUOTE), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *eoddata1__QUOTE::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_eoddata1__QUOTE(soap, tag, this, type);
}

SOAP_FMAC3 eoddata1__QUOTE * SOAP_FMAC4 soap_in_eoddata1__QUOTE(struct soap *soap, const char *tag, eoddata1__QUOTE *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (eoddata1__QUOTE *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata_eoddata1__QUOTE, sizeof(eoddata1__QUOTE), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	{	const char *t = soap_attr_value(soap, "Symbol", 0);
		if (t)
		{
			if (!(((eoddata1__QUOTE*)a)->Symbol = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__QUOTE*)a)->Symbol, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Description", 0);
		if (t)
		{
			if (!(((eoddata1__QUOTE*)a)->Description = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__QUOTE*)a)->Description, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Name", 0);
		if (t)
		{
			if (!(((eoddata1__QUOTE*)a)->Name = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__QUOTE*)a)->Name, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2dateTime(soap, soap_attr_value(soap, "DateTime", 1), &((eoddata1__QUOTE*)a)->DateTime))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "Open", 1), &((eoddata1__QUOTE*)a)->Open))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "High", 1), &((eoddata1__QUOTE*)a)->High))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "Low", 1), &((eoddata1__QUOTE*)a)->Low))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "Close", 1), &((eoddata1__QUOTE*)a)->Close))
		return NULL;
	if (soap_s2LONG64(soap, soap_attr_value(soap, "Volume", 1), &((eoddata1__QUOTE*)a)->Volume))
		return NULL;
	if (soap_s2LONG64(soap, soap_attr_value(soap, "OpenInterest", 1), &((eoddata1__QUOTE*)a)->OpenInterest))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "Previous", 1), &((eoddata1__QUOTE*)a)->Previous))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "Change", 1), &((eoddata1__QUOTE*)a)->Change))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "Bid", 1), &((eoddata1__QUOTE*)a)->Bid))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "Ask", 1), &((eoddata1__QUOTE*)a)->Ask))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "PreviousClose", 1), &((eoddata1__QUOTE*)a)->PreviousClose))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "NextOpen", 1), &((eoddata1__QUOTE*)a)->NextOpen))
		return NULL;
	if (soap_s2dateTime(soap, soap_attr_value(soap, "Modified", 1), &((eoddata1__QUOTE*)a)->Modified))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (eoddata1__QUOTE *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata_eoddata1__QUOTE, SOAP_TYPE_eoddata_eoddata1__QUOTE, sizeof(eoddata1__QUOTE), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 eoddata1__QUOTE * SOAP_FMAC2 soap_instantiate_eoddata1__QUOTE(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_eoddata1__QUOTE(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	eoddata1__QUOTE *p;
	size_t k = sizeof(eoddata1__QUOTE);
	if (n < 0)
	{	p = SOAP_NEW(eoddata1__QUOTE);
		if (p)
			((eoddata1__QUOTE*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(eoddata1__QUOTE, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((eoddata1__QUOTE*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated eoddata1__QUOTE location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata_eoddata1__QUOTE, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int eoddata1__QUOTE::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:QUOTE", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *eoddata1__QUOTE::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_eoddata1__QUOTE(soap, this, tag, type);
}

SOAP_FMAC3 eoddata1__QUOTE * SOAP_FMAC4 soap_get_eoddata1__QUOTE(struct soap *soap, eoddata1__QUOTE *p, const char *tag, const char *type)
{
	if ((p = soap_in_eoddata1__QUOTE(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void eoddata1__SYMBOL2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->eoddata1__SYMBOL2::c = NULL;
	this->eoddata1__SYMBOL2::n = NULL;
	/* transient soap skipped */
}

void eoddata1__SYMBOL2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int eoddata1__SYMBOL2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_eoddata1__SYMBOL2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_eoddata1__SYMBOL2(struct soap *soap, const char *tag, int id, const eoddata1__SYMBOL2 *a, const char *type)
{
	if (((eoddata1__SYMBOL2*)a)->c)
		soap_set_attr(soap, "c", ((eoddata1__SYMBOL2*)a)->c->c_str(), 1);
	if (((eoddata1__SYMBOL2*)a)->n)
		soap_set_attr(soap, "n", ((eoddata1__SYMBOL2*)a)->n->c_str(), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata_eoddata1__SYMBOL2), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *eoddata1__SYMBOL2::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_eoddata1__SYMBOL2(soap, tag, this, type);
}

SOAP_FMAC3 eoddata1__SYMBOL2 * SOAP_FMAC4 soap_in_eoddata1__SYMBOL2(struct soap *soap, const char *tag, eoddata1__SYMBOL2 *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (eoddata1__SYMBOL2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata_eoddata1__SYMBOL2, sizeof(eoddata1__SYMBOL2), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	{	const char *t = soap_attr_value(soap, "c", 0);
		if (t)
		{
			if (!(((eoddata1__SYMBOL2*)a)->c = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__SYMBOL2*)a)->c, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "n", 0);
		if (t)
		{
			if (!(((eoddata1__SYMBOL2*)a)->n = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__SYMBOL2*)a)->n, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (eoddata1__SYMBOL2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata_eoddata1__SYMBOL2, SOAP_TYPE_eoddata_eoddata1__SYMBOL2, sizeof(eoddata1__SYMBOL2), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 eoddata1__SYMBOL2 * SOAP_FMAC2 soap_instantiate_eoddata1__SYMBOL2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_eoddata1__SYMBOL2(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	eoddata1__SYMBOL2 *p;
	size_t k = sizeof(eoddata1__SYMBOL2);
	if (n < 0)
	{	p = SOAP_NEW(eoddata1__SYMBOL2);
		if (p)
			((eoddata1__SYMBOL2*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(eoddata1__SYMBOL2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((eoddata1__SYMBOL2*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated eoddata1__SYMBOL2 location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata_eoddata1__SYMBOL2, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int eoddata1__SYMBOL2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:SYMBOL2", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *eoddata1__SYMBOL2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_eoddata1__SYMBOL2(soap, this, tag, type);
}

SOAP_FMAC3 eoddata1__SYMBOL2 * SOAP_FMAC4 soap_get_eoddata1__SYMBOL2(struct soap *soap, eoddata1__SYMBOL2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_eoddata1__SYMBOL2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void eoddata1__ArrayOfSYMBOL2::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToeoddata1__SYMBOL2(soap, &this->eoddata1__ArrayOfSYMBOL2::SYMBOL2);
	/* transient soap skipped */
}

void eoddata1__ArrayOfSYMBOL2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerToeoddata1__SYMBOL2(soap, &this->eoddata1__ArrayOfSYMBOL2::SYMBOL2);
#endif
}

int eoddata1__ArrayOfSYMBOL2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_eoddata1__ArrayOfSYMBOL2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_eoddata1__ArrayOfSYMBOL2(struct soap *soap, const char *tag, int id, const eoddata1__ArrayOfSYMBOL2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata_eoddata1__ArrayOfSYMBOL2), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToeoddata1__SYMBOL2(soap, "eoddata1:SYMBOL2", -1, &a->eoddata1__ArrayOfSYMBOL2::SYMBOL2, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *eoddata1__ArrayOfSYMBOL2::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_eoddata1__ArrayOfSYMBOL2(soap, tag, this, type);
}

SOAP_FMAC3 eoddata1__ArrayOfSYMBOL2 * SOAP_FMAC4 soap_in_eoddata1__ArrayOfSYMBOL2(struct soap *soap, const char *tag, eoddata1__ArrayOfSYMBOL2 *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (eoddata1__ArrayOfSYMBOL2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata_eoddata1__ArrayOfSYMBOL2, sizeof(eoddata1__ArrayOfSYMBOL2), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerToeoddata1__SYMBOL2(soap, "eoddata1:SYMBOL2", &a->eoddata1__ArrayOfSYMBOL2::SYMBOL2, "eoddata1:SYMBOL2"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (eoddata1__ArrayOfSYMBOL2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata_eoddata1__ArrayOfSYMBOL2, SOAP_TYPE_eoddata_eoddata1__ArrayOfSYMBOL2, sizeof(eoddata1__ArrayOfSYMBOL2), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 eoddata1__ArrayOfSYMBOL2 * SOAP_FMAC2 soap_instantiate_eoddata1__ArrayOfSYMBOL2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_eoddata1__ArrayOfSYMBOL2(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	eoddata1__ArrayOfSYMBOL2 *p;
	size_t k = sizeof(eoddata1__ArrayOfSYMBOL2);
	if (n < 0)
	{	p = SOAP_NEW(eoddata1__ArrayOfSYMBOL2);
		if (p)
			((eoddata1__ArrayOfSYMBOL2*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(eoddata1__ArrayOfSYMBOL2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((eoddata1__ArrayOfSYMBOL2*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated eoddata1__ArrayOfSYMBOL2 location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata_eoddata1__ArrayOfSYMBOL2, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int eoddata1__ArrayOfSYMBOL2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:ArrayOfSYMBOL2", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *eoddata1__ArrayOfSYMBOL2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_eoddata1__ArrayOfSYMBOL2(soap, this, tag, type);
}

SOAP_FMAC3 eoddata1__ArrayOfSYMBOL2 * SOAP_FMAC4 soap_get_eoddata1__ArrayOfSYMBOL2(struct soap *soap, eoddata1__ArrayOfSYMBOL2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_eoddata1__ArrayOfSYMBOL2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void eoddata1__ArrayOfSYMBOL::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToeoddata1__SYMBOL(soap, &this->eoddata1__ArrayOfSYMBOL::SYMBOL);
	/* transient soap skipped */
}

void eoddata1__ArrayOfSYMBOL::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerToeoddata1__SYMBOL(soap, &this->eoddata1__ArrayOfSYMBOL::SYMBOL);
#endif
}

int eoddata1__ArrayOfSYMBOL::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_eoddata1__ArrayOfSYMBOL(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_eoddata1__ArrayOfSYMBOL(struct soap *soap, const char *tag, int id, const eoddata1__ArrayOfSYMBOL *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata_eoddata1__ArrayOfSYMBOL), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToeoddata1__SYMBOL(soap, "eoddata1:SYMBOL", -1, &a->eoddata1__ArrayOfSYMBOL::SYMBOL, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *eoddata1__ArrayOfSYMBOL::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_eoddata1__ArrayOfSYMBOL(soap, tag, this, type);
}

SOAP_FMAC3 eoddata1__ArrayOfSYMBOL * SOAP_FMAC4 soap_in_eoddata1__ArrayOfSYMBOL(struct soap *soap, const char *tag, eoddata1__ArrayOfSYMBOL *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (eoddata1__ArrayOfSYMBOL *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata_eoddata1__ArrayOfSYMBOL, sizeof(eoddata1__ArrayOfSYMBOL), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerToeoddata1__SYMBOL(soap, "eoddata1:SYMBOL", &a->eoddata1__ArrayOfSYMBOL::SYMBOL, "eoddata1:SYMBOL"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (eoddata1__ArrayOfSYMBOL *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata_eoddata1__ArrayOfSYMBOL, SOAP_TYPE_eoddata_eoddata1__ArrayOfSYMBOL, sizeof(eoddata1__ArrayOfSYMBOL), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 eoddata1__ArrayOfSYMBOL * SOAP_FMAC2 soap_instantiate_eoddata1__ArrayOfSYMBOL(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_eoddata1__ArrayOfSYMBOL(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	eoddata1__ArrayOfSYMBOL *p;
	size_t k = sizeof(eoddata1__ArrayOfSYMBOL);
	if (n < 0)
	{	p = SOAP_NEW(eoddata1__ArrayOfSYMBOL);
		if (p)
			((eoddata1__ArrayOfSYMBOL*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(eoddata1__ArrayOfSYMBOL, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((eoddata1__ArrayOfSYMBOL*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated eoddata1__ArrayOfSYMBOL location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata_eoddata1__ArrayOfSYMBOL, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int eoddata1__ArrayOfSYMBOL::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:ArrayOfSYMBOL", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *eoddata1__ArrayOfSYMBOL::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_eoddata1__ArrayOfSYMBOL(soap, this, tag, type);
}

SOAP_FMAC3 eoddata1__ArrayOfSYMBOL * SOAP_FMAC4 soap_get_eoddata1__ArrayOfSYMBOL(struct soap *soap, eoddata1__ArrayOfSYMBOL *p, const char *tag, const char *type)
{
	if ((p = soap_in_eoddata1__ArrayOfSYMBOL(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void eoddata1__SYMBOL::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->eoddata1__SYMBOL::Code = NULL;
	this->eoddata1__SYMBOL::Name = NULL;
	this->eoddata1__SYMBOL::LongName = NULL;
	soap_default_dateTime(soap, &this->eoddata1__SYMBOL::DateTime);
	/* transient soap skipped */
}

void eoddata1__SYMBOL::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int eoddata1__SYMBOL::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_eoddata1__SYMBOL(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_eoddata1__SYMBOL(struct soap *soap, const char *tag, int id, const eoddata1__SYMBOL *a, const char *type)
{
	if (((eoddata1__SYMBOL*)a)->Code)
		soap_set_attr(soap, "Code", ((eoddata1__SYMBOL*)a)->Code->c_str(), 1);
	if (((eoddata1__SYMBOL*)a)->Name)
		soap_set_attr(soap, "Name", ((eoddata1__SYMBOL*)a)->Name->c_str(), 1);
	if (((eoddata1__SYMBOL*)a)->LongName)
		soap_set_attr(soap, "LongName", ((eoddata1__SYMBOL*)a)->LongName->c_str(), 1);
	soap_set_attr(soap, "DateTime", soap_dateTime2s(soap, ((eoddata1__SYMBOL*)a)->DateTime), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata_eoddata1__SYMBOL), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *eoddata1__SYMBOL::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_eoddata1__SYMBOL(soap, tag, this, type);
}

SOAP_FMAC3 eoddata1__SYMBOL * SOAP_FMAC4 soap_in_eoddata1__SYMBOL(struct soap *soap, const char *tag, eoddata1__SYMBOL *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (eoddata1__SYMBOL *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata_eoddata1__SYMBOL, sizeof(eoddata1__SYMBOL), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	{	const char *t = soap_attr_value(soap, "Code", 0);
		if (t)
		{
			if (!(((eoddata1__SYMBOL*)a)->Code = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__SYMBOL*)a)->Code, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Name", 0);
		if (t)
		{
			if (!(((eoddata1__SYMBOL*)a)->Name = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__SYMBOL*)a)->Name, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "LongName", 0);
		if (t)
		{
			if (!(((eoddata1__SYMBOL*)a)->LongName = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__SYMBOL*)a)->LongName, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2dateTime(soap, soap_attr_value(soap, "DateTime", 1), &((eoddata1__SYMBOL*)a)->DateTime))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (eoddata1__SYMBOL *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata_eoddata1__SYMBOL, SOAP_TYPE_eoddata_eoddata1__SYMBOL, sizeof(eoddata1__SYMBOL), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 eoddata1__SYMBOL * SOAP_FMAC2 soap_instantiate_eoddata1__SYMBOL(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_eoddata1__SYMBOL(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	eoddata1__SYMBOL *p;
	size_t k = sizeof(eoddata1__SYMBOL);
	if (n < 0)
	{	p = SOAP_NEW(eoddata1__SYMBOL);
		if (p)
			((eoddata1__SYMBOL*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(eoddata1__SYMBOL, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((eoddata1__SYMBOL*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated eoddata1__SYMBOL location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata_eoddata1__SYMBOL, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int eoddata1__SYMBOL::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:SYMBOL", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *eoddata1__SYMBOL::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_eoddata1__SYMBOL(soap, this, tag, type);
}

SOAP_FMAC3 eoddata1__SYMBOL * SOAP_FMAC4 soap_get_eoddata1__SYMBOL(struct soap *soap, eoddata1__SYMBOL *p, const char *tag, const char *type)
{
	if ((p = soap_in_eoddata1__SYMBOL(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void eoddata1__ArrayOfEXCHANGE::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToeoddata1__EXCHANGE(soap, &this->eoddata1__ArrayOfEXCHANGE::EXCHANGE);
	/* transient soap skipped */
}

void eoddata1__ArrayOfEXCHANGE::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerToeoddata1__EXCHANGE(soap, &this->eoddata1__ArrayOfEXCHANGE::EXCHANGE);
#endif
}

int eoddata1__ArrayOfEXCHANGE::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_eoddata1__ArrayOfEXCHANGE(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_eoddata1__ArrayOfEXCHANGE(struct soap *soap, const char *tag, int id, const eoddata1__ArrayOfEXCHANGE *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata_eoddata1__ArrayOfEXCHANGE), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToeoddata1__EXCHANGE(soap, "eoddata1:EXCHANGE", -1, &a->eoddata1__ArrayOfEXCHANGE::EXCHANGE, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *eoddata1__ArrayOfEXCHANGE::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_eoddata1__ArrayOfEXCHANGE(soap, tag, this, type);
}

SOAP_FMAC3 eoddata1__ArrayOfEXCHANGE * SOAP_FMAC4 soap_in_eoddata1__ArrayOfEXCHANGE(struct soap *soap, const char *tag, eoddata1__ArrayOfEXCHANGE *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (eoddata1__ArrayOfEXCHANGE *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata_eoddata1__ArrayOfEXCHANGE, sizeof(eoddata1__ArrayOfEXCHANGE), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerToeoddata1__EXCHANGE(soap, "eoddata1:EXCHANGE", &a->eoddata1__ArrayOfEXCHANGE::EXCHANGE, "eoddata1:EXCHANGE"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (eoddata1__ArrayOfEXCHANGE *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata_eoddata1__ArrayOfEXCHANGE, SOAP_TYPE_eoddata_eoddata1__ArrayOfEXCHANGE, sizeof(eoddata1__ArrayOfEXCHANGE), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 eoddata1__ArrayOfEXCHANGE * SOAP_FMAC2 soap_instantiate_eoddata1__ArrayOfEXCHANGE(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_eoddata1__ArrayOfEXCHANGE(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	eoddata1__ArrayOfEXCHANGE *p;
	size_t k = sizeof(eoddata1__ArrayOfEXCHANGE);
	if (n < 0)
	{	p = SOAP_NEW(eoddata1__ArrayOfEXCHANGE);
		if (p)
			((eoddata1__ArrayOfEXCHANGE*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(eoddata1__ArrayOfEXCHANGE, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((eoddata1__ArrayOfEXCHANGE*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated eoddata1__ArrayOfEXCHANGE location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata_eoddata1__ArrayOfEXCHANGE, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int eoddata1__ArrayOfEXCHANGE::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:ArrayOfEXCHANGE", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *eoddata1__ArrayOfEXCHANGE::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_eoddata1__ArrayOfEXCHANGE(soap, this, tag, type);
}

SOAP_FMAC3 eoddata1__ArrayOfEXCHANGE * SOAP_FMAC4 soap_get_eoddata1__ArrayOfEXCHANGE(struct soap *soap, eoddata1__ArrayOfEXCHANGE *p, const char *tag, const char *type)
{
	if ((p = soap_in_eoddata1__ArrayOfEXCHANGE(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void eoddata1__EXCHANGE::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->eoddata1__EXCHANGE::Code = NULL;
	this->eoddata1__EXCHANGE::Name = NULL;
	soap_default_dateTime(soap, &this->eoddata1__EXCHANGE::LastTradeDateTime);
	this->eoddata1__EXCHANGE::Country = NULL;
	this->eoddata1__EXCHANGE::Currency = NULL;
	soap_default_int(soap, &this->eoddata1__EXCHANGE::Advances);
	soap_default_int(soap, &this->eoddata1__EXCHANGE::Declines);
	this->eoddata1__EXCHANGE::Suffix = NULL;
	this->eoddata1__EXCHANGE::TimeZone = NULL;
	soap_default_bool(soap, &this->eoddata1__EXCHANGE::IsIntraday);
	soap_default_dateTime(soap, &this->eoddata1__EXCHANGE::IntradayStartDate);
	soap_default_bool(soap, &this->eoddata1__EXCHANGE::HasIntradayProduct);
	/* transient soap skipped */
}

void eoddata1__EXCHANGE::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int eoddata1__EXCHANGE::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_eoddata1__EXCHANGE(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_eoddata1__EXCHANGE(struct soap *soap, const char *tag, int id, const eoddata1__EXCHANGE *a, const char *type)
{
	if (((eoddata1__EXCHANGE*)a)->Code)
		soap_set_attr(soap, "Code", ((eoddata1__EXCHANGE*)a)->Code->c_str(), 1);
	if (((eoddata1__EXCHANGE*)a)->Name)
		soap_set_attr(soap, "Name", ((eoddata1__EXCHANGE*)a)->Name->c_str(), 1);
	soap_set_attr(soap, "LastTradeDateTime", soap_dateTime2s(soap, ((eoddata1__EXCHANGE*)a)->LastTradeDateTime), 1);
	if (((eoddata1__EXCHANGE*)a)->Country)
		soap_set_attr(soap, "Country", ((eoddata1__EXCHANGE*)a)->Country->c_str(), 1);
	if (((eoddata1__EXCHANGE*)a)->Currency)
		soap_set_attr(soap, "Currency", ((eoddata1__EXCHANGE*)a)->Currency->c_str(), 1);
	soap_set_attr(soap, "Advances", soap_int2s(soap, ((eoddata1__EXCHANGE*)a)->Advances), 1);
	soap_set_attr(soap, "Declines", soap_int2s(soap, ((eoddata1__EXCHANGE*)a)->Declines), 1);
	if (((eoddata1__EXCHANGE*)a)->Suffix)
		soap_set_attr(soap, "Suffix", ((eoddata1__EXCHANGE*)a)->Suffix->c_str(), 1);
	if (((eoddata1__EXCHANGE*)a)->TimeZone)
		soap_set_attr(soap, "TimeZone", ((eoddata1__EXCHANGE*)a)->TimeZone->c_str(), 1);
	soap_set_attr(soap, "IsIntraday", soap_bool2s(soap, ((eoddata1__EXCHANGE*)a)->IsIntraday), 1);
	soap_set_attr(soap, "IntradayStartDate", soap_dateTime2s(soap, ((eoddata1__EXCHANGE*)a)->IntradayStartDate), 1);
	soap_set_attr(soap, "HasIntradayProduct", soap_bool2s(soap, ((eoddata1__EXCHANGE*)a)->HasIntradayProduct), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata_eoddata1__EXCHANGE), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *eoddata1__EXCHANGE::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_eoddata1__EXCHANGE(soap, tag, this, type);
}

SOAP_FMAC3 eoddata1__EXCHANGE * SOAP_FMAC4 soap_in_eoddata1__EXCHANGE(struct soap *soap, const char *tag, eoddata1__EXCHANGE *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (eoddata1__EXCHANGE *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata_eoddata1__EXCHANGE, sizeof(eoddata1__EXCHANGE), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	{	const char *t = soap_attr_value(soap, "Code", 0);
		if (t)
		{
			if (!(((eoddata1__EXCHANGE*)a)->Code = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__EXCHANGE*)a)->Code, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Name", 0);
		if (t)
		{
			if (!(((eoddata1__EXCHANGE*)a)->Name = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__EXCHANGE*)a)->Name, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2dateTime(soap, soap_attr_value(soap, "LastTradeDateTime", 1), &((eoddata1__EXCHANGE*)a)->LastTradeDateTime))
		return NULL;
	{	const char *t = soap_attr_value(soap, "Country", 0);
		if (t)
		{
			if (!(((eoddata1__EXCHANGE*)a)->Country = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__EXCHANGE*)a)->Country, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Currency", 0);
		if (t)
		{
			if (!(((eoddata1__EXCHANGE*)a)->Currency = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__EXCHANGE*)a)->Currency, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2int(soap, soap_attr_value(soap, "Advances", 1), &((eoddata1__EXCHANGE*)a)->Advances))
		return NULL;
	if (soap_s2int(soap, soap_attr_value(soap, "Declines", 1), &((eoddata1__EXCHANGE*)a)->Declines))
		return NULL;
	{	const char *t = soap_attr_value(soap, "Suffix", 0);
		if (t)
		{
			if (!(((eoddata1__EXCHANGE*)a)->Suffix = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__EXCHANGE*)a)->Suffix, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "TimeZone", 0);
		if (t)
		{
			if (!(((eoddata1__EXCHANGE*)a)->TimeZone = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__EXCHANGE*)a)->TimeZone, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2bool(soap, soap_attr_value(soap, "IsIntraday", 1), &((eoddata1__EXCHANGE*)a)->IsIntraday))
		return NULL;
	if (soap_s2dateTime(soap, soap_attr_value(soap, "IntradayStartDate", 1), &((eoddata1__EXCHANGE*)a)->IntradayStartDate))
		return NULL;
	if (soap_s2bool(soap, soap_attr_value(soap, "HasIntradayProduct", 1), &((eoddata1__EXCHANGE*)a)->HasIntradayProduct))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (eoddata1__EXCHANGE *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata_eoddata1__EXCHANGE, SOAP_TYPE_eoddata_eoddata1__EXCHANGE, sizeof(eoddata1__EXCHANGE), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 eoddata1__EXCHANGE * SOAP_FMAC2 soap_instantiate_eoddata1__EXCHANGE(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_eoddata1__EXCHANGE(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	eoddata1__EXCHANGE *p;
	size_t k = sizeof(eoddata1__EXCHANGE);
	if (n < 0)
	{	p = SOAP_NEW(eoddata1__EXCHANGE);
		if (p)
			((eoddata1__EXCHANGE*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(eoddata1__EXCHANGE, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((eoddata1__EXCHANGE*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated eoddata1__EXCHANGE location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata_eoddata1__EXCHANGE, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int eoddata1__EXCHANGE::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:EXCHANGE", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *eoddata1__EXCHANGE::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_eoddata1__EXCHANGE(soap, this, tag, type);
}

SOAP_FMAC3 eoddata1__EXCHANGE * SOAP_FMAC4 soap_get_eoddata1__EXCHANGE(struct soap *soap, eoddata1__EXCHANGE *p, const char *tag, const char *type)
{
	if ((p = soap_in_eoddata1__EXCHANGE(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void eoddata1__RESPONSE::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->eoddata1__RESPONSE::EXCHANGE = NULL;
	this->eoddata1__RESPONSE::EXCHANGES = NULL;
	this->eoddata1__RESPONSE::SYMBOL = NULL;
	this->eoddata1__RESPONSE::SYMBOLS = NULL;
	this->eoddata1__RESPONSE::SYMBOLS2 = NULL;
	this->eoddata1__RESPONSE::QUOTE = NULL;
	this->eoddata1__RESPONSE::QUOTES = NULL;
	this->eoddata1__RESPONSE::QUOTES2 = NULL;
	this->eoddata1__RESPONSE::SPLITS = NULL;
	this->eoddata1__RESPONSE::COUNTRIES = NULL;
	this->eoddata1__RESPONSE::FUNDAMENTALS = NULL;
	this->eoddata1__RESPONSE::TECHNICALS = NULL;
	this->eoddata1__RESPONSE::SYMBOLCHANGES = NULL;
	this->eoddata1__RESPONSE::NEWSLIST = NULL;
	this->eoddata1__RESPONSE::CHART = NULL;
	this->eoddata1__RESPONSE::MEMBERSHIP = NULL;
	this->eoddata1__RESPONSE::VERSION = NULL;
	this->eoddata1__RESPONSE::MONTHS = NULL;
	this->eoddata1__RESPONSE::DATAFORMATS = NULL;
	this->eoddata1__RESPONSE::Source = NULL;
	this->eoddata1__RESPONSE::Message = NULL;
	soap_default_dateTime(soap, &this->eoddata1__RESPONSE::Date);
	/* transient soap skipped */
}

void eoddata1__RESPONSE::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToeoddata1__EXCHANGE(soap, &this->eoddata1__RESPONSE::EXCHANGE);
	soap_serialize_PointerToeoddata1__ArrayOfEXCHANGE(soap, &this->eoddata1__RESPONSE::EXCHANGES);
	soap_serialize_PointerToeoddata1__SYMBOL(soap, &this->eoddata1__RESPONSE::SYMBOL);
	soap_serialize_PointerToeoddata1__ArrayOfSYMBOL(soap, &this->eoddata1__RESPONSE::SYMBOLS);
	soap_serialize_PointerToeoddata1__ArrayOfSYMBOL2(soap, &this->eoddata1__RESPONSE::SYMBOLS2);
	soap_serialize_PointerToeoddata1__QUOTE(soap, &this->eoddata1__RESPONSE::QUOTE);
	soap_serialize_PointerToeoddata1__ArrayOfQUOTE(soap, &this->eoddata1__RESPONSE::QUOTES);
	soap_serialize_PointerToeoddata1__ArrayOfQUOTE2(soap, &this->eoddata1__RESPONSE::QUOTES2);
	soap_serialize_PointerToeoddata1__ArrayOfSPLIT(soap, &this->eoddata1__RESPONSE::SPLITS);
	soap_serialize_PointerToeoddata1__ArrayOfCountryBase(soap, &this->eoddata1__RESPONSE::COUNTRIES);
	soap_serialize_PointerToeoddata1__ArrayOfFUNDAMENTAL(soap, &this->eoddata1__RESPONSE::FUNDAMENTALS);
	soap_serialize_PointerToeoddata1__ArrayOfTECHNICAL(soap, &this->eoddata1__RESPONSE::TECHNICALS);
	soap_serialize_PointerToeoddata1__ArrayOfSYMBOLCHANGE(soap, &this->eoddata1__RESPONSE::SYMBOLCHANGES);
	soap_serialize_PointerToeoddata1__ArrayOfNEWS(soap, &this->eoddata1__RESPONSE::NEWSLIST);
	soap_serialize_PointerTostd__string(soap, &this->eoddata1__RESPONSE::CHART);
	soap_serialize_PointerTostd__string(soap, &this->eoddata1__RESPONSE::MEMBERSHIP);
	soap_serialize_PointerTostd__string(soap, &this->eoddata1__RESPONSE::VERSION);
	soap_serialize_PointerTostd__string(soap, &this->eoddata1__RESPONSE::MONTHS);
	soap_serialize_PointerToeoddata1__ArrayOfDATAFORMAT(soap, &this->eoddata1__RESPONSE::DATAFORMATS);
#endif
}

int eoddata1__RESPONSE::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_eoddata1__RESPONSE(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_eoddata1__RESPONSE(struct soap *soap, const char *tag, int id, const eoddata1__RESPONSE *a, const char *type)
{
	if (((eoddata1__RESPONSE*)a)->Source)
		soap_set_attr(soap, "Source", ((eoddata1__RESPONSE*)a)->Source->c_str(), 1);
	if (((eoddata1__RESPONSE*)a)->Message)
		soap_set_attr(soap, "Message", ((eoddata1__RESPONSE*)a)->Message->c_str(), 1);
	soap_set_attr(soap, "Date", soap_dateTime2s(soap, ((eoddata1__RESPONSE*)a)->Date), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata_eoddata1__RESPONSE), type))
		return soap->error;
	if (soap_out_PointerToeoddata1__EXCHANGE(soap, "eoddata1:EXCHANGE", -1, &a->eoddata1__RESPONSE::EXCHANGE, ""))
		return soap->error;
	if (soap_out_PointerToeoddata1__ArrayOfEXCHANGE(soap, "eoddata1:EXCHANGES", -1, &a->eoddata1__RESPONSE::EXCHANGES, ""))
		return soap->error;
	if (soap_out_PointerToeoddata1__SYMBOL(soap, "eoddata1:SYMBOL", -1, &a->eoddata1__RESPONSE::SYMBOL, ""))
		return soap->error;
	if (soap_out_PointerToeoddata1__ArrayOfSYMBOL(soap, "eoddata1:SYMBOLS", -1, &a->eoddata1__RESPONSE::SYMBOLS, ""))
		return soap->error;
	if (soap_out_PointerToeoddata1__ArrayOfSYMBOL2(soap, "eoddata1:SYMBOLS2", -1, &a->eoddata1__RESPONSE::SYMBOLS2, ""))
		return soap->error;
	if (soap_out_PointerToeoddata1__QUOTE(soap, "eoddata1:QUOTE", -1, &a->eoddata1__RESPONSE::QUOTE, ""))
		return soap->error;
	if (soap_out_PointerToeoddata1__ArrayOfQUOTE(soap, "eoddata1:QUOTES", -1, &a->eoddata1__RESPONSE::QUOTES, ""))
		return soap->error;
	if (soap_out_PointerToeoddata1__ArrayOfQUOTE2(soap, "eoddata1:QUOTES2", -1, &a->eoddata1__RESPONSE::QUOTES2, ""))
		return soap->error;
	if (soap_out_PointerToeoddata1__ArrayOfSPLIT(soap, "eoddata1:SPLITS", -1, &a->eoddata1__RESPONSE::SPLITS, ""))
		return soap->error;
	if (soap_out_PointerToeoddata1__ArrayOfCountryBase(soap, "eoddata1:COUNTRIES", -1, &a->eoddata1__RESPONSE::COUNTRIES, ""))
		return soap->error;
	if (soap_out_PointerToeoddata1__ArrayOfFUNDAMENTAL(soap, "eoddata1:FUNDAMENTALS", -1, &a->eoddata1__RESPONSE::FUNDAMENTALS, ""))
		return soap->error;
	if (soap_out_PointerToeoddata1__ArrayOfTECHNICAL(soap, "eoddata1:TECHNICALS", -1, &a->eoddata1__RESPONSE::TECHNICALS, ""))
		return soap->error;
	if (soap_out_PointerToeoddata1__ArrayOfSYMBOLCHANGE(soap, "eoddata1:SYMBOLCHANGES", -1, &a->eoddata1__RESPONSE::SYMBOLCHANGES, ""))
		return soap->error;
	if (soap_out_PointerToeoddata1__ArrayOfNEWS(soap, "eoddata1:NEWSLIST", -1, &a->eoddata1__RESPONSE::NEWSLIST, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:CHART", -1, &a->eoddata1__RESPONSE::CHART, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:MEMBERSHIP", -1, &a->eoddata1__RESPONSE::MEMBERSHIP, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:VERSION", -1, &a->eoddata1__RESPONSE::VERSION, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eoddata1:MONTHS", -1, &a->eoddata1__RESPONSE::MONTHS, ""))
		return soap->error;
	if (soap_out_PointerToeoddata1__ArrayOfDATAFORMAT(soap, "eoddata1:DATAFORMATS", -1, &a->eoddata1__RESPONSE::DATAFORMATS, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *eoddata1__RESPONSE::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_eoddata1__RESPONSE(soap, tag, this, type);
}

SOAP_FMAC3 eoddata1__RESPONSE * SOAP_FMAC4 soap_in_eoddata1__RESPONSE(struct soap *soap, const char *tag, eoddata1__RESPONSE *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (eoddata1__RESPONSE *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata_eoddata1__RESPONSE, sizeof(eoddata1__RESPONSE), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	{	const char *t = soap_attr_value(soap, "Source", 0);
		if (t)
		{
			if (!(((eoddata1__RESPONSE*)a)->Source = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__RESPONSE*)a)->Source, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Message", 0);
		if (t)
		{
			if (!(((eoddata1__RESPONSE*)a)->Message = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__RESPONSE*)a)->Message, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2dateTime(soap, soap_attr_value(soap, "Date", 1), &((eoddata1__RESPONSE*)a)->Date))
		return NULL;
	size_t soap_flag_EXCHANGE1 = 1;
	size_t soap_flag_EXCHANGES1 = 1;
	size_t soap_flag_SYMBOL1 = 1;
	size_t soap_flag_SYMBOLS1 = 1;
	size_t soap_flag_SYMBOLS21 = 1;
	size_t soap_flag_QUOTE1 = 1;
	size_t soap_flag_QUOTES1 = 1;
	size_t soap_flag_QUOTES21 = 1;
	size_t soap_flag_SPLITS1 = 1;
	size_t soap_flag_COUNTRIES1 = 1;
	size_t soap_flag_FUNDAMENTALS1 = 1;
	size_t soap_flag_TECHNICALS1 = 1;
	size_t soap_flag_SYMBOLCHANGES1 = 1;
	size_t soap_flag_NEWSLIST1 = 1;
	size_t soap_flag_CHART1 = 1;
	size_t soap_flag_MEMBERSHIP1 = 1;
	size_t soap_flag_VERSION1 = 1;
	size_t soap_flag_MONTHS1 = 1;
	size_t soap_flag_DATAFORMATS1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EXCHANGE1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToeoddata1__EXCHANGE(soap, "eoddata1:EXCHANGE", &a->eoddata1__RESPONSE::EXCHANGE, "eoddata1:EXCHANGE"))
				{	soap_flag_EXCHANGE1--;
					continue;
				}
			if (soap_flag_EXCHANGES1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToeoddata1__ArrayOfEXCHANGE(soap, "eoddata1:EXCHANGES", &a->eoddata1__RESPONSE::EXCHANGES, "eoddata1:ArrayOfEXCHANGE"))
				{	soap_flag_EXCHANGES1--;
					continue;
				}
			if (soap_flag_SYMBOL1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToeoddata1__SYMBOL(soap, "eoddata1:SYMBOL", &a->eoddata1__RESPONSE::SYMBOL, "eoddata1:SYMBOL"))
				{	soap_flag_SYMBOL1--;
					continue;
				}
			if (soap_flag_SYMBOLS1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToeoddata1__ArrayOfSYMBOL(soap, "eoddata1:SYMBOLS", &a->eoddata1__RESPONSE::SYMBOLS, "eoddata1:ArrayOfSYMBOL"))
				{	soap_flag_SYMBOLS1--;
					continue;
				}
			if (soap_flag_SYMBOLS21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToeoddata1__ArrayOfSYMBOL2(soap, "eoddata1:SYMBOLS2", &a->eoddata1__RESPONSE::SYMBOLS2, "eoddata1:ArrayOfSYMBOL2"))
				{	soap_flag_SYMBOLS21--;
					continue;
				}
			if (soap_flag_QUOTE1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToeoddata1__QUOTE(soap, "eoddata1:QUOTE", &a->eoddata1__RESPONSE::QUOTE, "eoddata1:QUOTE"))
				{	soap_flag_QUOTE1--;
					continue;
				}
			if (soap_flag_QUOTES1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToeoddata1__ArrayOfQUOTE(soap, "eoddata1:QUOTES", &a->eoddata1__RESPONSE::QUOTES, "eoddata1:ArrayOfQUOTE"))
				{	soap_flag_QUOTES1--;
					continue;
				}
			if (soap_flag_QUOTES21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToeoddata1__ArrayOfQUOTE2(soap, "eoddata1:QUOTES2", &a->eoddata1__RESPONSE::QUOTES2, "eoddata1:ArrayOfQUOTE2"))
				{	soap_flag_QUOTES21--;
					continue;
				}
			if (soap_flag_SPLITS1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToeoddata1__ArrayOfSPLIT(soap, "eoddata1:SPLITS", &a->eoddata1__RESPONSE::SPLITS, "eoddata1:ArrayOfSPLIT"))
				{	soap_flag_SPLITS1--;
					continue;
				}
			if (soap_flag_COUNTRIES1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToeoddata1__ArrayOfCountryBase(soap, "eoddata1:COUNTRIES", &a->eoddata1__RESPONSE::COUNTRIES, "eoddata1:ArrayOfCountryBase"))
				{	soap_flag_COUNTRIES1--;
					continue;
				}
			if (soap_flag_FUNDAMENTALS1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToeoddata1__ArrayOfFUNDAMENTAL(soap, "eoddata1:FUNDAMENTALS", &a->eoddata1__RESPONSE::FUNDAMENTALS, "eoddata1:ArrayOfFUNDAMENTAL"))
				{	soap_flag_FUNDAMENTALS1--;
					continue;
				}
			if (soap_flag_TECHNICALS1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToeoddata1__ArrayOfTECHNICAL(soap, "eoddata1:TECHNICALS", &a->eoddata1__RESPONSE::TECHNICALS, "eoddata1:ArrayOfTECHNICAL"))
				{	soap_flag_TECHNICALS1--;
					continue;
				}
			if (soap_flag_SYMBOLCHANGES1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToeoddata1__ArrayOfSYMBOLCHANGE(soap, "eoddata1:SYMBOLCHANGES", &a->eoddata1__RESPONSE::SYMBOLCHANGES, "eoddata1:ArrayOfSYMBOLCHANGE"))
				{	soap_flag_SYMBOLCHANGES1--;
					continue;
				}
			if (soap_flag_NEWSLIST1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToeoddata1__ArrayOfNEWS(soap, "eoddata1:NEWSLIST", &a->eoddata1__RESPONSE::NEWSLIST, "eoddata1:ArrayOfNEWS"))
				{	soap_flag_NEWSLIST1--;
					continue;
				}
			if (soap_flag_CHART1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:CHART", &a->eoddata1__RESPONSE::CHART, "xsd:string"))
				{	soap_flag_CHART1--;
					continue;
				}
			if (soap_flag_MEMBERSHIP1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:MEMBERSHIP", &a->eoddata1__RESPONSE::MEMBERSHIP, "xsd:string"))
				{	soap_flag_MEMBERSHIP1--;
					continue;
				}
			if (soap_flag_VERSION1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:VERSION", &a->eoddata1__RESPONSE::VERSION, "xsd:string"))
				{	soap_flag_VERSION1--;
					continue;
				}
			if (soap_flag_MONTHS1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eoddata1:MONTHS", &a->eoddata1__RESPONSE::MONTHS, "xsd:string"))
				{	soap_flag_MONTHS1--;
					continue;
				}
			if (soap_flag_DATAFORMATS1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToeoddata1__ArrayOfDATAFORMAT(soap, "eoddata1:DATAFORMATS", &a->eoddata1__RESPONSE::DATAFORMATS, "eoddata1:ArrayOfDATAFORMAT"))
				{	soap_flag_DATAFORMATS1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (eoddata1__RESPONSE *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata_eoddata1__RESPONSE, SOAP_TYPE_eoddata_eoddata1__RESPONSE, sizeof(eoddata1__RESPONSE), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 eoddata1__RESPONSE * SOAP_FMAC2 soap_instantiate_eoddata1__RESPONSE(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_eoddata1__RESPONSE(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	eoddata1__RESPONSE *p;
	size_t k = sizeof(eoddata1__RESPONSE);
	if (n < 0)
	{	p = SOAP_NEW(eoddata1__RESPONSE);
		if (p)
			((eoddata1__RESPONSE*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(eoddata1__RESPONSE, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((eoddata1__RESPONSE*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated eoddata1__RESPONSE location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata_eoddata1__RESPONSE, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int eoddata1__RESPONSE::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:RESPONSE", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *eoddata1__RESPONSE::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_eoddata1__RESPONSE(soap, this, tag, type);
}

SOAP_FMAC3 eoddata1__RESPONSE * SOAP_FMAC4 soap_get_eoddata1__RESPONSE(struct soap *soap, eoddata1__RESPONSE *p, const char *tag, const char *type)
{
	if ((p = soap_in_eoddata1__RESPONSE(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void eoddata1__LOGINRESPONSE::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->eoddata1__LOGINRESPONSE::Message = NULL;
	this->eoddata1__LOGINRESPONSE::Token = NULL;
	this->eoddata1__LOGINRESPONSE::DataFormat = NULL;
	soap_default_bool(soap, &this->eoddata1__LOGINRESPONSE::Header);
	soap_default_bool(soap, &this->eoddata1__LOGINRESPONSE::Suffix);
	/* transient soap skipped */
}

void eoddata1__LOGINRESPONSE::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int eoddata1__LOGINRESPONSE::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_eoddata1__LOGINRESPONSE(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_eoddata1__LOGINRESPONSE(struct soap *soap, const char *tag, int id, const eoddata1__LOGINRESPONSE *a, const char *type)
{
	if (((eoddata1__LOGINRESPONSE*)a)->Message)
		soap_set_attr(soap, "Message", ((eoddata1__LOGINRESPONSE*)a)->Message->c_str(), 1);
	if (((eoddata1__LOGINRESPONSE*)a)->Token)
		soap_set_attr(soap, "Token", ((eoddata1__LOGINRESPONSE*)a)->Token->c_str(), 1);
	if (((eoddata1__LOGINRESPONSE*)a)->DataFormat)
		soap_set_attr(soap, "DataFormat", ((eoddata1__LOGINRESPONSE*)a)->DataFormat->c_str(), 1);
	soap_set_attr(soap, "Header", soap_bool2s(soap, ((eoddata1__LOGINRESPONSE*)a)->Header), 1);
	soap_set_attr(soap, "Suffix", soap_bool2s(soap, ((eoddata1__LOGINRESPONSE*)a)->Suffix), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata_eoddata1__LOGINRESPONSE), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *eoddata1__LOGINRESPONSE::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_eoddata1__LOGINRESPONSE(soap, tag, this, type);
}

SOAP_FMAC3 eoddata1__LOGINRESPONSE * SOAP_FMAC4 soap_in_eoddata1__LOGINRESPONSE(struct soap *soap, const char *tag, eoddata1__LOGINRESPONSE *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (eoddata1__LOGINRESPONSE *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata_eoddata1__LOGINRESPONSE, sizeof(eoddata1__LOGINRESPONSE), soap->type, soap->arrayType, eoddata_instantiate, eoddata_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	{	const char *t = soap_attr_value(soap, "Message", 0);
		if (t)
		{
			if (!(((eoddata1__LOGINRESPONSE*)a)->Message = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__LOGINRESPONSE*)a)->Message, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Token", 0);
		if (t)
		{
			if (!(((eoddata1__LOGINRESPONSE*)a)->Token = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__LOGINRESPONSE*)a)->Token, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "DataFormat", 0);
		if (t)
		{
			if (!(((eoddata1__LOGINRESPONSE*)a)->DataFormat = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((eoddata1__LOGINRESPONSE*)a)->DataFormat, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2bool(soap, soap_attr_value(soap, "Header", 1), &((eoddata1__LOGINRESPONSE*)a)->Header))
		return NULL;
	if (soap_s2bool(soap, soap_attr_value(soap, "Suffix", 1), &((eoddata1__LOGINRESPONSE*)a)->Suffix))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (eoddata1__LOGINRESPONSE *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata_eoddata1__LOGINRESPONSE, SOAP_TYPE_eoddata_eoddata1__LOGINRESPONSE, sizeof(eoddata1__LOGINRESPONSE), 0, eoddata_finsert, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 eoddata1__LOGINRESPONSE * SOAP_FMAC2 soap_instantiate_eoddata1__LOGINRESPONSE(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_eoddata1__LOGINRESPONSE(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	eoddata1__LOGINRESPONSE *p;
	size_t k = sizeof(eoddata1__LOGINRESPONSE);
	if (n < 0)
	{	p = SOAP_NEW(eoddata1__LOGINRESPONSE);
		if (p)
			((eoddata1__LOGINRESPONSE*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(eoddata1__LOGINRESPONSE, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((eoddata1__LOGINRESPONSE*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated eoddata1__LOGINRESPONSE location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata_eoddata1__LOGINRESPONSE, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

int eoddata1__LOGINRESPONSE::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"eoddata1:LOGINRESPONSE", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *eoddata1__LOGINRESPONSE::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_eoddata1__LOGINRESPONSE(soap, this, tag, type);
}

SOAP_FMAC3 eoddata1__LOGINRESPONSE * SOAP_FMAC4 soap_get_eoddata1__LOGINRESPONSE(struct soap *soap, eoddata1__LOGINRESPONSE *p, const char *tag, const char *type)
{
	if ((p = soap_in_eoddata1__LOGINRESPONSE(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_ENV__Fault::SOAP_ENV__Fault()
{
	soap_default_SOAP_ENV__Fault(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->faultcode);
	soap_serialize_string(soap, (char*const*)&a->faultstring);
	soap_serialize_string(soap, (char*const*)&a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Node);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, (char*const*)&a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, (char*const*)&a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, (char*const*)&a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, (char*const*)&a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", (char**)&a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", (char**)&a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", (char**)&a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", (char**)&a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", (char**)&a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata_SOAP_ENV__Fault, SOAP_TYPE_eoddata_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, eoddata_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Fault *p;
	size_t k = sizeof(struct SOAP_ENV__Fault);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Fault);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Fault, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Fault location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata_SOAP_ENV__Fault, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_ENV__Reason::SOAP_ENV__Reason()
{
	soap_default_SOAP_ENV__Reason(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, (char*const*)&a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", (char**)&a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata_SOAP_ENV__Reason, SOAP_TYPE_eoddata_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, eoddata_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Reason *p;
	size_t k = sizeof(struct SOAP_ENV__Reason);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Reason);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Reason, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Reason location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata_SOAP_ENV__Reason, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_ENV__Detail::SOAP_ENV__Detail()
{
	soap_default_SOAP_ENV__Detail(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata_SOAP_ENV__Detail, SOAP_TYPE_eoddata_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, eoddata_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Detail *p;
	size_t k = sizeof(struct SOAP_ENV__Detail);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Detail);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Detail, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Detail location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata_SOAP_ENV__Detail, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_ENV__Code::SOAP_ENV__Code()
{
	soap_default_SOAP_ENV__Code(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", (char**)&a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata_SOAP_ENV__Code, SOAP_TYPE_eoddata_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, eoddata_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Code *p;
	size_t k = sizeof(struct SOAP_ENV__Code);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Code);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Code, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Code location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata_SOAP_ENV__Code, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_ENV__Header::SOAP_ENV__Header()
{
	soap_default_SOAP_ENV__Header(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_eoddata_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_eoddata_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_eoddata_SOAP_ENV__Header, SOAP_TYPE_eoddata_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, eoddata_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Header *p;
	size_t k = sizeof(struct SOAP_ENV__Header);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Header);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Header, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Header location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata_SOAP_ENV__Header, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

__eoddata1__ValidateAccess_::__eoddata1__ValidateAccess_()
{
	soap_default___eoddata1__ValidateAccess_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__ValidateAccess_(struct soap *soap, struct __eoddata1__ValidateAccess_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__ValidateAccess = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__ValidateAccess_(struct soap *soap, const struct __eoddata1__ValidateAccess_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__ValidateAccess(soap, &a->eoddata1__ValidateAccess);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__ValidateAccess_(struct soap *soap, const char *tag, int id, const struct __eoddata1__ValidateAccess_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__ValidateAccess(soap, "eoddata1:ValidateAccess", -1, &a->eoddata1__ValidateAccess, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__ValidateAccess_ * SOAP_FMAC4 soap_in___eoddata1__ValidateAccess_(struct soap *soap, const char *tag, struct __eoddata1__ValidateAccess_ *a, const char *type)
{
	size_t soap_flag_eoddata1__ValidateAccess = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__ValidateAccess_ *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__ValidateAccess_, sizeof(struct __eoddata1__ValidateAccess_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__ValidateAccess_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__ValidateAccess && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__ValidateAccess(soap, "eoddata1:ValidateAccess", &a->eoddata1__ValidateAccess, ""))
				{	soap_flag_eoddata1__ValidateAccess--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__ValidateAccess_ * SOAP_FMAC2 soap_instantiate___eoddata1__ValidateAccess_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__ValidateAccess_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__ValidateAccess_ *p;
	size_t k = sizeof(struct __eoddata1__ValidateAccess_);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__ValidateAccess_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__ValidateAccess_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__ValidateAccess_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__ValidateAccess_, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__ValidateAccess_(struct soap *soap, const struct __eoddata1__ValidateAccess_ *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__ValidateAccess_(soap, tag?tag:"-eoddata1:ValidateAccess", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__ValidateAccess_ * SOAP_FMAC4 soap_get___eoddata1__ValidateAccess_(struct soap *soap, struct __eoddata1__ValidateAccess_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__ValidateAccess_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__UpdateDataFormat_::__eoddata1__UpdateDataFormat_()
{
	soap_default___eoddata1__UpdateDataFormat_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__UpdateDataFormat_(struct soap *soap, struct __eoddata1__UpdateDataFormat_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__UpdateDataFormat = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__UpdateDataFormat_(struct soap *soap, const struct __eoddata1__UpdateDataFormat_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__UpdateDataFormat(soap, &a->eoddata1__UpdateDataFormat);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__UpdateDataFormat_(struct soap *soap, const char *tag, int id, const struct __eoddata1__UpdateDataFormat_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__UpdateDataFormat(soap, "eoddata1:UpdateDataFormat", -1, &a->eoddata1__UpdateDataFormat, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__UpdateDataFormat_ * SOAP_FMAC4 soap_in___eoddata1__UpdateDataFormat_(struct soap *soap, const char *tag, struct __eoddata1__UpdateDataFormat_ *a, const char *type)
{
	size_t soap_flag_eoddata1__UpdateDataFormat = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__UpdateDataFormat_ *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__UpdateDataFormat_, sizeof(struct __eoddata1__UpdateDataFormat_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__UpdateDataFormat_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__UpdateDataFormat && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__UpdateDataFormat(soap, "eoddata1:UpdateDataFormat", &a->eoddata1__UpdateDataFormat, ""))
				{	soap_flag_eoddata1__UpdateDataFormat--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__UpdateDataFormat_ * SOAP_FMAC2 soap_instantiate___eoddata1__UpdateDataFormat_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__UpdateDataFormat_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__UpdateDataFormat_ *p;
	size_t k = sizeof(struct __eoddata1__UpdateDataFormat_);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__UpdateDataFormat_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__UpdateDataFormat_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__UpdateDataFormat_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__UpdateDataFormat_, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__UpdateDataFormat_(struct soap *soap, const struct __eoddata1__UpdateDataFormat_ *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__UpdateDataFormat_(soap, tag?tag:"-eoddata1:UpdateDataFormat", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__UpdateDataFormat_ * SOAP_FMAC4 soap_get___eoddata1__UpdateDataFormat_(struct soap *soap, struct __eoddata1__UpdateDataFormat_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__UpdateDataFormat_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__DataFormats_::__eoddata1__DataFormats_()
{
	soap_default___eoddata1__DataFormats_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__DataFormats_(struct soap *soap, struct __eoddata1__DataFormats_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__DataFormats = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__DataFormats_(struct soap *soap, const struct __eoddata1__DataFormats_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__DataFormats(soap, &a->eoddata1__DataFormats);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__DataFormats_(struct soap *soap, const char *tag, int id, const struct __eoddata1__DataFormats_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__DataFormats(soap, "eoddata1:DataFormats", -1, &a->eoddata1__DataFormats, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__DataFormats_ * SOAP_FMAC4 soap_in___eoddata1__DataFormats_(struct soap *soap, const char *tag, struct __eoddata1__DataFormats_ *a, const char *type)
{
	size_t soap_flag_eoddata1__DataFormats = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__DataFormats_ *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__DataFormats_, sizeof(struct __eoddata1__DataFormats_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__DataFormats_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__DataFormats && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__DataFormats(soap, "eoddata1:DataFormats", &a->eoddata1__DataFormats, ""))
				{	soap_flag_eoddata1__DataFormats--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__DataFormats_ * SOAP_FMAC2 soap_instantiate___eoddata1__DataFormats_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__DataFormats_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__DataFormats_ *p;
	size_t k = sizeof(struct __eoddata1__DataFormats_);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__DataFormats_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__DataFormats_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__DataFormats_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__DataFormats_, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__DataFormats_(struct soap *soap, const struct __eoddata1__DataFormats_ *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__DataFormats_(soap, tag?tag:"-eoddata1:DataFormats", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__DataFormats_ * SOAP_FMAC4 soap_get___eoddata1__DataFormats_(struct soap *soap, struct __eoddata1__DataFormats_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__DataFormats_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__DataClientLatestVersion_::__eoddata1__DataClientLatestVersion_()
{
	soap_default___eoddata1__DataClientLatestVersion_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__DataClientLatestVersion_(struct soap *soap, struct __eoddata1__DataClientLatestVersion_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__DataClientLatestVersion = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__DataClientLatestVersion_(struct soap *soap, const struct __eoddata1__DataClientLatestVersion_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__DataClientLatestVersion(soap, &a->eoddata1__DataClientLatestVersion);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__DataClientLatestVersion_(struct soap *soap, const char *tag, int id, const struct __eoddata1__DataClientLatestVersion_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__DataClientLatestVersion(soap, "eoddata1:DataClientLatestVersion", -1, &a->eoddata1__DataClientLatestVersion, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__DataClientLatestVersion_ * SOAP_FMAC4 soap_in___eoddata1__DataClientLatestVersion_(struct soap *soap, const char *tag, struct __eoddata1__DataClientLatestVersion_ *a, const char *type)
{
	size_t soap_flag_eoddata1__DataClientLatestVersion = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__DataClientLatestVersion_ *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__DataClientLatestVersion_, sizeof(struct __eoddata1__DataClientLatestVersion_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__DataClientLatestVersion_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__DataClientLatestVersion && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__DataClientLatestVersion(soap, "eoddata1:DataClientLatestVersion", &a->eoddata1__DataClientLatestVersion, ""))
				{	soap_flag_eoddata1__DataClientLatestVersion--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__DataClientLatestVersion_ * SOAP_FMAC2 soap_instantiate___eoddata1__DataClientLatestVersion_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__DataClientLatestVersion_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__DataClientLatestVersion_ *p;
	size_t k = sizeof(struct __eoddata1__DataClientLatestVersion_);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__DataClientLatestVersion_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__DataClientLatestVersion_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__DataClientLatestVersion_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__DataClientLatestVersion_, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__DataClientLatestVersion_(struct soap *soap, const struct __eoddata1__DataClientLatestVersion_ *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__DataClientLatestVersion_(soap, tag?tag:"-eoddata1:DataClientLatestVersion", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__DataClientLatestVersion_ * SOAP_FMAC4 soap_get___eoddata1__DataClientLatestVersion_(struct soap *soap, struct __eoddata1__DataClientLatestVersion_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__DataClientLatestVersion_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__SymbolChangesByExchange_::__eoddata1__SymbolChangesByExchange_()
{
	soap_default___eoddata1__SymbolChangesByExchange_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__SymbolChangesByExchange_(struct soap *soap, struct __eoddata1__SymbolChangesByExchange_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__SymbolChangesByExchange = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__SymbolChangesByExchange_(struct soap *soap, const struct __eoddata1__SymbolChangesByExchange_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__SymbolChangesByExchange(soap, &a->eoddata1__SymbolChangesByExchange);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__SymbolChangesByExchange_(struct soap *soap, const char *tag, int id, const struct __eoddata1__SymbolChangesByExchange_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__SymbolChangesByExchange(soap, "eoddata1:SymbolChangesByExchange", -1, &a->eoddata1__SymbolChangesByExchange, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__SymbolChangesByExchange_ * SOAP_FMAC4 soap_in___eoddata1__SymbolChangesByExchange_(struct soap *soap, const char *tag, struct __eoddata1__SymbolChangesByExchange_ *a, const char *type)
{
	size_t soap_flag_eoddata1__SymbolChangesByExchange = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__SymbolChangesByExchange_ *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__SymbolChangesByExchange_, sizeof(struct __eoddata1__SymbolChangesByExchange_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__SymbolChangesByExchange_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__SymbolChangesByExchange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__SymbolChangesByExchange(soap, "eoddata1:SymbolChangesByExchange", &a->eoddata1__SymbolChangesByExchange, ""))
				{	soap_flag_eoddata1__SymbolChangesByExchange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__SymbolChangesByExchange_ * SOAP_FMAC2 soap_instantiate___eoddata1__SymbolChangesByExchange_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__SymbolChangesByExchange_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__SymbolChangesByExchange_ *p;
	size_t k = sizeof(struct __eoddata1__SymbolChangesByExchange_);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__SymbolChangesByExchange_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__SymbolChangesByExchange_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__SymbolChangesByExchange_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__SymbolChangesByExchange_, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__SymbolChangesByExchange_(struct soap *soap, const struct __eoddata1__SymbolChangesByExchange_ *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__SymbolChangesByExchange_(soap, tag?tag:"-eoddata1:SymbolChangesByExchange", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__SymbolChangesByExchange_ * SOAP_FMAC4 soap_get___eoddata1__SymbolChangesByExchange_(struct soap *soap, struct __eoddata1__SymbolChangesByExchange_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__SymbolChangesByExchange_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__QuoteListByDatePeriod2_::__eoddata1__QuoteListByDatePeriod2_()
{
	soap_default___eoddata1__QuoteListByDatePeriod2_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__QuoteListByDatePeriod2_(struct soap *soap, struct __eoddata1__QuoteListByDatePeriod2_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__QuoteListByDatePeriod2 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__QuoteListByDatePeriod2_(struct soap *soap, const struct __eoddata1__QuoteListByDatePeriod2_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__QuoteListByDatePeriod2(soap, &a->eoddata1__QuoteListByDatePeriod2);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__QuoteListByDatePeriod2_(struct soap *soap, const char *tag, int id, const struct __eoddata1__QuoteListByDatePeriod2_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__QuoteListByDatePeriod2(soap, "eoddata1:QuoteListByDatePeriod2", -1, &a->eoddata1__QuoteListByDatePeriod2, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__QuoteListByDatePeriod2_ * SOAP_FMAC4 soap_in___eoddata1__QuoteListByDatePeriod2_(struct soap *soap, const char *tag, struct __eoddata1__QuoteListByDatePeriod2_ *a, const char *type)
{
	size_t soap_flag_eoddata1__QuoteListByDatePeriod2 = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__QuoteListByDatePeriod2_ *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__QuoteListByDatePeriod2_, sizeof(struct __eoddata1__QuoteListByDatePeriod2_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__QuoteListByDatePeriod2_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__QuoteListByDatePeriod2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__QuoteListByDatePeriod2(soap, "eoddata1:QuoteListByDatePeriod2", &a->eoddata1__QuoteListByDatePeriod2, ""))
				{	soap_flag_eoddata1__QuoteListByDatePeriod2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__QuoteListByDatePeriod2_ * SOAP_FMAC2 soap_instantiate___eoddata1__QuoteListByDatePeriod2_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__QuoteListByDatePeriod2_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__QuoteListByDatePeriod2_ *p;
	size_t k = sizeof(struct __eoddata1__QuoteListByDatePeriod2_);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__QuoteListByDatePeriod2_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__QuoteListByDatePeriod2_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__QuoteListByDatePeriod2_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__QuoteListByDatePeriod2_, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__QuoteListByDatePeriod2_(struct soap *soap, const struct __eoddata1__QuoteListByDatePeriod2_ *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__QuoteListByDatePeriod2_(soap, tag?tag:"-eoddata1:QuoteListByDatePeriod2", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__QuoteListByDatePeriod2_ * SOAP_FMAC4 soap_get___eoddata1__QuoteListByDatePeriod2_(struct soap *soap, struct __eoddata1__QuoteListByDatePeriod2_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__QuoteListByDatePeriod2_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__QuoteListByDatePeriod_::__eoddata1__QuoteListByDatePeriod_()
{
	soap_default___eoddata1__QuoteListByDatePeriod_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__QuoteListByDatePeriod_(struct soap *soap, struct __eoddata1__QuoteListByDatePeriod_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__QuoteListByDatePeriod = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__QuoteListByDatePeriod_(struct soap *soap, const struct __eoddata1__QuoteListByDatePeriod_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__QuoteListByDatePeriod(soap, &a->eoddata1__QuoteListByDatePeriod);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__QuoteListByDatePeriod_(struct soap *soap, const char *tag, int id, const struct __eoddata1__QuoteListByDatePeriod_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__QuoteListByDatePeriod(soap, "eoddata1:QuoteListByDatePeriod", -1, &a->eoddata1__QuoteListByDatePeriod, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__QuoteListByDatePeriod_ * SOAP_FMAC4 soap_in___eoddata1__QuoteListByDatePeriod_(struct soap *soap, const char *tag, struct __eoddata1__QuoteListByDatePeriod_ *a, const char *type)
{
	size_t soap_flag_eoddata1__QuoteListByDatePeriod = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__QuoteListByDatePeriod_ *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__QuoteListByDatePeriod_, sizeof(struct __eoddata1__QuoteListByDatePeriod_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__QuoteListByDatePeriod_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__QuoteListByDatePeriod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__QuoteListByDatePeriod(soap, "eoddata1:QuoteListByDatePeriod", &a->eoddata1__QuoteListByDatePeriod, ""))
				{	soap_flag_eoddata1__QuoteListByDatePeriod--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__QuoteListByDatePeriod_ * SOAP_FMAC2 soap_instantiate___eoddata1__QuoteListByDatePeriod_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__QuoteListByDatePeriod_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__QuoteListByDatePeriod_ *p;
	size_t k = sizeof(struct __eoddata1__QuoteListByDatePeriod_);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__QuoteListByDatePeriod_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__QuoteListByDatePeriod_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__QuoteListByDatePeriod_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__QuoteListByDatePeriod_, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__QuoteListByDatePeriod_(struct soap *soap, const struct __eoddata1__QuoteListByDatePeriod_ *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__QuoteListByDatePeriod_(soap, tag?tag:"-eoddata1:QuoteListByDatePeriod", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__QuoteListByDatePeriod_ * SOAP_FMAC4 soap_get___eoddata1__QuoteListByDatePeriod_(struct soap *soap, struct __eoddata1__QuoteListByDatePeriod_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__QuoteListByDatePeriod_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__SymbolHistoryPeriodByDateRange_::__eoddata1__SymbolHistoryPeriodByDateRange_()
{
	soap_default___eoddata1__SymbolHistoryPeriodByDateRange_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__SymbolHistoryPeriodByDateRange_(struct soap *soap, struct __eoddata1__SymbolHistoryPeriodByDateRange_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__SymbolHistoryPeriodByDateRange = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__SymbolHistoryPeriodByDateRange_(struct soap *soap, const struct __eoddata1__SymbolHistoryPeriodByDateRange_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__SymbolHistoryPeriodByDateRange(soap, &a->eoddata1__SymbolHistoryPeriodByDateRange);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__SymbolHistoryPeriodByDateRange_(struct soap *soap, const char *tag, int id, const struct __eoddata1__SymbolHistoryPeriodByDateRange_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__SymbolHistoryPeriodByDateRange(soap, "eoddata1:SymbolHistoryPeriodByDateRange", -1, &a->eoddata1__SymbolHistoryPeriodByDateRange, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__SymbolHistoryPeriodByDateRange_ * SOAP_FMAC4 soap_in___eoddata1__SymbolHistoryPeriodByDateRange_(struct soap *soap, const char *tag, struct __eoddata1__SymbolHistoryPeriodByDateRange_ *a, const char *type)
{
	size_t soap_flag_eoddata1__SymbolHistoryPeriodByDateRange = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__SymbolHistoryPeriodByDateRange_ *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__SymbolHistoryPeriodByDateRange_, sizeof(struct __eoddata1__SymbolHistoryPeriodByDateRange_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__SymbolHistoryPeriodByDateRange_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__SymbolHistoryPeriodByDateRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__SymbolHistoryPeriodByDateRange(soap, "eoddata1:SymbolHistoryPeriodByDateRange", &a->eoddata1__SymbolHistoryPeriodByDateRange, ""))
				{	soap_flag_eoddata1__SymbolHistoryPeriodByDateRange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__SymbolHistoryPeriodByDateRange_ * SOAP_FMAC2 soap_instantiate___eoddata1__SymbolHistoryPeriodByDateRange_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__SymbolHistoryPeriodByDateRange_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__SymbolHistoryPeriodByDateRange_ *p;
	size_t k = sizeof(struct __eoddata1__SymbolHistoryPeriodByDateRange_);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__SymbolHistoryPeriodByDateRange_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__SymbolHistoryPeriodByDateRange_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__SymbolHistoryPeriodByDateRange_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__SymbolHistoryPeriodByDateRange_, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__SymbolHistoryPeriodByDateRange_(struct soap *soap, const struct __eoddata1__SymbolHistoryPeriodByDateRange_ *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__SymbolHistoryPeriodByDateRange_(soap, tag?tag:"-eoddata1:SymbolHistoryPeriodByDateRange", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__SymbolHistoryPeriodByDateRange_ * SOAP_FMAC4 soap_get___eoddata1__SymbolHistoryPeriodByDateRange_(struct soap *soap, struct __eoddata1__SymbolHistoryPeriodByDateRange_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__SymbolHistoryPeriodByDateRange_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__SymbolHistoryPeriod_::__eoddata1__SymbolHistoryPeriod_()
{
	soap_default___eoddata1__SymbolHistoryPeriod_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__SymbolHistoryPeriod_(struct soap *soap, struct __eoddata1__SymbolHistoryPeriod_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__SymbolHistoryPeriod = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__SymbolHistoryPeriod_(struct soap *soap, const struct __eoddata1__SymbolHistoryPeriod_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__SymbolHistoryPeriod(soap, &a->eoddata1__SymbolHistoryPeriod);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__SymbolHistoryPeriod_(struct soap *soap, const char *tag, int id, const struct __eoddata1__SymbolHistoryPeriod_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__SymbolHistoryPeriod(soap, "eoddata1:SymbolHistoryPeriod", -1, &a->eoddata1__SymbolHistoryPeriod, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__SymbolHistoryPeriod_ * SOAP_FMAC4 soap_in___eoddata1__SymbolHistoryPeriod_(struct soap *soap, const char *tag, struct __eoddata1__SymbolHistoryPeriod_ *a, const char *type)
{
	size_t soap_flag_eoddata1__SymbolHistoryPeriod = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__SymbolHistoryPeriod_ *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__SymbolHistoryPeriod_, sizeof(struct __eoddata1__SymbolHistoryPeriod_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__SymbolHistoryPeriod_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__SymbolHistoryPeriod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__SymbolHistoryPeriod(soap, "eoddata1:SymbolHistoryPeriod", &a->eoddata1__SymbolHistoryPeriod, ""))
				{	soap_flag_eoddata1__SymbolHistoryPeriod--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__SymbolHistoryPeriod_ * SOAP_FMAC2 soap_instantiate___eoddata1__SymbolHistoryPeriod_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__SymbolHistoryPeriod_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__SymbolHistoryPeriod_ *p;
	size_t k = sizeof(struct __eoddata1__SymbolHistoryPeriod_);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__SymbolHistoryPeriod_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__SymbolHistoryPeriod_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__SymbolHistoryPeriod_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__SymbolHistoryPeriod_, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__SymbolHistoryPeriod_(struct soap *soap, const struct __eoddata1__SymbolHistoryPeriod_ *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__SymbolHistoryPeriod_(soap, tag?tag:"-eoddata1:SymbolHistoryPeriod", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__SymbolHistoryPeriod_ * SOAP_FMAC4 soap_get___eoddata1__SymbolHistoryPeriod_(struct soap *soap, struct __eoddata1__SymbolHistoryPeriod_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__SymbolHistoryPeriod_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__CountryList_::__eoddata1__CountryList_()
{
	soap_default___eoddata1__CountryList_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__CountryList_(struct soap *soap, struct __eoddata1__CountryList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__CountryList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__CountryList_(struct soap *soap, const struct __eoddata1__CountryList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__CountryList(soap, &a->eoddata1__CountryList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__CountryList_(struct soap *soap, const char *tag, int id, const struct __eoddata1__CountryList_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__CountryList(soap, "eoddata1:CountryList", -1, &a->eoddata1__CountryList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__CountryList_ * SOAP_FMAC4 soap_in___eoddata1__CountryList_(struct soap *soap, const char *tag, struct __eoddata1__CountryList_ *a, const char *type)
{
	size_t soap_flag_eoddata1__CountryList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__CountryList_ *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__CountryList_, sizeof(struct __eoddata1__CountryList_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__CountryList_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__CountryList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__CountryList(soap, "eoddata1:CountryList", &a->eoddata1__CountryList, ""))
				{	soap_flag_eoddata1__CountryList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__CountryList_ * SOAP_FMAC2 soap_instantiate___eoddata1__CountryList_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__CountryList_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__CountryList_ *p;
	size_t k = sizeof(struct __eoddata1__CountryList_);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__CountryList_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__CountryList_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__CountryList_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__CountryList_, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__CountryList_(struct soap *soap, const struct __eoddata1__CountryList_ *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__CountryList_(soap, tag?tag:"-eoddata1:CountryList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__CountryList_ * SOAP_FMAC4 soap_get___eoddata1__CountryList_(struct soap *soap, struct __eoddata1__CountryList_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__CountryList_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__SplitListBySymbol_::__eoddata1__SplitListBySymbol_()
{
	soap_default___eoddata1__SplitListBySymbol_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__SplitListBySymbol_(struct soap *soap, struct __eoddata1__SplitListBySymbol_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__SplitListBySymbol = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__SplitListBySymbol_(struct soap *soap, const struct __eoddata1__SplitListBySymbol_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__SplitListBySymbol(soap, &a->eoddata1__SplitListBySymbol);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__SplitListBySymbol_(struct soap *soap, const char *tag, int id, const struct __eoddata1__SplitListBySymbol_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__SplitListBySymbol(soap, "eoddata1:SplitListBySymbol", -1, &a->eoddata1__SplitListBySymbol, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__SplitListBySymbol_ * SOAP_FMAC4 soap_in___eoddata1__SplitListBySymbol_(struct soap *soap, const char *tag, struct __eoddata1__SplitListBySymbol_ *a, const char *type)
{
	size_t soap_flag_eoddata1__SplitListBySymbol = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__SplitListBySymbol_ *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__SplitListBySymbol_, sizeof(struct __eoddata1__SplitListBySymbol_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__SplitListBySymbol_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__SplitListBySymbol && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__SplitListBySymbol(soap, "eoddata1:SplitListBySymbol", &a->eoddata1__SplitListBySymbol, ""))
				{	soap_flag_eoddata1__SplitListBySymbol--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__SplitListBySymbol_ * SOAP_FMAC2 soap_instantiate___eoddata1__SplitListBySymbol_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__SplitListBySymbol_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__SplitListBySymbol_ *p;
	size_t k = sizeof(struct __eoddata1__SplitListBySymbol_);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__SplitListBySymbol_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__SplitListBySymbol_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__SplitListBySymbol_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__SplitListBySymbol_, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__SplitListBySymbol_(struct soap *soap, const struct __eoddata1__SplitListBySymbol_ *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__SplitListBySymbol_(soap, tag?tag:"-eoddata1:SplitListBySymbol", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__SplitListBySymbol_ * SOAP_FMAC4 soap_get___eoddata1__SplitListBySymbol_(struct soap *soap, struct __eoddata1__SplitListBySymbol_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__SplitListBySymbol_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__SplitListByExchange_::__eoddata1__SplitListByExchange_()
{
	soap_default___eoddata1__SplitListByExchange_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__SplitListByExchange_(struct soap *soap, struct __eoddata1__SplitListByExchange_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__SplitListByExchange = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__SplitListByExchange_(struct soap *soap, const struct __eoddata1__SplitListByExchange_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__SplitListByExchange(soap, &a->eoddata1__SplitListByExchange);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__SplitListByExchange_(struct soap *soap, const char *tag, int id, const struct __eoddata1__SplitListByExchange_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__SplitListByExchange(soap, "eoddata1:SplitListByExchange", -1, &a->eoddata1__SplitListByExchange, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__SplitListByExchange_ * SOAP_FMAC4 soap_in___eoddata1__SplitListByExchange_(struct soap *soap, const char *tag, struct __eoddata1__SplitListByExchange_ *a, const char *type)
{
	size_t soap_flag_eoddata1__SplitListByExchange = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__SplitListByExchange_ *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__SplitListByExchange_, sizeof(struct __eoddata1__SplitListByExchange_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__SplitListByExchange_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__SplitListByExchange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__SplitListByExchange(soap, "eoddata1:SplitListByExchange", &a->eoddata1__SplitListByExchange, ""))
				{	soap_flag_eoddata1__SplitListByExchange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__SplitListByExchange_ * SOAP_FMAC2 soap_instantiate___eoddata1__SplitListByExchange_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__SplitListByExchange_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__SplitListByExchange_ *p;
	size_t k = sizeof(struct __eoddata1__SplitListByExchange_);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__SplitListByExchange_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__SplitListByExchange_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__SplitListByExchange_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__SplitListByExchange_, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__SplitListByExchange_(struct soap *soap, const struct __eoddata1__SplitListByExchange_ *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__SplitListByExchange_(soap, tag?tag:"-eoddata1:SplitListByExchange", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__SplitListByExchange_ * SOAP_FMAC4 soap_get___eoddata1__SplitListByExchange_(struct soap *soap, struct __eoddata1__SplitListByExchange_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__SplitListByExchange_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__ExchangeMonths_::__eoddata1__ExchangeMonths_()
{
	soap_default___eoddata1__ExchangeMonths_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__ExchangeMonths_(struct soap *soap, struct __eoddata1__ExchangeMonths_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__ExchangeMonths = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__ExchangeMonths_(struct soap *soap, const struct __eoddata1__ExchangeMonths_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__ExchangeMonths(soap, &a->eoddata1__ExchangeMonths);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__ExchangeMonths_(struct soap *soap, const char *tag, int id, const struct __eoddata1__ExchangeMonths_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__ExchangeMonths(soap, "eoddata1:ExchangeMonths", -1, &a->eoddata1__ExchangeMonths, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__ExchangeMonths_ * SOAP_FMAC4 soap_in___eoddata1__ExchangeMonths_(struct soap *soap, const char *tag, struct __eoddata1__ExchangeMonths_ *a, const char *type)
{
	size_t soap_flag_eoddata1__ExchangeMonths = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__ExchangeMonths_ *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__ExchangeMonths_, sizeof(struct __eoddata1__ExchangeMonths_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__ExchangeMonths_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__ExchangeMonths && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__ExchangeMonths(soap, "eoddata1:ExchangeMonths", &a->eoddata1__ExchangeMonths, ""))
				{	soap_flag_eoddata1__ExchangeMonths--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__ExchangeMonths_ * SOAP_FMAC2 soap_instantiate___eoddata1__ExchangeMonths_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__ExchangeMonths_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__ExchangeMonths_ *p;
	size_t k = sizeof(struct __eoddata1__ExchangeMonths_);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__ExchangeMonths_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__ExchangeMonths_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__ExchangeMonths_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__ExchangeMonths_, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__ExchangeMonths_(struct soap *soap, const struct __eoddata1__ExchangeMonths_ *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__ExchangeMonths_(soap, tag?tag:"-eoddata1:ExchangeMonths", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__ExchangeMonths_ * SOAP_FMAC4 soap_get___eoddata1__ExchangeMonths_(struct soap *soap, struct __eoddata1__ExchangeMonths_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__ExchangeMonths_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__SymbolChart_::__eoddata1__SymbolChart_()
{
	soap_default___eoddata1__SymbolChart_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__SymbolChart_(struct soap *soap, struct __eoddata1__SymbolChart_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__SymbolChart = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__SymbolChart_(struct soap *soap, const struct __eoddata1__SymbolChart_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__SymbolChart(soap, &a->eoddata1__SymbolChart);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__SymbolChart_(struct soap *soap, const char *tag, int id, const struct __eoddata1__SymbolChart_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__SymbolChart(soap, "eoddata1:SymbolChart", -1, &a->eoddata1__SymbolChart, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__SymbolChart_ * SOAP_FMAC4 soap_in___eoddata1__SymbolChart_(struct soap *soap, const char *tag, struct __eoddata1__SymbolChart_ *a, const char *type)
{
	size_t soap_flag_eoddata1__SymbolChart = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__SymbolChart_ *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__SymbolChart_, sizeof(struct __eoddata1__SymbolChart_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__SymbolChart_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__SymbolChart && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__SymbolChart(soap, "eoddata1:SymbolChart", &a->eoddata1__SymbolChart, ""))
				{	soap_flag_eoddata1__SymbolChart--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__SymbolChart_ * SOAP_FMAC2 soap_instantiate___eoddata1__SymbolChart_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__SymbolChart_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__SymbolChart_ *p;
	size_t k = sizeof(struct __eoddata1__SymbolChart_);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__SymbolChart_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__SymbolChart_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__SymbolChart_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__SymbolChart_, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__SymbolChart_(struct soap *soap, const struct __eoddata1__SymbolChart_ *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__SymbolChart_(soap, tag?tag:"-eoddata1:SymbolChart", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__SymbolChart_ * SOAP_FMAC4 soap_get___eoddata1__SymbolChart_(struct soap *soap, struct __eoddata1__SymbolChart_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__SymbolChart_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__Top10Losses_::__eoddata1__Top10Losses_()
{
	soap_default___eoddata1__Top10Losses_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__Top10Losses_(struct soap *soap, struct __eoddata1__Top10Losses_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__Top10Losses = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__Top10Losses_(struct soap *soap, const struct __eoddata1__Top10Losses_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__Top10Losses(soap, &a->eoddata1__Top10Losses);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__Top10Losses_(struct soap *soap, const char *tag, int id, const struct __eoddata1__Top10Losses_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__Top10Losses(soap, "eoddata1:Top10Losses", -1, &a->eoddata1__Top10Losses, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__Top10Losses_ * SOAP_FMAC4 soap_in___eoddata1__Top10Losses_(struct soap *soap, const char *tag, struct __eoddata1__Top10Losses_ *a, const char *type)
{
	size_t soap_flag_eoddata1__Top10Losses = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__Top10Losses_ *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__Top10Losses_, sizeof(struct __eoddata1__Top10Losses_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__Top10Losses_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__Top10Losses && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__Top10Losses(soap, "eoddata1:Top10Losses", &a->eoddata1__Top10Losses, ""))
				{	soap_flag_eoddata1__Top10Losses--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__Top10Losses_ * SOAP_FMAC2 soap_instantiate___eoddata1__Top10Losses_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__Top10Losses_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__Top10Losses_ *p;
	size_t k = sizeof(struct __eoddata1__Top10Losses_);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__Top10Losses_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__Top10Losses_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__Top10Losses_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__Top10Losses_, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__Top10Losses_(struct soap *soap, const struct __eoddata1__Top10Losses_ *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__Top10Losses_(soap, tag?tag:"-eoddata1:Top10Losses", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__Top10Losses_ * SOAP_FMAC4 soap_get___eoddata1__Top10Losses_(struct soap *soap, struct __eoddata1__Top10Losses_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__Top10Losses_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__Top10Gains_::__eoddata1__Top10Gains_()
{
	soap_default___eoddata1__Top10Gains_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__Top10Gains_(struct soap *soap, struct __eoddata1__Top10Gains_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__Top10Gains = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__Top10Gains_(struct soap *soap, const struct __eoddata1__Top10Gains_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__Top10Gains(soap, &a->eoddata1__Top10Gains);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__Top10Gains_(struct soap *soap, const char *tag, int id, const struct __eoddata1__Top10Gains_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__Top10Gains(soap, "eoddata1:Top10Gains", -1, &a->eoddata1__Top10Gains, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__Top10Gains_ * SOAP_FMAC4 soap_in___eoddata1__Top10Gains_(struct soap *soap, const char *tag, struct __eoddata1__Top10Gains_ *a, const char *type)
{
	size_t soap_flag_eoddata1__Top10Gains = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__Top10Gains_ *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__Top10Gains_, sizeof(struct __eoddata1__Top10Gains_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__Top10Gains_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__Top10Gains && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__Top10Gains(soap, "eoddata1:Top10Gains", &a->eoddata1__Top10Gains, ""))
				{	soap_flag_eoddata1__Top10Gains--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__Top10Gains_ * SOAP_FMAC2 soap_instantiate___eoddata1__Top10Gains_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__Top10Gains_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__Top10Gains_ *p;
	size_t k = sizeof(struct __eoddata1__Top10Gains_);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__Top10Gains_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__Top10Gains_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__Top10Gains_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__Top10Gains_, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__Top10Gains_(struct soap *soap, const struct __eoddata1__Top10Gains_ *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__Top10Gains_(soap, tag?tag:"-eoddata1:Top10Gains", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__Top10Gains_ * SOAP_FMAC4 soap_get___eoddata1__Top10Gains_(struct soap *soap, struct __eoddata1__Top10Gains_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__Top10Gains_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__SymbolHistory_::__eoddata1__SymbolHistory_()
{
	soap_default___eoddata1__SymbolHistory_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__SymbolHistory_(struct soap *soap, struct __eoddata1__SymbolHistory_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__SymbolHistory = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__SymbolHistory_(struct soap *soap, const struct __eoddata1__SymbolHistory_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__SymbolHistory(soap, &a->eoddata1__SymbolHistory);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__SymbolHistory_(struct soap *soap, const char *tag, int id, const struct __eoddata1__SymbolHistory_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__SymbolHistory(soap, "eoddata1:SymbolHistory", -1, &a->eoddata1__SymbolHistory, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__SymbolHistory_ * SOAP_FMAC4 soap_in___eoddata1__SymbolHistory_(struct soap *soap, const char *tag, struct __eoddata1__SymbolHistory_ *a, const char *type)
{
	size_t soap_flag_eoddata1__SymbolHistory = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__SymbolHistory_ *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__SymbolHistory_, sizeof(struct __eoddata1__SymbolHistory_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__SymbolHistory_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__SymbolHistory && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__SymbolHistory(soap, "eoddata1:SymbolHistory", &a->eoddata1__SymbolHistory, ""))
				{	soap_flag_eoddata1__SymbolHistory--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__SymbolHistory_ * SOAP_FMAC2 soap_instantiate___eoddata1__SymbolHistory_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__SymbolHistory_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__SymbolHistory_ *p;
	size_t k = sizeof(struct __eoddata1__SymbolHistory_);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__SymbolHistory_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__SymbolHistory_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__SymbolHistory_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__SymbolHistory_, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__SymbolHistory_(struct soap *soap, const struct __eoddata1__SymbolHistory_ *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__SymbolHistory_(soap, tag?tag:"-eoddata1:SymbolHistory", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__SymbolHistory_ * SOAP_FMAC4 soap_get___eoddata1__SymbolHistory_(struct soap *soap, struct __eoddata1__SymbolHistory_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__SymbolHistory_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__QuoteListByDate2_::__eoddata1__QuoteListByDate2_()
{
	soap_default___eoddata1__QuoteListByDate2_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__QuoteListByDate2_(struct soap *soap, struct __eoddata1__QuoteListByDate2_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__QuoteListByDate2 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__QuoteListByDate2_(struct soap *soap, const struct __eoddata1__QuoteListByDate2_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__QuoteListByDate2(soap, &a->eoddata1__QuoteListByDate2);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__QuoteListByDate2_(struct soap *soap, const char *tag, int id, const struct __eoddata1__QuoteListByDate2_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__QuoteListByDate2(soap, "eoddata1:QuoteListByDate2", -1, &a->eoddata1__QuoteListByDate2, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__QuoteListByDate2_ * SOAP_FMAC4 soap_in___eoddata1__QuoteListByDate2_(struct soap *soap, const char *tag, struct __eoddata1__QuoteListByDate2_ *a, const char *type)
{
	size_t soap_flag_eoddata1__QuoteListByDate2 = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__QuoteListByDate2_ *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__QuoteListByDate2_, sizeof(struct __eoddata1__QuoteListByDate2_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__QuoteListByDate2_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__QuoteListByDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__QuoteListByDate2(soap, "eoddata1:QuoteListByDate2", &a->eoddata1__QuoteListByDate2, ""))
				{	soap_flag_eoddata1__QuoteListByDate2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__QuoteListByDate2_ * SOAP_FMAC2 soap_instantiate___eoddata1__QuoteListByDate2_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__QuoteListByDate2_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__QuoteListByDate2_ *p;
	size_t k = sizeof(struct __eoddata1__QuoteListByDate2_);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__QuoteListByDate2_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__QuoteListByDate2_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__QuoteListByDate2_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__QuoteListByDate2_, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__QuoteListByDate2_(struct soap *soap, const struct __eoddata1__QuoteListByDate2_ *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__QuoteListByDate2_(soap, tag?tag:"-eoddata1:QuoteListByDate2", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__QuoteListByDate2_ * SOAP_FMAC4 soap_get___eoddata1__QuoteListByDate2_(struct soap *soap, struct __eoddata1__QuoteListByDate2_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__QuoteListByDate2_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__QuoteListByDate_::__eoddata1__QuoteListByDate_()
{
	soap_default___eoddata1__QuoteListByDate_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__QuoteListByDate_(struct soap *soap, struct __eoddata1__QuoteListByDate_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__QuoteListByDate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__QuoteListByDate_(struct soap *soap, const struct __eoddata1__QuoteListByDate_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__QuoteListByDate(soap, &a->eoddata1__QuoteListByDate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__QuoteListByDate_(struct soap *soap, const char *tag, int id, const struct __eoddata1__QuoteListByDate_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__QuoteListByDate(soap, "eoddata1:QuoteListByDate", -1, &a->eoddata1__QuoteListByDate, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__QuoteListByDate_ * SOAP_FMAC4 soap_in___eoddata1__QuoteListByDate_(struct soap *soap, const char *tag, struct __eoddata1__QuoteListByDate_ *a, const char *type)
{
	size_t soap_flag_eoddata1__QuoteListByDate = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__QuoteListByDate_ *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__QuoteListByDate_, sizeof(struct __eoddata1__QuoteListByDate_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__QuoteListByDate_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__QuoteListByDate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__QuoteListByDate(soap, "eoddata1:QuoteListByDate", &a->eoddata1__QuoteListByDate, ""))
				{	soap_flag_eoddata1__QuoteListByDate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__QuoteListByDate_ * SOAP_FMAC2 soap_instantiate___eoddata1__QuoteListByDate_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__QuoteListByDate_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__QuoteListByDate_ *p;
	size_t k = sizeof(struct __eoddata1__QuoteListByDate_);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__QuoteListByDate_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__QuoteListByDate_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__QuoteListByDate_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__QuoteListByDate_, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__QuoteListByDate_(struct soap *soap, const struct __eoddata1__QuoteListByDate_ *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__QuoteListByDate_(soap, tag?tag:"-eoddata1:QuoteListByDate", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__QuoteListByDate_ * SOAP_FMAC4 soap_get___eoddata1__QuoteListByDate_(struct soap *soap, struct __eoddata1__QuoteListByDate_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__QuoteListByDate_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__TechnicalList_::__eoddata1__TechnicalList_()
{
	soap_default___eoddata1__TechnicalList_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__TechnicalList_(struct soap *soap, struct __eoddata1__TechnicalList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__TechnicalList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__TechnicalList_(struct soap *soap, const struct __eoddata1__TechnicalList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__TechnicalList(soap, &a->eoddata1__TechnicalList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__TechnicalList_(struct soap *soap, const char *tag, int id, const struct __eoddata1__TechnicalList_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__TechnicalList(soap, "eoddata1:TechnicalList", -1, &a->eoddata1__TechnicalList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__TechnicalList_ * SOAP_FMAC4 soap_in___eoddata1__TechnicalList_(struct soap *soap, const char *tag, struct __eoddata1__TechnicalList_ *a, const char *type)
{
	size_t soap_flag_eoddata1__TechnicalList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__TechnicalList_ *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__TechnicalList_, sizeof(struct __eoddata1__TechnicalList_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__TechnicalList_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__TechnicalList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__TechnicalList(soap, "eoddata1:TechnicalList", &a->eoddata1__TechnicalList, ""))
				{	soap_flag_eoddata1__TechnicalList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__TechnicalList_ * SOAP_FMAC2 soap_instantiate___eoddata1__TechnicalList_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__TechnicalList_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__TechnicalList_ *p;
	size_t k = sizeof(struct __eoddata1__TechnicalList_);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__TechnicalList_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__TechnicalList_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__TechnicalList_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__TechnicalList_, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__TechnicalList_(struct soap *soap, const struct __eoddata1__TechnicalList_ *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__TechnicalList_(soap, tag?tag:"-eoddata1:TechnicalList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__TechnicalList_ * SOAP_FMAC4 soap_get___eoddata1__TechnicalList_(struct soap *soap, struct __eoddata1__TechnicalList_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__TechnicalList_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__FundamentalList_::__eoddata1__FundamentalList_()
{
	soap_default___eoddata1__FundamentalList_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__FundamentalList_(struct soap *soap, struct __eoddata1__FundamentalList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__FundamentalList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__FundamentalList_(struct soap *soap, const struct __eoddata1__FundamentalList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__FundamentalList(soap, &a->eoddata1__FundamentalList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__FundamentalList_(struct soap *soap, const char *tag, int id, const struct __eoddata1__FundamentalList_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__FundamentalList(soap, "eoddata1:FundamentalList", -1, &a->eoddata1__FundamentalList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__FundamentalList_ * SOAP_FMAC4 soap_in___eoddata1__FundamentalList_(struct soap *soap, const char *tag, struct __eoddata1__FundamentalList_ *a, const char *type)
{
	size_t soap_flag_eoddata1__FundamentalList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__FundamentalList_ *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__FundamentalList_, sizeof(struct __eoddata1__FundamentalList_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__FundamentalList_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__FundamentalList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__FundamentalList(soap, "eoddata1:FundamentalList", &a->eoddata1__FundamentalList, ""))
				{	soap_flag_eoddata1__FundamentalList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__FundamentalList_ * SOAP_FMAC2 soap_instantiate___eoddata1__FundamentalList_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__FundamentalList_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__FundamentalList_ *p;
	size_t k = sizeof(struct __eoddata1__FundamentalList_);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__FundamentalList_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__FundamentalList_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__FundamentalList_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__FundamentalList_, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__FundamentalList_(struct soap *soap, const struct __eoddata1__FundamentalList_ *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__FundamentalList_(soap, tag?tag:"-eoddata1:FundamentalList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__FundamentalList_ * SOAP_FMAC4 soap_get___eoddata1__FundamentalList_(struct soap *soap, struct __eoddata1__FundamentalList_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__FundamentalList_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__NewsListBySymbol_::__eoddata1__NewsListBySymbol_()
{
	soap_default___eoddata1__NewsListBySymbol_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__NewsListBySymbol_(struct soap *soap, struct __eoddata1__NewsListBySymbol_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__NewsListBySymbol = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__NewsListBySymbol_(struct soap *soap, const struct __eoddata1__NewsListBySymbol_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__NewsListBySymbol(soap, &a->eoddata1__NewsListBySymbol);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__NewsListBySymbol_(struct soap *soap, const char *tag, int id, const struct __eoddata1__NewsListBySymbol_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__NewsListBySymbol(soap, "eoddata1:NewsListBySymbol", -1, &a->eoddata1__NewsListBySymbol, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__NewsListBySymbol_ * SOAP_FMAC4 soap_in___eoddata1__NewsListBySymbol_(struct soap *soap, const char *tag, struct __eoddata1__NewsListBySymbol_ *a, const char *type)
{
	size_t soap_flag_eoddata1__NewsListBySymbol = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__NewsListBySymbol_ *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__NewsListBySymbol_, sizeof(struct __eoddata1__NewsListBySymbol_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__NewsListBySymbol_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__NewsListBySymbol && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__NewsListBySymbol(soap, "eoddata1:NewsListBySymbol", &a->eoddata1__NewsListBySymbol, ""))
				{	soap_flag_eoddata1__NewsListBySymbol--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__NewsListBySymbol_ * SOAP_FMAC2 soap_instantiate___eoddata1__NewsListBySymbol_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__NewsListBySymbol_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__NewsListBySymbol_ *p;
	size_t k = sizeof(struct __eoddata1__NewsListBySymbol_);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__NewsListBySymbol_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__NewsListBySymbol_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__NewsListBySymbol_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__NewsListBySymbol_, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__NewsListBySymbol_(struct soap *soap, const struct __eoddata1__NewsListBySymbol_ *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__NewsListBySymbol_(soap, tag?tag:"-eoddata1:NewsListBySymbol", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__NewsListBySymbol_ * SOAP_FMAC4 soap_get___eoddata1__NewsListBySymbol_(struct soap *soap, struct __eoddata1__NewsListBySymbol_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__NewsListBySymbol_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__NewsList_::__eoddata1__NewsList_()
{
	soap_default___eoddata1__NewsList_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__NewsList_(struct soap *soap, struct __eoddata1__NewsList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__NewsList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__NewsList_(struct soap *soap, const struct __eoddata1__NewsList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__NewsList(soap, &a->eoddata1__NewsList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__NewsList_(struct soap *soap, const char *tag, int id, const struct __eoddata1__NewsList_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__NewsList(soap, "eoddata1:NewsList", -1, &a->eoddata1__NewsList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__NewsList_ * SOAP_FMAC4 soap_in___eoddata1__NewsList_(struct soap *soap, const char *tag, struct __eoddata1__NewsList_ *a, const char *type)
{
	size_t soap_flag_eoddata1__NewsList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__NewsList_ *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__NewsList_, sizeof(struct __eoddata1__NewsList_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__NewsList_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__NewsList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__NewsList(soap, "eoddata1:NewsList", &a->eoddata1__NewsList, ""))
				{	soap_flag_eoddata1__NewsList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__NewsList_ * SOAP_FMAC2 soap_instantiate___eoddata1__NewsList_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__NewsList_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__NewsList_ *p;
	size_t k = sizeof(struct __eoddata1__NewsList_);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__NewsList_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__NewsList_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__NewsList_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__NewsList_, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__NewsList_(struct soap *soap, const struct __eoddata1__NewsList_ *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__NewsList_(soap, tag?tag:"-eoddata1:NewsList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__NewsList_ * SOAP_FMAC4 soap_get___eoddata1__NewsList_(struct soap *soap, struct __eoddata1__NewsList_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__NewsList_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__QuoteList_::__eoddata1__QuoteList_()
{
	soap_default___eoddata1__QuoteList_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__QuoteList_(struct soap *soap, struct __eoddata1__QuoteList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__QuoteList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__QuoteList_(struct soap *soap, const struct __eoddata1__QuoteList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__QuoteList(soap, &a->eoddata1__QuoteList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__QuoteList_(struct soap *soap, const char *tag, int id, const struct __eoddata1__QuoteList_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__QuoteList(soap, "eoddata1:QuoteList", -1, &a->eoddata1__QuoteList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__QuoteList_ * SOAP_FMAC4 soap_in___eoddata1__QuoteList_(struct soap *soap, const char *tag, struct __eoddata1__QuoteList_ *a, const char *type)
{
	size_t soap_flag_eoddata1__QuoteList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__QuoteList_ *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__QuoteList_, sizeof(struct __eoddata1__QuoteList_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__QuoteList_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__QuoteList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__QuoteList(soap, "eoddata1:QuoteList", &a->eoddata1__QuoteList, ""))
				{	soap_flag_eoddata1__QuoteList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__QuoteList_ * SOAP_FMAC2 soap_instantiate___eoddata1__QuoteList_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__QuoteList_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__QuoteList_ *p;
	size_t k = sizeof(struct __eoddata1__QuoteList_);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__QuoteList_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__QuoteList_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__QuoteList_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__QuoteList_, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__QuoteList_(struct soap *soap, const struct __eoddata1__QuoteList_ *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__QuoteList_(soap, tag?tag:"-eoddata1:QuoteList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__QuoteList_ * SOAP_FMAC4 soap_get___eoddata1__QuoteList_(struct soap *soap, struct __eoddata1__QuoteList_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__QuoteList_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__SymbolGet_::__eoddata1__SymbolGet_()
{
	soap_default___eoddata1__SymbolGet_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__SymbolGet_(struct soap *soap, struct __eoddata1__SymbolGet_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__SymbolGet = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__SymbolGet_(struct soap *soap, const struct __eoddata1__SymbolGet_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__SymbolGet(soap, &a->eoddata1__SymbolGet);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__SymbolGet_(struct soap *soap, const char *tag, int id, const struct __eoddata1__SymbolGet_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__SymbolGet(soap, "eoddata1:SymbolGet", -1, &a->eoddata1__SymbolGet, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__SymbolGet_ * SOAP_FMAC4 soap_in___eoddata1__SymbolGet_(struct soap *soap, const char *tag, struct __eoddata1__SymbolGet_ *a, const char *type)
{
	size_t soap_flag_eoddata1__SymbolGet = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__SymbolGet_ *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__SymbolGet_, sizeof(struct __eoddata1__SymbolGet_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__SymbolGet_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__SymbolGet && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__SymbolGet(soap, "eoddata1:SymbolGet", &a->eoddata1__SymbolGet, ""))
				{	soap_flag_eoddata1__SymbolGet--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__SymbolGet_ * SOAP_FMAC2 soap_instantiate___eoddata1__SymbolGet_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__SymbolGet_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__SymbolGet_ *p;
	size_t k = sizeof(struct __eoddata1__SymbolGet_);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__SymbolGet_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__SymbolGet_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__SymbolGet_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__SymbolGet_, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__SymbolGet_(struct soap *soap, const struct __eoddata1__SymbolGet_ *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__SymbolGet_(soap, tag?tag:"-eoddata1:SymbolGet", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__SymbolGet_ * SOAP_FMAC4 soap_get___eoddata1__SymbolGet_(struct soap *soap, struct __eoddata1__SymbolGet_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__SymbolGet_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__QuoteList2_::__eoddata1__QuoteList2_()
{
	soap_default___eoddata1__QuoteList2_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__QuoteList2_(struct soap *soap, struct __eoddata1__QuoteList2_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__QuoteList2 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__QuoteList2_(struct soap *soap, const struct __eoddata1__QuoteList2_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__QuoteList2(soap, &a->eoddata1__QuoteList2);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__QuoteList2_(struct soap *soap, const char *tag, int id, const struct __eoddata1__QuoteList2_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__QuoteList2(soap, "eoddata1:QuoteList2", -1, &a->eoddata1__QuoteList2, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__QuoteList2_ * SOAP_FMAC4 soap_in___eoddata1__QuoteList2_(struct soap *soap, const char *tag, struct __eoddata1__QuoteList2_ *a, const char *type)
{
	size_t soap_flag_eoddata1__QuoteList2 = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__QuoteList2_ *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__QuoteList2_, sizeof(struct __eoddata1__QuoteList2_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__QuoteList2_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__QuoteList2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__QuoteList2(soap, "eoddata1:QuoteList2", &a->eoddata1__QuoteList2, ""))
				{	soap_flag_eoddata1__QuoteList2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__QuoteList2_ * SOAP_FMAC2 soap_instantiate___eoddata1__QuoteList2_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__QuoteList2_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__QuoteList2_ *p;
	size_t k = sizeof(struct __eoddata1__QuoteList2_);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__QuoteList2_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__QuoteList2_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__QuoteList2_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__QuoteList2_, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__QuoteList2_(struct soap *soap, const struct __eoddata1__QuoteList2_ *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__QuoteList2_(soap, tag?tag:"-eoddata1:QuoteList2", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__QuoteList2_ * SOAP_FMAC4 soap_get___eoddata1__QuoteList2_(struct soap *soap, struct __eoddata1__QuoteList2_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__QuoteList2_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__QuoteGet_::__eoddata1__QuoteGet_()
{
	soap_default___eoddata1__QuoteGet_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__QuoteGet_(struct soap *soap, struct __eoddata1__QuoteGet_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__QuoteGet = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__QuoteGet_(struct soap *soap, const struct __eoddata1__QuoteGet_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__QuoteGet(soap, &a->eoddata1__QuoteGet);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__QuoteGet_(struct soap *soap, const char *tag, int id, const struct __eoddata1__QuoteGet_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__QuoteGet(soap, "eoddata1:QuoteGet", -1, &a->eoddata1__QuoteGet, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__QuoteGet_ * SOAP_FMAC4 soap_in___eoddata1__QuoteGet_(struct soap *soap, const char *tag, struct __eoddata1__QuoteGet_ *a, const char *type)
{
	size_t soap_flag_eoddata1__QuoteGet = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__QuoteGet_ *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__QuoteGet_, sizeof(struct __eoddata1__QuoteGet_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__QuoteGet_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__QuoteGet && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__QuoteGet(soap, "eoddata1:QuoteGet", &a->eoddata1__QuoteGet, ""))
				{	soap_flag_eoddata1__QuoteGet--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__QuoteGet_ * SOAP_FMAC2 soap_instantiate___eoddata1__QuoteGet_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__QuoteGet_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__QuoteGet_ *p;
	size_t k = sizeof(struct __eoddata1__QuoteGet_);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__QuoteGet_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__QuoteGet_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__QuoteGet_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__QuoteGet_, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__QuoteGet_(struct soap *soap, const struct __eoddata1__QuoteGet_ *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__QuoteGet_(soap, tag?tag:"-eoddata1:QuoteGet", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__QuoteGet_ * SOAP_FMAC4 soap_get___eoddata1__QuoteGet_(struct soap *soap, struct __eoddata1__QuoteGet_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__QuoteGet_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__SymbolList2_::__eoddata1__SymbolList2_()
{
	soap_default___eoddata1__SymbolList2_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__SymbolList2_(struct soap *soap, struct __eoddata1__SymbolList2_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__SymbolList2 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__SymbolList2_(struct soap *soap, const struct __eoddata1__SymbolList2_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__SymbolList2(soap, &a->eoddata1__SymbolList2);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__SymbolList2_(struct soap *soap, const char *tag, int id, const struct __eoddata1__SymbolList2_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__SymbolList2(soap, "eoddata1:SymbolList2", -1, &a->eoddata1__SymbolList2, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__SymbolList2_ * SOAP_FMAC4 soap_in___eoddata1__SymbolList2_(struct soap *soap, const char *tag, struct __eoddata1__SymbolList2_ *a, const char *type)
{
	size_t soap_flag_eoddata1__SymbolList2 = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__SymbolList2_ *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__SymbolList2_, sizeof(struct __eoddata1__SymbolList2_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__SymbolList2_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__SymbolList2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__SymbolList2(soap, "eoddata1:SymbolList2", &a->eoddata1__SymbolList2, ""))
				{	soap_flag_eoddata1__SymbolList2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__SymbolList2_ * SOAP_FMAC2 soap_instantiate___eoddata1__SymbolList2_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__SymbolList2_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__SymbolList2_ *p;
	size_t k = sizeof(struct __eoddata1__SymbolList2_);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__SymbolList2_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__SymbolList2_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__SymbolList2_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__SymbolList2_, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__SymbolList2_(struct soap *soap, const struct __eoddata1__SymbolList2_ *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__SymbolList2_(soap, tag?tag:"-eoddata1:SymbolList2", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__SymbolList2_ * SOAP_FMAC4 soap_get___eoddata1__SymbolList2_(struct soap *soap, struct __eoddata1__SymbolList2_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__SymbolList2_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__SymbolList_::__eoddata1__SymbolList_()
{
	soap_default___eoddata1__SymbolList_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__SymbolList_(struct soap *soap, struct __eoddata1__SymbolList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__SymbolList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__SymbolList_(struct soap *soap, const struct __eoddata1__SymbolList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__SymbolList(soap, &a->eoddata1__SymbolList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__SymbolList_(struct soap *soap, const char *tag, int id, const struct __eoddata1__SymbolList_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__SymbolList(soap, "eoddata1:SymbolList", -1, &a->eoddata1__SymbolList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__SymbolList_ * SOAP_FMAC4 soap_in___eoddata1__SymbolList_(struct soap *soap, const char *tag, struct __eoddata1__SymbolList_ *a, const char *type)
{
	size_t soap_flag_eoddata1__SymbolList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__SymbolList_ *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__SymbolList_, sizeof(struct __eoddata1__SymbolList_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__SymbolList_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__SymbolList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__SymbolList(soap, "eoddata1:SymbolList", &a->eoddata1__SymbolList, ""))
				{	soap_flag_eoddata1__SymbolList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__SymbolList_ * SOAP_FMAC2 soap_instantiate___eoddata1__SymbolList_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__SymbolList_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__SymbolList_ *p;
	size_t k = sizeof(struct __eoddata1__SymbolList_);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__SymbolList_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__SymbolList_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__SymbolList_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__SymbolList_, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__SymbolList_(struct soap *soap, const struct __eoddata1__SymbolList_ *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__SymbolList_(soap, tag?tag:"-eoddata1:SymbolList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__SymbolList_ * SOAP_FMAC4 soap_get___eoddata1__SymbolList_(struct soap *soap, struct __eoddata1__SymbolList_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__SymbolList_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__ExchangeGet_::__eoddata1__ExchangeGet_()
{
	soap_default___eoddata1__ExchangeGet_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__ExchangeGet_(struct soap *soap, struct __eoddata1__ExchangeGet_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__ExchangeGet = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__ExchangeGet_(struct soap *soap, const struct __eoddata1__ExchangeGet_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__ExchangeGet(soap, &a->eoddata1__ExchangeGet);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__ExchangeGet_(struct soap *soap, const char *tag, int id, const struct __eoddata1__ExchangeGet_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__ExchangeGet(soap, "eoddata1:ExchangeGet", -1, &a->eoddata1__ExchangeGet, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__ExchangeGet_ * SOAP_FMAC4 soap_in___eoddata1__ExchangeGet_(struct soap *soap, const char *tag, struct __eoddata1__ExchangeGet_ *a, const char *type)
{
	size_t soap_flag_eoddata1__ExchangeGet = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__ExchangeGet_ *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__ExchangeGet_, sizeof(struct __eoddata1__ExchangeGet_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__ExchangeGet_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__ExchangeGet && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__ExchangeGet(soap, "eoddata1:ExchangeGet", &a->eoddata1__ExchangeGet, ""))
				{	soap_flag_eoddata1__ExchangeGet--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__ExchangeGet_ * SOAP_FMAC2 soap_instantiate___eoddata1__ExchangeGet_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__ExchangeGet_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__ExchangeGet_ *p;
	size_t k = sizeof(struct __eoddata1__ExchangeGet_);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__ExchangeGet_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__ExchangeGet_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__ExchangeGet_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__ExchangeGet_, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__ExchangeGet_(struct soap *soap, const struct __eoddata1__ExchangeGet_ *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__ExchangeGet_(soap, tag?tag:"-eoddata1:ExchangeGet", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__ExchangeGet_ * SOAP_FMAC4 soap_get___eoddata1__ExchangeGet_(struct soap *soap, struct __eoddata1__ExchangeGet_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__ExchangeGet_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__ExchangeList_::__eoddata1__ExchangeList_()
{
	soap_default___eoddata1__ExchangeList_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__ExchangeList_(struct soap *soap, struct __eoddata1__ExchangeList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__ExchangeList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__ExchangeList_(struct soap *soap, const struct __eoddata1__ExchangeList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__ExchangeList(soap, &a->eoddata1__ExchangeList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__ExchangeList_(struct soap *soap, const char *tag, int id, const struct __eoddata1__ExchangeList_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__ExchangeList(soap, "eoddata1:ExchangeList", -1, &a->eoddata1__ExchangeList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__ExchangeList_ * SOAP_FMAC4 soap_in___eoddata1__ExchangeList_(struct soap *soap, const char *tag, struct __eoddata1__ExchangeList_ *a, const char *type)
{
	size_t soap_flag_eoddata1__ExchangeList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__ExchangeList_ *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__ExchangeList_, sizeof(struct __eoddata1__ExchangeList_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__ExchangeList_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__ExchangeList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__ExchangeList(soap, "eoddata1:ExchangeList", &a->eoddata1__ExchangeList, ""))
				{	soap_flag_eoddata1__ExchangeList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__ExchangeList_ * SOAP_FMAC2 soap_instantiate___eoddata1__ExchangeList_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__ExchangeList_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__ExchangeList_ *p;
	size_t k = sizeof(struct __eoddata1__ExchangeList_);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__ExchangeList_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__ExchangeList_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__ExchangeList_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__ExchangeList_, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__ExchangeList_(struct soap *soap, const struct __eoddata1__ExchangeList_ *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__ExchangeList_(soap, tag?tag:"-eoddata1:ExchangeList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__ExchangeList_ * SOAP_FMAC4 soap_get___eoddata1__ExchangeList_(struct soap *soap, struct __eoddata1__ExchangeList_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__ExchangeList_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__Membership_::__eoddata1__Membership_()
{
	soap_default___eoddata1__Membership_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__Membership_(struct soap *soap, struct __eoddata1__Membership_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__Membership = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__Membership_(struct soap *soap, const struct __eoddata1__Membership_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__Membership(soap, &a->eoddata1__Membership);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__Membership_(struct soap *soap, const char *tag, int id, const struct __eoddata1__Membership_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__Membership(soap, "eoddata1:Membership", -1, &a->eoddata1__Membership, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__Membership_ * SOAP_FMAC4 soap_in___eoddata1__Membership_(struct soap *soap, const char *tag, struct __eoddata1__Membership_ *a, const char *type)
{
	size_t soap_flag_eoddata1__Membership = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__Membership_ *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__Membership_, sizeof(struct __eoddata1__Membership_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__Membership_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__Membership && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__Membership(soap, "eoddata1:Membership", &a->eoddata1__Membership, ""))
				{	soap_flag_eoddata1__Membership--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__Membership_ * SOAP_FMAC2 soap_instantiate___eoddata1__Membership_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__Membership_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__Membership_ *p;
	size_t k = sizeof(struct __eoddata1__Membership_);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__Membership_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__Membership_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__Membership_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__Membership_, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__Membership_(struct soap *soap, const struct __eoddata1__Membership_ *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__Membership_(soap, tag?tag:"-eoddata1:Membership", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__Membership_ * SOAP_FMAC4 soap_get___eoddata1__Membership_(struct soap *soap, struct __eoddata1__Membership_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__Membership_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__Login2_::__eoddata1__Login2_()
{
	soap_default___eoddata1__Login2_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__Login2_(struct soap *soap, struct __eoddata1__Login2_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__Login2 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__Login2_(struct soap *soap, const struct __eoddata1__Login2_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__Login2(soap, &a->eoddata1__Login2);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__Login2_(struct soap *soap, const char *tag, int id, const struct __eoddata1__Login2_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__Login2(soap, "eoddata1:Login2", -1, &a->eoddata1__Login2, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__Login2_ * SOAP_FMAC4 soap_in___eoddata1__Login2_(struct soap *soap, const char *tag, struct __eoddata1__Login2_ *a, const char *type)
{
	size_t soap_flag_eoddata1__Login2 = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__Login2_ *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__Login2_, sizeof(struct __eoddata1__Login2_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__Login2_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__Login2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__Login2(soap, "eoddata1:Login2", &a->eoddata1__Login2, ""))
				{	soap_flag_eoddata1__Login2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__Login2_ * SOAP_FMAC2 soap_instantiate___eoddata1__Login2_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__Login2_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__Login2_ *p;
	size_t k = sizeof(struct __eoddata1__Login2_);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__Login2_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__Login2_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__Login2_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__Login2_, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__Login2_(struct soap *soap, const struct __eoddata1__Login2_ *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__Login2_(soap, tag?tag:"-eoddata1:Login2", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__Login2_ * SOAP_FMAC4 soap_get___eoddata1__Login2_(struct soap *soap, struct __eoddata1__Login2_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__Login2_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__Login_::__eoddata1__Login_()
{
	soap_default___eoddata1__Login_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__Login_(struct soap *soap, struct __eoddata1__Login_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__Login = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__Login_(struct soap *soap, const struct __eoddata1__Login_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__Login(soap, &a->eoddata1__Login);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__Login_(struct soap *soap, const char *tag, int id, const struct __eoddata1__Login_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__Login(soap, "eoddata1:Login", -1, &a->eoddata1__Login, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__Login_ * SOAP_FMAC4 soap_in___eoddata1__Login_(struct soap *soap, const char *tag, struct __eoddata1__Login_ *a, const char *type)
{
	size_t soap_flag_eoddata1__Login = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__Login_ *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__Login_, sizeof(struct __eoddata1__Login_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__Login_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__Login && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__Login(soap, "eoddata1:Login", &a->eoddata1__Login, ""))
				{	soap_flag_eoddata1__Login--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__Login_ * SOAP_FMAC2 soap_instantiate___eoddata1__Login_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__Login_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__Login_ *p;
	size_t k = sizeof(struct __eoddata1__Login_);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__Login_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__Login_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__Login_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__Login_, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__Login_(struct soap *soap, const struct __eoddata1__Login_ *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__Login_(soap, tag?tag:"-eoddata1:Login", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__Login_ * SOAP_FMAC4 soap_get___eoddata1__Login_(struct soap *soap, struct __eoddata1__Login_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__Login_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__ValidateAccess::__eoddata1__ValidateAccess()
{
	soap_default___eoddata1__ValidateAccess(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__ValidateAccess(struct soap *soap, struct __eoddata1__ValidateAccess *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__ValidateAccess = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__ValidateAccess(struct soap *soap, const struct __eoddata1__ValidateAccess *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__ValidateAccess(soap, &a->eoddata1__ValidateAccess);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__ValidateAccess(struct soap *soap, const char *tag, int id, const struct __eoddata1__ValidateAccess *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__ValidateAccess(soap, "eoddata1:ValidateAccess", -1, &a->eoddata1__ValidateAccess, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__ValidateAccess * SOAP_FMAC4 soap_in___eoddata1__ValidateAccess(struct soap *soap, const char *tag, struct __eoddata1__ValidateAccess *a, const char *type)
{
	size_t soap_flag_eoddata1__ValidateAccess = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__ValidateAccess *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__ValidateAccess, sizeof(struct __eoddata1__ValidateAccess), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__ValidateAccess(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__ValidateAccess && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__ValidateAccess(soap, "eoddata1:ValidateAccess", &a->eoddata1__ValidateAccess, ""))
				{	soap_flag_eoddata1__ValidateAccess--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__ValidateAccess * SOAP_FMAC2 soap_instantiate___eoddata1__ValidateAccess(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__ValidateAccess(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__ValidateAccess *p;
	size_t k = sizeof(struct __eoddata1__ValidateAccess);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__ValidateAccess);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__ValidateAccess, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__ValidateAccess location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__ValidateAccess, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__ValidateAccess(struct soap *soap, const struct __eoddata1__ValidateAccess *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__ValidateAccess(soap, tag?tag:"-eoddata1:ValidateAccess", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__ValidateAccess * SOAP_FMAC4 soap_get___eoddata1__ValidateAccess(struct soap *soap, struct __eoddata1__ValidateAccess *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__ValidateAccess(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__UpdateDataFormat::__eoddata1__UpdateDataFormat()
{
	soap_default___eoddata1__UpdateDataFormat(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__UpdateDataFormat(struct soap *soap, struct __eoddata1__UpdateDataFormat *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__UpdateDataFormat = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__UpdateDataFormat(struct soap *soap, const struct __eoddata1__UpdateDataFormat *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__UpdateDataFormat(soap, &a->eoddata1__UpdateDataFormat);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__UpdateDataFormat(struct soap *soap, const char *tag, int id, const struct __eoddata1__UpdateDataFormat *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__UpdateDataFormat(soap, "eoddata1:UpdateDataFormat", -1, &a->eoddata1__UpdateDataFormat, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__UpdateDataFormat * SOAP_FMAC4 soap_in___eoddata1__UpdateDataFormat(struct soap *soap, const char *tag, struct __eoddata1__UpdateDataFormat *a, const char *type)
{
	size_t soap_flag_eoddata1__UpdateDataFormat = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__UpdateDataFormat *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__UpdateDataFormat, sizeof(struct __eoddata1__UpdateDataFormat), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__UpdateDataFormat(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__UpdateDataFormat && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__UpdateDataFormat(soap, "eoddata1:UpdateDataFormat", &a->eoddata1__UpdateDataFormat, ""))
				{	soap_flag_eoddata1__UpdateDataFormat--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__UpdateDataFormat * SOAP_FMAC2 soap_instantiate___eoddata1__UpdateDataFormat(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__UpdateDataFormat(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__UpdateDataFormat *p;
	size_t k = sizeof(struct __eoddata1__UpdateDataFormat);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__UpdateDataFormat);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__UpdateDataFormat, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__UpdateDataFormat location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__UpdateDataFormat, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__UpdateDataFormat(struct soap *soap, const struct __eoddata1__UpdateDataFormat *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__UpdateDataFormat(soap, tag?tag:"-eoddata1:UpdateDataFormat", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__UpdateDataFormat * SOAP_FMAC4 soap_get___eoddata1__UpdateDataFormat(struct soap *soap, struct __eoddata1__UpdateDataFormat *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__UpdateDataFormat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__DataFormats::__eoddata1__DataFormats()
{
	soap_default___eoddata1__DataFormats(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__DataFormats(struct soap *soap, struct __eoddata1__DataFormats *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__DataFormats = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__DataFormats(struct soap *soap, const struct __eoddata1__DataFormats *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__DataFormats(soap, &a->eoddata1__DataFormats);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__DataFormats(struct soap *soap, const char *tag, int id, const struct __eoddata1__DataFormats *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__DataFormats(soap, "eoddata1:DataFormats", -1, &a->eoddata1__DataFormats, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__DataFormats * SOAP_FMAC4 soap_in___eoddata1__DataFormats(struct soap *soap, const char *tag, struct __eoddata1__DataFormats *a, const char *type)
{
	size_t soap_flag_eoddata1__DataFormats = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__DataFormats *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__DataFormats, sizeof(struct __eoddata1__DataFormats), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__DataFormats(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__DataFormats && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__DataFormats(soap, "eoddata1:DataFormats", &a->eoddata1__DataFormats, ""))
				{	soap_flag_eoddata1__DataFormats--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__DataFormats * SOAP_FMAC2 soap_instantiate___eoddata1__DataFormats(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__DataFormats(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__DataFormats *p;
	size_t k = sizeof(struct __eoddata1__DataFormats);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__DataFormats);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__DataFormats, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__DataFormats location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__DataFormats, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__DataFormats(struct soap *soap, const struct __eoddata1__DataFormats *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__DataFormats(soap, tag?tag:"-eoddata1:DataFormats", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__DataFormats * SOAP_FMAC4 soap_get___eoddata1__DataFormats(struct soap *soap, struct __eoddata1__DataFormats *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__DataFormats(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__DataClientLatestVersion::__eoddata1__DataClientLatestVersion()
{
	soap_default___eoddata1__DataClientLatestVersion(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__DataClientLatestVersion(struct soap *soap, struct __eoddata1__DataClientLatestVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__DataClientLatestVersion = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__DataClientLatestVersion(struct soap *soap, const struct __eoddata1__DataClientLatestVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__DataClientLatestVersion(soap, &a->eoddata1__DataClientLatestVersion);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__DataClientLatestVersion(struct soap *soap, const char *tag, int id, const struct __eoddata1__DataClientLatestVersion *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__DataClientLatestVersion(soap, "eoddata1:DataClientLatestVersion", -1, &a->eoddata1__DataClientLatestVersion, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__DataClientLatestVersion * SOAP_FMAC4 soap_in___eoddata1__DataClientLatestVersion(struct soap *soap, const char *tag, struct __eoddata1__DataClientLatestVersion *a, const char *type)
{
	size_t soap_flag_eoddata1__DataClientLatestVersion = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__DataClientLatestVersion *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__DataClientLatestVersion, sizeof(struct __eoddata1__DataClientLatestVersion), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__DataClientLatestVersion(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__DataClientLatestVersion && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__DataClientLatestVersion(soap, "eoddata1:DataClientLatestVersion", &a->eoddata1__DataClientLatestVersion, ""))
				{	soap_flag_eoddata1__DataClientLatestVersion--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__DataClientLatestVersion * SOAP_FMAC2 soap_instantiate___eoddata1__DataClientLatestVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__DataClientLatestVersion(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__DataClientLatestVersion *p;
	size_t k = sizeof(struct __eoddata1__DataClientLatestVersion);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__DataClientLatestVersion);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__DataClientLatestVersion, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__DataClientLatestVersion location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__DataClientLatestVersion, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__DataClientLatestVersion(struct soap *soap, const struct __eoddata1__DataClientLatestVersion *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__DataClientLatestVersion(soap, tag?tag:"-eoddata1:DataClientLatestVersion", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__DataClientLatestVersion * SOAP_FMAC4 soap_get___eoddata1__DataClientLatestVersion(struct soap *soap, struct __eoddata1__DataClientLatestVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__DataClientLatestVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__SymbolChangesByExchange::__eoddata1__SymbolChangesByExchange()
{
	soap_default___eoddata1__SymbolChangesByExchange(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__SymbolChangesByExchange(struct soap *soap, struct __eoddata1__SymbolChangesByExchange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__SymbolChangesByExchange = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__SymbolChangesByExchange(struct soap *soap, const struct __eoddata1__SymbolChangesByExchange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__SymbolChangesByExchange(soap, &a->eoddata1__SymbolChangesByExchange);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__SymbolChangesByExchange(struct soap *soap, const char *tag, int id, const struct __eoddata1__SymbolChangesByExchange *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__SymbolChangesByExchange(soap, "eoddata1:SymbolChangesByExchange", -1, &a->eoddata1__SymbolChangesByExchange, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__SymbolChangesByExchange * SOAP_FMAC4 soap_in___eoddata1__SymbolChangesByExchange(struct soap *soap, const char *tag, struct __eoddata1__SymbolChangesByExchange *a, const char *type)
{
	size_t soap_flag_eoddata1__SymbolChangesByExchange = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__SymbolChangesByExchange *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__SymbolChangesByExchange, sizeof(struct __eoddata1__SymbolChangesByExchange), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__SymbolChangesByExchange(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__SymbolChangesByExchange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__SymbolChangesByExchange(soap, "eoddata1:SymbolChangesByExchange", &a->eoddata1__SymbolChangesByExchange, ""))
				{	soap_flag_eoddata1__SymbolChangesByExchange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__SymbolChangesByExchange * SOAP_FMAC2 soap_instantiate___eoddata1__SymbolChangesByExchange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__SymbolChangesByExchange(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__SymbolChangesByExchange *p;
	size_t k = sizeof(struct __eoddata1__SymbolChangesByExchange);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__SymbolChangesByExchange);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__SymbolChangesByExchange, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__SymbolChangesByExchange location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__SymbolChangesByExchange, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__SymbolChangesByExchange(struct soap *soap, const struct __eoddata1__SymbolChangesByExchange *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__SymbolChangesByExchange(soap, tag?tag:"-eoddata1:SymbolChangesByExchange", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__SymbolChangesByExchange * SOAP_FMAC4 soap_get___eoddata1__SymbolChangesByExchange(struct soap *soap, struct __eoddata1__SymbolChangesByExchange *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__SymbolChangesByExchange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__QuoteListByDatePeriod2::__eoddata1__QuoteListByDatePeriod2()
{
	soap_default___eoddata1__QuoteListByDatePeriod2(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__QuoteListByDatePeriod2(struct soap *soap, struct __eoddata1__QuoteListByDatePeriod2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__QuoteListByDatePeriod2 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__QuoteListByDatePeriod2(struct soap *soap, const struct __eoddata1__QuoteListByDatePeriod2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__QuoteListByDatePeriod2(soap, &a->eoddata1__QuoteListByDatePeriod2);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__QuoteListByDatePeriod2(struct soap *soap, const char *tag, int id, const struct __eoddata1__QuoteListByDatePeriod2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__QuoteListByDatePeriod2(soap, "eoddata1:QuoteListByDatePeriod2", -1, &a->eoddata1__QuoteListByDatePeriod2, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__QuoteListByDatePeriod2 * SOAP_FMAC4 soap_in___eoddata1__QuoteListByDatePeriod2(struct soap *soap, const char *tag, struct __eoddata1__QuoteListByDatePeriod2 *a, const char *type)
{
	size_t soap_flag_eoddata1__QuoteListByDatePeriod2 = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__QuoteListByDatePeriod2 *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__QuoteListByDatePeriod2, sizeof(struct __eoddata1__QuoteListByDatePeriod2), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__QuoteListByDatePeriod2(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__QuoteListByDatePeriod2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__QuoteListByDatePeriod2(soap, "eoddata1:QuoteListByDatePeriod2", &a->eoddata1__QuoteListByDatePeriod2, ""))
				{	soap_flag_eoddata1__QuoteListByDatePeriod2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__QuoteListByDatePeriod2 * SOAP_FMAC2 soap_instantiate___eoddata1__QuoteListByDatePeriod2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__QuoteListByDatePeriod2(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__QuoteListByDatePeriod2 *p;
	size_t k = sizeof(struct __eoddata1__QuoteListByDatePeriod2);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__QuoteListByDatePeriod2);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__QuoteListByDatePeriod2, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__QuoteListByDatePeriod2 location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__QuoteListByDatePeriod2, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__QuoteListByDatePeriod2(struct soap *soap, const struct __eoddata1__QuoteListByDatePeriod2 *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__QuoteListByDatePeriod2(soap, tag?tag:"-eoddata1:QuoteListByDatePeriod2", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__QuoteListByDatePeriod2 * SOAP_FMAC4 soap_get___eoddata1__QuoteListByDatePeriod2(struct soap *soap, struct __eoddata1__QuoteListByDatePeriod2 *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__QuoteListByDatePeriod2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__QuoteListByDatePeriod::__eoddata1__QuoteListByDatePeriod()
{
	soap_default___eoddata1__QuoteListByDatePeriod(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__QuoteListByDatePeriod(struct soap *soap, struct __eoddata1__QuoteListByDatePeriod *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__QuoteListByDatePeriod = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__QuoteListByDatePeriod(struct soap *soap, const struct __eoddata1__QuoteListByDatePeriod *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__QuoteListByDatePeriod(soap, &a->eoddata1__QuoteListByDatePeriod);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__QuoteListByDatePeriod(struct soap *soap, const char *tag, int id, const struct __eoddata1__QuoteListByDatePeriod *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__QuoteListByDatePeriod(soap, "eoddata1:QuoteListByDatePeriod", -1, &a->eoddata1__QuoteListByDatePeriod, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__QuoteListByDatePeriod * SOAP_FMAC4 soap_in___eoddata1__QuoteListByDatePeriod(struct soap *soap, const char *tag, struct __eoddata1__QuoteListByDatePeriod *a, const char *type)
{
	size_t soap_flag_eoddata1__QuoteListByDatePeriod = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__QuoteListByDatePeriod *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__QuoteListByDatePeriod, sizeof(struct __eoddata1__QuoteListByDatePeriod), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__QuoteListByDatePeriod(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__QuoteListByDatePeriod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__QuoteListByDatePeriod(soap, "eoddata1:QuoteListByDatePeriod", &a->eoddata1__QuoteListByDatePeriod, ""))
				{	soap_flag_eoddata1__QuoteListByDatePeriod--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__QuoteListByDatePeriod * SOAP_FMAC2 soap_instantiate___eoddata1__QuoteListByDatePeriod(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__QuoteListByDatePeriod(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__QuoteListByDatePeriod *p;
	size_t k = sizeof(struct __eoddata1__QuoteListByDatePeriod);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__QuoteListByDatePeriod);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__QuoteListByDatePeriod, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__QuoteListByDatePeriod location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__QuoteListByDatePeriod, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__QuoteListByDatePeriod(struct soap *soap, const struct __eoddata1__QuoteListByDatePeriod *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__QuoteListByDatePeriod(soap, tag?tag:"-eoddata1:QuoteListByDatePeriod", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__QuoteListByDatePeriod * SOAP_FMAC4 soap_get___eoddata1__QuoteListByDatePeriod(struct soap *soap, struct __eoddata1__QuoteListByDatePeriod *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__QuoteListByDatePeriod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__SymbolHistoryPeriodByDateRange::__eoddata1__SymbolHistoryPeriodByDateRange()
{
	soap_default___eoddata1__SymbolHistoryPeriodByDateRange(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__SymbolHistoryPeriodByDateRange(struct soap *soap, struct __eoddata1__SymbolHistoryPeriodByDateRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__SymbolHistoryPeriodByDateRange = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__SymbolHistoryPeriodByDateRange(struct soap *soap, const struct __eoddata1__SymbolHistoryPeriodByDateRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__SymbolHistoryPeriodByDateRange(soap, &a->eoddata1__SymbolHistoryPeriodByDateRange);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__SymbolHistoryPeriodByDateRange(struct soap *soap, const char *tag, int id, const struct __eoddata1__SymbolHistoryPeriodByDateRange *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__SymbolHistoryPeriodByDateRange(soap, "eoddata1:SymbolHistoryPeriodByDateRange", -1, &a->eoddata1__SymbolHistoryPeriodByDateRange, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__SymbolHistoryPeriodByDateRange * SOAP_FMAC4 soap_in___eoddata1__SymbolHistoryPeriodByDateRange(struct soap *soap, const char *tag, struct __eoddata1__SymbolHistoryPeriodByDateRange *a, const char *type)
{
	size_t soap_flag_eoddata1__SymbolHistoryPeriodByDateRange = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__SymbolHistoryPeriodByDateRange *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__SymbolHistoryPeriodByDateRange, sizeof(struct __eoddata1__SymbolHistoryPeriodByDateRange), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__SymbolHistoryPeriodByDateRange(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__SymbolHistoryPeriodByDateRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__SymbolHistoryPeriodByDateRange(soap, "eoddata1:SymbolHistoryPeriodByDateRange", &a->eoddata1__SymbolHistoryPeriodByDateRange, ""))
				{	soap_flag_eoddata1__SymbolHistoryPeriodByDateRange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__SymbolHistoryPeriodByDateRange * SOAP_FMAC2 soap_instantiate___eoddata1__SymbolHistoryPeriodByDateRange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__SymbolHistoryPeriodByDateRange(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__SymbolHistoryPeriodByDateRange *p;
	size_t k = sizeof(struct __eoddata1__SymbolHistoryPeriodByDateRange);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__SymbolHistoryPeriodByDateRange);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__SymbolHistoryPeriodByDateRange, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__SymbolHistoryPeriodByDateRange location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__SymbolHistoryPeriodByDateRange, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__SymbolHistoryPeriodByDateRange(struct soap *soap, const struct __eoddata1__SymbolHistoryPeriodByDateRange *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__SymbolHistoryPeriodByDateRange(soap, tag?tag:"-eoddata1:SymbolHistoryPeriodByDateRange", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__SymbolHistoryPeriodByDateRange * SOAP_FMAC4 soap_get___eoddata1__SymbolHistoryPeriodByDateRange(struct soap *soap, struct __eoddata1__SymbolHistoryPeriodByDateRange *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__SymbolHistoryPeriodByDateRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__SymbolHistoryPeriod::__eoddata1__SymbolHistoryPeriod()
{
	soap_default___eoddata1__SymbolHistoryPeriod(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__SymbolHistoryPeriod(struct soap *soap, struct __eoddata1__SymbolHistoryPeriod *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__SymbolHistoryPeriod = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__SymbolHistoryPeriod(struct soap *soap, const struct __eoddata1__SymbolHistoryPeriod *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__SymbolHistoryPeriod(soap, &a->eoddata1__SymbolHistoryPeriod);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__SymbolHistoryPeriod(struct soap *soap, const char *tag, int id, const struct __eoddata1__SymbolHistoryPeriod *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__SymbolHistoryPeriod(soap, "eoddata1:SymbolHistoryPeriod", -1, &a->eoddata1__SymbolHistoryPeriod, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__SymbolHistoryPeriod * SOAP_FMAC4 soap_in___eoddata1__SymbolHistoryPeriod(struct soap *soap, const char *tag, struct __eoddata1__SymbolHistoryPeriod *a, const char *type)
{
	size_t soap_flag_eoddata1__SymbolHistoryPeriod = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__SymbolHistoryPeriod *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__SymbolHistoryPeriod, sizeof(struct __eoddata1__SymbolHistoryPeriod), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__SymbolHistoryPeriod(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__SymbolHistoryPeriod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__SymbolHistoryPeriod(soap, "eoddata1:SymbolHistoryPeriod", &a->eoddata1__SymbolHistoryPeriod, ""))
				{	soap_flag_eoddata1__SymbolHistoryPeriod--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__SymbolHistoryPeriod * SOAP_FMAC2 soap_instantiate___eoddata1__SymbolHistoryPeriod(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__SymbolHistoryPeriod(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__SymbolHistoryPeriod *p;
	size_t k = sizeof(struct __eoddata1__SymbolHistoryPeriod);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__SymbolHistoryPeriod);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__SymbolHistoryPeriod, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__SymbolHistoryPeriod location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__SymbolHistoryPeriod, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__SymbolHistoryPeriod(struct soap *soap, const struct __eoddata1__SymbolHistoryPeriod *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__SymbolHistoryPeriod(soap, tag?tag:"-eoddata1:SymbolHistoryPeriod", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__SymbolHistoryPeriod * SOAP_FMAC4 soap_get___eoddata1__SymbolHistoryPeriod(struct soap *soap, struct __eoddata1__SymbolHistoryPeriod *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__SymbolHistoryPeriod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__CountryList::__eoddata1__CountryList()
{
	soap_default___eoddata1__CountryList(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__CountryList(struct soap *soap, struct __eoddata1__CountryList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__CountryList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__CountryList(struct soap *soap, const struct __eoddata1__CountryList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__CountryList(soap, &a->eoddata1__CountryList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__CountryList(struct soap *soap, const char *tag, int id, const struct __eoddata1__CountryList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__CountryList(soap, "eoddata1:CountryList", -1, &a->eoddata1__CountryList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__CountryList * SOAP_FMAC4 soap_in___eoddata1__CountryList(struct soap *soap, const char *tag, struct __eoddata1__CountryList *a, const char *type)
{
	size_t soap_flag_eoddata1__CountryList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__CountryList *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__CountryList, sizeof(struct __eoddata1__CountryList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__CountryList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__CountryList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__CountryList(soap, "eoddata1:CountryList", &a->eoddata1__CountryList, ""))
				{	soap_flag_eoddata1__CountryList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__CountryList * SOAP_FMAC2 soap_instantiate___eoddata1__CountryList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__CountryList(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__CountryList *p;
	size_t k = sizeof(struct __eoddata1__CountryList);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__CountryList);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__CountryList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__CountryList location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__CountryList, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__CountryList(struct soap *soap, const struct __eoddata1__CountryList *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__CountryList(soap, tag?tag:"-eoddata1:CountryList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__CountryList * SOAP_FMAC4 soap_get___eoddata1__CountryList(struct soap *soap, struct __eoddata1__CountryList *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__CountryList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__SplitListBySymbol::__eoddata1__SplitListBySymbol()
{
	soap_default___eoddata1__SplitListBySymbol(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__SplitListBySymbol(struct soap *soap, struct __eoddata1__SplitListBySymbol *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__SplitListBySymbol = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__SplitListBySymbol(struct soap *soap, const struct __eoddata1__SplitListBySymbol *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__SplitListBySymbol(soap, &a->eoddata1__SplitListBySymbol);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__SplitListBySymbol(struct soap *soap, const char *tag, int id, const struct __eoddata1__SplitListBySymbol *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__SplitListBySymbol(soap, "eoddata1:SplitListBySymbol", -1, &a->eoddata1__SplitListBySymbol, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__SplitListBySymbol * SOAP_FMAC4 soap_in___eoddata1__SplitListBySymbol(struct soap *soap, const char *tag, struct __eoddata1__SplitListBySymbol *a, const char *type)
{
	size_t soap_flag_eoddata1__SplitListBySymbol = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__SplitListBySymbol *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__SplitListBySymbol, sizeof(struct __eoddata1__SplitListBySymbol), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__SplitListBySymbol(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__SplitListBySymbol && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__SplitListBySymbol(soap, "eoddata1:SplitListBySymbol", &a->eoddata1__SplitListBySymbol, ""))
				{	soap_flag_eoddata1__SplitListBySymbol--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__SplitListBySymbol * SOAP_FMAC2 soap_instantiate___eoddata1__SplitListBySymbol(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__SplitListBySymbol(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__SplitListBySymbol *p;
	size_t k = sizeof(struct __eoddata1__SplitListBySymbol);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__SplitListBySymbol);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__SplitListBySymbol, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__SplitListBySymbol location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__SplitListBySymbol, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__SplitListBySymbol(struct soap *soap, const struct __eoddata1__SplitListBySymbol *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__SplitListBySymbol(soap, tag?tag:"-eoddata1:SplitListBySymbol", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__SplitListBySymbol * SOAP_FMAC4 soap_get___eoddata1__SplitListBySymbol(struct soap *soap, struct __eoddata1__SplitListBySymbol *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__SplitListBySymbol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__SplitListByExchange::__eoddata1__SplitListByExchange()
{
	soap_default___eoddata1__SplitListByExchange(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__SplitListByExchange(struct soap *soap, struct __eoddata1__SplitListByExchange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__SplitListByExchange = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__SplitListByExchange(struct soap *soap, const struct __eoddata1__SplitListByExchange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__SplitListByExchange(soap, &a->eoddata1__SplitListByExchange);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__SplitListByExchange(struct soap *soap, const char *tag, int id, const struct __eoddata1__SplitListByExchange *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__SplitListByExchange(soap, "eoddata1:SplitListByExchange", -1, &a->eoddata1__SplitListByExchange, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__SplitListByExchange * SOAP_FMAC4 soap_in___eoddata1__SplitListByExchange(struct soap *soap, const char *tag, struct __eoddata1__SplitListByExchange *a, const char *type)
{
	size_t soap_flag_eoddata1__SplitListByExchange = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__SplitListByExchange *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__SplitListByExchange, sizeof(struct __eoddata1__SplitListByExchange), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__SplitListByExchange(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__SplitListByExchange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__SplitListByExchange(soap, "eoddata1:SplitListByExchange", &a->eoddata1__SplitListByExchange, ""))
				{	soap_flag_eoddata1__SplitListByExchange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__SplitListByExchange * SOAP_FMAC2 soap_instantiate___eoddata1__SplitListByExchange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__SplitListByExchange(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__SplitListByExchange *p;
	size_t k = sizeof(struct __eoddata1__SplitListByExchange);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__SplitListByExchange);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__SplitListByExchange, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__SplitListByExchange location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__SplitListByExchange, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__SplitListByExchange(struct soap *soap, const struct __eoddata1__SplitListByExchange *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__SplitListByExchange(soap, tag?tag:"-eoddata1:SplitListByExchange", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__SplitListByExchange * SOAP_FMAC4 soap_get___eoddata1__SplitListByExchange(struct soap *soap, struct __eoddata1__SplitListByExchange *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__SplitListByExchange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__ExchangeMonths::__eoddata1__ExchangeMonths()
{
	soap_default___eoddata1__ExchangeMonths(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__ExchangeMonths(struct soap *soap, struct __eoddata1__ExchangeMonths *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__ExchangeMonths = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__ExchangeMonths(struct soap *soap, const struct __eoddata1__ExchangeMonths *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__ExchangeMonths(soap, &a->eoddata1__ExchangeMonths);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__ExchangeMonths(struct soap *soap, const char *tag, int id, const struct __eoddata1__ExchangeMonths *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__ExchangeMonths(soap, "eoddata1:ExchangeMonths", -1, &a->eoddata1__ExchangeMonths, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__ExchangeMonths * SOAP_FMAC4 soap_in___eoddata1__ExchangeMonths(struct soap *soap, const char *tag, struct __eoddata1__ExchangeMonths *a, const char *type)
{
	size_t soap_flag_eoddata1__ExchangeMonths = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__ExchangeMonths *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__ExchangeMonths, sizeof(struct __eoddata1__ExchangeMonths), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__ExchangeMonths(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__ExchangeMonths && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__ExchangeMonths(soap, "eoddata1:ExchangeMonths", &a->eoddata1__ExchangeMonths, ""))
				{	soap_flag_eoddata1__ExchangeMonths--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__ExchangeMonths * SOAP_FMAC2 soap_instantiate___eoddata1__ExchangeMonths(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__ExchangeMonths(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__ExchangeMonths *p;
	size_t k = sizeof(struct __eoddata1__ExchangeMonths);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__ExchangeMonths);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__ExchangeMonths, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__ExchangeMonths location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__ExchangeMonths, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__ExchangeMonths(struct soap *soap, const struct __eoddata1__ExchangeMonths *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__ExchangeMonths(soap, tag?tag:"-eoddata1:ExchangeMonths", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__ExchangeMonths * SOAP_FMAC4 soap_get___eoddata1__ExchangeMonths(struct soap *soap, struct __eoddata1__ExchangeMonths *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__ExchangeMonths(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__SymbolChart::__eoddata1__SymbolChart()
{
	soap_default___eoddata1__SymbolChart(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__SymbolChart(struct soap *soap, struct __eoddata1__SymbolChart *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__SymbolChart = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__SymbolChart(struct soap *soap, const struct __eoddata1__SymbolChart *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__SymbolChart(soap, &a->eoddata1__SymbolChart);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__SymbolChart(struct soap *soap, const char *tag, int id, const struct __eoddata1__SymbolChart *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__SymbolChart(soap, "eoddata1:SymbolChart", -1, &a->eoddata1__SymbolChart, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__SymbolChart * SOAP_FMAC4 soap_in___eoddata1__SymbolChart(struct soap *soap, const char *tag, struct __eoddata1__SymbolChart *a, const char *type)
{
	size_t soap_flag_eoddata1__SymbolChart = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__SymbolChart *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__SymbolChart, sizeof(struct __eoddata1__SymbolChart), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__SymbolChart(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__SymbolChart && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__SymbolChart(soap, "eoddata1:SymbolChart", &a->eoddata1__SymbolChart, ""))
				{	soap_flag_eoddata1__SymbolChart--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__SymbolChart * SOAP_FMAC2 soap_instantiate___eoddata1__SymbolChart(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__SymbolChart(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__SymbolChart *p;
	size_t k = sizeof(struct __eoddata1__SymbolChart);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__SymbolChart);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__SymbolChart, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__SymbolChart location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__SymbolChart, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__SymbolChart(struct soap *soap, const struct __eoddata1__SymbolChart *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__SymbolChart(soap, tag?tag:"-eoddata1:SymbolChart", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__SymbolChart * SOAP_FMAC4 soap_get___eoddata1__SymbolChart(struct soap *soap, struct __eoddata1__SymbolChart *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__SymbolChart(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__Top10Losses::__eoddata1__Top10Losses()
{
	soap_default___eoddata1__Top10Losses(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__Top10Losses(struct soap *soap, struct __eoddata1__Top10Losses *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__Top10Losses = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__Top10Losses(struct soap *soap, const struct __eoddata1__Top10Losses *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__Top10Losses(soap, &a->eoddata1__Top10Losses);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__Top10Losses(struct soap *soap, const char *tag, int id, const struct __eoddata1__Top10Losses *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__Top10Losses(soap, "eoddata1:Top10Losses", -1, &a->eoddata1__Top10Losses, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__Top10Losses * SOAP_FMAC4 soap_in___eoddata1__Top10Losses(struct soap *soap, const char *tag, struct __eoddata1__Top10Losses *a, const char *type)
{
	size_t soap_flag_eoddata1__Top10Losses = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__Top10Losses *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__Top10Losses, sizeof(struct __eoddata1__Top10Losses), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__Top10Losses(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__Top10Losses && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__Top10Losses(soap, "eoddata1:Top10Losses", &a->eoddata1__Top10Losses, ""))
				{	soap_flag_eoddata1__Top10Losses--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__Top10Losses * SOAP_FMAC2 soap_instantiate___eoddata1__Top10Losses(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__Top10Losses(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__Top10Losses *p;
	size_t k = sizeof(struct __eoddata1__Top10Losses);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__Top10Losses);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__Top10Losses, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__Top10Losses location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__Top10Losses, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__Top10Losses(struct soap *soap, const struct __eoddata1__Top10Losses *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__Top10Losses(soap, tag?tag:"-eoddata1:Top10Losses", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__Top10Losses * SOAP_FMAC4 soap_get___eoddata1__Top10Losses(struct soap *soap, struct __eoddata1__Top10Losses *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__Top10Losses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__Top10Gains::__eoddata1__Top10Gains()
{
	soap_default___eoddata1__Top10Gains(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__Top10Gains(struct soap *soap, struct __eoddata1__Top10Gains *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__Top10Gains = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__Top10Gains(struct soap *soap, const struct __eoddata1__Top10Gains *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__Top10Gains(soap, &a->eoddata1__Top10Gains);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__Top10Gains(struct soap *soap, const char *tag, int id, const struct __eoddata1__Top10Gains *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__Top10Gains(soap, "eoddata1:Top10Gains", -1, &a->eoddata1__Top10Gains, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__Top10Gains * SOAP_FMAC4 soap_in___eoddata1__Top10Gains(struct soap *soap, const char *tag, struct __eoddata1__Top10Gains *a, const char *type)
{
	size_t soap_flag_eoddata1__Top10Gains = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__Top10Gains *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__Top10Gains, sizeof(struct __eoddata1__Top10Gains), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__Top10Gains(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__Top10Gains && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__Top10Gains(soap, "eoddata1:Top10Gains", &a->eoddata1__Top10Gains, ""))
				{	soap_flag_eoddata1__Top10Gains--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__Top10Gains * SOAP_FMAC2 soap_instantiate___eoddata1__Top10Gains(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__Top10Gains(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__Top10Gains *p;
	size_t k = sizeof(struct __eoddata1__Top10Gains);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__Top10Gains);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__Top10Gains, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__Top10Gains location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__Top10Gains, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__Top10Gains(struct soap *soap, const struct __eoddata1__Top10Gains *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__Top10Gains(soap, tag?tag:"-eoddata1:Top10Gains", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__Top10Gains * SOAP_FMAC4 soap_get___eoddata1__Top10Gains(struct soap *soap, struct __eoddata1__Top10Gains *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__Top10Gains(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__SymbolHistory::__eoddata1__SymbolHistory()
{
	soap_default___eoddata1__SymbolHistory(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__SymbolHistory(struct soap *soap, struct __eoddata1__SymbolHistory *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__SymbolHistory = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__SymbolHistory(struct soap *soap, const struct __eoddata1__SymbolHistory *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__SymbolHistory(soap, &a->eoddata1__SymbolHistory);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__SymbolHistory(struct soap *soap, const char *tag, int id, const struct __eoddata1__SymbolHistory *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__SymbolHistory(soap, "eoddata1:SymbolHistory", -1, &a->eoddata1__SymbolHistory, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__SymbolHistory * SOAP_FMAC4 soap_in___eoddata1__SymbolHistory(struct soap *soap, const char *tag, struct __eoddata1__SymbolHistory *a, const char *type)
{
	size_t soap_flag_eoddata1__SymbolHistory = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__SymbolHistory *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__SymbolHistory, sizeof(struct __eoddata1__SymbolHistory), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__SymbolHistory(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__SymbolHistory && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__SymbolHistory(soap, "eoddata1:SymbolHistory", &a->eoddata1__SymbolHistory, ""))
				{	soap_flag_eoddata1__SymbolHistory--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__SymbolHistory * SOAP_FMAC2 soap_instantiate___eoddata1__SymbolHistory(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__SymbolHistory(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__SymbolHistory *p;
	size_t k = sizeof(struct __eoddata1__SymbolHistory);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__SymbolHistory);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__SymbolHistory, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__SymbolHistory location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__SymbolHistory, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__SymbolHistory(struct soap *soap, const struct __eoddata1__SymbolHistory *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__SymbolHistory(soap, tag?tag:"-eoddata1:SymbolHistory", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__SymbolHistory * SOAP_FMAC4 soap_get___eoddata1__SymbolHistory(struct soap *soap, struct __eoddata1__SymbolHistory *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__SymbolHistory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__QuoteListByDate2::__eoddata1__QuoteListByDate2()
{
	soap_default___eoddata1__QuoteListByDate2(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__QuoteListByDate2(struct soap *soap, struct __eoddata1__QuoteListByDate2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__QuoteListByDate2 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__QuoteListByDate2(struct soap *soap, const struct __eoddata1__QuoteListByDate2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__QuoteListByDate2(soap, &a->eoddata1__QuoteListByDate2);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__QuoteListByDate2(struct soap *soap, const char *tag, int id, const struct __eoddata1__QuoteListByDate2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__QuoteListByDate2(soap, "eoddata1:QuoteListByDate2", -1, &a->eoddata1__QuoteListByDate2, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__QuoteListByDate2 * SOAP_FMAC4 soap_in___eoddata1__QuoteListByDate2(struct soap *soap, const char *tag, struct __eoddata1__QuoteListByDate2 *a, const char *type)
{
	size_t soap_flag_eoddata1__QuoteListByDate2 = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__QuoteListByDate2 *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__QuoteListByDate2, sizeof(struct __eoddata1__QuoteListByDate2), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__QuoteListByDate2(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__QuoteListByDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__QuoteListByDate2(soap, "eoddata1:QuoteListByDate2", &a->eoddata1__QuoteListByDate2, ""))
				{	soap_flag_eoddata1__QuoteListByDate2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__QuoteListByDate2 * SOAP_FMAC2 soap_instantiate___eoddata1__QuoteListByDate2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__QuoteListByDate2(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__QuoteListByDate2 *p;
	size_t k = sizeof(struct __eoddata1__QuoteListByDate2);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__QuoteListByDate2);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__QuoteListByDate2, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__QuoteListByDate2 location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__QuoteListByDate2, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__QuoteListByDate2(struct soap *soap, const struct __eoddata1__QuoteListByDate2 *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__QuoteListByDate2(soap, tag?tag:"-eoddata1:QuoteListByDate2", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__QuoteListByDate2 * SOAP_FMAC4 soap_get___eoddata1__QuoteListByDate2(struct soap *soap, struct __eoddata1__QuoteListByDate2 *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__QuoteListByDate2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__QuoteListByDate::__eoddata1__QuoteListByDate()
{
	soap_default___eoddata1__QuoteListByDate(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__QuoteListByDate(struct soap *soap, struct __eoddata1__QuoteListByDate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__QuoteListByDate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__QuoteListByDate(struct soap *soap, const struct __eoddata1__QuoteListByDate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__QuoteListByDate(soap, &a->eoddata1__QuoteListByDate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__QuoteListByDate(struct soap *soap, const char *tag, int id, const struct __eoddata1__QuoteListByDate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__QuoteListByDate(soap, "eoddata1:QuoteListByDate", -1, &a->eoddata1__QuoteListByDate, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__QuoteListByDate * SOAP_FMAC4 soap_in___eoddata1__QuoteListByDate(struct soap *soap, const char *tag, struct __eoddata1__QuoteListByDate *a, const char *type)
{
	size_t soap_flag_eoddata1__QuoteListByDate = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__QuoteListByDate *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__QuoteListByDate, sizeof(struct __eoddata1__QuoteListByDate), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__QuoteListByDate(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__QuoteListByDate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__QuoteListByDate(soap, "eoddata1:QuoteListByDate", &a->eoddata1__QuoteListByDate, ""))
				{	soap_flag_eoddata1__QuoteListByDate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__QuoteListByDate * SOAP_FMAC2 soap_instantiate___eoddata1__QuoteListByDate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__QuoteListByDate(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__QuoteListByDate *p;
	size_t k = sizeof(struct __eoddata1__QuoteListByDate);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__QuoteListByDate);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__QuoteListByDate, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__QuoteListByDate location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__QuoteListByDate, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__QuoteListByDate(struct soap *soap, const struct __eoddata1__QuoteListByDate *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__QuoteListByDate(soap, tag?tag:"-eoddata1:QuoteListByDate", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__QuoteListByDate * SOAP_FMAC4 soap_get___eoddata1__QuoteListByDate(struct soap *soap, struct __eoddata1__QuoteListByDate *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__QuoteListByDate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__TechnicalList::__eoddata1__TechnicalList()
{
	soap_default___eoddata1__TechnicalList(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__TechnicalList(struct soap *soap, struct __eoddata1__TechnicalList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__TechnicalList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__TechnicalList(struct soap *soap, const struct __eoddata1__TechnicalList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__TechnicalList(soap, &a->eoddata1__TechnicalList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__TechnicalList(struct soap *soap, const char *tag, int id, const struct __eoddata1__TechnicalList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__TechnicalList(soap, "eoddata1:TechnicalList", -1, &a->eoddata1__TechnicalList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__TechnicalList * SOAP_FMAC4 soap_in___eoddata1__TechnicalList(struct soap *soap, const char *tag, struct __eoddata1__TechnicalList *a, const char *type)
{
	size_t soap_flag_eoddata1__TechnicalList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__TechnicalList *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__TechnicalList, sizeof(struct __eoddata1__TechnicalList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__TechnicalList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__TechnicalList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__TechnicalList(soap, "eoddata1:TechnicalList", &a->eoddata1__TechnicalList, ""))
				{	soap_flag_eoddata1__TechnicalList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__TechnicalList * SOAP_FMAC2 soap_instantiate___eoddata1__TechnicalList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__TechnicalList(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__TechnicalList *p;
	size_t k = sizeof(struct __eoddata1__TechnicalList);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__TechnicalList);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__TechnicalList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__TechnicalList location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__TechnicalList, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__TechnicalList(struct soap *soap, const struct __eoddata1__TechnicalList *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__TechnicalList(soap, tag?tag:"-eoddata1:TechnicalList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__TechnicalList * SOAP_FMAC4 soap_get___eoddata1__TechnicalList(struct soap *soap, struct __eoddata1__TechnicalList *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__TechnicalList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__FundamentalList::__eoddata1__FundamentalList()
{
	soap_default___eoddata1__FundamentalList(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__FundamentalList(struct soap *soap, struct __eoddata1__FundamentalList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__FundamentalList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__FundamentalList(struct soap *soap, const struct __eoddata1__FundamentalList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__FundamentalList(soap, &a->eoddata1__FundamentalList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__FundamentalList(struct soap *soap, const char *tag, int id, const struct __eoddata1__FundamentalList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__FundamentalList(soap, "eoddata1:FundamentalList", -1, &a->eoddata1__FundamentalList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__FundamentalList * SOAP_FMAC4 soap_in___eoddata1__FundamentalList(struct soap *soap, const char *tag, struct __eoddata1__FundamentalList *a, const char *type)
{
	size_t soap_flag_eoddata1__FundamentalList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__FundamentalList *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__FundamentalList, sizeof(struct __eoddata1__FundamentalList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__FundamentalList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__FundamentalList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__FundamentalList(soap, "eoddata1:FundamentalList", &a->eoddata1__FundamentalList, ""))
				{	soap_flag_eoddata1__FundamentalList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__FundamentalList * SOAP_FMAC2 soap_instantiate___eoddata1__FundamentalList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__FundamentalList(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__FundamentalList *p;
	size_t k = sizeof(struct __eoddata1__FundamentalList);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__FundamentalList);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__FundamentalList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__FundamentalList location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__FundamentalList, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__FundamentalList(struct soap *soap, const struct __eoddata1__FundamentalList *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__FundamentalList(soap, tag?tag:"-eoddata1:FundamentalList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__FundamentalList * SOAP_FMAC4 soap_get___eoddata1__FundamentalList(struct soap *soap, struct __eoddata1__FundamentalList *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__FundamentalList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__NewsListBySymbol::__eoddata1__NewsListBySymbol()
{
	soap_default___eoddata1__NewsListBySymbol(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__NewsListBySymbol(struct soap *soap, struct __eoddata1__NewsListBySymbol *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__NewsListBySymbol = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__NewsListBySymbol(struct soap *soap, const struct __eoddata1__NewsListBySymbol *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__NewsListBySymbol(soap, &a->eoddata1__NewsListBySymbol);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__NewsListBySymbol(struct soap *soap, const char *tag, int id, const struct __eoddata1__NewsListBySymbol *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__NewsListBySymbol(soap, "eoddata1:NewsListBySymbol", -1, &a->eoddata1__NewsListBySymbol, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__NewsListBySymbol * SOAP_FMAC4 soap_in___eoddata1__NewsListBySymbol(struct soap *soap, const char *tag, struct __eoddata1__NewsListBySymbol *a, const char *type)
{
	size_t soap_flag_eoddata1__NewsListBySymbol = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__NewsListBySymbol *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__NewsListBySymbol, sizeof(struct __eoddata1__NewsListBySymbol), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__NewsListBySymbol(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__NewsListBySymbol && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__NewsListBySymbol(soap, "eoddata1:NewsListBySymbol", &a->eoddata1__NewsListBySymbol, ""))
				{	soap_flag_eoddata1__NewsListBySymbol--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__NewsListBySymbol * SOAP_FMAC2 soap_instantiate___eoddata1__NewsListBySymbol(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__NewsListBySymbol(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__NewsListBySymbol *p;
	size_t k = sizeof(struct __eoddata1__NewsListBySymbol);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__NewsListBySymbol);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__NewsListBySymbol, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__NewsListBySymbol location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__NewsListBySymbol, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__NewsListBySymbol(struct soap *soap, const struct __eoddata1__NewsListBySymbol *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__NewsListBySymbol(soap, tag?tag:"-eoddata1:NewsListBySymbol", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__NewsListBySymbol * SOAP_FMAC4 soap_get___eoddata1__NewsListBySymbol(struct soap *soap, struct __eoddata1__NewsListBySymbol *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__NewsListBySymbol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__NewsList::__eoddata1__NewsList()
{
	soap_default___eoddata1__NewsList(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__NewsList(struct soap *soap, struct __eoddata1__NewsList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__NewsList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__NewsList(struct soap *soap, const struct __eoddata1__NewsList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__NewsList(soap, &a->eoddata1__NewsList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__NewsList(struct soap *soap, const char *tag, int id, const struct __eoddata1__NewsList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__NewsList(soap, "eoddata1:NewsList", -1, &a->eoddata1__NewsList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__NewsList * SOAP_FMAC4 soap_in___eoddata1__NewsList(struct soap *soap, const char *tag, struct __eoddata1__NewsList *a, const char *type)
{
	size_t soap_flag_eoddata1__NewsList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__NewsList *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__NewsList, sizeof(struct __eoddata1__NewsList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__NewsList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__NewsList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__NewsList(soap, "eoddata1:NewsList", &a->eoddata1__NewsList, ""))
				{	soap_flag_eoddata1__NewsList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__NewsList * SOAP_FMAC2 soap_instantiate___eoddata1__NewsList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__NewsList(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__NewsList *p;
	size_t k = sizeof(struct __eoddata1__NewsList);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__NewsList);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__NewsList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__NewsList location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__NewsList, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__NewsList(struct soap *soap, const struct __eoddata1__NewsList *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__NewsList(soap, tag?tag:"-eoddata1:NewsList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__NewsList * SOAP_FMAC4 soap_get___eoddata1__NewsList(struct soap *soap, struct __eoddata1__NewsList *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__NewsList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__QuoteList::__eoddata1__QuoteList()
{
	soap_default___eoddata1__QuoteList(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__QuoteList(struct soap *soap, struct __eoddata1__QuoteList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__QuoteList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__QuoteList(struct soap *soap, const struct __eoddata1__QuoteList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__QuoteList(soap, &a->eoddata1__QuoteList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__QuoteList(struct soap *soap, const char *tag, int id, const struct __eoddata1__QuoteList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__QuoteList(soap, "eoddata1:QuoteList", -1, &a->eoddata1__QuoteList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__QuoteList * SOAP_FMAC4 soap_in___eoddata1__QuoteList(struct soap *soap, const char *tag, struct __eoddata1__QuoteList *a, const char *type)
{
	size_t soap_flag_eoddata1__QuoteList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__QuoteList *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__QuoteList, sizeof(struct __eoddata1__QuoteList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__QuoteList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__QuoteList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__QuoteList(soap, "eoddata1:QuoteList", &a->eoddata1__QuoteList, ""))
				{	soap_flag_eoddata1__QuoteList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__QuoteList * SOAP_FMAC2 soap_instantiate___eoddata1__QuoteList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__QuoteList(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__QuoteList *p;
	size_t k = sizeof(struct __eoddata1__QuoteList);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__QuoteList);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__QuoteList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__QuoteList location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__QuoteList, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__QuoteList(struct soap *soap, const struct __eoddata1__QuoteList *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__QuoteList(soap, tag?tag:"-eoddata1:QuoteList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__QuoteList * SOAP_FMAC4 soap_get___eoddata1__QuoteList(struct soap *soap, struct __eoddata1__QuoteList *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__QuoteList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__SymbolGet::__eoddata1__SymbolGet()
{
	soap_default___eoddata1__SymbolGet(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__SymbolGet(struct soap *soap, struct __eoddata1__SymbolGet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__SymbolGet = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__SymbolGet(struct soap *soap, const struct __eoddata1__SymbolGet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__SymbolGet(soap, &a->eoddata1__SymbolGet);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__SymbolGet(struct soap *soap, const char *tag, int id, const struct __eoddata1__SymbolGet *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__SymbolGet(soap, "eoddata1:SymbolGet", -1, &a->eoddata1__SymbolGet, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__SymbolGet * SOAP_FMAC4 soap_in___eoddata1__SymbolGet(struct soap *soap, const char *tag, struct __eoddata1__SymbolGet *a, const char *type)
{
	size_t soap_flag_eoddata1__SymbolGet = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__SymbolGet *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__SymbolGet, sizeof(struct __eoddata1__SymbolGet), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__SymbolGet(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__SymbolGet && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__SymbolGet(soap, "eoddata1:SymbolGet", &a->eoddata1__SymbolGet, ""))
				{	soap_flag_eoddata1__SymbolGet--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__SymbolGet * SOAP_FMAC2 soap_instantiate___eoddata1__SymbolGet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__SymbolGet(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__SymbolGet *p;
	size_t k = sizeof(struct __eoddata1__SymbolGet);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__SymbolGet);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__SymbolGet, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__SymbolGet location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__SymbolGet, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__SymbolGet(struct soap *soap, const struct __eoddata1__SymbolGet *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__SymbolGet(soap, tag?tag:"-eoddata1:SymbolGet", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__SymbolGet * SOAP_FMAC4 soap_get___eoddata1__SymbolGet(struct soap *soap, struct __eoddata1__SymbolGet *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__SymbolGet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__QuoteList2::__eoddata1__QuoteList2()
{
	soap_default___eoddata1__QuoteList2(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__QuoteList2(struct soap *soap, struct __eoddata1__QuoteList2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__QuoteList2 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__QuoteList2(struct soap *soap, const struct __eoddata1__QuoteList2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__QuoteList2(soap, &a->eoddata1__QuoteList2);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__QuoteList2(struct soap *soap, const char *tag, int id, const struct __eoddata1__QuoteList2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__QuoteList2(soap, "eoddata1:QuoteList2", -1, &a->eoddata1__QuoteList2, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__QuoteList2 * SOAP_FMAC4 soap_in___eoddata1__QuoteList2(struct soap *soap, const char *tag, struct __eoddata1__QuoteList2 *a, const char *type)
{
	size_t soap_flag_eoddata1__QuoteList2 = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__QuoteList2 *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__QuoteList2, sizeof(struct __eoddata1__QuoteList2), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__QuoteList2(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__QuoteList2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__QuoteList2(soap, "eoddata1:QuoteList2", &a->eoddata1__QuoteList2, ""))
				{	soap_flag_eoddata1__QuoteList2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__QuoteList2 * SOAP_FMAC2 soap_instantiate___eoddata1__QuoteList2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__QuoteList2(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__QuoteList2 *p;
	size_t k = sizeof(struct __eoddata1__QuoteList2);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__QuoteList2);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__QuoteList2, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__QuoteList2 location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__QuoteList2, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__QuoteList2(struct soap *soap, const struct __eoddata1__QuoteList2 *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__QuoteList2(soap, tag?tag:"-eoddata1:QuoteList2", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__QuoteList2 * SOAP_FMAC4 soap_get___eoddata1__QuoteList2(struct soap *soap, struct __eoddata1__QuoteList2 *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__QuoteList2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__QuoteGet::__eoddata1__QuoteGet()
{
	soap_default___eoddata1__QuoteGet(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__QuoteGet(struct soap *soap, struct __eoddata1__QuoteGet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__QuoteGet = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__QuoteGet(struct soap *soap, const struct __eoddata1__QuoteGet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__QuoteGet(soap, &a->eoddata1__QuoteGet);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__QuoteGet(struct soap *soap, const char *tag, int id, const struct __eoddata1__QuoteGet *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__QuoteGet(soap, "eoddata1:QuoteGet", -1, &a->eoddata1__QuoteGet, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__QuoteGet * SOAP_FMAC4 soap_in___eoddata1__QuoteGet(struct soap *soap, const char *tag, struct __eoddata1__QuoteGet *a, const char *type)
{
	size_t soap_flag_eoddata1__QuoteGet = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__QuoteGet *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__QuoteGet, sizeof(struct __eoddata1__QuoteGet), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__QuoteGet(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__QuoteGet && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__QuoteGet(soap, "eoddata1:QuoteGet", &a->eoddata1__QuoteGet, ""))
				{	soap_flag_eoddata1__QuoteGet--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__QuoteGet * SOAP_FMAC2 soap_instantiate___eoddata1__QuoteGet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__QuoteGet(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__QuoteGet *p;
	size_t k = sizeof(struct __eoddata1__QuoteGet);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__QuoteGet);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__QuoteGet, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__QuoteGet location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__QuoteGet, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__QuoteGet(struct soap *soap, const struct __eoddata1__QuoteGet *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__QuoteGet(soap, tag?tag:"-eoddata1:QuoteGet", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__QuoteGet * SOAP_FMAC4 soap_get___eoddata1__QuoteGet(struct soap *soap, struct __eoddata1__QuoteGet *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__QuoteGet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__SymbolList2::__eoddata1__SymbolList2()
{
	soap_default___eoddata1__SymbolList2(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__SymbolList2(struct soap *soap, struct __eoddata1__SymbolList2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__SymbolList2 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__SymbolList2(struct soap *soap, const struct __eoddata1__SymbolList2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__SymbolList2(soap, &a->eoddata1__SymbolList2);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__SymbolList2(struct soap *soap, const char *tag, int id, const struct __eoddata1__SymbolList2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__SymbolList2(soap, "eoddata1:SymbolList2", -1, &a->eoddata1__SymbolList2, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__SymbolList2 * SOAP_FMAC4 soap_in___eoddata1__SymbolList2(struct soap *soap, const char *tag, struct __eoddata1__SymbolList2 *a, const char *type)
{
	size_t soap_flag_eoddata1__SymbolList2 = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__SymbolList2 *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__SymbolList2, sizeof(struct __eoddata1__SymbolList2), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__SymbolList2(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__SymbolList2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__SymbolList2(soap, "eoddata1:SymbolList2", &a->eoddata1__SymbolList2, ""))
				{	soap_flag_eoddata1__SymbolList2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__SymbolList2 * SOAP_FMAC2 soap_instantiate___eoddata1__SymbolList2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__SymbolList2(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__SymbolList2 *p;
	size_t k = sizeof(struct __eoddata1__SymbolList2);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__SymbolList2);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__SymbolList2, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__SymbolList2 location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__SymbolList2, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__SymbolList2(struct soap *soap, const struct __eoddata1__SymbolList2 *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__SymbolList2(soap, tag?tag:"-eoddata1:SymbolList2", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__SymbolList2 * SOAP_FMAC4 soap_get___eoddata1__SymbolList2(struct soap *soap, struct __eoddata1__SymbolList2 *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__SymbolList2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__SymbolList::__eoddata1__SymbolList()
{
	soap_default___eoddata1__SymbolList(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__SymbolList(struct soap *soap, struct __eoddata1__SymbolList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__SymbolList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__SymbolList(struct soap *soap, const struct __eoddata1__SymbolList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__SymbolList(soap, &a->eoddata1__SymbolList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__SymbolList(struct soap *soap, const char *tag, int id, const struct __eoddata1__SymbolList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__SymbolList(soap, "eoddata1:SymbolList", -1, &a->eoddata1__SymbolList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__SymbolList * SOAP_FMAC4 soap_in___eoddata1__SymbolList(struct soap *soap, const char *tag, struct __eoddata1__SymbolList *a, const char *type)
{
	size_t soap_flag_eoddata1__SymbolList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__SymbolList *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__SymbolList, sizeof(struct __eoddata1__SymbolList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__SymbolList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__SymbolList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__SymbolList(soap, "eoddata1:SymbolList", &a->eoddata1__SymbolList, ""))
				{	soap_flag_eoddata1__SymbolList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__SymbolList * SOAP_FMAC2 soap_instantiate___eoddata1__SymbolList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__SymbolList(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__SymbolList *p;
	size_t k = sizeof(struct __eoddata1__SymbolList);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__SymbolList);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__SymbolList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__SymbolList location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__SymbolList, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__SymbolList(struct soap *soap, const struct __eoddata1__SymbolList *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__SymbolList(soap, tag?tag:"-eoddata1:SymbolList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__SymbolList * SOAP_FMAC4 soap_get___eoddata1__SymbolList(struct soap *soap, struct __eoddata1__SymbolList *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__SymbolList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__ExchangeGet::__eoddata1__ExchangeGet()
{
	soap_default___eoddata1__ExchangeGet(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__ExchangeGet(struct soap *soap, struct __eoddata1__ExchangeGet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__ExchangeGet = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__ExchangeGet(struct soap *soap, const struct __eoddata1__ExchangeGet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__ExchangeGet(soap, &a->eoddata1__ExchangeGet);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__ExchangeGet(struct soap *soap, const char *tag, int id, const struct __eoddata1__ExchangeGet *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__ExchangeGet(soap, "eoddata1:ExchangeGet", -1, &a->eoddata1__ExchangeGet, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__ExchangeGet * SOAP_FMAC4 soap_in___eoddata1__ExchangeGet(struct soap *soap, const char *tag, struct __eoddata1__ExchangeGet *a, const char *type)
{
	size_t soap_flag_eoddata1__ExchangeGet = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__ExchangeGet *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__ExchangeGet, sizeof(struct __eoddata1__ExchangeGet), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__ExchangeGet(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__ExchangeGet && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__ExchangeGet(soap, "eoddata1:ExchangeGet", &a->eoddata1__ExchangeGet, ""))
				{	soap_flag_eoddata1__ExchangeGet--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__ExchangeGet * SOAP_FMAC2 soap_instantiate___eoddata1__ExchangeGet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__ExchangeGet(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__ExchangeGet *p;
	size_t k = sizeof(struct __eoddata1__ExchangeGet);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__ExchangeGet);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__ExchangeGet, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__ExchangeGet location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__ExchangeGet, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__ExchangeGet(struct soap *soap, const struct __eoddata1__ExchangeGet *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__ExchangeGet(soap, tag?tag:"-eoddata1:ExchangeGet", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__ExchangeGet * SOAP_FMAC4 soap_get___eoddata1__ExchangeGet(struct soap *soap, struct __eoddata1__ExchangeGet *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__ExchangeGet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__ExchangeList::__eoddata1__ExchangeList()
{
	soap_default___eoddata1__ExchangeList(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__ExchangeList(struct soap *soap, struct __eoddata1__ExchangeList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__ExchangeList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__ExchangeList(struct soap *soap, const struct __eoddata1__ExchangeList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__ExchangeList(soap, &a->eoddata1__ExchangeList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__ExchangeList(struct soap *soap, const char *tag, int id, const struct __eoddata1__ExchangeList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__ExchangeList(soap, "eoddata1:ExchangeList", -1, &a->eoddata1__ExchangeList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__ExchangeList * SOAP_FMAC4 soap_in___eoddata1__ExchangeList(struct soap *soap, const char *tag, struct __eoddata1__ExchangeList *a, const char *type)
{
	size_t soap_flag_eoddata1__ExchangeList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__ExchangeList *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__ExchangeList, sizeof(struct __eoddata1__ExchangeList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__ExchangeList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__ExchangeList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__ExchangeList(soap, "eoddata1:ExchangeList", &a->eoddata1__ExchangeList, ""))
				{	soap_flag_eoddata1__ExchangeList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__ExchangeList * SOAP_FMAC2 soap_instantiate___eoddata1__ExchangeList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__ExchangeList(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__ExchangeList *p;
	size_t k = sizeof(struct __eoddata1__ExchangeList);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__ExchangeList);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__ExchangeList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__ExchangeList location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__ExchangeList, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__ExchangeList(struct soap *soap, const struct __eoddata1__ExchangeList *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__ExchangeList(soap, tag?tag:"-eoddata1:ExchangeList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__ExchangeList * SOAP_FMAC4 soap_get___eoddata1__ExchangeList(struct soap *soap, struct __eoddata1__ExchangeList *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__ExchangeList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__Membership::__eoddata1__Membership()
{
	soap_default___eoddata1__Membership(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__Membership(struct soap *soap, struct __eoddata1__Membership *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__Membership = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__Membership(struct soap *soap, const struct __eoddata1__Membership *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__Membership(soap, &a->eoddata1__Membership);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__Membership(struct soap *soap, const char *tag, int id, const struct __eoddata1__Membership *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__Membership(soap, "eoddata1:Membership", -1, &a->eoddata1__Membership, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__Membership * SOAP_FMAC4 soap_in___eoddata1__Membership(struct soap *soap, const char *tag, struct __eoddata1__Membership *a, const char *type)
{
	size_t soap_flag_eoddata1__Membership = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__Membership *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__Membership, sizeof(struct __eoddata1__Membership), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__Membership(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__Membership && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__Membership(soap, "eoddata1:Membership", &a->eoddata1__Membership, ""))
				{	soap_flag_eoddata1__Membership--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__Membership * SOAP_FMAC2 soap_instantiate___eoddata1__Membership(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__Membership(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__Membership *p;
	size_t k = sizeof(struct __eoddata1__Membership);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__Membership);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__Membership, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__Membership location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__Membership, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__Membership(struct soap *soap, const struct __eoddata1__Membership *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__Membership(soap, tag?tag:"-eoddata1:Membership", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__Membership * SOAP_FMAC4 soap_get___eoddata1__Membership(struct soap *soap, struct __eoddata1__Membership *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__Membership(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__Login2::__eoddata1__Login2()
{
	soap_default___eoddata1__Login2(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__Login2(struct soap *soap, struct __eoddata1__Login2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__Login2 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__Login2(struct soap *soap, const struct __eoddata1__Login2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__Login2(soap, &a->eoddata1__Login2);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__Login2(struct soap *soap, const char *tag, int id, const struct __eoddata1__Login2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__Login2(soap, "eoddata1:Login2", -1, &a->eoddata1__Login2, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__Login2 * SOAP_FMAC4 soap_in___eoddata1__Login2(struct soap *soap, const char *tag, struct __eoddata1__Login2 *a, const char *type)
{
	size_t soap_flag_eoddata1__Login2 = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__Login2 *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__Login2, sizeof(struct __eoddata1__Login2), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__Login2(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__Login2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__Login2(soap, "eoddata1:Login2", &a->eoddata1__Login2, ""))
				{	soap_flag_eoddata1__Login2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__Login2 * SOAP_FMAC2 soap_instantiate___eoddata1__Login2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__Login2(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__Login2 *p;
	size_t k = sizeof(struct __eoddata1__Login2);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__Login2);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__Login2, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__Login2 location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__Login2, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__Login2(struct soap *soap, const struct __eoddata1__Login2 *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__Login2(soap, tag?tag:"-eoddata1:Login2", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__Login2 * SOAP_FMAC4 soap_get___eoddata1__Login2(struct soap *soap, struct __eoddata1__Login2 *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__Login2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__eoddata1__Login::__eoddata1__Login()
{
	soap_default___eoddata1__Login(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___eoddata1__Login(struct soap *soap, struct __eoddata1__Login *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->eoddata1__Login = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___eoddata1__Login(struct soap *soap, const struct __eoddata1__Login *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_eoddata1__Login(soap, &a->eoddata1__Login);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___eoddata1__Login(struct soap *soap, const char *tag, int id, const struct __eoddata1__Login *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_eoddata1__Login(soap, "eoddata1:Login", -1, &a->eoddata1__Login, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__Login * SOAP_FMAC4 soap_in___eoddata1__Login(struct soap *soap, const char *tag, struct __eoddata1__Login *a, const char *type)
{
	size_t soap_flag_eoddata1__Login = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __eoddata1__Login *)soap_id_enter(soap, "", a, SOAP_TYPE_eoddata___eoddata1__Login, sizeof(struct __eoddata1__Login), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___eoddata1__Login(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eoddata1__Login && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_eoddata1__Login(soap, "eoddata1:Login", &a->eoddata1__Login, ""))
				{	soap_flag_eoddata1__Login--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __eoddata1__Login * SOAP_FMAC2 soap_instantiate___eoddata1__Login(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___eoddata1__Login(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __eoddata1__Login *p;
	size_t k = sizeof(struct __eoddata1__Login);
	if (n < 0)
	{	p = SOAP_NEW(struct __eoddata1__Login);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __eoddata1__Login, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __eoddata1__Login location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata___eoddata1__Login, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___eoddata1__Login(struct soap *soap, const struct __eoddata1__Login *a, const char *tag, const char *type)
{
	if (soap_out___eoddata1__Login(soap, tag?tag:"-eoddata1:Login", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __eoddata1__Login * SOAP_FMAC4 soap_get___eoddata1__Login(struct soap *soap, struct __eoddata1__Login *p, const char *tag, const char *type)
{
	if ((p = soap_in___eoddata1__Login(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata_SOAP_ENV__Reason, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata_SOAP_ENV__Detail, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata_SOAP_ENV__Code, &mark);
	if (id < 0)
		return soap->error;
	soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_eoddata1__ValidateAccess(struct soap *soap, _eoddata1__ValidateAccess *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata__eoddata1__ValidateAccess))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_eoddata1__ValidateAccess(struct soap *soap, const char *tag, int id, _eoddata1__ValidateAccess *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata__eoddata1__ValidateAccess, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _eoddata1__ValidateAccess ** SOAP_FMAC4 soap_in_PointerTo_eoddata1__ValidateAccess(struct soap *soap, const char *tag, _eoddata1__ValidateAccess **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_eoddata1__ValidateAccess **)soap_malloc(soap, sizeof(_eoddata1__ValidateAccess *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_eoddata1__ValidateAccess *)soap_instantiate__eoddata1__ValidateAccess(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_eoddata1__ValidateAccess **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata__eoddata1__ValidateAccess, sizeof(_eoddata1__ValidateAccess), 0, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_eoddata1__ValidateAccess(struct soap *soap, _eoddata1__ValidateAccess *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_eoddata1__ValidateAccess(soap, tag?tag:"eoddata1:ValidateAccess", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _eoddata1__ValidateAccess ** SOAP_FMAC4 soap_get_PointerTo_eoddata1__ValidateAccess(struct soap *soap, _eoddata1__ValidateAccess **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_eoddata1__ValidateAccess(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_eoddata1__UpdateDataFormat(struct soap *soap, _eoddata1__UpdateDataFormat *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata__eoddata1__UpdateDataFormat))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_eoddata1__UpdateDataFormat(struct soap *soap, const char *tag, int id, _eoddata1__UpdateDataFormat *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata__eoddata1__UpdateDataFormat, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _eoddata1__UpdateDataFormat ** SOAP_FMAC4 soap_in_PointerTo_eoddata1__UpdateDataFormat(struct soap *soap, const char *tag, _eoddata1__UpdateDataFormat **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_eoddata1__UpdateDataFormat **)soap_malloc(soap, sizeof(_eoddata1__UpdateDataFormat *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_eoddata1__UpdateDataFormat *)soap_instantiate__eoddata1__UpdateDataFormat(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_eoddata1__UpdateDataFormat **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata__eoddata1__UpdateDataFormat, sizeof(_eoddata1__UpdateDataFormat), 0, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_eoddata1__UpdateDataFormat(struct soap *soap, _eoddata1__UpdateDataFormat *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_eoddata1__UpdateDataFormat(soap, tag?tag:"eoddata1:UpdateDataFormat", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _eoddata1__UpdateDataFormat ** SOAP_FMAC4 soap_get_PointerTo_eoddata1__UpdateDataFormat(struct soap *soap, _eoddata1__UpdateDataFormat **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_eoddata1__UpdateDataFormat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_eoddata1__DataFormats(struct soap *soap, _eoddata1__DataFormats *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata__eoddata1__DataFormats))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_eoddata1__DataFormats(struct soap *soap, const char *tag, int id, _eoddata1__DataFormats *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata__eoddata1__DataFormats, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _eoddata1__DataFormats ** SOAP_FMAC4 soap_in_PointerTo_eoddata1__DataFormats(struct soap *soap, const char *tag, _eoddata1__DataFormats **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_eoddata1__DataFormats **)soap_malloc(soap, sizeof(_eoddata1__DataFormats *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_eoddata1__DataFormats *)soap_instantiate__eoddata1__DataFormats(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_eoddata1__DataFormats **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata__eoddata1__DataFormats, sizeof(_eoddata1__DataFormats), 0, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_eoddata1__DataFormats(struct soap *soap, _eoddata1__DataFormats *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_eoddata1__DataFormats(soap, tag?tag:"eoddata1:DataFormats", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _eoddata1__DataFormats ** SOAP_FMAC4 soap_get_PointerTo_eoddata1__DataFormats(struct soap *soap, _eoddata1__DataFormats **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_eoddata1__DataFormats(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_eoddata1__DataClientLatestVersion(struct soap *soap, _eoddata1__DataClientLatestVersion *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata__eoddata1__DataClientLatestVersion))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_eoddata1__DataClientLatestVersion(struct soap *soap, const char *tag, int id, _eoddata1__DataClientLatestVersion *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata__eoddata1__DataClientLatestVersion, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _eoddata1__DataClientLatestVersion ** SOAP_FMAC4 soap_in_PointerTo_eoddata1__DataClientLatestVersion(struct soap *soap, const char *tag, _eoddata1__DataClientLatestVersion **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_eoddata1__DataClientLatestVersion **)soap_malloc(soap, sizeof(_eoddata1__DataClientLatestVersion *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_eoddata1__DataClientLatestVersion *)soap_instantiate__eoddata1__DataClientLatestVersion(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_eoddata1__DataClientLatestVersion **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata__eoddata1__DataClientLatestVersion, sizeof(_eoddata1__DataClientLatestVersion), 0, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_eoddata1__DataClientLatestVersion(struct soap *soap, _eoddata1__DataClientLatestVersion *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_eoddata1__DataClientLatestVersion(soap, tag?tag:"eoddata1:DataClientLatestVersion", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _eoddata1__DataClientLatestVersion ** SOAP_FMAC4 soap_get_PointerTo_eoddata1__DataClientLatestVersion(struct soap *soap, _eoddata1__DataClientLatestVersion **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_eoddata1__DataClientLatestVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_eoddata1__SymbolChangesByExchange(struct soap *soap, _eoddata1__SymbolChangesByExchange *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata__eoddata1__SymbolChangesByExchange))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_eoddata1__SymbolChangesByExchange(struct soap *soap, const char *tag, int id, _eoddata1__SymbolChangesByExchange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata__eoddata1__SymbolChangesByExchange, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _eoddata1__SymbolChangesByExchange ** SOAP_FMAC4 soap_in_PointerTo_eoddata1__SymbolChangesByExchange(struct soap *soap, const char *tag, _eoddata1__SymbolChangesByExchange **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_eoddata1__SymbolChangesByExchange **)soap_malloc(soap, sizeof(_eoddata1__SymbolChangesByExchange *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_eoddata1__SymbolChangesByExchange *)soap_instantiate__eoddata1__SymbolChangesByExchange(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_eoddata1__SymbolChangesByExchange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata__eoddata1__SymbolChangesByExchange, sizeof(_eoddata1__SymbolChangesByExchange), 0, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_eoddata1__SymbolChangesByExchange(struct soap *soap, _eoddata1__SymbolChangesByExchange *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_eoddata1__SymbolChangesByExchange(soap, tag?tag:"eoddata1:SymbolChangesByExchange", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _eoddata1__SymbolChangesByExchange ** SOAP_FMAC4 soap_get_PointerTo_eoddata1__SymbolChangesByExchange(struct soap *soap, _eoddata1__SymbolChangesByExchange **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_eoddata1__SymbolChangesByExchange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_eoddata1__QuoteListByDatePeriod2(struct soap *soap, _eoddata1__QuoteListByDatePeriod2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata__eoddata1__QuoteListByDatePeriod2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_eoddata1__QuoteListByDatePeriod2(struct soap *soap, const char *tag, int id, _eoddata1__QuoteListByDatePeriod2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata__eoddata1__QuoteListByDatePeriod2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _eoddata1__QuoteListByDatePeriod2 ** SOAP_FMAC4 soap_in_PointerTo_eoddata1__QuoteListByDatePeriod2(struct soap *soap, const char *tag, _eoddata1__QuoteListByDatePeriod2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_eoddata1__QuoteListByDatePeriod2 **)soap_malloc(soap, sizeof(_eoddata1__QuoteListByDatePeriod2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_eoddata1__QuoteListByDatePeriod2 *)soap_instantiate__eoddata1__QuoteListByDatePeriod2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_eoddata1__QuoteListByDatePeriod2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata__eoddata1__QuoteListByDatePeriod2, sizeof(_eoddata1__QuoteListByDatePeriod2), 0, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_eoddata1__QuoteListByDatePeriod2(struct soap *soap, _eoddata1__QuoteListByDatePeriod2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_eoddata1__QuoteListByDatePeriod2(soap, tag?tag:"eoddata1:QuoteListByDatePeriod2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _eoddata1__QuoteListByDatePeriod2 ** SOAP_FMAC4 soap_get_PointerTo_eoddata1__QuoteListByDatePeriod2(struct soap *soap, _eoddata1__QuoteListByDatePeriod2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_eoddata1__QuoteListByDatePeriod2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_eoddata1__QuoteListByDatePeriod(struct soap *soap, _eoddata1__QuoteListByDatePeriod *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata__eoddata1__QuoteListByDatePeriod))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_eoddata1__QuoteListByDatePeriod(struct soap *soap, const char *tag, int id, _eoddata1__QuoteListByDatePeriod *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata__eoddata1__QuoteListByDatePeriod, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _eoddata1__QuoteListByDatePeriod ** SOAP_FMAC4 soap_in_PointerTo_eoddata1__QuoteListByDatePeriod(struct soap *soap, const char *tag, _eoddata1__QuoteListByDatePeriod **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_eoddata1__QuoteListByDatePeriod **)soap_malloc(soap, sizeof(_eoddata1__QuoteListByDatePeriod *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_eoddata1__QuoteListByDatePeriod *)soap_instantiate__eoddata1__QuoteListByDatePeriod(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_eoddata1__QuoteListByDatePeriod **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata__eoddata1__QuoteListByDatePeriod, sizeof(_eoddata1__QuoteListByDatePeriod), 0, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_eoddata1__QuoteListByDatePeriod(struct soap *soap, _eoddata1__QuoteListByDatePeriod *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_eoddata1__QuoteListByDatePeriod(soap, tag?tag:"eoddata1:QuoteListByDatePeriod", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _eoddata1__QuoteListByDatePeriod ** SOAP_FMAC4 soap_get_PointerTo_eoddata1__QuoteListByDatePeriod(struct soap *soap, _eoddata1__QuoteListByDatePeriod **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_eoddata1__QuoteListByDatePeriod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_eoddata1__SymbolHistoryPeriodByDateRange(struct soap *soap, _eoddata1__SymbolHistoryPeriodByDateRange *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata__eoddata1__SymbolHistoryPeriodByDateRange))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_eoddata1__SymbolHistoryPeriodByDateRange(struct soap *soap, const char *tag, int id, _eoddata1__SymbolHistoryPeriodByDateRange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata__eoddata1__SymbolHistoryPeriodByDateRange, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _eoddata1__SymbolHistoryPeriodByDateRange ** SOAP_FMAC4 soap_in_PointerTo_eoddata1__SymbolHistoryPeriodByDateRange(struct soap *soap, const char *tag, _eoddata1__SymbolHistoryPeriodByDateRange **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_eoddata1__SymbolHistoryPeriodByDateRange **)soap_malloc(soap, sizeof(_eoddata1__SymbolHistoryPeriodByDateRange *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_eoddata1__SymbolHistoryPeriodByDateRange *)soap_instantiate__eoddata1__SymbolHistoryPeriodByDateRange(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_eoddata1__SymbolHistoryPeriodByDateRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata__eoddata1__SymbolHistoryPeriodByDateRange, sizeof(_eoddata1__SymbolHistoryPeriodByDateRange), 0, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_eoddata1__SymbolHistoryPeriodByDateRange(struct soap *soap, _eoddata1__SymbolHistoryPeriodByDateRange *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_eoddata1__SymbolHistoryPeriodByDateRange(soap, tag?tag:"eoddata1:SymbolHistoryPeriodByDateRange", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _eoddata1__SymbolHistoryPeriodByDateRange ** SOAP_FMAC4 soap_get_PointerTo_eoddata1__SymbolHistoryPeriodByDateRange(struct soap *soap, _eoddata1__SymbolHistoryPeriodByDateRange **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_eoddata1__SymbolHistoryPeriodByDateRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_eoddata1__SymbolHistoryPeriod(struct soap *soap, _eoddata1__SymbolHistoryPeriod *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata__eoddata1__SymbolHistoryPeriod))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_eoddata1__SymbolHistoryPeriod(struct soap *soap, const char *tag, int id, _eoddata1__SymbolHistoryPeriod *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata__eoddata1__SymbolHistoryPeriod, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _eoddata1__SymbolHistoryPeriod ** SOAP_FMAC4 soap_in_PointerTo_eoddata1__SymbolHistoryPeriod(struct soap *soap, const char *tag, _eoddata1__SymbolHistoryPeriod **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_eoddata1__SymbolHistoryPeriod **)soap_malloc(soap, sizeof(_eoddata1__SymbolHistoryPeriod *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_eoddata1__SymbolHistoryPeriod *)soap_instantiate__eoddata1__SymbolHistoryPeriod(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_eoddata1__SymbolHistoryPeriod **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata__eoddata1__SymbolHistoryPeriod, sizeof(_eoddata1__SymbolHistoryPeriod), 0, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_eoddata1__SymbolHistoryPeriod(struct soap *soap, _eoddata1__SymbolHistoryPeriod *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_eoddata1__SymbolHistoryPeriod(soap, tag?tag:"eoddata1:SymbolHistoryPeriod", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _eoddata1__SymbolHistoryPeriod ** SOAP_FMAC4 soap_get_PointerTo_eoddata1__SymbolHistoryPeriod(struct soap *soap, _eoddata1__SymbolHistoryPeriod **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_eoddata1__SymbolHistoryPeriod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_eoddata1__CountryList(struct soap *soap, _eoddata1__CountryList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata__eoddata1__CountryList))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_eoddata1__CountryList(struct soap *soap, const char *tag, int id, _eoddata1__CountryList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata__eoddata1__CountryList, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _eoddata1__CountryList ** SOAP_FMAC4 soap_in_PointerTo_eoddata1__CountryList(struct soap *soap, const char *tag, _eoddata1__CountryList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_eoddata1__CountryList **)soap_malloc(soap, sizeof(_eoddata1__CountryList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_eoddata1__CountryList *)soap_instantiate__eoddata1__CountryList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_eoddata1__CountryList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata__eoddata1__CountryList, sizeof(_eoddata1__CountryList), 0, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_eoddata1__CountryList(struct soap *soap, _eoddata1__CountryList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_eoddata1__CountryList(soap, tag?tag:"eoddata1:CountryList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _eoddata1__CountryList ** SOAP_FMAC4 soap_get_PointerTo_eoddata1__CountryList(struct soap *soap, _eoddata1__CountryList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_eoddata1__CountryList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_eoddata1__SplitListBySymbol(struct soap *soap, _eoddata1__SplitListBySymbol *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata__eoddata1__SplitListBySymbol))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_eoddata1__SplitListBySymbol(struct soap *soap, const char *tag, int id, _eoddata1__SplitListBySymbol *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata__eoddata1__SplitListBySymbol, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _eoddata1__SplitListBySymbol ** SOAP_FMAC4 soap_in_PointerTo_eoddata1__SplitListBySymbol(struct soap *soap, const char *tag, _eoddata1__SplitListBySymbol **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_eoddata1__SplitListBySymbol **)soap_malloc(soap, sizeof(_eoddata1__SplitListBySymbol *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_eoddata1__SplitListBySymbol *)soap_instantiate__eoddata1__SplitListBySymbol(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_eoddata1__SplitListBySymbol **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata__eoddata1__SplitListBySymbol, sizeof(_eoddata1__SplitListBySymbol), 0, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_eoddata1__SplitListBySymbol(struct soap *soap, _eoddata1__SplitListBySymbol *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_eoddata1__SplitListBySymbol(soap, tag?tag:"eoddata1:SplitListBySymbol", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _eoddata1__SplitListBySymbol ** SOAP_FMAC4 soap_get_PointerTo_eoddata1__SplitListBySymbol(struct soap *soap, _eoddata1__SplitListBySymbol **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_eoddata1__SplitListBySymbol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_eoddata1__SplitListByExchange(struct soap *soap, _eoddata1__SplitListByExchange *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata__eoddata1__SplitListByExchange))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_eoddata1__SplitListByExchange(struct soap *soap, const char *tag, int id, _eoddata1__SplitListByExchange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata__eoddata1__SplitListByExchange, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _eoddata1__SplitListByExchange ** SOAP_FMAC4 soap_in_PointerTo_eoddata1__SplitListByExchange(struct soap *soap, const char *tag, _eoddata1__SplitListByExchange **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_eoddata1__SplitListByExchange **)soap_malloc(soap, sizeof(_eoddata1__SplitListByExchange *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_eoddata1__SplitListByExchange *)soap_instantiate__eoddata1__SplitListByExchange(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_eoddata1__SplitListByExchange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata__eoddata1__SplitListByExchange, sizeof(_eoddata1__SplitListByExchange), 0, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_eoddata1__SplitListByExchange(struct soap *soap, _eoddata1__SplitListByExchange *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_eoddata1__SplitListByExchange(soap, tag?tag:"eoddata1:SplitListByExchange", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _eoddata1__SplitListByExchange ** SOAP_FMAC4 soap_get_PointerTo_eoddata1__SplitListByExchange(struct soap *soap, _eoddata1__SplitListByExchange **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_eoddata1__SplitListByExchange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_eoddata1__ExchangeMonths(struct soap *soap, _eoddata1__ExchangeMonths *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata__eoddata1__ExchangeMonths))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_eoddata1__ExchangeMonths(struct soap *soap, const char *tag, int id, _eoddata1__ExchangeMonths *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata__eoddata1__ExchangeMonths, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _eoddata1__ExchangeMonths ** SOAP_FMAC4 soap_in_PointerTo_eoddata1__ExchangeMonths(struct soap *soap, const char *tag, _eoddata1__ExchangeMonths **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_eoddata1__ExchangeMonths **)soap_malloc(soap, sizeof(_eoddata1__ExchangeMonths *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_eoddata1__ExchangeMonths *)soap_instantiate__eoddata1__ExchangeMonths(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_eoddata1__ExchangeMonths **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata__eoddata1__ExchangeMonths, sizeof(_eoddata1__ExchangeMonths), 0, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_eoddata1__ExchangeMonths(struct soap *soap, _eoddata1__ExchangeMonths *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_eoddata1__ExchangeMonths(soap, tag?tag:"eoddata1:ExchangeMonths", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _eoddata1__ExchangeMonths ** SOAP_FMAC4 soap_get_PointerTo_eoddata1__ExchangeMonths(struct soap *soap, _eoddata1__ExchangeMonths **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_eoddata1__ExchangeMonths(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_eoddata1__SymbolChart(struct soap *soap, _eoddata1__SymbolChart *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata__eoddata1__SymbolChart))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_eoddata1__SymbolChart(struct soap *soap, const char *tag, int id, _eoddata1__SymbolChart *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata__eoddata1__SymbolChart, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _eoddata1__SymbolChart ** SOAP_FMAC4 soap_in_PointerTo_eoddata1__SymbolChart(struct soap *soap, const char *tag, _eoddata1__SymbolChart **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_eoddata1__SymbolChart **)soap_malloc(soap, sizeof(_eoddata1__SymbolChart *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_eoddata1__SymbolChart *)soap_instantiate__eoddata1__SymbolChart(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_eoddata1__SymbolChart **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata__eoddata1__SymbolChart, sizeof(_eoddata1__SymbolChart), 0, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_eoddata1__SymbolChart(struct soap *soap, _eoddata1__SymbolChart *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_eoddata1__SymbolChart(soap, tag?tag:"eoddata1:SymbolChart", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _eoddata1__SymbolChart ** SOAP_FMAC4 soap_get_PointerTo_eoddata1__SymbolChart(struct soap *soap, _eoddata1__SymbolChart **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_eoddata1__SymbolChart(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_eoddata1__Top10Losses(struct soap *soap, _eoddata1__Top10Losses *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata__eoddata1__Top10Losses))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_eoddata1__Top10Losses(struct soap *soap, const char *tag, int id, _eoddata1__Top10Losses *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata__eoddata1__Top10Losses, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _eoddata1__Top10Losses ** SOAP_FMAC4 soap_in_PointerTo_eoddata1__Top10Losses(struct soap *soap, const char *tag, _eoddata1__Top10Losses **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_eoddata1__Top10Losses **)soap_malloc(soap, sizeof(_eoddata1__Top10Losses *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_eoddata1__Top10Losses *)soap_instantiate__eoddata1__Top10Losses(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_eoddata1__Top10Losses **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata__eoddata1__Top10Losses, sizeof(_eoddata1__Top10Losses), 0, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_eoddata1__Top10Losses(struct soap *soap, _eoddata1__Top10Losses *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_eoddata1__Top10Losses(soap, tag?tag:"eoddata1:Top10Losses", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _eoddata1__Top10Losses ** SOAP_FMAC4 soap_get_PointerTo_eoddata1__Top10Losses(struct soap *soap, _eoddata1__Top10Losses **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_eoddata1__Top10Losses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_eoddata1__Top10Gains(struct soap *soap, _eoddata1__Top10Gains *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata__eoddata1__Top10Gains))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_eoddata1__Top10Gains(struct soap *soap, const char *tag, int id, _eoddata1__Top10Gains *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata__eoddata1__Top10Gains, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _eoddata1__Top10Gains ** SOAP_FMAC4 soap_in_PointerTo_eoddata1__Top10Gains(struct soap *soap, const char *tag, _eoddata1__Top10Gains **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_eoddata1__Top10Gains **)soap_malloc(soap, sizeof(_eoddata1__Top10Gains *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_eoddata1__Top10Gains *)soap_instantiate__eoddata1__Top10Gains(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_eoddata1__Top10Gains **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata__eoddata1__Top10Gains, sizeof(_eoddata1__Top10Gains), 0, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_eoddata1__Top10Gains(struct soap *soap, _eoddata1__Top10Gains *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_eoddata1__Top10Gains(soap, tag?tag:"eoddata1:Top10Gains", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _eoddata1__Top10Gains ** SOAP_FMAC4 soap_get_PointerTo_eoddata1__Top10Gains(struct soap *soap, _eoddata1__Top10Gains **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_eoddata1__Top10Gains(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_eoddata1__SymbolHistory(struct soap *soap, _eoddata1__SymbolHistory *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata__eoddata1__SymbolHistory))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_eoddata1__SymbolHistory(struct soap *soap, const char *tag, int id, _eoddata1__SymbolHistory *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata__eoddata1__SymbolHistory, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _eoddata1__SymbolHistory ** SOAP_FMAC4 soap_in_PointerTo_eoddata1__SymbolHistory(struct soap *soap, const char *tag, _eoddata1__SymbolHistory **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_eoddata1__SymbolHistory **)soap_malloc(soap, sizeof(_eoddata1__SymbolHistory *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_eoddata1__SymbolHistory *)soap_instantiate__eoddata1__SymbolHistory(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_eoddata1__SymbolHistory **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata__eoddata1__SymbolHistory, sizeof(_eoddata1__SymbolHistory), 0, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_eoddata1__SymbolHistory(struct soap *soap, _eoddata1__SymbolHistory *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_eoddata1__SymbolHistory(soap, tag?tag:"eoddata1:SymbolHistory", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _eoddata1__SymbolHistory ** SOAP_FMAC4 soap_get_PointerTo_eoddata1__SymbolHistory(struct soap *soap, _eoddata1__SymbolHistory **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_eoddata1__SymbolHistory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_eoddata1__QuoteListByDate2(struct soap *soap, _eoddata1__QuoteListByDate2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata__eoddata1__QuoteListByDate2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_eoddata1__QuoteListByDate2(struct soap *soap, const char *tag, int id, _eoddata1__QuoteListByDate2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata__eoddata1__QuoteListByDate2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _eoddata1__QuoteListByDate2 ** SOAP_FMAC4 soap_in_PointerTo_eoddata1__QuoteListByDate2(struct soap *soap, const char *tag, _eoddata1__QuoteListByDate2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_eoddata1__QuoteListByDate2 **)soap_malloc(soap, sizeof(_eoddata1__QuoteListByDate2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_eoddata1__QuoteListByDate2 *)soap_instantiate__eoddata1__QuoteListByDate2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_eoddata1__QuoteListByDate2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata__eoddata1__QuoteListByDate2, sizeof(_eoddata1__QuoteListByDate2), 0, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_eoddata1__QuoteListByDate2(struct soap *soap, _eoddata1__QuoteListByDate2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_eoddata1__QuoteListByDate2(soap, tag?tag:"eoddata1:QuoteListByDate2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _eoddata1__QuoteListByDate2 ** SOAP_FMAC4 soap_get_PointerTo_eoddata1__QuoteListByDate2(struct soap *soap, _eoddata1__QuoteListByDate2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_eoddata1__QuoteListByDate2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_eoddata1__QuoteListByDate(struct soap *soap, _eoddata1__QuoteListByDate *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata__eoddata1__QuoteListByDate))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_eoddata1__QuoteListByDate(struct soap *soap, const char *tag, int id, _eoddata1__QuoteListByDate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata__eoddata1__QuoteListByDate, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _eoddata1__QuoteListByDate ** SOAP_FMAC4 soap_in_PointerTo_eoddata1__QuoteListByDate(struct soap *soap, const char *tag, _eoddata1__QuoteListByDate **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_eoddata1__QuoteListByDate **)soap_malloc(soap, sizeof(_eoddata1__QuoteListByDate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_eoddata1__QuoteListByDate *)soap_instantiate__eoddata1__QuoteListByDate(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_eoddata1__QuoteListByDate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata__eoddata1__QuoteListByDate, sizeof(_eoddata1__QuoteListByDate), 0, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_eoddata1__QuoteListByDate(struct soap *soap, _eoddata1__QuoteListByDate *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_eoddata1__QuoteListByDate(soap, tag?tag:"eoddata1:QuoteListByDate", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _eoddata1__QuoteListByDate ** SOAP_FMAC4 soap_get_PointerTo_eoddata1__QuoteListByDate(struct soap *soap, _eoddata1__QuoteListByDate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_eoddata1__QuoteListByDate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_eoddata1__TechnicalList(struct soap *soap, _eoddata1__TechnicalList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata__eoddata1__TechnicalList))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_eoddata1__TechnicalList(struct soap *soap, const char *tag, int id, _eoddata1__TechnicalList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata__eoddata1__TechnicalList, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _eoddata1__TechnicalList ** SOAP_FMAC4 soap_in_PointerTo_eoddata1__TechnicalList(struct soap *soap, const char *tag, _eoddata1__TechnicalList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_eoddata1__TechnicalList **)soap_malloc(soap, sizeof(_eoddata1__TechnicalList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_eoddata1__TechnicalList *)soap_instantiate__eoddata1__TechnicalList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_eoddata1__TechnicalList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata__eoddata1__TechnicalList, sizeof(_eoddata1__TechnicalList), 0, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_eoddata1__TechnicalList(struct soap *soap, _eoddata1__TechnicalList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_eoddata1__TechnicalList(soap, tag?tag:"eoddata1:TechnicalList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _eoddata1__TechnicalList ** SOAP_FMAC4 soap_get_PointerTo_eoddata1__TechnicalList(struct soap *soap, _eoddata1__TechnicalList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_eoddata1__TechnicalList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_eoddata1__FundamentalList(struct soap *soap, _eoddata1__FundamentalList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata__eoddata1__FundamentalList))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_eoddata1__FundamentalList(struct soap *soap, const char *tag, int id, _eoddata1__FundamentalList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata__eoddata1__FundamentalList, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _eoddata1__FundamentalList ** SOAP_FMAC4 soap_in_PointerTo_eoddata1__FundamentalList(struct soap *soap, const char *tag, _eoddata1__FundamentalList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_eoddata1__FundamentalList **)soap_malloc(soap, sizeof(_eoddata1__FundamentalList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_eoddata1__FundamentalList *)soap_instantiate__eoddata1__FundamentalList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_eoddata1__FundamentalList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata__eoddata1__FundamentalList, sizeof(_eoddata1__FundamentalList), 0, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_eoddata1__FundamentalList(struct soap *soap, _eoddata1__FundamentalList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_eoddata1__FundamentalList(soap, tag?tag:"eoddata1:FundamentalList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _eoddata1__FundamentalList ** SOAP_FMAC4 soap_get_PointerTo_eoddata1__FundamentalList(struct soap *soap, _eoddata1__FundamentalList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_eoddata1__FundamentalList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_eoddata1__NewsListBySymbol(struct soap *soap, _eoddata1__NewsListBySymbol *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata__eoddata1__NewsListBySymbol))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_eoddata1__NewsListBySymbol(struct soap *soap, const char *tag, int id, _eoddata1__NewsListBySymbol *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata__eoddata1__NewsListBySymbol, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _eoddata1__NewsListBySymbol ** SOAP_FMAC4 soap_in_PointerTo_eoddata1__NewsListBySymbol(struct soap *soap, const char *tag, _eoddata1__NewsListBySymbol **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_eoddata1__NewsListBySymbol **)soap_malloc(soap, sizeof(_eoddata1__NewsListBySymbol *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_eoddata1__NewsListBySymbol *)soap_instantiate__eoddata1__NewsListBySymbol(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_eoddata1__NewsListBySymbol **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata__eoddata1__NewsListBySymbol, sizeof(_eoddata1__NewsListBySymbol), 0, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_eoddata1__NewsListBySymbol(struct soap *soap, _eoddata1__NewsListBySymbol *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_eoddata1__NewsListBySymbol(soap, tag?tag:"eoddata1:NewsListBySymbol", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _eoddata1__NewsListBySymbol ** SOAP_FMAC4 soap_get_PointerTo_eoddata1__NewsListBySymbol(struct soap *soap, _eoddata1__NewsListBySymbol **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_eoddata1__NewsListBySymbol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_eoddata1__NewsList(struct soap *soap, _eoddata1__NewsList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata__eoddata1__NewsList))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_eoddata1__NewsList(struct soap *soap, const char *tag, int id, _eoddata1__NewsList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata__eoddata1__NewsList, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _eoddata1__NewsList ** SOAP_FMAC4 soap_in_PointerTo_eoddata1__NewsList(struct soap *soap, const char *tag, _eoddata1__NewsList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_eoddata1__NewsList **)soap_malloc(soap, sizeof(_eoddata1__NewsList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_eoddata1__NewsList *)soap_instantiate__eoddata1__NewsList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_eoddata1__NewsList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata__eoddata1__NewsList, sizeof(_eoddata1__NewsList), 0, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_eoddata1__NewsList(struct soap *soap, _eoddata1__NewsList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_eoddata1__NewsList(soap, tag?tag:"eoddata1:NewsList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _eoddata1__NewsList ** SOAP_FMAC4 soap_get_PointerTo_eoddata1__NewsList(struct soap *soap, _eoddata1__NewsList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_eoddata1__NewsList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_eoddata1__QuoteList(struct soap *soap, _eoddata1__QuoteList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata__eoddata1__QuoteList))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_eoddata1__QuoteList(struct soap *soap, const char *tag, int id, _eoddata1__QuoteList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata__eoddata1__QuoteList, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _eoddata1__QuoteList ** SOAP_FMAC4 soap_in_PointerTo_eoddata1__QuoteList(struct soap *soap, const char *tag, _eoddata1__QuoteList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_eoddata1__QuoteList **)soap_malloc(soap, sizeof(_eoddata1__QuoteList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_eoddata1__QuoteList *)soap_instantiate__eoddata1__QuoteList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_eoddata1__QuoteList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata__eoddata1__QuoteList, sizeof(_eoddata1__QuoteList), 0, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_eoddata1__QuoteList(struct soap *soap, _eoddata1__QuoteList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_eoddata1__QuoteList(soap, tag?tag:"eoddata1:QuoteList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _eoddata1__QuoteList ** SOAP_FMAC4 soap_get_PointerTo_eoddata1__QuoteList(struct soap *soap, _eoddata1__QuoteList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_eoddata1__QuoteList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_eoddata1__SymbolGet(struct soap *soap, _eoddata1__SymbolGet *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata__eoddata1__SymbolGet))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_eoddata1__SymbolGet(struct soap *soap, const char *tag, int id, _eoddata1__SymbolGet *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata__eoddata1__SymbolGet, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _eoddata1__SymbolGet ** SOAP_FMAC4 soap_in_PointerTo_eoddata1__SymbolGet(struct soap *soap, const char *tag, _eoddata1__SymbolGet **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_eoddata1__SymbolGet **)soap_malloc(soap, sizeof(_eoddata1__SymbolGet *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_eoddata1__SymbolGet *)soap_instantiate__eoddata1__SymbolGet(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_eoddata1__SymbolGet **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata__eoddata1__SymbolGet, sizeof(_eoddata1__SymbolGet), 0, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_eoddata1__SymbolGet(struct soap *soap, _eoddata1__SymbolGet *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_eoddata1__SymbolGet(soap, tag?tag:"eoddata1:SymbolGet", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _eoddata1__SymbolGet ** SOAP_FMAC4 soap_get_PointerTo_eoddata1__SymbolGet(struct soap *soap, _eoddata1__SymbolGet **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_eoddata1__SymbolGet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_eoddata1__QuoteList2(struct soap *soap, _eoddata1__QuoteList2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata__eoddata1__QuoteList2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_eoddata1__QuoteList2(struct soap *soap, const char *tag, int id, _eoddata1__QuoteList2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata__eoddata1__QuoteList2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _eoddata1__QuoteList2 ** SOAP_FMAC4 soap_in_PointerTo_eoddata1__QuoteList2(struct soap *soap, const char *tag, _eoddata1__QuoteList2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_eoddata1__QuoteList2 **)soap_malloc(soap, sizeof(_eoddata1__QuoteList2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_eoddata1__QuoteList2 *)soap_instantiate__eoddata1__QuoteList2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_eoddata1__QuoteList2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata__eoddata1__QuoteList2, sizeof(_eoddata1__QuoteList2), 0, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_eoddata1__QuoteList2(struct soap *soap, _eoddata1__QuoteList2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_eoddata1__QuoteList2(soap, tag?tag:"eoddata1:QuoteList2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _eoddata1__QuoteList2 ** SOAP_FMAC4 soap_get_PointerTo_eoddata1__QuoteList2(struct soap *soap, _eoddata1__QuoteList2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_eoddata1__QuoteList2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_eoddata1__QuoteGet(struct soap *soap, _eoddata1__QuoteGet *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata__eoddata1__QuoteGet))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_eoddata1__QuoteGet(struct soap *soap, const char *tag, int id, _eoddata1__QuoteGet *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata__eoddata1__QuoteGet, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _eoddata1__QuoteGet ** SOAP_FMAC4 soap_in_PointerTo_eoddata1__QuoteGet(struct soap *soap, const char *tag, _eoddata1__QuoteGet **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_eoddata1__QuoteGet **)soap_malloc(soap, sizeof(_eoddata1__QuoteGet *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_eoddata1__QuoteGet *)soap_instantiate__eoddata1__QuoteGet(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_eoddata1__QuoteGet **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata__eoddata1__QuoteGet, sizeof(_eoddata1__QuoteGet), 0, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_eoddata1__QuoteGet(struct soap *soap, _eoddata1__QuoteGet *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_eoddata1__QuoteGet(soap, tag?tag:"eoddata1:QuoteGet", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _eoddata1__QuoteGet ** SOAP_FMAC4 soap_get_PointerTo_eoddata1__QuoteGet(struct soap *soap, _eoddata1__QuoteGet **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_eoddata1__QuoteGet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_eoddata1__SymbolList2(struct soap *soap, _eoddata1__SymbolList2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata__eoddata1__SymbolList2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_eoddata1__SymbolList2(struct soap *soap, const char *tag, int id, _eoddata1__SymbolList2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata__eoddata1__SymbolList2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _eoddata1__SymbolList2 ** SOAP_FMAC4 soap_in_PointerTo_eoddata1__SymbolList2(struct soap *soap, const char *tag, _eoddata1__SymbolList2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_eoddata1__SymbolList2 **)soap_malloc(soap, sizeof(_eoddata1__SymbolList2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_eoddata1__SymbolList2 *)soap_instantiate__eoddata1__SymbolList2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_eoddata1__SymbolList2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata__eoddata1__SymbolList2, sizeof(_eoddata1__SymbolList2), 0, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_eoddata1__SymbolList2(struct soap *soap, _eoddata1__SymbolList2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_eoddata1__SymbolList2(soap, tag?tag:"eoddata1:SymbolList2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _eoddata1__SymbolList2 ** SOAP_FMAC4 soap_get_PointerTo_eoddata1__SymbolList2(struct soap *soap, _eoddata1__SymbolList2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_eoddata1__SymbolList2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_eoddata1__SymbolList(struct soap *soap, _eoddata1__SymbolList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata__eoddata1__SymbolList))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_eoddata1__SymbolList(struct soap *soap, const char *tag, int id, _eoddata1__SymbolList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata__eoddata1__SymbolList, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _eoddata1__SymbolList ** SOAP_FMAC4 soap_in_PointerTo_eoddata1__SymbolList(struct soap *soap, const char *tag, _eoddata1__SymbolList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_eoddata1__SymbolList **)soap_malloc(soap, sizeof(_eoddata1__SymbolList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_eoddata1__SymbolList *)soap_instantiate__eoddata1__SymbolList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_eoddata1__SymbolList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata__eoddata1__SymbolList, sizeof(_eoddata1__SymbolList), 0, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_eoddata1__SymbolList(struct soap *soap, _eoddata1__SymbolList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_eoddata1__SymbolList(soap, tag?tag:"eoddata1:SymbolList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _eoddata1__SymbolList ** SOAP_FMAC4 soap_get_PointerTo_eoddata1__SymbolList(struct soap *soap, _eoddata1__SymbolList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_eoddata1__SymbolList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_eoddata1__ExchangeGet(struct soap *soap, _eoddata1__ExchangeGet *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata__eoddata1__ExchangeGet))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_eoddata1__ExchangeGet(struct soap *soap, const char *tag, int id, _eoddata1__ExchangeGet *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata__eoddata1__ExchangeGet, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _eoddata1__ExchangeGet ** SOAP_FMAC4 soap_in_PointerTo_eoddata1__ExchangeGet(struct soap *soap, const char *tag, _eoddata1__ExchangeGet **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_eoddata1__ExchangeGet **)soap_malloc(soap, sizeof(_eoddata1__ExchangeGet *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_eoddata1__ExchangeGet *)soap_instantiate__eoddata1__ExchangeGet(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_eoddata1__ExchangeGet **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata__eoddata1__ExchangeGet, sizeof(_eoddata1__ExchangeGet), 0, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_eoddata1__ExchangeGet(struct soap *soap, _eoddata1__ExchangeGet *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_eoddata1__ExchangeGet(soap, tag?tag:"eoddata1:ExchangeGet", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _eoddata1__ExchangeGet ** SOAP_FMAC4 soap_get_PointerTo_eoddata1__ExchangeGet(struct soap *soap, _eoddata1__ExchangeGet **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_eoddata1__ExchangeGet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_eoddata1__ExchangeList(struct soap *soap, _eoddata1__ExchangeList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata__eoddata1__ExchangeList))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_eoddata1__ExchangeList(struct soap *soap, const char *tag, int id, _eoddata1__ExchangeList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata__eoddata1__ExchangeList, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _eoddata1__ExchangeList ** SOAP_FMAC4 soap_in_PointerTo_eoddata1__ExchangeList(struct soap *soap, const char *tag, _eoddata1__ExchangeList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_eoddata1__ExchangeList **)soap_malloc(soap, sizeof(_eoddata1__ExchangeList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_eoddata1__ExchangeList *)soap_instantiate__eoddata1__ExchangeList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_eoddata1__ExchangeList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata__eoddata1__ExchangeList, sizeof(_eoddata1__ExchangeList), 0, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_eoddata1__ExchangeList(struct soap *soap, _eoddata1__ExchangeList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_eoddata1__ExchangeList(soap, tag?tag:"eoddata1:ExchangeList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _eoddata1__ExchangeList ** SOAP_FMAC4 soap_get_PointerTo_eoddata1__ExchangeList(struct soap *soap, _eoddata1__ExchangeList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_eoddata1__ExchangeList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_eoddata1__Membership(struct soap *soap, _eoddata1__Membership *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata__eoddata1__Membership))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_eoddata1__Membership(struct soap *soap, const char *tag, int id, _eoddata1__Membership *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata__eoddata1__Membership, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _eoddata1__Membership ** SOAP_FMAC4 soap_in_PointerTo_eoddata1__Membership(struct soap *soap, const char *tag, _eoddata1__Membership **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_eoddata1__Membership **)soap_malloc(soap, sizeof(_eoddata1__Membership *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_eoddata1__Membership *)soap_instantiate__eoddata1__Membership(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_eoddata1__Membership **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata__eoddata1__Membership, sizeof(_eoddata1__Membership), 0, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_eoddata1__Membership(struct soap *soap, _eoddata1__Membership *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_eoddata1__Membership(soap, tag?tag:"eoddata1:Membership", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _eoddata1__Membership ** SOAP_FMAC4 soap_get_PointerTo_eoddata1__Membership(struct soap *soap, _eoddata1__Membership **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_eoddata1__Membership(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_eoddata1__Login2(struct soap *soap, _eoddata1__Login2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata__eoddata1__Login2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_eoddata1__Login2(struct soap *soap, const char *tag, int id, _eoddata1__Login2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata__eoddata1__Login2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _eoddata1__Login2 ** SOAP_FMAC4 soap_in_PointerTo_eoddata1__Login2(struct soap *soap, const char *tag, _eoddata1__Login2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_eoddata1__Login2 **)soap_malloc(soap, sizeof(_eoddata1__Login2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_eoddata1__Login2 *)soap_instantiate__eoddata1__Login2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_eoddata1__Login2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata__eoddata1__Login2, sizeof(_eoddata1__Login2), 0, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_eoddata1__Login2(struct soap *soap, _eoddata1__Login2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_eoddata1__Login2(soap, tag?tag:"eoddata1:Login2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _eoddata1__Login2 ** SOAP_FMAC4 soap_get_PointerTo_eoddata1__Login2(struct soap *soap, _eoddata1__Login2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_eoddata1__Login2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_eoddata1__Login(struct soap *soap, _eoddata1__Login *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata__eoddata1__Login))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_eoddata1__Login(struct soap *soap, const char *tag, int id, _eoddata1__Login *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata__eoddata1__Login, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _eoddata1__Login ** SOAP_FMAC4 soap_in_PointerTo_eoddata1__Login(struct soap *soap, const char *tag, _eoddata1__Login **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_eoddata1__Login **)soap_malloc(soap, sizeof(_eoddata1__Login *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_eoddata1__Login *)soap_instantiate__eoddata1__Login(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_eoddata1__Login **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata__eoddata1__Login, sizeof(_eoddata1__Login), 0, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_eoddata1__Login(struct soap *soap, _eoddata1__Login *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_eoddata1__Login(soap, tag?tag:"eoddata1:Login", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _eoddata1__Login ** SOAP_FMAC4 soap_get_PointerTo_eoddata1__Login(struct soap *soap, _eoddata1__Login **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_eoddata1__Login(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToeoddata1__RESPONSE(struct soap *soap, eoddata1__RESPONSE *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata_eoddata1__RESPONSE))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToeoddata1__RESPONSE(struct soap *soap, const char *tag, int id, eoddata1__RESPONSE *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata_eoddata1__RESPONSE, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 eoddata1__RESPONSE ** SOAP_FMAC4 soap_in_PointerToeoddata1__RESPONSE(struct soap *soap, const char *tag, eoddata1__RESPONSE **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (eoddata1__RESPONSE **)soap_malloc(soap, sizeof(eoddata1__RESPONSE *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (eoddata1__RESPONSE *)soap_instantiate_eoddata1__RESPONSE(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (eoddata1__RESPONSE **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata_eoddata1__RESPONSE, sizeof(eoddata1__RESPONSE), 0, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToeoddata1__RESPONSE(struct soap *soap, eoddata1__RESPONSE *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToeoddata1__RESPONSE(soap, tag?tag:"eoddata1:RESPONSE", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 eoddata1__RESPONSE ** SOAP_FMAC4 soap_get_PointerToeoddata1__RESPONSE(struct soap *soap, eoddata1__RESPONSE **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToeoddata1__RESPONSE(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToeoddata1__LOGINRESPONSE(struct soap *soap, eoddata1__LOGINRESPONSE *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata_eoddata1__LOGINRESPONSE))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToeoddata1__LOGINRESPONSE(struct soap *soap, const char *tag, int id, eoddata1__LOGINRESPONSE *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata_eoddata1__LOGINRESPONSE, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 eoddata1__LOGINRESPONSE ** SOAP_FMAC4 soap_in_PointerToeoddata1__LOGINRESPONSE(struct soap *soap, const char *tag, eoddata1__LOGINRESPONSE **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (eoddata1__LOGINRESPONSE **)soap_malloc(soap, sizeof(eoddata1__LOGINRESPONSE *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (eoddata1__LOGINRESPONSE *)soap_instantiate_eoddata1__LOGINRESPONSE(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (eoddata1__LOGINRESPONSE **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata_eoddata1__LOGINRESPONSE, sizeof(eoddata1__LOGINRESPONSE), 0, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToeoddata1__LOGINRESPONSE(struct soap *soap, eoddata1__LOGINRESPONSE *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToeoddata1__LOGINRESPONSE(soap, tag?tag:"eoddata1:LOGINRESPONSE", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 eoddata1__LOGINRESPONSE ** SOAP_FMAC4 soap_get_PointerToeoddata1__LOGINRESPONSE(struct soap *soap, eoddata1__LOGINRESPONSE **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToeoddata1__LOGINRESPONSE(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToeoddata1__DATAFORMAT_USCORECOLUMN(struct soap *soap, eoddata1__DATAFORMAT_USCORECOLUMN *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata_eoddata1__DATAFORMAT_USCORECOLUMN))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToeoddata1__DATAFORMAT_USCORECOLUMN(struct soap *soap, const char *tag, int id, eoddata1__DATAFORMAT_USCORECOLUMN *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata_eoddata1__DATAFORMAT_USCORECOLUMN, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 eoddata1__DATAFORMAT_USCORECOLUMN ** SOAP_FMAC4 soap_in_PointerToeoddata1__DATAFORMAT_USCORECOLUMN(struct soap *soap, const char *tag, eoddata1__DATAFORMAT_USCORECOLUMN **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (eoddata1__DATAFORMAT_USCORECOLUMN **)soap_malloc(soap, sizeof(eoddata1__DATAFORMAT_USCORECOLUMN *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (eoddata1__DATAFORMAT_USCORECOLUMN *)soap_instantiate_eoddata1__DATAFORMAT_USCORECOLUMN(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (eoddata1__DATAFORMAT_USCORECOLUMN **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata_eoddata1__DATAFORMAT_USCORECOLUMN, sizeof(eoddata1__DATAFORMAT_USCORECOLUMN), 0, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToeoddata1__DATAFORMAT_USCORECOLUMN(struct soap *soap, eoddata1__DATAFORMAT_USCORECOLUMN *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToeoddata1__DATAFORMAT_USCORECOLUMN(soap, tag?tag:"eoddata1:DATAFORMAT_COLUMN", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 eoddata1__DATAFORMAT_USCORECOLUMN ** SOAP_FMAC4 soap_get_PointerToeoddata1__DATAFORMAT_USCORECOLUMN(struct soap *soap, eoddata1__DATAFORMAT_USCORECOLUMN **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToeoddata1__DATAFORMAT_USCORECOLUMN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToeoddata1__ArrayOfDATAFORMAT_USCORECOLUMN(struct soap *soap, eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata_eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToeoddata1__ArrayOfDATAFORMAT_USCORECOLUMN(struct soap *soap, const char *tag, int id, eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata_eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN ** SOAP_FMAC4 soap_in_PointerToeoddata1__ArrayOfDATAFORMAT_USCORECOLUMN(struct soap *soap, const char *tag, eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN **)soap_malloc(soap, sizeof(eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN *)soap_instantiate_eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata_eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN, sizeof(eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN), 0, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToeoddata1__ArrayOfDATAFORMAT_USCORECOLUMN(struct soap *soap, eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToeoddata1__ArrayOfDATAFORMAT_USCORECOLUMN(soap, tag?tag:"eoddata1:ArrayOfDATAFORMAT_COLUMN", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN ** SOAP_FMAC4 soap_get_PointerToeoddata1__ArrayOfDATAFORMAT_USCORECOLUMN(struct soap *soap, eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToeoddata1__ArrayOfDATAFORMAT_USCORECOLUMN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToeoddata1__DATAFORMAT(struct soap *soap, eoddata1__DATAFORMAT *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata_eoddata1__DATAFORMAT))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToeoddata1__DATAFORMAT(struct soap *soap, const char *tag, int id, eoddata1__DATAFORMAT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata_eoddata1__DATAFORMAT, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 eoddata1__DATAFORMAT ** SOAP_FMAC4 soap_in_PointerToeoddata1__DATAFORMAT(struct soap *soap, const char *tag, eoddata1__DATAFORMAT **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (eoddata1__DATAFORMAT **)soap_malloc(soap, sizeof(eoddata1__DATAFORMAT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (eoddata1__DATAFORMAT *)soap_instantiate_eoddata1__DATAFORMAT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (eoddata1__DATAFORMAT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata_eoddata1__DATAFORMAT, sizeof(eoddata1__DATAFORMAT), 0, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToeoddata1__DATAFORMAT(struct soap *soap, eoddata1__DATAFORMAT *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToeoddata1__DATAFORMAT(soap, tag?tag:"eoddata1:DATAFORMAT", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 eoddata1__DATAFORMAT ** SOAP_FMAC4 soap_get_PointerToeoddata1__DATAFORMAT(struct soap *soap, eoddata1__DATAFORMAT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToeoddata1__DATAFORMAT(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToeoddata1__NEWS(struct soap *soap, eoddata1__NEWS *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata_eoddata1__NEWS))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToeoddata1__NEWS(struct soap *soap, const char *tag, int id, eoddata1__NEWS *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata_eoddata1__NEWS, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 eoddata1__NEWS ** SOAP_FMAC4 soap_in_PointerToeoddata1__NEWS(struct soap *soap, const char *tag, eoddata1__NEWS **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (eoddata1__NEWS **)soap_malloc(soap, sizeof(eoddata1__NEWS *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (eoddata1__NEWS *)soap_instantiate_eoddata1__NEWS(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (eoddata1__NEWS **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata_eoddata1__NEWS, sizeof(eoddata1__NEWS), 0, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToeoddata1__NEWS(struct soap *soap, eoddata1__NEWS *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToeoddata1__NEWS(soap, tag?tag:"eoddata1:NEWS", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 eoddata1__NEWS ** SOAP_FMAC4 soap_get_PointerToeoddata1__NEWS(struct soap *soap, eoddata1__NEWS **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToeoddata1__NEWS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToeoddata1__SYMBOLCHANGE(struct soap *soap, eoddata1__SYMBOLCHANGE *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata_eoddata1__SYMBOLCHANGE))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToeoddata1__SYMBOLCHANGE(struct soap *soap, const char *tag, int id, eoddata1__SYMBOLCHANGE *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata_eoddata1__SYMBOLCHANGE, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 eoddata1__SYMBOLCHANGE ** SOAP_FMAC4 soap_in_PointerToeoddata1__SYMBOLCHANGE(struct soap *soap, const char *tag, eoddata1__SYMBOLCHANGE **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (eoddata1__SYMBOLCHANGE **)soap_malloc(soap, sizeof(eoddata1__SYMBOLCHANGE *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (eoddata1__SYMBOLCHANGE *)soap_instantiate_eoddata1__SYMBOLCHANGE(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (eoddata1__SYMBOLCHANGE **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata_eoddata1__SYMBOLCHANGE, sizeof(eoddata1__SYMBOLCHANGE), 0, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToeoddata1__SYMBOLCHANGE(struct soap *soap, eoddata1__SYMBOLCHANGE *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToeoddata1__SYMBOLCHANGE(soap, tag?tag:"eoddata1:SYMBOLCHANGE", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 eoddata1__SYMBOLCHANGE ** SOAP_FMAC4 soap_get_PointerToeoddata1__SYMBOLCHANGE(struct soap *soap, eoddata1__SYMBOLCHANGE **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToeoddata1__SYMBOLCHANGE(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToeoddata1__TECHNICAL(struct soap *soap, eoddata1__TECHNICAL *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata_eoddata1__TECHNICAL))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToeoddata1__TECHNICAL(struct soap *soap, const char *tag, int id, eoddata1__TECHNICAL *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata_eoddata1__TECHNICAL, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 eoddata1__TECHNICAL ** SOAP_FMAC4 soap_in_PointerToeoddata1__TECHNICAL(struct soap *soap, const char *tag, eoddata1__TECHNICAL **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (eoddata1__TECHNICAL **)soap_malloc(soap, sizeof(eoddata1__TECHNICAL *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (eoddata1__TECHNICAL *)soap_instantiate_eoddata1__TECHNICAL(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (eoddata1__TECHNICAL **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata_eoddata1__TECHNICAL, sizeof(eoddata1__TECHNICAL), 0, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToeoddata1__TECHNICAL(struct soap *soap, eoddata1__TECHNICAL *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToeoddata1__TECHNICAL(soap, tag?tag:"eoddata1:TECHNICAL", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 eoddata1__TECHNICAL ** SOAP_FMAC4 soap_get_PointerToeoddata1__TECHNICAL(struct soap *soap, eoddata1__TECHNICAL **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToeoddata1__TECHNICAL(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToeoddata1__FUNDAMENTAL(struct soap *soap, eoddata1__FUNDAMENTAL *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata_eoddata1__FUNDAMENTAL))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToeoddata1__FUNDAMENTAL(struct soap *soap, const char *tag, int id, eoddata1__FUNDAMENTAL *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata_eoddata1__FUNDAMENTAL, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 eoddata1__FUNDAMENTAL ** SOAP_FMAC4 soap_in_PointerToeoddata1__FUNDAMENTAL(struct soap *soap, const char *tag, eoddata1__FUNDAMENTAL **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (eoddata1__FUNDAMENTAL **)soap_malloc(soap, sizeof(eoddata1__FUNDAMENTAL *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (eoddata1__FUNDAMENTAL *)soap_instantiate_eoddata1__FUNDAMENTAL(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (eoddata1__FUNDAMENTAL **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata_eoddata1__FUNDAMENTAL, sizeof(eoddata1__FUNDAMENTAL), 0, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToeoddata1__FUNDAMENTAL(struct soap *soap, eoddata1__FUNDAMENTAL *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToeoddata1__FUNDAMENTAL(soap, tag?tag:"eoddata1:FUNDAMENTAL", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 eoddata1__FUNDAMENTAL ** SOAP_FMAC4 soap_get_PointerToeoddata1__FUNDAMENTAL(struct soap *soap, eoddata1__FUNDAMENTAL **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToeoddata1__FUNDAMENTAL(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToeoddata1__CountryBase(struct soap *soap, eoddata1__CountryBase *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata_eoddata1__CountryBase))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToeoddata1__CountryBase(struct soap *soap, const char *tag, int id, eoddata1__CountryBase *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata_eoddata1__CountryBase, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 eoddata1__CountryBase ** SOAP_FMAC4 soap_in_PointerToeoddata1__CountryBase(struct soap *soap, const char *tag, eoddata1__CountryBase **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (eoddata1__CountryBase **)soap_malloc(soap, sizeof(eoddata1__CountryBase *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (eoddata1__CountryBase *)soap_instantiate_eoddata1__CountryBase(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (eoddata1__CountryBase **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata_eoddata1__CountryBase, sizeof(eoddata1__CountryBase), 0, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToeoddata1__CountryBase(struct soap *soap, eoddata1__CountryBase *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToeoddata1__CountryBase(soap, tag?tag:"eoddata1:CountryBase", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 eoddata1__CountryBase ** SOAP_FMAC4 soap_get_PointerToeoddata1__CountryBase(struct soap *soap, eoddata1__CountryBase **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToeoddata1__CountryBase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToeoddata1__SPLIT(struct soap *soap, eoddata1__SPLIT *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata_eoddata1__SPLIT))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToeoddata1__SPLIT(struct soap *soap, const char *tag, int id, eoddata1__SPLIT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata_eoddata1__SPLIT, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 eoddata1__SPLIT ** SOAP_FMAC4 soap_in_PointerToeoddata1__SPLIT(struct soap *soap, const char *tag, eoddata1__SPLIT **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (eoddata1__SPLIT **)soap_malloc(soap, sizeof(eoddata1__SPLIT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (eoddata1__SPLIT *)soap_instantiate_eoddata1__SPLIT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (eoddata1__SPLIT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata_eoddata1__SPLIT, sizeof(eoddata1__SPLIT), 0, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToeoddata1__SPLIT(struct soap *soap, eoddata1__SPLIT *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToeoddata1__SPLIT(soap, tag?tag:"eoddata1:SPLIT", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 eoddata1__SPLIT ** SOAP_FMAC4 soap_get_PointerToeoddata1__SPLIT(struct soap *soap, eoddata1__SPLIT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToeoddata1__SPLIT(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToeoddata1__QUOTE2(struct soap *soap, eoddata1__QUOTE2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata_eoddata1__QUOTE2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToeoddata1__QUOTE2(struct soap *soap, const char *tag, int id, eoddata1__QUOTE2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata_eoddata1__QUOTE2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 eoddata1__QUOTE2 ** SOAP_FMAC4 soap_in_PointerToeoddata1__QUOTE2(struct soap *soap, const char *tag, eoddata1__QUOTE2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (eoddata1__QUOTE2 **)soap_malloc(soap, sizeof(eoddata1__QUOTE2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (eoddata1__QUOTE2 *)soap_instantiate_eoddata1__QUOTE2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (eoddata1__QUOTE2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata_eoddata1__QUOTE2, sizeof(eoddata1__QUOTE2), 0, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToeoddata1__QUOTE2(struct soap *soap, eoddata1__QUOTE2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToeoddata1__QUOTE2(soap, tag?tag:"eoddata1:QUOTE2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 eoddata1__QUOTE2 ** SOAP_FMAC4 soap_get_PointerToeoddata1__QUOTE2(struct soap *soap, eoddata1__QUOTE2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToeoddata1__QUOTE2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToeoddata1__SYMBOL2(struct soap *soap, eoddata1__SYMBOL2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata_eoddata1__SYMBOL2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToeoddata1__SYMBOL2(struct soap *soap, const char *tag, int id, eoddata1__SYMBOL2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata_eoddata1__SYMBOL2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 eoddata1__SYMBOL2 ** SOAP_FMAC4 soap_in_PointerToeoddata1__SYMBOL2(struct soap *soap, const char *tag, eoddata1__SYMBOL2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (eoddata1__SYMBOL2 **)soap_malloc(soap, sizeof(eoddata1__SYMBOL2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (eoddata1__SYMBOL2 *)soap_instantiate_eoddata1__SYMBOL2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (eoddata1__SYMBOL2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata_eoddata1__SYMBOL2, sizeof(eoddata1__SYMBOL2), 0, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToeoddata1__SYMBOL2(struct soap *soap, eoddata1__SYMBOL2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToeoddata1__SYMBOL2(soap, tag?tag:"eoddata1:SYMBOL2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 eoddata1__SYMBOL2 ** SOAP_FMAC4 soap_get_PointerToeoddata1__SYMBOL2(struct soap *soap, eoddata1__SYMBOL2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToeoddata1__SYMBOL2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToeoddata1__ArrayOfDATAFORMAT(struct soap *soap, eoddata1__ArrayOfDATAFORMAT *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata_eoddata1__ArrayOfDATAFORMAT))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToeoddata1__ArrayOfDATAFORMAT(struct soap *soap, const char *tag, int id, eoddata1__ArrayOfDATAFORMAT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata_eoddata1__ArrayOfDATAFORMAT, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 eoddata1__ArrayOfDATAFORMAT ** SOAP_FMAC4 soap_in_PointerToeoddata1__ArrayOfDATAFORMAT(struct soap *soap, const char *tag, eoddata1__ArrayOfDATAFORMAT **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (eoddata1__ArrayOfDATAFORMAT **)soap_malloc(soap, sizeof(eoddata1__ArrayOfDATAFORMAT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (eoddata1__ArrayOfDATAFORMAT *)soap_instantiate_eoddata1__ArrayOfDATAFORMAT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (eoddata1__ArrayOfDATAFORMAT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata_eoddata1__ArrayOfDATAFORMAT, sizeof(eoddata1__ArrayOfDATAFORMAT), 0, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToeoddata1__ArrayOfDATAFORMAT(struct soap *soap, eoddata1__ArrayOfDATAFORMAT *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToeoddata1__ArrayOfDATAFORMAT(soap, tag?tag:"eoddata1:ArrayOfDATAFORMAT", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 eoddata1__ArrayOfDATAFORMAT ** SOAP_FMAC4 soap_get_PointerToeoddata1__ArrayOfDATAFORMAT(struct soap *soap, eoddata1__ArrayOfDATAFORMAT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToeoddata1__ArrayOfDATAFORMAT(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToeoddata1__ArrayOfNEWS(struct soap *soap, eoddata1__ArrayOfNEWS *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata_eoddata1__ArrayOfNEWS))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToeoddata1__ArrayOfNEWS(struct soap *soap, const char *tag, int id, eoddata1__ArrayOfNEWS *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata_eoddata1__ArrayOfNEWS, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 eoddata1__ArrayOfNEWS ** SOAP_FMAC4 soap_in_PointerToeoddata1__ArrayOfNEWS(struct soap *soap, const char *tag, eoddata1__ArrayOfNEWS **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (eoddata1__ArrayOfNEWS **)soap_malloc(soap, sizeof(eoddata1__ArrayOfNEWS *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (eoddata1__ArrayOfNEWS *)soap_instantiate_eoddata1__ArrayOfNEWS(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (eoddata1__ArrayOfNEWS **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata_eoddata1__ArrayOfNEWS, sizeof(eoddata1__ArrayOfNEWS), 0, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToeoddata1__ArrayOfNEWS(struct soap *soap, eoddata1__ArrayOfNEWS *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToeoddata1__ArrayOfNEWS(soap, tag?tag:"eoddata1:ArrayOfNEWS", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 eoddata1__ArrayOfNEWS ** SOAP_FMAC4 soap_get_PointerToeoddata1__ArrayOfNEWS(struct soap *soap, eoddata1__ArrayOfNEWS **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToeoddata1__ArrayOfNEWS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToeoddata1__ArrayOfSYMBOLCHANGE(struct soap *soap, eoddata1__ArrayOfSYMBOLCHANGE *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata_eoddata1__ArrayOfSYMBOLCHANGE))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToeoddata1__ArrayOfSYMBOLCHANGE(struct soap *soap, const char *tag, int id, eoddata1__ArrayOfSYMBOLCHANGE *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata_eoddata1__ArrayOfSYMBOLCHANGE, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 eoddata1__ArrayOfSYMBOLCHANGE ** SOAP_FMAC4 soap_in_PointerToeoddata1__ArrayOfSYMBOLCHANGE(struct soap *soap, const char *tag, eoddata1__ArrayOfSYMBOLCHANGE **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (eoddata1__ArrayOfSYMBOLCHANGE **)soap_malloc(soap, sizeof(eoddata1__ArrayOfSYMBOLCHANGE *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (eoddata1__ArrayOfSYMBOLCHANGE *)soap_instantiate_eoddata1__ArrayOfSYMBOLCHANGE(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (eoddata1__ArrayOfSYMBOLCHANGE **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata_eoddata1__ArrayOfSYMBOLCHANGE, sizeof(eoddata1__ArrayOfSYMBOLCHANGE), 0, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToeoddata1__ArrayOfSYMBOLCHANGE(struct soap *soap, eoddata1__ArrayOfSYMBOLCHANGE *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToeoddata1__ArrayOfSYMBOLCHANGE(soap, tag?tag:"eoddata1:ArrayOfSYMBOLCHANGE", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 eoddata1__ArrayOfSYMBOLCHANGE ** SOAP_FMAC4 soap_get_PointerToeoddata1__ArrayOfSYMBOLCHANGE(struct soap *soap, eoddata1__ArrayOfSYMBOLCHANGE **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToeoddata1__ArrayOfSYMBOLCHANGE(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToeoddata1__ArrayOfTECHNICAL(struct soap *soap, eoddata1__ArrayOfTECHNICAL *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata_eoddata1__ArrayOfTECHNICAL))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToeoddata1__ArrayOfTECHNICAL(struct soap *soap, const char *tag, int id, eoddata1__ArrayOfTECHNICAL *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata_eoddata1__ArrayOfTECHNICAL, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 eoddata1__ArrayOfTECHNICAL ** SOAP_FMAC4 soap_in_PointerToeoddata1__ArrayOfTECHNICAL(struct soap *soap, const char *tag, eoddata1__ArrayOfTECHNICAL **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (eoddata1__ArrayOfTECHNICAL **)soap_malloc(soap, sizeof(eoddata1__ArrayOfTECHNICAL *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (eoddata1__ArrayOfTECHNICAL *)soap_instantiate_eoddata1__ArrayOfTECHNICAL(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (eoddata1__ArrayOfTECHNICAL **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata_eoddata1__ArrayOfTECHNICAL, sizeof(eoddata1__ArrayOfTECHNICAL), 0, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToeoddata1__ArrayOfTECHNICAL(struct soap *soap, eoddata1__ArrayOfTECHNICAL *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToeoddata1__ArrayOfTECHNICAL(soap, tag?tag:"eoddata1:ArrayOfTECHNICAL", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 eoddata1__ArrayOfTECHNICAL ** SOAP_FMAC4 soap_get_PointerToeoddata1__ArrayOfTECHNICAL(struct soap *soap, eoddata1__ArrayOfTECHNICAL **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToeoddata1__ArrayOfTECHNICAL(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToeoddata1__ArrayOfFUNDAMENTAL(struct soap *soap, eoddata1__ArrayOfFUNDAMENTAL *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata_eoddata1__ArrayOfFUNDAMENTAL))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToeoddata1__ArrayOfFUNDAMENTAL(struct soap *soap, const char *tag, int id, eoddata1__ArrayOfFUNDAMENTAL *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata_eoddata1__ArrayOfFUNDAMENTAL, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 eoddata1__ArrayOfFUNDAMENTAL ** SOAP_FMAC4 soap_in_PointerToeoddata1__ArrayOfFUNDAMENTAL(struct soap *soap, const char *tag, eoddata1__ArrayOfFUNDAMENTAL **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (eoddata1__ArrayOfFUNDAMENTAL **)soap_malloc(soap, sizeof(eoddata1__ArrayOfFUNDAMENTAL *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (eoddata1__ArrayOfFUNDAMENTAL *)soap_instantiate_eoddata1__ArrayOfFUNDAMENTAL(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (eoddata1__ArrayOfFUNDAMENTAL **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata_eoddata1__ArrayOfFUNDAMENTAL, sizeof(eoddata1__ArrayOfFUNDAMENTAL), 0, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToeoddata1__ArrayOfFUNDAMENTAL(struct soap *soap, eoddata1__ArrayOfFUNDAMENTAL *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToeoddata1__ArrayOfFUNDAMENTAL(soap, tag?tag:"eoddata1:ArrayOfFUNDAMENTAL", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 eoddata1__ArrayOfFUNDAMENTAL ** SOAP_FMAC4 soap_get_PointerToeoddata1__ArrayOfFUNDAMENTAL(struct soap *soap, eoddata1__ArrayOfFUNDAMENTAL **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToeoddata1__ArrayOfFUNDAMENTAL(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToeoddata1__ArrayOfCountryBase(struct soap *soap, eoddata1__ArrayOfCountryBase *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata_eoddata1__ArrayOfCountryBase))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToeoddata1__ArrayOfCountryBase(struct soap *soap, const char *tag, int id, eoddata1__ArrayOfCountryBase *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata_eoddata1__ArrayOfCountryBase, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 eoddata1__ArrayOfCountryBase ** SOAP_FMAC4 soap_in_PointerToeoddata1__ArrayOfCountryBase(struct soap *soap, const char *tag, eoddata1__ArrayOfCountryBase **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (eoddata1__ArrayOfCountryBase **)soap_malloc(soap, sizeof(eoddata1__ArrayOfCountryBase *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (eoddata1__ArrayOfCountryBase *)soap_instantiate_eoddata1__ArrayOfCountryBase(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (eoddata1__ArrayOfCountryBase **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata_eoddata1__ArrayOfCountryBase, sizeof(eoddata1__ArrayOfCountryBase), 0, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToeoddata1__ArrayOfCountryBase(struct soap *soap, eoddata1__ArrayOfCountryBase *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToeoddata1__ArrayOfCountryBase(soap, tag?tag:"eoddata1:ArrayOfCountryBase", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 eoddata1__ArrayOfCountryBase ** SOAP_FMAC4 soap_get_PointerToeoddata1__ArrayOfCountryBase(struct soap *soap, eoddata1__ArrayOfCountryBase **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToeoddata1__ArrayOfCountryBase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToeoddata1__ArrayOfSPLIT(struct soap *soap, eoddata1__ArrayOfSPLIT *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata_eoddata1__ArrayOfSPLIT))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToeoddata1__ArrayOfSPLIT(struct soap *soap, const char *tag, int id, eoddata1__ArrayOfSPLIT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata_eoddata1__ArrayOfSPLIT, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 eoddata1__ArrayOfSPLIT ** SOAP_FMAC4 soap_in_PointerToeoddata1__ArrayOfSPLIT(struct soap *soap, const char *tag, eoddata1__ArrayOfSPLIT **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (eoddata1__ArrayOfSPLIT **)soap_malloc(soap, sizeof(eoddata1__ArrayOfSPLIT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (eoddata1__ArrayOfSPLIT *)soap_instantiate_eoddata1__ArrayOfSPLIT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (eoddata1__ArrayOfSPLIT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata_eoddata1__ArrayOfSPLIT, sizeof(eoddata1__ArrayOfSPLIT), 0, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToeoddata1__ArrayOfSPLIT(struct soap *soap, eoddata1__ArrayOfSPLIT *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToeoddata1__ArrayOfSPLIT(soap, tag?tag:"eoddata1:ArrayOfSPLIT", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 eoddata1__ArrayOfSPLIT ** SOAP_FMAC4 soap_get_PointerToeoddata1__ArrayOfSPLIT(struct soap *soap, eoddata1__ArrayOfSPLIT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToeoddata1__ArrayOfSPLIT(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToeoddata1__ArrayOfQUOTE2(struct soap *soap, eoddata1__ArrayOfQUOTE2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata_eoddata1__ArrayOfQUOTE2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToeoddata1__ArrayOfQUOTE2(struct soap *soap, const char *tag, int id, eoddata1__ArrayOfQUOTE2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata_eoddata1__ArrayOfQUOTE2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 eoddata1__ArrayOfQUOTE2 ** SOAP_FMAC4 soap_in_PointerToeoddata1__ArrayOfQUOTE2(struct soap *soap, const char *tag, eoddata1__ArrayOfQUOTE2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (eoddata1__ArrayOfQUOTE2 **)soap_malloc(soap, sizeof(eoddata1__ArrayOfQUOTE2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (eoddata1__ArrayOfQUOTE2 *)soap_instantiate_eoddata1__ArrayOfQUOTE2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (eoddata1__ArrayOfQUOTE2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata_eoddata1__ArrayOfQUOTE2, sizeof(eoddata1__ArrayOfQUOTE2), 0, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToeoddata1__ArrayOfQUOTE2(struct soap *soap, eoddata1__ArrayOfQUOTE2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToeoddata1__ArrayOfQUOTE2(soap, tag?tag:"eoddata1:ArrayOfQUOTE2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 eoddata1__ArrayOfQUOTE2 ** SOAP_FMAC4 soap_get_PointerToeoddata1__ArrayOfQUOTE2(struct soap *soap, eoddata1__ArrayOfQUOTE2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToeoddata1__ArrayOfQUOTE2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToeoddata1__ArrayOfQUOTE(struct soap *soap, eoddata1__ArrayOfQUOTE *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata_eoddata1__ArrayOfQUOTE))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToeoddata1__ArrayOfQUOTE(struct soap *soap, const char *tag, int id, eoddata1__ArrayOfQUOTE *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata_eoddata1__ArrayOfQUOTE, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 eoddata1__ArrayOfQUOTE ** SOAP_FMAC4 soap_in_PointerToeoddata1__ArrayOfQUOTE(struct soap *soap, const char *tag, eoddata1__ArrayOfQUOTE **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (eoddata1__ArrayOfQUOTE **)soap_malloc(soap, sizeof(eoddata1__ArrayOfQUOTE *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (eoddata1__ArrayOfQUOTE *)soap_instantiate_eoddata1__ArrayOfQUOTE(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (eoddata1__ArrayOfQUOTE **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata_eoddata1__ArrayOfQUOTE, sizeof(eoddata1__ArrayOfQUOTE), 0, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToeoddata1__ArrayOfQUOTE(struct soap *soap, eoddata1__ArrayOfQUOTE *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToeoddata1__ArrayOfQUOTE(soap, tag?tag:"eoddata1:ArrayOfQUOTE", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 eoddata1__ArrayOfQUOTE ** SOAP_FMAC4 soap_get_PointerToeoddata1__ArrayOfQUOTE(struct soap *soap, eoddata1__ArrayOfQUOTE **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToeoddata1__ArrayOfQUOTE(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToeoddata1__QUOTE(struct soap *soap, eoddata1__QUOTE *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata_eoddata1__QUOTE))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToeoddata1__QUOTE(struct soap *soap, const char *tag, int id, eoddata1__QUOTE *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata_eoddata1__QUOTE, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 eoddata1__QUOTE ** SOAP_FMAC4 soap_in_PointerToeoddata1__QUOTE(struct soap *soap, const char *tag, eoddata1__QUOTE **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (eoddata1__QUOTE **)soap_malloc(soap, sizeof(eoddata1__QUOTE *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (eoddata1__QUOTE *)soap_instantiate_eoddata1__QUOTE(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (eoddata1__QUOTE **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata_eoddata1__QUOTE, sizeof(eoddata1__QUOTE), 0, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToeoddata1__QUOTE(struct soap *soap, eoddata1__QUOTE *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToeoddata1__QUOTE(soap, tag?tag:"eoddata1:QUOTE", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 eoddata1__QUOTE ** SOAP_FMAC4 soap_get_PointerToeoddata1__QUOTE(struct soap *soap, eoddata1__QUOTE **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToeoddata1__QUOTE(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToeoddata1__ArrayOfSYMBOL2(struct soap *soap, eoddata1__ArrayOfSYMBOL2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata_eoddata1__ArrayOfSYMBOL2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToeoddata1__ArrayOfSYMBOL2(struct soap *soap, const char *tag, int id, eoddata1__ArrayOfSYMBOL2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata_eoddata1__ArrayOfSYMBOL2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 eoddata1__ArrayOfSYMBOL2 ** SOAP_FMAC4 soap_in_PointerToeoddata1__ArrayOfSYMBOL2(struct soap *soap, const char *tag, eoddata1__ArrayOfSYMBOL2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (eoddata1__ArrayOfSYMBOL2 **)soap_malloc(soap, sizeof(eoddata1__ArrayOfSYMBOL2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (eoddata1__ArrayOfSYMBOL2 *)soap_instantiate_eoddata1__ArrayOfSYMBOL2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (eoddata1__ArrayOfSYMBOL2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata_eoddata1__ArrayOfSYMBOL2, sizeof(eoddata1__ArrayOfSYMBOL2), 0, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToeoddata1__ArrayOfSYMBOL2(struct soap *soap, eoddata1__ArrayOfSYMBOL2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToeoddata1__ArrayOfSYMBOL2(soap, tag?tag:"eoddata1:ArrayOfSYMBOL2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 eoddata1__ArrayOfSYMBOL2 ** SOAP_FMAC4 soap_get_PointerToeoddata1__ArrayOfSYMBOL2(struct soap *soap, eoddata1__ArrayOfSYMBOL2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToeoddata1__ArrayOfSYMBOL2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToeoddata1__ArrayOfSYMBOL(struct soap *soap, eoddata1__ArrayOfSYMBOL *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata_eoddata1__ArrayOfSYMBOL))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToeoddata1__ArrayOfSYMBOL(struct soap *soap, const char *tag, int id, eoddata1__ArrayOfSYMBOL *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata_eoddata1__ArrayOfSYMBOL, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 eoddata1__ArrayOfSYMBOL ** SOAP_FMAC4 soap_in_PointerToeoddata1__ArrayOfSYMBOL(struct soap *soap, const char *tag, eoddata1__ArrayOfSYMBOL **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (eoddata1__ArrayOfSYMBOL **)soap_malloc(soap, sizeof(eoddata1__ArrayOfSYMBOL *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (eoddata1__ArrayOfSYMBOL *)soap_instantiate_eoddata1__ArrayOfSYMBOL(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (eoddata1__ArrayOfSYMBOL **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata_eoddata1__ArrayOfSYMBOL, sizeof(eoddata1__ArrayOfSYMBOL), 0, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToeoddata1__ArrayOfSYMBOL(struct soap *soap, eoddata1__ArrayOfSYMBOL *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToeoddata1__ArrayOfSYMBOL(soap, tag?tag:"eoddata1:ArrayOfSYMBOL", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 eoddata1__ArrayOfSYMBOL ** SOAP_FMAC4 soap_get_PointerToeoddata1__ArrayOfSYMBOL(struct soap *soap, eoddata1__ArrayOfSYMBOL **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToeoddata1__ArrayOfSYMBOL(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToeoddata1__SYMBOL(struct soap *soap, eoddata1__SYMBOL *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata_eoddata1__SYMBOL))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToeoddata1__SYMBOL(struct soap *soap, const char *tag, int id, eoddata1__SYMBOL *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata_eoddata1__SYMBOL, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 eoddata1__SYMBOL ** SOAP_FMAC4 soap_in_PointerToeoddata1__SYMBOL(struct soap *soap, const char *tag, eoddata1__SYMBOL **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (eoddata1__SYMBOL **)soap_malloc(soap, sizeof(eoddata1__SYMBOL *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (eoddata1__SYMBOL *)soap_instantiate_eoddata1__SYMBOL(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (eoddata1__SYMBOL **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata_eoddata1__SYMBOL, sizeof(eoddata1__SYMBOL), 0, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToeoddata1__SYMBOL(struct soap *soap, eoddata1__SYMBOL *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToeoddata1__SYMBOL(soap, tag?tag:"eoddata1:SYMBOL", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 eoddata1__SYMBOL ** SOAP_FMAC4 soap_get_PointerToeoddata1__SYMBOL(struct soap *soap, eoddata1__SYMBOL **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToeoddata1__SYMBOL(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToeoddata1__ArrayOfEXCHANGE(struct soap *soap, eoddata1__ArrayOfEXCHANGE *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata_eoddata1__ArrayOfEXCHANGE))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToeoddata1__ArrayOfEXCHANGE(struct soap *soap, const char *tag, int id, eoddata1__ArrayOfEXCHANGE *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata_eoddata1__ArrayOfEXCHANGE, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 eoddata1__ArrayOfEXCHANGE ** SOAP_FMAC4 soap_in_PointerToeoddata1__ArrayOfEXCHANGE(struct soap *soap, const char *tag, eoddata1__ArrayOfEXCHANGE **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (eoddata1__ArrayOfEXCHANGE **)soap_malloc(soap, sizeof(eoddata1__ArrayOfEXCHANGE *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (eoddata1__ArrayOfEXCHANGE *)soap_instantiate_eoddata1__ArrayOfEXCHANGE(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (eoddata1__ArrayOfEXCHANGE **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata_eoddata1__ArrayOfEXCHANGE, sizeof(eoddata1__ArrayOfEXCHANGE), 0, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToeoddata1__ArrayOfEXCHANGE(struct soap *soap, eoddata1__ArrayOfEXCHANGE *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToeoddata1__ArrayOfEXCHANGE(soap, tag?tag:"eoddata1:ArrayOfEXCHANGE", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 eoddata1__ArrayOfEXCHANGE ** SOAP_FMAC4 soap_get_PointerToeoddata1__ArrayOfEXCHANGE(struct soap *soap, eoddata1__ArrayOfEXCHANGE **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToeoddata1__ArrayOfEXCHANGE(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToeoddata1__EXCHANGE(struct soap *soap, eoddata1__EXCHANGE *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata_eoddata1__EXCHANGE))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToeoddata1__EXCHANGE(struct soap *soap, const char *tag, int id, eoddata1__EXCHANGE *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata_eoddata1__EXCHANGE, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 eoddata1__EXCHANGE ** SOAP_FMAC4 soap_in_PointerToeoddata1__EXCHANGE(struct soap *soap, const char *tag, eoddata1__EXCHANGE **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (eoddata1__EXCHANGE **)soap_malloc(soap, sizeof(eoddata1__EXCHANGE *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (eoddata1__EXCHANGE *)soap_instantiate_eoddata1__EXCHANGE(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (eoddata1__EXCHANGE **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata_eoddata1__EXCHANGE, sizeof(eoddata1__EXCHANGE), 0, eoddata_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToeoddata1__EXCHANGE(struct soap *soap, eoddata1__EXCHANGE *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToeoddata1__EXCHANGE(soap, tag?tag:"eoddata1:EXCHANGE", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 eoddata1__EXCHANGE ** SOAP_FMAC4 soap_get_PointerToeoddata1__EXCHANGE(struct soap *soap, eoddata1__EXCHANGE **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToeoddata1__EXCHANGE(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_eoddata_std__string))
		soap_serialize_std__string(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_eoddata_std__string, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_eoddata_std__string, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTostd__string(soap, tag?tag:"string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_eoddata__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_eoddata__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_eoddata__QName, 2, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__QName(soap, tag?tag:"QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_eoddata_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_eoddata_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_eoddata_string, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_string(soap, tag?tag:"string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToeoddata1__DATAFORMAT_USCORECOLUMN(struct soap *soap, std::vector<eoddata1__DATAFORMAT_USCORECOLUMN *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToeoddata1__DATAFORMAT_USCORECOLUMN(struct soap *soap, const std::vector<eoddata1__DATAFORMAT_USCORECOLUMN *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<eoddata1__DATAFORMAT_USCORECOLUMN *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToeoddata1__DATAFORMAT_USCORECOLUMN(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToeoddata1__DATAFORMAT_USCORECOLUMN(struct soap *soap, const char *tag, int id, const std::vector<eoddata1__DATAFORMAT_USCORECOLUMN *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<eoddata1__DATAFORMAT_USCORECOLUMN *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToeoddata1__DATAFORMAT_USCORECOLUMN(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<eoddata1__DATAFORMAT_USCORECOLUMN *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToeoddata1__DATAFORMAT_USCORECOLUMN(struct soap *soap, const char *tag, std::vector<eoddata1__DATAFORMAT_USCORECOLUMN *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerToeoddata1__DATAFORMAT_USCORECOLUMN(soap)))
			return NULL;
		eoddata1__DATAFORMAT_USCORECOLUMN *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_eoddata_eoddata1__DATAFORMAT_USCORECOLUMN, SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__DATAFORMAT_USCORECOLUMN, sizeof(eoddata1__DATAFORMAT_USCORECOLUMN), 1, eoddata_finsert, eoddata_fbase))
				break;
			if (!soap_in_PointerToeoddata1__DATAFORMAT_USCORECOLUMN(soap, tag, NULL, "eoddata1:DATAFORMAT_COLUMN"))
				break;
		}
		else
		{	if (!soap_in_PointerToeoddata1__DATAFORMAT_USCORECOLUMN(soap, tag, &n, "eoddata1:DATAFORMAT_COLUMN"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<eoddata1__DATAFORMAT_USCORECOLUMN *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerToeoddata1__DATAFORMAT_USCORECOLUMN(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToeoddata1__DATAFORMAT_USCORECOLUMN(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<eoddata1__DATAFORMAT_USCORECOLUMN *> *p;
	size_t k = sizeof(std::vector<eoddata1__DATAFORMAT_USCORECOLUMN *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<eoddata1__DATAFORMAT_USCORECOLUMN *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<eoddata1__DATAFORMAT_USCORECOLUMN *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<eoddata1__DATAFORMAT_USCORECOLUMN *>  location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__DATAFORMAT_USCORECOLUMN, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToeoddata1__DATAFORMAT(struct soap *soap, std::vector<eoddata1__DATAFORMAT *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToeoddata1__DATAFORMAT(struct soap *soap, const std::vector<eoddata1__DATAFORMAT *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<eoddata1__DATAFORMAT *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToeoddata1__DATAFORMAT(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToeoddata1__DATAFORMAT(struct soap *soap, const char *tag, int id, const std::vector<eoddata1__DATAFORMAT *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<eoddata1__DATAFORMAT *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToeoddata1__DATAFORMAT(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<eoddata1__DATAFORMAT *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToeoddata1__DATAFORMAT(struct soap *soap, const char *tag, std::vector<eoddata1__DATAFORMAT *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerToeoddata1__DATAFORMAT(soap)))
			return NULL;
		eoddata1__DATAFORMAT *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_eoddata_eoddata1__DATAFORMAT, SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__DATAFORMAT, sizeof(eoddata1__DATAFORMAT), 1, eoddata_finsert, eoddata_fbase))
				break;
			if (!soap_in_PointerToeoddata1__DATAFORMAT(soap, tag, NULL, "eoddata1:DATAFORMAT"))
				break;
		}
		else
		{	if (!soap_in_PointerToeoddata1__DATAFORMAT(soap, tag, &n, "eoddata1:DATAFORMAT"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<eoddata1__DATAFORMAT *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerToeoddata1__DATAFORMAT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToeoddata1__DATAFORMAT(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<eoddata1__DATAFORMAT *> *p;
	size_t k = sizeof(std::vector<eoddata1__DATAFORMAT *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<eoddata1__DATAFORMAT *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<eoddata1__DATAFORMAT *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<eoddata1__DATAFORMAT *>  location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__DATAFORMAT, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToeoddata1__NEWS(struct soap *soap, std::vector<eoddata1__NEWS *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToeoddata1__NEWS(struct soap *soap, const std::vector<eoddata1__NEWS *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<eoddata1__NEWS *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToeoddata1__NEWS(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToeoddata1__NEWS(struct soap *soap, const char *tag, int id, const std::vector<eoddata1__NEWS *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<eoddata1__NEWS *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToeoddata1__NEWS(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<eoddata1__NEWS *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToeoddata1__NEWS(struct soap *soap, const char *tag, std::vector<eoddata1__NEWS *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerToeoddata1__NEWS(soap)))
			return NULL;
		eoddata1__NEWS *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_eoddata_eoddata1__NEWS, SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__NEWS, sizeof(eoddata1__NEWS), 1, eoddata_finsert, eoddata_fbase))
				break;
			if (!soap_in_PointerToeoddata1__NEWS(soap, tag, NULL, "eoddata1:NEWS"))
				break;
		}
		else
		{	if (!soap_in_PointerToeoddata1__NEWS(soap, tag, &n, "eoddata1:NEWS"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<eoddata1__NEWS *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerToeoddata1__NEWS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToeoddata1__NEWS(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<eoddata1__NEWS *> *p;
	size_t k = sizeof(std::vector<eoddata1__NEWS *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<eoddata1__NEWS *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<eoddata1__NEWS *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<eoddata1__NEWS *>  location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__NEWS, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToeoddata1__SYMBOLCHANGE(struct soap *soap, std::vector<eoddata1__SYMBOLCHANGE *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToeoddata1__SYMBOLCHANGE(struct soap *soap, const std::vector<eoddata1__SYMBOLCHANGE *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<eoddata1__SYMBOLCHANGE *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToeoddata1__SYMBOLCHANGE(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToeoddata1__SYMBOLCHANGE(struct soap *soap, const char *tag, int id, const std::vector<eoddata1__SYMBOLCHANGE *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<eoddata1__SYMBOLCHANGE *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToeoddata1__SYMBOLCHANGE(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<eoddata1__SYMBOLCHANGE *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToeoddata1__SYMBOLCHANGE(struct soap *soap, const char *tag, std::vector<eoddata1__SYMBOLCHANGE *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerToeoddata1__SYMBOLCHANGE(soap)))
			return NULL;
		eoddata1__SYMBOLCHANGE *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_eoddata_eoddata1__SYMBOLCHANGE, SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__SYMBOLCHANGE, sizeof(eoddata1__SYMBOLCHANGE), 1, eoddata_finsert, eoddata_fbase))
				break;
			if (!soap_in_PointerToeoddata1__SYMBOLCHANGE(soap, tag, NULL, "eoddata1:SYMBOLCHANGE"))
				break;
		}
		else
		{	if (!soap_in_PointerToeoddata1__SYMBOLCHANGE(soap, tag, &n, "eoddata1:SYMBOLCHANGE"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<eoddata1__SYMBOLCHANGE *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerToeoddata1__SYMBOLCHANGE(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToeoddata1__SYMBOLCHANGE(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<eoddata1__SYMBOLCHANGE *> *p;
	size_t k = sizeof(std::vector<eoddata1__SYMBOLCHANGE *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<eoddata1__SYMBOLCHANGE *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<eoddata1__SYMBOLCHANGE *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<eoddata1__SYMBOLCHANGE *>  location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__SYMBOLCHANGE, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToeoddata1__TECHNICAL(struct soap *soap, std::vector<eoddata1__TECHNICAL *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToeoddata1__TECHNICAL(struct soap *soap, const std::vector<eoddata1__TECHNICAL *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<eoddata1__TECHNICAL *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToeoddata1__TECHNICAL(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToeoddata1__TECHNICAL(struct soap *soap, const char *tag, int id, const std::vector<eoddata1__TECHNICAL *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<eoddata1__TECHNICAL *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToeoddata1__TECHNICAL(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<eoddata1__TECHNICAL *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToeoddata1__TECHNICAL(struct soap *soap, const char *tag, std::vector<eoddata1__TECHNICAL *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerToeoddata1__TECHNICAL(soap)))
			return NULL;
		eoddata1__TECHNICAL *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_eoddata_eoddata1__TECHNICAL, SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__TECHNICAL, sizeof(eoddata1__TECHNICAL), 1, eoddata_finsert, eoddata_fbase))
				break;
			if (!soap_in_PointerToeoddata1__TECHNICAL(soap, tag, NULL, "eoddata1:TECHNICAL"))
				break;
		}
		else
		{	if (!soap_in_PointerToeoddata1__TECHNICAL(soap, tag, &n, "eoddata1:TECHNICAL"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<eoddata1__TECHNICAL *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerToeoddata1__TECHNICAL(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToeoddata1__TECHNICAL(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<eoddata1__TECHNICAL *> *p;
	size_t k = sizeof(std::vector<eoddata1__TECHNICAL *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<eoddata1__TECHNICAL *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<eoddata1__TECHNICAL *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<eoddata1__TECHNICAL *>  location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__TECHNICAL, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToeoddata1__FUNDAMENTAL(struct soap *soap, std::vector<eoddata1__FUNDAMENTAL *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToeoddata1__FUNDAMENTAL(struct soap *soap, const std::vector<eoddata1__FUNDAMENTAL *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<eoddata1__FUNDAMENTAL *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToeoddata1__FUNDAMENTAL(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToeoddata1__FUNDAMENTAL(struct soap *soap, const char *tag, int id, const std::vector<eoddata1__FUNDAMENTAL *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<eoddata1__FUNDAMENTAL *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToeoddata1__FUNDAMENTAL(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<eoddata1__FUNDAMENTAL *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToeoddata1__FUNDAMENTAL(struct soap *soap, const char *tag, std::vector<eoddata1__FUNDAMENTAL *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerToeoddata1__FUNDAMENTAL(soap)))
			return NULL;
		eoddata1__FUNDAMENTAL *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_eoddata_eoddata1__FUNDAMENTAL, SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__FUNDAMENTAL, sizeof(eoddata1__FUNDAMENTAL), 1, eoddata_finsert, eoddata_fbase))
				break;
			if (!soap_in_PointerToeoddata1__FUNDAMENTAL(soap, tag, NULL, "eoddata1:FUNDAMENTAL"))
				break;
		}
		else
		{	if (!soap_in_PointerToeoddata1__FUNDAMENTAL(soap, tag, &n, "eoddata1:FUNDAMENTAL"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<eoddata1__FUNDAMENTAL *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerToeoddata1__FUNDAMENTAL(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToeoddata1__FUNDAMENTAL(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<eoddata1__FUNDAMENTAL *> *p;
	size_t k = sizeof(std::vector<eoddata1__FUNDAMENTAL *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<eoddata1__FUNDAMENTAL *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<eoddata1__FUNDAMENTAL *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<eoddata1__FUNDAMENTAL *>  location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__FUNDAMENTAL, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToeoddata1__CountryBase(struct soap *soap, std::vector<eoddata1__CountryBase *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToeoddata1__CountryBase(struct soap *soap, const std::vector<eoddata1__CountryBase *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<eoddata1__CountryBase *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToeoddata1__CountryBase(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToeoddata1__CountryBase(struct soap *soap, const char *tag, int id, const std::vector<eoddata1__CountryBase *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<eoddata1__CountryBase *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToeoddata1__CountryBase(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<eoddata1__CountryBase *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToeoddata1__CountryBase(struct soap *soap, const char *tag, std::vector<eoddata1__CountryBase *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerToeoddata1__CountryBase(soap)))
			return NULL;
		eoddata1__CountryBase *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_eoddata_eoddata1__CountryBase, SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__CountryBase, sizeof(eoddata1__CountryBase), 1, eoddata_finsert, eoddata_fbase))
				break;
			if (!soap_in_PointerToeoddata1__CountryBase(soap, tag, NULL, "eoddata1:CountryBase"))
				break;
		}
		else
		{	if (!soap_in_PointerToeoddata1__CountryBase(soap, tag, &n, "eoddata1:CountryBase"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<eoddata1__CountryBase *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerToeoddata1__CountryBase(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToeoddata1__CountryBase(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<eoddata1__CountryBase *> *p;
	size_t k = sizeof(std::vector<eoddata1__CountryBase *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<eoddata1__CountryBase *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<eoddata1__CountryBase *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<eoddata1__CountryBase *>  location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__CountryBase, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToeoddata1__SPLIT(struct soap *soap, std::vector<eoddata1__SPLIT *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToeoddata1__SPLIT(struct soap *soap, const std::vector<eoddata1__SPLIT *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<eoddata1__SPLIT *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToeoddata1__SPLIT(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToeoddata1__SPLIT(struct soap *soap, const char *tag, int id, const std::vector<eoddata1__SPLIT *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<eoddata1__SPLIT *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToeoddata1__SPLIT(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<eoddata1__SPLIT *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToeoddata1__SPLIT(struct soap *soap, const char *tag, std::vector<eoddata1__SPLIT *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerToeoddata1__SPLIT(soap)))
			return NULL;
		eoddata1__SPLIT *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_eoddata_eoddata1__SPLIT, SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__SPLIT, sizeof(eoddata1__SPLIT), 1, eoddata_finsert, eoddata_fbase))
				break;
			if (!soap_in_PointerToeoddata1__SPLIT(soap, tag, NULL, "eoddata1:SPLIT"))
				break;
		}
		else
		{	if (!soap_in_PointerToeoddata1__SPLIT(soap, tag, &n, "eoddata1:SPLIT"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<eoddata1__SPLIT *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerToeoddata1__SPLIT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToeoddata1__SPLIT(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<eoddata1__SPLIT *> *p;
	size_t k = sizeof(std::vector<eoddata1__SPLIT *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<eoddata1__SPLIT *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<eoddata1__SPLIT *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<eoddata1__SPLIT *>  location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__SPLIT, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToeoddata1__QUOTE2(struct soap *soap, std::vector<eoddata1__QUOTE2 *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToeoddata1__QUOTE2(struct soap *soap, const std::vector<eoddata1__QUOTE2 *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<eoddata1__QUOTE2 *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToeoddata1__QUOTE2(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToeoddata1__QUOTE2(struct soap *soap, const char *tag, int id, const std::vector<eoddata1__QUOTE2 *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<eoddata1__QUOTE2 *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToeoddata1__QUOTE2(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<eoddata1__QUOTE2 *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToeoddata1__QUOTE2(struct soap *soap, const char *tag, std::vector<eoddata1__QUOTE2 *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerToeoddata1__QUOTE2(soap)))
			return NULL;
		eoddata1__QUOTE2 *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_eoddata_eoddata1__QUOTE2, SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__QUOTE2, sizeof(eoddata1__QUOTE2), 1, eoddata_finsert, eoddata_fbase))
				break;
			if (!soap_in_PointerToeoddata1__QUOTE2(soap, tag, NULL, "eoddata1:QUOTE2"))
				break;
		}
		else
		{	if (!soap_in_PointerToeoddata1__QUOTE2(soap, tag, &n, "eoddata1:QUOTE2"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<eoddata1__QUOTE2 *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerToeoddata1__QUOTE2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToeoddata1__QUOTE2(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<eoddata1__QUOTE2 *> *p;
	size_t k = sizeof(std::vector<eoddata1__QUOTE2 *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<eoddata1__QUOTE2 *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<eoddata1__QUOTE2 *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<eoddata1__QUOTE2 *>  location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__QUOTE2, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToeoddata1__QUOTE(struct soap *soap, std::vector<eoddata1__QUOTE *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToeoddata1__QUOTE(struct soap *soap, const std::vector<eoddata1__QUOTE *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<eoddata1__QUOTE *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToeoddata1__QUOTE(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToeoddata1__QUOTE(struct soap *soap, const char *tag, int id, const std::vector<eoddata1__QUOTE *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<eoddata1__QUOTE *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToeoddata1__QUOTE(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<eoddata1__QUOTE *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToeoddata1__QUOTE(struct soap *soap, const char *tag, std::vector<eoddata1__QUOTE *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerToeoddata1__QUOTE(soap)))
			return NULL;
		eoddata1__QUOTE *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_eoddata_eoddata1__QUOTE, SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__QUOTE, sizeof(eoddata1__QUOTE), 1, eoddata_finsert, eoddata_fbase))
				break;
			if (!soap_in_PointerToeoddata1__QUOTE(soap, tag, NULL, "eoddata1:QUOTE"))
				break;
		}
		else
		{	if (!soap_in_PointerToeoddata1__QUOTE(soap, tag, &n, "eoddata1:QUOTE"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<eoddata1__QUOTE *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerToeoddata1__QUOTE(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToeoddata1__QUOTE(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<eoddata1__QUOTE *> *p;
	size_t k = sizeof(std::vector<eoddata1__QUOTE *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<eoddata1__QUOTE *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<eoddata1__QUOTE *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<eoddata1__QUOTE *>  location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__QUOTE, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToeoddata1__SYMBOL2(struct soap *soap, std::vector<eoddata1__SYMBOL2 *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToeoddata1__SYMBOL2(struct soap *soap, const std::vector<eoddata1__SYMBOL2 *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<eoddata1__SYMBOL2 *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToeoddata1__SYMBOL2(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToeoddata1__SYMBOL2(struct soap *soap, const char *tag, int id, const std::vector<eoddata1__SYMBOL2 *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<eoddata1__SYMBOL2 *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToeoddata1__SYMBOL2(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<eoddata1__SYMBOL2 *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToeoddata1__SYMBOL2(struct soap *soap, const char *tag, std::vector<eoddata1__SYMBOL2 *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerToeoddata1__SYMBOL2(soap)))
			return NULL;
		eoddata1__SYMBOL2 *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_eoddata_eoddata1__SYMBOL2, SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__SYMBOL2, sizeof(eoddata1__SYMBOL2), 1, eoddata_finsert, eoddata_fbase))
				break;
			if (!soap_in_PointerToeoddata1__SYMBOL2(soap, tag, NULL, "eoddata1:SYMBOL2"))
				break;
		}
		else
		{	if (!soap_in_PointerToeoddata1__SYMBOL2(soap, tag, &n, "eoddata1:SYMBOL2"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<eoddata1__SYMBOL2 *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerToeoddata1__SYMBOL2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToeoddata1__SYMBOL2(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<eoddata1__SYMBOL2 *> *p;
	size_t k = sizeof(std::vector<eoddata1__SYMBOL2 *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<eoddata1__SYMBOL2 *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<eoddata1__SYMBOL2 *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<eoddata1__SYMBOL2 *>  location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__SYMBOL2, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToeoddata1__SYMBOL(struct soap *soap, std::vector<eoddata1__SYMBOL *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToeoddata1__SYMBOL(struct soap *soap, const std::vector<eoddata1__SYMBOL *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<eoddata1__SYMBOL *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToeoddata1__SYMBOL(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToeoddata1__SYMBOL(struct soap *soap, const char *tag, int id, const std::vector<eoddata1__SYMBOL *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<eoddata1__SYMBOL *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToeoddata1__SYMBOL(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<eoddata1__SYMBOL *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToeoddata1__SYMBOL(struct soap *soap, const char *tag, std::vector<eoddata1__SYMBOL *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerToeoddata1__SYMBOL(soap)))
			return NULL;
		eoddata1__SYMBOL *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_eoddata_eoddata1__SYMBOL, SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__SYMBOL, sizeof(eoddata1__SYMBOL), 1, eoddata_finsert, eoddata_fbase))
				break;
			if (!soap_in_PointerToeoddata1__SYMBOL(soap, tag, NULL, "eoddata1:SYMBOL"))
				break;
		}
		else
		{	if (!soap_in_PointerToeoddata1__SYMBOL(soap, tag, &n, "eoddata1:SYMBOL"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<eoddata1__SYMBOL *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerToeoddata1__SYMBOL(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToeoddata1__SYMBOL(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<eoddata1__SYMBOL *> *p;
	size_t k = sizeof(std::vector<eoddata1__SYMBOL *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<eoddata1__SYMBOL *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<eoddata1__SYMBOL *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<eoddata1__SYMBOL *>  location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__SYMBOL, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToeoddata1__EXCHANGE(struct soap *soap, std::vector<eoddata1__EXCHANGE *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToeoddata1__EXCHANGE(struct soap *soap, const std::vector<eoddata1__EXCHANGE *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<eoddata1__EXCHANGE *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToeoddata1__EXCHANGE(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToeoddata1__EXCHANGE(struct soap *soap, const char *tag, int id, const std::vector<eoddata1__EXCHANGE *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<eoddata1__EXCHANGE *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToeoddata1__EXCHANGE(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<eoddata1__EXCHANGE *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToeoddata1__EXCHANGE(struct soap *soap, const char *tag, std::vector<eoddata1__EXCHANGE *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerToeoddata1__EXCHANGE(soap)))
			return NULL;
		eoddata1__EXCHANGE *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_eoddata_eoddata1__EXCHANGE, SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__EXCHANGE, sizeof(eoddata1__EXCHANGE), 1, eoddata_finsert, eoddata_fbase))
				break;
			if (!soap_in_PointerToeoddata1__EXCHANGE(soap, tag, NULL, "eoddata1:EXCHANGE"))
				break;
		}
		else
		{	if (!soap_in_PointerToeoddata1__EXCHANGE(soap, tag, &n, "eoddata1:EXCHANGE"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<eoddata1__EXCHANGE *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerToeoddata1__EXCHANGE(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToeoddata1__EXCHANGE(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<eoddata1__EXCHANGE *> *p;
	size_t k = sizeof(std::vector<eoddata1__EXCHANGE *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<eoddata1__EXCHANGE *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<eoddata1__EXCHANGE *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<eoddata1__EXCHANGE *>  location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_eoddata_std__vectorTemplateOfPointerToeoddata1__EXCHANGE, n, eoddata_fdelete);
	if (size)
		*size = k;
	return p;
}

} // namespace eoddata


#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of eoddataC.cpp */
