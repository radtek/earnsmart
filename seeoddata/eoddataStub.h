/* eoddataStub.h
   Generated by gSOAP 2.8.28 from eoddata.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include <deque>
#include <list>
#include <vector>
#include <set>
#define SOAP_NAMESPACE_OF_eoddata1	"http://ws.eoddata.com/Data"

#ifndef eoddataStub_H
#define eoddataStub_H
#ifndef WITH_NOGLOBAL
#define WITH_NOGLOBAL
#endif
#include "stdsoap2.h"
#if GSOAP_VERSION != 20828
# error "GSOAP VERSION 20828 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


namespace eoddata {

/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes, Structs, and Unions                                               *
 *                                                                            *
\******************************************************************************/

class eoddata1__LOGINRESPONSE;	/* eoddata.h:154 */
class eoddata1__RESPONSE;	/* eoddata.h:157 */
class eoddata1__EXCHANGE;	/* eoddata.h:160 */
class eoddata1__ArrayOfEXCHANGE;	/* eoddata.h:163 */
class eoddata1__SYMBOL;	/* eoddata.h:166 */
class eoddata1__ArrayOfSYMBOL;	/* eoddata.h:169 */
class eoddata1__ArrayOfSYMBOL2;	/* eoddata.h:172 */
class eoddata1__SYMBOL2;	/* eoddata.h:175 */
class eoddata1__QUOTE;	/* eoddata.h:178 */
class eoddata1__ArrayOfQUOTE;	/* eoddata.h:181 */
class eoddata1__ArrayOfQUOTE2;	/* eoddata.h:184 */
class eoddata1__QUOTE2;	/* eoddata.h:187 */
class eoddata1__ArrayOfSPLIT;	/* eoddata.h:190 */
class eoddata1__SPLIT;	/* eoddata.h:193 */
class eoddata1__ArrayOfCountryBase;	/* eoddata.h:196 */
class eoddata1__CountryBase;	/* eoddata.h:199 */
class eoddata1__ArrayOfFUNDAMENTAL;	/* eoddata.h:202 */
class eoddata1__FUNDAMENTAL;	/* eoddata.h:205 */
class eoddata1__ArrayOfTECHNICAL;	/* eoddata.h:208 */
class eoddata1__TECHNICAL;	/* eoddata.h:211 */
class eoddata1__ArrayOfSYMBOLCHANGE;	/* eoddata.h:214 */
class eoddata1__SYMBOLCHANGE;	/* eoddata.h:217 */
class eoddata1__ArrayOfNEWS;	/* eoddata.h:220 */
class eoddata1__NEWS;	/* eoddata.h:223 */
class eoddata1__ArrayOfDATAFORMAT;	/* eoddata.h:226 */
class eoddata1__DATAFORMAT;	/* eoddata.h:229 */
class eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN;	/* eoddata.h:232 */
class eoddata1__DATAFORMAT_USCORECOLUMN;	/* eoddata.h:235 */
class _eoddata1__Login;	/* eoddata.h:238 */
class _eoddata1__LoginResponse;	/* eoddata.h:241 */
class _eoddata1__Login2;	/* eoddata.h:244 */
class _eoddata1__Login2Response;	/* eoddata.h:247 */
class _eoddata1__Membership;	/* eoddata.h:250 */
class _eoddata1__MembershipResponse;	/* eoddata.h:253 */
class _eoddata1__ExchangeList;	/* eoddata.h:256 */
class _eoddata1__ExchangeListResponse;	/* eoddata.h:259 */
class _eoddata1__ExchangeGet;	/* eoddata.h:262 */
class _eoddata1__ExchangeGetResponse;	/* eoddata.h:265 */
class _eoddata1__SymbolList;	/* eoddata.h:268 */
class _eoddata1__SymbolListResponse;	/* eoddata.h:271 */
class _eoddata1__SymbolList2;	/* eoddata.h:274 */
class _eoddata1__SymbolList2Response;	/* eoddata.h:277 */
class _eoddata1__QuoteGet;	/* eoddata.h:280 */
class _eoddata1__QuoteGetResponse;	/* eoddata.h:283 */
class _eoddata1__QuoteList2;	/* eoddata.h:286 */
class _eoddata1__QuoteList2Response;	/* eoddata.h:289 */
class _eoddata1__SymbolGet;	/* eoddata.h:292 */
class _eoddata1__SymbolGetResponse;	/* eoddata.h:295 */
class _eoddata1__QuoteList;	/* eoddata.h:298 */
class _eoddata1__QuoteListResponse;	/* eoddata.h:301 */
class _eoddata1__NewsList;	/* eoddata.h:304 */
class _eoddata1__NewsListResponse;	/* eoddata.h:307 */
class _eoddata1__NewsListBySymbol;	/* eoddata.h:310 */
class _eoddata1__NewsListBySymbolResponse;	/* eoddata.h:313 */
class _eoddata1__FundamentalList;	/* eoddata.h:316 */
class _eoddata1__FundamentalListResponse;	/* eoddata.h:319 */
class _eoddata1__TechnicalList;	/* eoddata.h:322 */
class _eoddata1__TechnicalListResponse;	/* eoddata.h:325 */
class _eoddata1__QuoteListByDate;	/* eoddata.h:328 */
class _eoddata1__QuoteListByDateResponse;	/* eoddata.h:331 */
class _eoddata1__QuoteListByDate2;	/* eoddata.h:334 */
class _eoddata1__QuoteListByDate2Response;	/* eoddata.h:337 */
class _eoddata1__SymbolHistory;	/* eoddata.h:340 */
class _eoddata1__SymbolHistoryResponse;	/* eoddata.h:343 */
class _eoddata1__Top10Gains;	/* eoddata.h:346 */
class _eoddata1__Top10GainsResponse;	/* eoddata.h:349 */
class _eoddata1__Top10Losses;	/* eoddata.h:352 */
class _eoddata1__Top10LossesResponse;	/* eoddata.h:355 */
class _eoddata1__SymbolChart;	/* eoddata.h:358 */
class _eoddata1__SymbolChartResponse;	/* eoddata.h:361 */
class _eoddata1__ExchangeMonths;	/* eoddata.h:364 */
class _eoddata1__ExchangeMonthsResponse;	/* eoddata.h:367 */
class _eoddata1__SplitListByExchange;	/* eoddata.h:370 */
class _eoddata1__SplitListByExchangeResponse;	/* eoddata.h:373 */
class _eoddata1__SplitListBySymbol;	/* eoddata.h:376 */
class _eoddata1__SplitListBySymbolResponse;	/* eoddata.h:379 */
class _eoddata1__CountryList;	/* eoddata.h:382 */
class _eoddata1__CountryListResponse;	/* eoddata.h:385 */
class _eoddata1__SymbolHistoryPeriod;	/* eoddata.h:388 */
class _eoddata1__SymbolHistoryPeriodResponse;	/* eoddata.h:391 */
class _eoddata1__SymbolHistoryPeriodByDateRange;	/* eoddata.h:394 */
class _eoddata1__SymbolHistoryPeriodByDateRangeResponse;	/* eoddata.h:397 */
class _eoddata1__QuoteListByDatePeriod;	/* eoddata.h:400 */
class _eoddata1__QuoteListByDatePeriodResponse;	/* eoddata.h:403 */
class _eoddata1__QuoteListByDatePeriod2;	/* eoddata.h:406 */
class _eoddata1__QuoteListByDatePeriod2Response;	/* eoddata.h:409 */
class _eoddata1__SymbolChangesByExchange;	/* eoddata.h:412 */
class _eoddata1__SymbolChangesByExchangeResponse;	/* eoddata.h:415 */
class _eoddata1__DataClientLatestVersion;	/* eoddata.h:418 */
class _eoddata1__DataClientLatestVersionResponse;	/* eoddata.h:421 */
class _eoddata1__DataFormats;	/* eoddata.h:424 */
class _eoddata1__DataFormatsResponse;	/* eoddata.h:427 */
class _eoddata1__UpdateDataFormat;	/* eoddata.h:430 */
class _eoddata1__UpdateDataFormatResponse;	/* eoddata.h:433 */
class _eoddata1__ValidateAccess;	/* eoddata.h:436 */
class _eoddata1__ValidateAccessResponse;	/* eoddata.h:439 */
struct __eoddata1__Login;	/* eoddata.h:3187 */
struct __eoddata1__Login2;	/* eoddata.h:3255 */
struct __eoddata1__Membership;	/* eoddata.h:3322 */
struct __eoddata1__ExchangeList;	/* eoddata.h:3390 */
struct __eoddata1__ExchangeGet;	/* eoddata.h:3458 */
struct __eoddata1__SymbolList;	/* eoddata.h:3526 */
struct __eoddata1__SymbolList2;	/* eoddata.h:3594 */
struct __eoddata1__QuoteGet;	/* eoddata.h:3662 */
struct __eoddata1__QuoteList2;	/* eoddata.h:3731 */
struct __eoddata1__SymbolGet;	/* eoddata.h:3799 */
struct __eoddata1__QuoteList;	/* eoddata.h:3867 */
struct __eoddata1__NewsList;	/* eoddata.h:3935 */
struct __eoddata1__NewsListBySymbol;	/* eoddata.h:4004 */
struct __eoddata1__FundamentalList;	/* eoddata.h:4072 */
struct __eoddata1__TechnicalList;	/* eoddata.h:4140 */
struct __eoddata1__QuoteListByDate;	/* eoddata.h:4209 */
struct __eoddata1__QuoteListByDate2;	/* eoddata.h:4278 */
struct __eoddata1__SymbolHistory;	/* eoddata.h:4348 */
struct __eoddata1__Top10Gains;	/* eoddata.h:4416 */
struct __eoddata1__Top10Losses;	/* eoddata.h:4484 */
struct __eoddata1__SymbolChart;	/* eoddata.h:4552 */
struct __eoddata1__ExchangeMonths;	/* eoddata.h:4620 */
struct __eoddata1__SplitListByExchange;	/* eoddata.h:4688 */
struct __eoddata1__SplitListBySymbol;	/* eoddata.h:4756 */
struct __eoddata1__CountryList;	/* eoddata.h:4824 */
struct __eoddata1__SymbolHistoryPeriod;	/* eoddata.h:4894 */
struct __eoddata1__SymbolHistoryPeriodByDateRange;	/* eoddata.h:4964 */
struct __eoddata1__QuoteListByDatePeriod;	/* eoddata.h:5033 */
struct __eoddata1__QuoteListByDatePeriod2;	/* eoddata.h:5103 */
struct __eoddata1__SymbolChangesByExchange;	/* eoddata.h:5171 */
struct __eoddata1__DataClientLatestVersion;	/* eoddata.h:5239 */
struct __eoddata1__DataFormats;	/* eoddata.h:5307 */
struct __eoddata1__UpdateDataFormat;	/* eoddata.h:5375 */
struct __eoddata1__ValidateAccess;	/* eoddata.h:5444 */
struct __eoddata1__Login_;	/* eoddata.h:5512 */
struct __eoddata1__Login2_;	/* eoddata.h:5580 */
struct __eoddata1__Membership_;	/* eoddata.h:5647 */
struct __eoddata1__ExchangeList_;	/* eoddata.h:5715 */
struct __eoddata1__ExchangeGet_;	/* eoddata.h:5783 */
struct __eoddata1__SymbolList_;	/* eoddata.h:5851 */
struct __eoddata1__SymbolList2_;	/* eoddata.h:5919 */
struct __eoddata1__QuoteGet_;	/* eoddata.h:5987 */
struct __eoddata1__QuoteList2_;	/* eoddata.h:6056 */
struct __eoddata1__SymbolGet_;	/* eoddata.h:6124 */
struct __eoddata1__QuoteList_;	/* eoddata.h:6192 */
struct __eoddata1__NewsList_;	/* eoddata.h:6260 */
struct __eoddata1__NewsListBySymbol_;	/* eoddata.h:6329 */
struct __eoddata1__FundamentalList_;	/* eoddata.h:6397 */
struct __eoddata1__TechnicalList_;	/* eoddata.h:6465 */
struct __eoddata1__QuoteListByDate_;	/* eoddata.h:6534 */
struct __eoddata1__QuoteListByDate2_;	/* eoddata.h:6603 */
struct __eoddata1__SymbolHistory_;	/* eoddata.h:6673 */
struct __eoddata1__Top10Gains_;	/* eoddata.h:6741 */
struct __eoddata1__Top10Losses_;	/* eoddata.h:6809 */
struct __eoddata1__SymbolChart_;	/* eoddata.h:6877 */
struct __eoddata1__ExchangeMonths_;	/* eoddata.h:6945 */
struct __eoddata1__SplitListByExchange_;	/* eoddata.h:7013 */
struct __eoddata1__SplitListBySymbol_;	/* eoddata.h:7081 */
struct __eoddata1__CountryList_;	/* eoddata.h:7149 */
struct __eoddata1__SymbolHistoryPeriod_;	/* eoddata.h:7219 */
struct __eoddata1__SymbolHistoryPeriodByDateRange_;	/* eoddata.h:7289 */
struct __eoddata1__QuoteListByDatePeriod_;	/* eoddata.h:7358 */
struct __eoddata1__QuoteListByDatePeriod2_;	/* eoddata.h:7428 */
struct __eoddata1__SymbolChangesByExchange_;	/* eoddata.h:7496 */
struct __eoddata1__DataClientLatestVersion_;	/* eoddata.h:7564 */
struct __eoddata1__DataFormats_;	/* eoddata.h:7632 */
struct __eoddata1__UpdateDataFormat_;	/* eoddata.h:7700 */
struct __eoddata1__ValidateAccess_;	/* eoddata.h:7769 */

/* eoddata.h:154 */
#ifndef SOAP_TYPE_eoddata_eoddata1__LOGINRESPONSE
#define SOAP_TYPE_eoddata_eoddata1__LOGINRESPONSE (11)
/* eoddata1:LOGINRESPONSE complex type: */
class SOAP_CMAC eoddata1__LOGINRESPONSE
{
public:
	std::string *Message;	/* optional attribute of XSD type xsd:string */
	std::string *Token;	/* optional attribute of XSD type xsd:string */
	std::string *DataFormat;	/* optional attribute of XSD type xsd:string */
	bool Header;	/* required attribute of XSD type xsd:boolean */
	bool Suffix;	/* required attribute of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata_eoddata1__LOGINRESPONSE (11)
	virtual int soap_type(void) const { return 11; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eoddata1__LOGINRESPONSE, default initialized and not managed by a soap context
	virtual eoddata1__LOGINRESPONSE *soap_alloc(void) const { return SOAP_NEW(eoddata1__LOGINRESPONSE); }
	         eoddata1__LOGINRESPONSE() { eoddata1__LOGINRESPONSE::soap_default(NULL); }
	virtual ~eoddata1__LOGINRESPONSE() { }
	friend SOAP_FMAC1 eoddata1__LOGINRESPONSE * SOAP_FMAC2 soap_instantiate_eoddata1__LOGINRESPONSE(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:157 */
#ifndef SOAP_TYPE_eoddata_eoddata1__RESPONSE
#define SOAP_TYPE_eoddata_eoddata1__RESPONSE (12)
/* eoddata1:RESPONSE complex type: */
class SOAP_CMAC eoddata1__RESPONSE
{
public:
	eoddata1__EXCHANGE *EXCHANGE;	/* optional element of XSD type eoddata1:EXCHANGE */
	eoddata1__ArrayOfEXCHANGE *EXCHANGES;	/* optional element of XSD type eoddata1:ArrayOfEXCHANGE */
	eoddata1__SYMBOL *SYMBOL;	/* optional element of XSD type eoddata1:SYMBOL */
	eoddata1__ArrayOfSYMBOL *SYMBOLS;	/* optional element of XSD type eoddata1:ArrayOfSYMBOL */
	eoddata1__ArrayOfSYMBOL2 *SYMBOLS2;	/* optional element of XSD type eoddata1:ArrayOfSYMBOL2 */
	eoddata1__QUOTE *QUOTE;	/* optional element of XSD type eoddata1:QUOTE */
	eoddata1__ArrayOfQUOTE *QUOTES;	/* optional element of XSD type eoddata1:ArrayOfQUOTE */
	eoddata1__ArrayOfQUOTE2 *QUOTES2;	/* optional element of XSD type eoddata1:ArrayOfQUOTE2 */
	eoddata1__ArrayOfSPLIT *SPLITS;	/* optional element of XSD type eoddata1:ArrayOfSPLIT */
	eoddata1__ArrayOfCountryBase *COUNTRIES;	/* optional element of XSD type eoddata1:ArrayOfCountryBase */
	eoddata1__ArrayOfFUNDAMENTAL *FUNDAMENTALS;	/* optional element of XSD type eoddata1:ArrayOfFUNDAMENTAL */
	eoddata1__ArrayOfTECHNICAL *TECHNICALS;	/* optional element of XSD type eoddata1:ArrayOfTECHNICAL */
	eoddata1__ArrayOfSYMBOLCHANGE *SYMBOLCHANGES;	/* optional element of XSD type eoddata1:ArrayOfSYMBOLCHANGE */
	eoddata1__ArrayOfNEWS *NEWSLIST;	/* optional element of XSD type eoddata1:ArrayOfNEWS */
	std::string *CHART;	/* optional element of XSD type xsd:string */
	std::string *MEMBERSHIP;	/* optional element of XSD type xsd:string */
	std::string *VERSION;	/* optional element of XSD type xsd:string */
	std::string *MONTHS;	/* optional element of XSD type xsd:string */
	eoddata1__ArrayOfDATAFORMAT *DATAFORMATS;	/* optional element of XSD type eoddata1:ArrayOfDATAFORMAT */
	std::string *Source;	/* optional attribute of XSD type xsd:string */
	std::string *Message;	/* optional attribute of XSD type xsd:string */
	time_t Date;	/* required attribute of XSD type xsd:dateTime */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata_eoddata1__RESPONSE (12)
	virtual int soap_type(void) const { return 12; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eoddata1__RESPONSE, default initialized and not managed by a soap context
	virtual eoddata1__RESPONSE *soap_alloc(void) const { return SOAP_NEW(eoddata1__RESPONSE); }
	         eoddata1__RESPONSE() { eoddata1__RESPONSE::soap_default(NULL); }
	virtual ~eoddata1__RESPONSE() { }
	friend SOAP_FMAC1 eoddata1__RESPONSE * SOAP_FMAC2 soap_instantiate_eoddata1__RESPONSE(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:160 */
#ifndef SOAP_TYPE_eoddata_eoddata1__EXCHANGE
#define SOAP_TYPE_eoddata_eoddata1__EXCHANGE (13)
/* eoddata1:EXCHANGE complex type: */
class SOAP_CMAC eoddata1__EXCHANGE
{
public:
	std::string *Code;	/* optional attribute of XSD type xsd:string */
	std::string *Name;	/* optional attribute of XSD type xsd:string */
	time_t LastTradeDateTime;	/* required attribute of XSD type xsd:dateTime */
	std::string *Country;	/* optional attribute of XSD type xsd:string */
	std::string *Currency;	/* optional attribute of XSD type xsd:string */
	int Advances;	/* required attribute of XSD type xsd:int */
	int Declines;	/* required attribute of XSD type xsd:int */
	std::string *Suffix;	/* optional attribute of XSD type xsd:string */
	std::string *TimeZone;	/* optional attribute of XSD type xsd:string */
	bool IsIntraday;	/* required attribute of XSD type xsd:boolean */
	time_t IntradayStartDate;	/* required attribute of XSD type xsd:dateTime */
	bool HasIntradayProduct;	/* required attribute of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata_eoddata1__EXCHANGE (13)
	virtual int soap_type(void) const { return 13; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eoddata1__EXCHANGE, default initialized and not managed by a soap context
	virtual eoddata1__EXCHANGE *soap_alloc(void) const { return SOAP_NEW(eoddata1__EXCHANGE); }
	         eoddata1__EXCHANGE() { eoddata1__EXCHANGE::soap_default(NULL); }
	virtual ~eoddata1__EXCHANGE() { }
	friend SOAP_FMAC1 eoddata1__EXCHANGE * SOAP_FMAC2 soap_instantiate_eoddata1__EXCHANGE(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:163 */
#ifndef SOAP_TYPE_eoddata_eoddata1__ArrayOfEXCHANGE
#define SOAP_TYPE_eoddata_eoddata1__ArrayOfEXCHANGE (14)
/* eoddata1:ArrayOfEXCHANGE complex type: */
class SOAP_CMAC eoddata1__ArrayOfEXCHANGE
{
public:
	std::vector<eoddata1__EXCHANGE *> EXCHANGE;	/* optional element of XSD type eoddata1:EXCHANGE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata_eoddata1__ArrayOfEXCHANGE (14)
	virtual int soap_type(void) const { return 14; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eoddata1__ArrayOfEXCHANGE, default initialized and not managed by a soap context
	virtual eoddata1__ArrayOfEXCHANGE *soap_alloc(void) const { return SOAP_NEW(eoddata1__ArrayOfEXCHANGE); }
	         eoddata1__ArrayOfEXCHANGE() { eoddata1__ArrayOfEXCHANGE::soap_default(NULL); }
	virtual ~eoddata1__ArrayOfEXCHANGE() { }
	friend SOAP_FMAC1 eoddata1__ArrayOfEXCHANGE * SOAP_FMAC2 soap_instantiate_eoddata1__ArrayOfEXCHANGE(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:166 */
#ifndef SOAP_TYPE_eoddata_eoddata1__SYMBOL
#define SOAP_TYPE_eoddata_eoddata1__SYMBOL (15)
/* eoddata1:SYMBOL complex type: */
class SOAP_CMAC eoddata1__SYMBOL
{
public:
	std::string *Code;	/* optional attribute of XSD type xsd:string */
	std::string *Name;	/* optional attribute of XSD type xsd:string */
	std::string *LongName;	/* optional attribute of XSD type xsd:string */
	time_t DateTime;	/* required attribute of XSD type xsd:dateTime */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata_eoddata1__SYMBOL (15)
	virtual int soap_type(void) const { return 15; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eoddata1__SYMBOL, default initialized and not managed by a soap context
	virtual eoddata1__SYMBOL *soap_alloc(void) const { return SOAP_NEW(eoddata1__SYMBOL); }
	         eoddata1__SYMBOL() { eoddata1__SYMBOL::soap_default(NULL); }
	virtual ~eoddata1__SYMBOL() { }
	friend SOAP_FMAC1 eoddata1__SYMBOL * SOAP_FMAC2 soap_instantiate_eoddata1__SYMBOL(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:169 */
#ifndef SOAP_TYPE_eoddata_eoddata1__ArrayOfSYMBOL
#define SOAP_TYPE_eoddata_eoddata1__ArrayOfSYMBOL (16)
/* eoddata1:ArrayOfSYMBOL complex type: */
class SOAP_CMAC eoddata1__ArrayOfSYMBOL
{
public:
	std::vector<eoddata1__SYMBOL *> SYMBOL;	/* optional element of XSD type eoddata1:SYMBOL */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata_eoddata1__ArrayOfSYMBOL (16)
	virtual int soap_type(void) const { return 16; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eoddata1__ArrayOfSYMBOL, default initialized and not managed by a soap context
	virtual eoddata1__ArrayOfSYMBOL *soap_alloc(void) const { return SOAP_NEW(eoddata1__ArrayOfSYMBOL); }
	         eoddata1__ArrayOfSYMBOL() { eoddata1__ArrayOfSYMBOL::soap_default(NULL); }
	virtual ~eoddata1__ArrayOfSYMBOL() { }
	friend SOAP_FMAC1 eoddata1__ArrayOfSYMBOL * SOAP_FMAC2 soap_instantiate_eoddata1__ArrayOfSYMBOL(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:172 */
#ifndef SOAP_TYPE_eoddata_eoddata1__ArrayOfSYMBOL2
#define SOAP_TYPE_eoddata_eoddata1__ArrayOfSYMBOL2 (17)
/* eoddata1:ArrayOfSYMBOL2 complex type: */
class SOAP_CMAC eoddata1__ArrayOfSYMBOL2
{
public:
	std::vector<eoddata1__SYMBOL2 *> SYMBOL2;	/* optional element of XSD type eoddata1:SYMBOL2 */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata_eoddata1__ArrayOfSYMBOL2 (17)
	virtual int soap_type(void) const { return 17; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eoddata1__ArrayOfSYMBOL2, default initialized and not managed by a soap context
	virtual eoddata1__ArrayOfSYMBOL2 *soap_alloc(void) const { return SOAP_NEW(eoddata1__ArrayOfSYMBOL2); }
	         eoddata1__ArrayOfSYMBOL2() { eoddata1__ArrayOfSYMBOL2::soap_default(NULL); }
	virtual ~eoddata1__ArrayOfSYMBOL2() { }
	friend SOAP_FMAC1 eoddata1__ArrayOfSYMBOL2 * SOAP_FMAC2 soap_instantiate_eoddata1__ArrayOfSYMBOL2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:175 */
#ifndef SOAP_TYPE_eoddata_eoddata1__SYMBOL2
#define SOAP_TYPE_eoddata_eoddata1__SYMBOL2 (18)
/* eoddata1:SYMBOL2 complex type: */
class SOAP_CMAC eoddata1__SYMBOL2
{
public:
	std::string *c;	/* optional attribute of XSD type xsd:string */
	std::string *n;	/* optional attribute of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata_eoddata1__SYMBOL2 (18)
	virtual int soap_type(void) const { return 18; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eoddata1__SYMBOL2, default initialized and not managed by a soap context
	virtual eoddata1__SYMBOL2 *soap_alloc(void) const { return SOAP_NEW(eoddata1__SYMBOL2); }
	         eoddata1__SYMBOL2() { eoddata1__SYMBOL2::soap_default(NULL); }
	virtual ~eoddata1__SYMBOL2() { }
	friend SOAP_FMAC1 eoddata1__SYMBOL2 * SOAP_FMAC2 soap_instantiate_eoddata1__SYMBOL2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:178 */
#ifndef SOAP_TYPE_eoddata_eoddata1__QUOTE
#define SOAP_TYPE_eoddata_eoddata1__QUOTE (19)
/* eoddata1:QUOTE complex type: */
class SOAP_CMAC eoddata1__QUOTE
{
public:
	std::string *Symbol;	/* optional attribute of XSD type xsd:string */
	std::string *Description;	/* optional attribute of XSD type xsd:string */
	std::string *Name;	/* optional attribute of XSD type xsd:string */
	time_t DateTime;	/* required attribute of XSD type xsd:dateTime */
	double Open;	/* required attribute of XSD type xsd:double */
	double High;	/* required attribute of XSD type xsd:double */
	double Low;	/* required attribute of XSD type xsd:double */
	double Close;	/* required attribute of XSD type xsd:double */
	LONG64 Volume;	/* required attribute of XSD type xsd:long */
	LONG64 OpenInterest;	/* required attribute of XSD type xsd:long */
	double Previous;	/* required attribute of XSD type xsd:double */
	double Change;	/* required attribute of XSD type xsd:double */
	double Bid;	/* required attribute of XSD type xsd:double */
	double Ask;	/* required attribute of XSD type xsd:double */
	double PreviousClose;	/* required attribute of XSD type xsd:double */
	double NextOpen;	/* required attribute of XSD type xsd:double */
	time_t Modified;	/* required attribute of XSD type xsd:dateTime */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata_eoddata1__QUOTE (19)
	virtual int soap_type(void) const { return 19; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eoddata1__QUOTE, default initialized and not managed by a soap context
	virtual eoddata1__QUOTE *soap_alloc(void) const { return SOAP_NEW(eoddata1__QUOTE); }
	         eoddata1__QUOTE() { eoddata1__QUOTE::soap_default(NULL); }
	virtual ~eoddata1__QUOTE() { }
	friend SOAP_FMAC1 eoddata1__QUOTE * SOAP_FMAC2 soap_instantiate_eoddata1__QUOTE(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:181 */
#ifndef SOAP_TYPE_eoddata_eoddata1__ArrayOfQUOTE
#define SOAP_TYPE_eoddata_eoddata1__ArrayOfQUOTE (20)
/* eoddata1:ArrayOfQUOTE complex type: */
class SOAP_CMAC eoddata1__ArrayOfQUOTE
{
public:
	std::vector<eoddata1__QUOTE *> QUOTE;	/* optional element of XSD type eoddata1:QUOTE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata_eoddata1__ArrayOfQUOTE (20)
	virtual int soap_type(void) const { return 20; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eoddata1__ArrayOfQUOTE, default initialized and not managed by a soap context
	virtual eoddata1__ArrayOfQUOTE *soap_alloc(void) const { return SOAP_NEW(eoddata1__ArrayOfQUOTE); }
	         eoddata1__ArrayOfQUOTE() { eoddata1__ArrayOfQUOTE::soap_default(NULL); }
	virtual ~eoddata1__ArrayOfQUOTE() { }
	friend SOAP_FMAC1 eoddata1__ArrayOfQUOTE * SOAP_FMAC2 soap_instantiate_eoddata1__ArrayOfQUOTE(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:184 */
#ifndef SOAP_TYPE_eoddata_eoddata1__ArrayOfQUOTE2
#define SOAP_TYPE_eoddata_eoddata1__ArrayOfQUOTE2 (21)
/* eoddata1:ArrayOfQUOTE2 complex type: */
class SOAP_CMAC eoddata1__ArrayOfQUOTE2
{
public:
	std::vector<eoddata1__QUOTE2 *> QUOTE2;	/* optional element of XSD type eoddata1:QUOTE2 */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata_eoddata1__ArrayOfQUOTE2 (21)
	virtual int soap_type(void) const { return 21; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eoddata1__ArrayOfQUOTE2, default initialized and not managed by a soap context
	virtual eoddata1__ArrayOfQUOTE2 *soap_alloc(void) const { return SOAP_NEW(eoddata1__ArrayOfQUOTE2); }
	         eoddata1__ArrayOfQUOTE2() { eoddata1__ArrayOfQUOTE2::soap_default(NULL); }
	virtual ~eoddata1__ArrayOfQUOTE2() { }
	friend SOAP_FMAC1 eoddata1__ArrayOfQUOTE2 * SOAP_FMAC2 soap_instantiate_eoddata1__ArrayOfQUOTE2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:187 */
#ifndef SOAP_TYPE_eoddata_eoddata1__QUOTE2
#define SOAP_TYPE_eoddata_eoddata1__QUOTE2 (22)
/* eoddata1:QUOTE2 complex type: */
class SOAP_CMAC eoddata1__QUOTE2
{
public:
	std::string *s;	/* optional attribute of XSD type xsd:string */
	time_t d;	/* required attribute of XSD type xsd:dateTime */
	double o;	/* required attribute of XSD type xsd:double */
	double h;	/* required attribute of XSD type xsd:double */
	double l;	/* required attribute of XSD type xsd:double */
	double c;	/* required attribute of XSD type xsd:double */
	LONG64 v;	/* required attribute of XSD type xsd:long */
	LONG64 i;	/* required attribute of XSD type xsd:long */
	double b;	/* required attribute of XSD type xsd:double */
	double a;	/* required attribute of XSD type xsd:double */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata_eoddata1__QUOTE2 (22)
	virtual int soap_type(void) const { return 22; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eoddata1__QUOTE2, default initialized and not managed by a soap context
	virtual eoddata1__QUOTE2 *soap_alloc(void) const { return SOAP_NEW(eoddata1__QUOTE2); }
	         eoddata1__QUOTE2() { eoddata1__QUOTE2::soap_default(NULL); }
	virtual ~eoddata1__QUOTE2() { }
	friend SOAP_FMAC1 eoddata1__QUOTE2 * SOAP_FMAC2 soap_instantiate_eoddata1__QUOTE2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:190 */
#ifndef SOAP_TYPE_eoddata_eoddata1__ArrayOfSPLIT
#define SOAP_TYPE_eoddata_eoddata1__ArrayOfSPLIT (23)
/* eoddata1:ArrayOfSPLIT complex type: */
class SOAP_CMAC eoddata1__ArrayOfSPLIT
{
public:
	std::vector<eoddata1__SPLIT *> SPLIT;	/* optional element of XSD type eoddata1:SPLIT */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata_eoddata1__ArrayOfSPLIT (23)
	virtual int soap_type(void) const { return 23; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eoddata1__ArrayOfSPLIT, default initialized and not managed by a soap context
	virtual eoddata1__ArrayOfSPLIT *soap_alloc(void) const { return SOAP_NEW(eoddata1__ArrayOfSPLIT); }
	         eoddata1__ArrayOfSPLIT() { eoddata1__ArrayOfSPLIT::soap_default(NULL); }
	virtual ~eoddata1__ArrayOfSPLIT() { }
	friend SOAP_FMAC1 eoddata1__ArrayOfSPLIT * SOAP_FMAC2 soap_instantiate_eoddata1__ArrayOfSPLIT(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:193 */
#ifndef SOAP_TYPE_eoddata_eoddata1__SPLIT
#define SOAP_TYPE_eoddata_eoddata1__SPLIT (24)
/* eoddata1:SPLIT complex type: */
class SOAP_CMAC eoddata1__SPLIT
{
public:
	std::string *Exchange;	/* optional attribute of XSD type xsd:string */
	std::string *Symbol;	/* optional attribute of XSD type xsd:string */
	time_t DateTime;	/* required attribute of XSD type xsd:dateTime */
	std::string *Ratio;	/* optional attribute of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata_eoddata1__SPLIT (24)
	virtual int soap_type(void) const { return 24; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eoddata1__SPLIT, default initialized and not managed by a soap context
	virtual eoddata1__SPLIT *soap_alloc(void) const { return SOAP_NEW(eoddata1__SPLIT); }
	         eoddata1__SPLIT() { eoddata1__SPLIT::soap_default(NULL); }
	virtual ~eoddata1__SPLIT() { }
	friend SOAP_FMAC1 eoddata1__SPLIT * SOAP_FMAC2 soap_instantiate_eoddata1__SPLIT(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:196 */
#ifndef SOAP_TYPE_eoddata_eoddata1__ArrayOfCountryBase
#define SOAP_TYPE_eoddata_eoddata1__ArrayOfCountryBase (25)
/* eoddata1:ArrayOfCountryBase complex type: */
class SOAP_CMAC eoddata1__ArrayOfCountryBase
{
public:
	std::vector<eoddata1__CountryBase *> CountryBase;	/* optional element of XSD type eoddata1:CountryBase */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata_eoddata1__ArrayOfCountryBase (25)
	virtual int soap_type(void) const { return 25; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eoddata1__ArrayOfCountryBase, default initialized and not managed by a soap context
	virtual eoddata1__ArrayOfCountryBase *soap_alloc(void) const { return SOAP_NEW(eoddata1__ArrayOfCountryBase); }
	         eoddata1__ArrayOfCountryBase() { eoddata1__ArrayOfCountryBase::soap_default(NULL); }
	virtual ~eoddata1__ArrayOfCountryBase() { }
	friend SOAP_FMAC1 eoddata1__ArrayOfCountryBase * SOAP_FMAC2 soap_instantiate_eoddata1__ArrayOfCountryBase(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:199 */
#ifndef SOAP_TYPE_eoddata_eoddata1__CountryBase
#define SOAP_TYPE_eoddata_eoddata1__CountryBase (26)
/* eoddata1:CountryBase complex type: */
class SOAP_CMAC eoddata1__CountryBase
{
public:
	std::string *Code;	/* optional attribute of XSD type xsd:string */
	std::string *Name;	/* optional attribute of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata_eoddata1__CountryBase (26)
	virtual int soap_type(void) const { return 26; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eoddata1__CountryBase, default initialized and not managed by a soap context
	virtual eoddata1__CountryBase *soap_alloc(void) const { return SOAP_NEW(eoddata1__CountryBase); }
	         eoddata1__CountryBase() { eoddata1__CountryBase::soap_default(NULL); }
	virtual ~eoddata1__CountryBase() { }
	friend SOAP_FMAC1 eoddata1__CountryBase * SOAP_FMAC2 soap_instantiate_eoddata1__CountryBase(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:202 */
#ifndef SOAP_TYPE_eoddata_eoddata1__ArrayOfFUNDAMENTAL
#define SOAP_TYPE_eoddata_eoddata1__ArrayOfFUNDAMENTAL (27)
/* eoddata1:ArrayOfFUNDAMENTAL complex type: */
class SOAP_CMAC eoddata1__ArrayOfFUNDAMENTAL
{
public:
	std::vector<eoddata1__FUNDAMENTAL *> FUNDAMENTAL;	/* optional element of XSD type eoddata1:FUNDAMENTAL */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata_eoddata1__ArrayOfFUNDAMENTAL (27)
	virtual int soap_type(void) const { return 27; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eoddata1__ArrayOfFUNDAMENTAL, default initialized and not managed by a soap context
	virtual eoddata1__ArrayOfFUNDAMENTAL *soap_alloc(void) const { return SOAP_NEW(eoddata1__ArrayOfFUNDAMENTAL); }
	         eoddata1__ArrayOfFUNDAMENTAL() { eoddata1__ArrayOfFUNDAMENTAL::soap_default(NULL); }
	virtual ~eoddata1__ArrayOfFUNDAMENTAL() { }
	friend SOAP_FMAC1 eoddata1__ArrayOfFUNDAMENTAL * SOAP_FMAC2 soap_instantiate_eoddata1__ArrayOfFUNDAMENTAL(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:205 */
#ifndef SOAP_TYPE_eoddata_eoddata1__FUNDAMENTAL
#define SOAP_TYPE_eoddata_eoddata1__FUNDAMENTAL (28)
/* eoddata1:FUNDAMENTAL complex type: */
class SOAP_CMAC eoddata1__FUNDAMENTAL
{
public:
	std::string *Symbol;	/* optional attribute of XSD type xsd:string */
	std::string *Name;	/* optional attribute of XSD type xsd:string */
	std::string *Description;	/* optional attribute of XSD type xsd:string */
	time_t DateTime;	/* required attribute of XSD type xsd:dateTime */
	std::string *Industry;	/* optional attribute of XSD type xsd:string */
	std::string *Sector;	/* optional attribute of XSD type xsd:string */
	LONG64 Shares;	/* required attribute of XSD type xsd:long */
	LONG64 MarketCap;	/* required attribute of XSD type xsd:long */
	double PE;	/* required attribute of XSD type xsd:double */
	double EPS;	/* required attribute of XSD type xsd:double */
	double NTA;	/* required attribute of XSD type xsd:double */
	double DivYield;	/* required attribute of XSD type xsd:double */
	double Dividend;	/* required attribute of XSD type xsd:double */
	time_t DividendDate;	/* required attribute of XSD type xsd:dateTime */
	double DPS;	/* required attribute of XSD type xsd:double */
	double ImputationCredits;	/* required attribute of XSD type xsd:double */
	double EBITDA;	/* required attribute of XSD type xsd:double */
	double PEG;	/* required attribute of XSD type xsd:double */
	double PtS;	/* required attribute of XSD type xsd:double */
	double PtB;	/* required attribute of XSD type xsd:double */
	double Yield;	/* required attribute of XSD type xsd:double */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata_eoddata1__FUNDAMENTAL (28)
	virtual int soap_type(void) const { return 28; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eoddata1__FUNDAMENTAL, default initialized and not managed by a soap context
	virtual eoddata1__FUNDAMENTAL *soap_alloc(void) const { return SOAP_NEW(eoddata1__FUNDAMENTAL); }
	         eoddata1__FUNDAMENTAL() { eoddata1__FUNDAMENTAL::soap_default(NULL); }
	virtual ~eoddata1__FUNDAMENTAL() { }
	friend SOAP_FMAC1 eoddata1__FUNDAMENTAL * SOAP_FMAC2 soap_instantiate_eoddata1__FUNDAMENTAL(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:208 */
#ifndef SOAP_TYPE_eoddata_eoddata1__ArrayOfTECHNICAL
#define SOAP_TYPE_eoddata_eoddata1__ArrayOfTECHNICAL (29)
/* eoddata1:ArrayOfTECHNICAL complex type: */
class SOAP_CMAC eoddata1__ArrayOfTECHNICAL
{
public:
	std::vector<eoddata1__TECHNICAL *> TECHNICAL;	/* optional element of XSD type eoddata1:TECHNICAL */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata_eoddata1__ArrayOfTECHNICAL (29)
	virtual int soap_type(void) const { return 29; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eoddata1__ArrayOfTECHNICAL, default initialized and not managed by a soap context
	virtual eoddata1__ArrayOfTECHNICAL *soap_alloc(void) const { return SOAP_NEW(eoddata1__ArrayOfTECHNICAL); }
	         eoddata1__ArrayOfTECHNICAL() { eoddata1__ArrayOfTECHNICAL::soap_default(NULL); }
	virtual ~eoddata1__ArrayOfTECHNICAL() { }
	friend SOAP_FMAC1 eoddata1__ArrayOfTECHNICAL * SOAP_FMAC2 soap_instantiate_eoddata1__ArrayOfTECHNICAL(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:211 */
#ifndef SOAP_TYPE_eoddata_eoddata1__TECHNICAL
#define SOAP_TYPE_eoddata_eoddata1__TECHNICAL (30)
/* eoddata1:TECHNICAL complex type: */
class SOAP_CMAC eoddata1__TECHNICAL
{
public:
	std::string *Symbol;	/* optional attribute of XSD type xsd:string */
	std::string *Name;	/* optional attribute of XSD type xsd:string */
	std::string *Description;	/* optional attribute of XSD type xsd:string */
	time_t DateTime;	/* required attribute of XSD type xsd:dateTime */
	double Previous;	/* required attribute of XSD type xsd:double */
	double Change;	/* required attribute of XSD type xsd:double */
	int MA1;	/* required attribute of XSD type xsd:int */
	int MA2;	/* required attribute of XSD type xsd:int */
	int MA5;	/* required attribute of XSD type xsd:int */
	int MA20;	/* required attribute of XSD type xsd:int */
	int MA50;	/* required attribute of XSD type xsd:int */
	int MA100;	/* required attribute of XSD type xsd:int */
	int MA200;	/* required attribute of XSD type xsd:int */
	double MAPercent;	/* required attribute of XSD type xsd:double */
	double MAReturn;	/* required attribute of XSD type xsd:double */
	LONG64 VolumeChange;	/* required attribute of XSD type xsd:long */
	double ThreeMonthChange;	/* required attribute of XSD type xsd:double */
	double SixMonthChange;	/* required attribute of XSD type xsd:double */
	double WeekHigh;	/* required attribute of XSD type xsd:double */
	double WeekLow;	/* required attribute of XSD type xsd:double */
	double WeekChange;	/* required attribute of XSD type xsd:double */
	double AvgWeekChange;	/* required attribute of XSD type xsd:double */
	double AvgWeekVolume;	/* required attribute of XSD type xsd:double */
	double WeekVolume;	/* required attribute of XSD type xsd:double */
	double MonthHigh;	/* required attribute of XSD type xsd:double */
	double MonthLow;	/* required attribute of XSD type xsd:double */
	double MonthChange;	/* required attribute of XSD type xsd:double */
	double AvgMonthChange;	/* required attribute of XSD type xsd:double */
	double AvgMonthVolume;	/* required attribute of XSD type xsd:double */
	double MonthVolume;	/* required attribute of XSD type xsd:double */
	double YearHigh;	/* required attribute of XSD type xsd:double */
	double YearLow;	/* required attribute of XSD type xsd:double */
	double YearChange;	/* required attribute of XSD type xsd:double */
	double AvgYearChange;	/* required attribute of XSD type xsd:double */
	double AvgYearVolume;	/* required attribute of XSD type xsd:double */
	double YTDChange;	/* required attribute of XSD type xsd:double */
	double RSI14;	/* required attribute of XSD type xsd:double */
	double STO9;	/* required attribute of XSD type xsd:double */
	double WPR14;	/* required attribute of XSD type xsd:double */
	double MTM14;	/* required attribute of XSD type xsd:double */
	double ROC14;	/* required attribute of XSD type xsd:double */
	LONG64 PTC;	/* required attribute of XSD type xsd:long */
	double SAR;	/* required attribute of XSD type xsd:double */
	double Volatility;	/* required attribute of XSD type xsd:double */
	double Liquidity;	/* required attribute of XSD type xsd:double */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata_eoddata1__TECHNICAL (30)
	virtual int soap_type(void) const { return 30; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eoddata1__TECHNICAL, default initialized and not managed by a soap context
	virtual eoddata1__TECHNICAL *soap_alloc(void) const { return SOAP_NEW(eoddata1__TECHNICAL); }
	         eoddata1__TECHNICAL() { eoddata1__TECHNICAL::soap_default(NULL); }
	virtual ~eoddata1__TECHNICAL() { }
	friend SOAP_FMAC1 eoddata1__TECHNICAL * SOAP_FMAC2 soap_instantiate_eoddata1__TECHNICAL(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:214 */
#ifndef SOAP_TYPE_eoddata_eoddata1__ArrayOfSYMBOLCHANGE
#define SOAP_TYPE_eoddata_eoddata1__ArrayOfSYMBOLCHANGE (31)
/* eoddata1:ArrayOfSYMBOLCHANGE complex type: */
class SOAP_CMAC eoddata1__ArrayOfSYMBOLCHANGE
{
public:
	std::vector<eoddata1__SYMBOLCHANGE *> SYMBOLCHANGE;	/* optional element of XSD type eoddata1:SYMBOLCHANGE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata_eoddata1__ArrayOfSYMBOLCHANGE (31)
	virtual int soap_type(void) const { return 31; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eoddata1__ArrayOfSYMBOLCHANGE, default initialized and not managed by a soap context
	virtual eoddata1__ArrayOfSYMBOLCHANGE *soap_alloc(void) const { return SOAP_NEW(eoddata1__ArrayOfSYMBOLCHANGE); }
	         eoddata1__ArrayOfSYMBOLCHANGE() { eoddata1__ArrayOfSYMBOLCHANGE::soap_default(NULL); }
	virtual ~eoddata1__ArrayOfSYMBOLCHANGE() { }
	friend SOAP_FMAC1 eoddata1__ArrayOfSYMBOLCHANGE * SOAP_FMAC2 soap_instantiate_eoddata1__ArrayOfSYMBOLCHANGE(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:217 */
#ifndef SOAP_TYPE_eoddata_eoddata1__SYMBOLCHANGE
#define SOAP_TYPE_eoddata_eoddata1__SYMBOLCHANGE (32)
/* eoddata1:SYMBOLCHANGE complex type: */
class SOAP_CMAC eoddata1__SYMBOLCHANGE
{
public:
	time_t DateTime;	/* required attribute of XSD type xsd:dateTime */
	std::string *OldSymbol;	/* optional attribute of XSD type xsd:string */
	std::string *NewSymbol;	/* optional attribute of XSD type xsd:string */
	std::string *ExchangeCode;	/* optional attribute of XSD type xsd:string */
	std::string *NewExchangeCode;	/* optional attribute of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata_eoddata1__SYMBOLCHANGE (32)
	virtual int soap_type(void) const { return 32; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eoddata1__SYMBOLCHANGE, default initialized and not managed by a soap context
	virtual eoddata1__SYMBOLCHANGE *soap_alloc(void) const { return SOAP_NEW(eoddata1__SYMBOLCHANGE); }
	         eoddata1__SYMBOLCHANGE() { eoddata1__SYMBOLCHANGE::soap_default(NULL); }
	virtual ~eoddata1__SYMBOLCHANGE() { }
	friend SOAP_FMAC1 eoddata1__SYMBOLCHANGE * SOAP_FMAC2 soap_instantiate_eoddata1__SYMBOLCHANGE(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:220 */
#ifndef SOAP_TYPE_eoddata_eoddata1__ArrayOfNEWS
#define SOAP_TYPE_eoddata_eoddata1__ArrayOfNEWS (33)
/* eoddata1:ArrayOfNEWS complex type: */
class SOAP_CMAC eoddata1__ArrayOfNEWS
{
public:
	std::vector<eoddata1__NEWS *> NEWS;	/* optional element of XSD type eoddata1:NEWS */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata_eoddata1__ArrayOfNEWS (33)
	virtual int soap_type(void) const { return 33; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eoddata1__ArrayOfNEWS, default initialized and not managed by a soap context
	virtual eoddata1__ArrayOfNEWS *soap_alloc(void) const { return SOAP_NEW(eoddata1__ArrayOfNEWS); }
	         eoddata1__ArrayOfNEWS() { eoddata1__ArrayOfNEWS::soap_default(NULL); }
	virtual ~eoddata1__ArrayOfNEWS() { }
	friend SOAP_FMAC1 eoddata1__ArrayOfNEWS * SOAP_FMAC2 soap_instantiate_eoddata1__ArrayOfNEWS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:223 */
#ifndef SOAP_TYPE_eoddata_eoddata1__NEWS
#define SOAP_TYPE_eoddata_eoddata1__NEWS (34)
/* eoddata1:NEWS complex type: */
class SOAP_CMAC eoddata1__NEWS
{
public:
	std::string *Exchange;	/* optional attribute of XSD type xsd:string */
	std::string *Symbol;	/* optional attribute of XSD type xsd:string */
	LONG64 Id;	/* required attribute of XSD type xsd:long */
	std::string *SourceKey;	/* optional attribute of XSD type xsd:string */
	time_t DateTime;	/* required attribute of XSD type xsd:dateTime */
	std::string *Headline;	/* optional attribute of XSD type xsd:string */
	std::string *Introduction;	/* optional attribute of XSD type xsd:string */
	std::string *Story;	/* optional attribute of XSD type xsd:string */
	std::string *Caption;	/* optional attribute of XSD type xsd:string */
	int Views;	/* required attribute of XSD type xsd:int */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata_eoddata1__NEWS (34)
	virtual int soap_type(void) const { return 34; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eoddata1__NEWS, default initialized and not managed by a soap context
	virtual eoddata1__NEWS *soap_alloc(void) const { return SOAP_NEW(eoddata1__NEWS); }
	         eoddata1__NEWS() { eoddata1__NEWS::soap_default(NULL); }
	virtual ~eoddata1__NEWS() { }
	friend SOAP_FMAC1 eoddata1__NEWS * SOAP_FMAC2 soap_instantiate_eoddata1__NEWS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:226 */
#ifndef SOAP_TYPE_eoddata_eoddata1__ArrayOfDATAFORMAT
#define SOAP_TYPE_eoddata_eoddata1__ArrayOfDATAFORMAT (35)
/* eoddata1:ArrayOfDATAFORMAT complex type: */
class SOAP_CMAC eoddata1__ArrayOfDATAFORMAT
{
public:
	std::vector<eoddata1__DATAFORMAT *> DATAFORMAT;	/* optional element of XSD type eoddata1:DATAFORMAT */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata_eoddata1__ArrayOfDATAFORMAT (35)
	virtual int soap_type(void) const { return 35; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eoddata1__ArrayOfDATAFORMAT, default initialized and not managed by a soap context
	virtual eoddata1__ArrayOfDATAFORMAT *soap_alloc(void) const { return SOAP_NEW(eoddata1__ArrayOfDATAFORMAT); }
	         eoddata1__ArrayOfDATAFORMAT() { eoddata1__ArrayOfDATAFORMAT::soap_default(NULL); }
	virtual ~eoddata1__ArrayOfDATAFORMAT() { }
	friend SOAP_FMAC1 eoddata1__ArrayOfDATAFORMAT * SOAP_FMAC2 soap_instantiate_eoddata1__ArrayOfDATAFORMAT(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:229 */
#ifndef SOAP_TYPE_eoddata_eoddata1__DATAFORMAT
#define SOAP_TYPE_eoddata_eoddata1__DATAFORMAT (36)
/* eoddata1:DATAFORMAT complex type: */
class SOAP_CMAC eoddata1__DATAFORMAT
{
public:
	eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN *COLUMNS;	/* optional element of XSD type eoddata1:ArrayOfDATAFORMAT_COLUMN */
	std::string *Code;	/* optional attribute of XSD type xsd:string */
	std::string *Name;	/* optional attribute of XSD type xsd:string */
	std::string *Header;	/* optional attribute of XSD type xsd:string */
	std::string *DateFormat;	/* optional attribute of XSD type xsd:string */
	std::string *Extension;	/* optional attribute of XSD type xsd:string */
	bool IncludeSuffix;	/* required attribute of XSD type xsd:boolean */
	bool TabColumnSeperator;	/* required attribute of XSD type xsd:boolean */
	std::string *ColumnSeperator;	/* optional attribute of XSD type xsd:string */
	std::string *TextQualifier;	/* optional attribute of XSD type xsd:string */
	std::string *FilenamePrefix;	/* optional attribute of XSD type xsd:string */
	bool FilenameExchangeCode;	/* required attribute of XSD type xsd:boolean */
	bool FilenameDate;	/* required attribute of XSD type xsd:boolean */
	bool IncludeHeaderRow;	/* required attribute of XSD type xsd:boolean */
	std::string *HourFormat;	/* optional attribute of XSD type xsd:string */
	std::string *DateTimeSeperator;	/* optional attribute of XSD type xsd:string */
	std::string *ExchangeFilenameFormatDate;	/* optional attribute of XSD type xsd:string */
	std::string *ExchangeFilenameFormatDateRange;	/* optional attribute of XSD type xsd:string */
	std::string *SymbolFilenameFormatDate;	/* optional attribute of XSD type xsd:string */
	std::string *SymbolFilenameFormatDateRange;	/* optional attribute of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata_eoddata1__DATAFORMAT (36)
	virtual int soap_type(void) const { return 36; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eoddata1__DATAFORMAT, default initialized and not managed by a soap context
	virtual eoddata1__DATAFORMAT *soap_alloc(void) const { return SOAP_NEW(eoddata1__DATAFORMAT); }
	         eoddata1__DATAFORMAT() { eoddata1__DATAFORMAT::soap_default(NULL); }
	virtual ~eoddata1__DATAFORMAT() { }
	friend SOAP_FMAC1 eoddata1__DATAFORMAT * SOAP_FMAC2 soap_instantiate_eoddata1__DATAFORMAT(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:232 */
#ifndef SOAP_TYPE_eoddata_eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN
#define SOAP_TYPE_eoddata_eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN (37)
/* eoddata1:ArrayOfDATAFORMAT_COLUMN complex type: */
class SOAP_CMAC eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN
{
public:
	std::vector<eoddata1__DATAFORMAT_USCORECOLUMN *> DATAFORMAT_USCORECOLUMN;	/* optional element of XSD type eoddata1:DATAFORMAT_COLUMN */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata_eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN (37)
	virtual int soap_type(void) const { return 37; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN, default initialized and not managed by a soap context
	virtual eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN *soap_alloc(void) const { return SOAP_NEW(eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN); }
	         eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN() { eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN::soap_default(NULL); }
	virtual ~eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN() { }
	friend SOAP_FMAC1 eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN * SOAP_FMAC2 soap_instantiate_eoddata1__ArrayOfDATAFORMAT_USCORECOLUMN(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:235 */
#ifndef SOAP_TYPE_eoddata_eoddata1__DATAFORMAT_USCORECOLUMN
#define SOAP_TYPE_eoddata_eoddata1__DATAFORMAT_USCORECOLUMN (38)
/* eoddata1:DATAFORMAT_COLUMN complex type: */
class SOAP_CMAC eoddata1__DATAFORMAT_USCORECOLUMN
{
public:
	int SortOrder;	/* required attribute of XSD type xsd:int */
	std::string *Code;	/* optional attribute of XSD type xsd:string */
	std::string *DataFormat;	/* optional attribute of XSD type xsd:string */
	std::string *ColumnCode;	/* optional attribute of XSD type xsd:string */
	std::string *ColumnName;	/* optional attribute of XSD type xsd:string */
	int ColumnTypeId;	/* required attribute of XSD type xsd:int */
	std::string *ColumnType;	/* optional attribute of XSD type xsd:string */
	std::string *Header;	/* optional attribute of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata_eoddata1__DATAFORMAT_USCORECOLUMN (38)
	virtual int soap_type(void) const { return 38; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eoddata1__DATAFORMAT_USCORECOLUMN, default initialized and not managed by a soap context
	virtual eoddata1__DATAFORMAT_USCORECOLUMN *soap_alloc(void) const { return SOAP_NEW(eoddata1__DATAFORMAT_USCORECOLUMN); }
	         eoddata1__DATAFORMAT_USCORECOLUMN() { eoddata1__DATAFORMAT_USCORECOLUMN::soap_default(NULL); }
	virtual ~eoddata1__DATAFORMAT_USCORECOLUMN() { }
	friend SOAP_FMAC1 eoddata1__DATAFORMAT_USCORECOLUMN * SOAP_FMAC2 soap_instantiate_eoddata1__DATAFORMAT_USCORECOLUMN(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:238 */
#ifndef SOAP_TYPE_eoddata__eoddata1__Login
#define SOAP_TYPE_eoddata__eoddata1__Login (39)
/* eoddata1:Login complex type: */
class SOAP_CMAC _eoddata1__Login
{
public:
	std::string *Username;	/* optional element of XSD type xsd:string */
	std::string *Password;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__Login (39)
	virtual int soap_type(void) const { return 39; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__Login, default initialized and not managed by a soap context
	virtual _eoddata1__Login *soap_alloc(void) const { return SOAP_NEW(_eoddata1__Login); }
	         _eoddata1__Login() { _eoddata1__Login::soap_default(NULL); }
	virtual ~_eoddata1__Login() { }
	friend SOAP_FMAC1 _eoddata1__Login * SOAP_FMAC2 soap_instantiate__eoddata1__Login(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:241 */
#ifndef SOAP_TYPE_eoddata__eoddata1__LoginResponse
#define SOAP_TYPE_eoddata__eoddata1__LoginResponse (40)
/* eoddata1:LoginResponse complex type: */
class SOAP_CMAC _eoddata1__LoginResponse
{
public:
	eoddata1__LOGINRESPONSE *LoginResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type eoddata1:LOGINRESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__LoginResponse (40)
	virtual int soap_type(void) const { return 40; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__LoginResponse, default initialized and not managed by a soap context
	virtual _eoddata1__LoginResponse *soap_alloc(void) const { return SOAP_NEW(_eoddata1__LoginResponse); }
	         _eoddata1__LoginResponse() { _eoddata1__LoginResponse::soap_default(NULL); }
	virtual ~_eoddata1__LoginResponse() { }
	friend SOAP_FMAC1 _eoddata1__LoginResponse * SOAP_FMAC2 soap_instantiate__eoddata1__LoginResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:244 */
#ifndef SOAP_TYPE_eoddata__eoddata1__Login2
#define SOAP_TYPE_eoddata__eoddata1__Login2 (41)
/* eoddata1:Login2 complex type: */
class SOAP_CMAC _eoddata1__Login2
{
public:
	std::string *Username;	/* optional element of XSD type xsd:string */
	std::string *Password;	/* optional element of XSD type xsd:string */
	std::string *Version;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__Login2 (41)
	virtual int soap_type(void) const { return 41; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__Login2, default initialized and not managed by a soap context
	virtual _eoddata1__Login2 *soap_alloc(void) const { return SOAP_NEW(_eoddata1__Login2); }
	         _eoddata1__Login2() { _eoddata1__Login2::soap_default(NULL); }
	virtual ~_eoddata1__Login2() { }
	friend SOAP_FMAC1 _eoddata1__Login2 * SOAP_FMAC2 soap_instantiate__eoddata1__Login2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:247 */
#ifndef SOAP_TYPE_eoddata__eoddata1__Login2Response
#define SOAP_TYPE_eoddata__eoddata1__Login2Response (42)
/* eoddata1:Login2Response complex type: */
class SOAP_CMAC _eoddata1__Login2Response
{
public:
	eoddata1__LOGINRESPONSE *Login2Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type eoddata1:LOGINRESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__Login2Response (42)
	virtual int soap_type(void) const { return 42; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__Login2Response, default initialized and not managed by a soap context
	virtual _eoddata1__Login2Response *soap_alloc(void) const { return SOAP_NEW(_eoddata1__Login2Response); }
	         _eoddata1__Login2Response() { _eoddata1__Login2Response::soap_default(NULL); }
	virtual ~_eoddata1__Login2Response() { }
	friend SOAP_FMAC1 _eoddata1__Login2Response * SOAP_FMAC2 soap_instantiate__eoddata1__Login2Response(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:250 */
#ifndef SOAP_TYPE_eoddata__eoddata1__Membership
#define SOAP_TYPE_eoddata__eoddata1__Membership (43)
/* eoddata1:Membership complex type: */
class SOAP_CMAC _eoddata1__Membership
{
public:
	std::string *Token;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__Membership (43)
	virtual int soap_type(void) const { return 43; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__Membership, default initialized and not managed by a soap context
	virtual _eoddata1__Membership *soap_alloc(void) const { return SOAP_NEW(_eoddata1__Membership); }
	         _eoddata1__Membership() { _eoddata1__Membership::soap_default(NULL); }
	virtual ~_eoddata1__Membership() { }
	friend SOAP_FMAC1 _eoddata1__Membership * SOAP_FMAC2 soap_instantiate__eoddata1__Membership(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:253 */
#ifndef SOAP_TYPE_eoddata__eoddata1__MembershipResponse
#define SOAP_TYPE_eoddata__eoddata1__MembershipResponse (44)
/* eoddata1:MembershipResponse complex type: */
class SOAP_CMAC _eoddata1__MembershipResponse
{
public:
	eoddata1__RESPONSE *MembershipResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type eoddata1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__MembershipResponse (44)
	virtual int soap_type(void) const { return 44; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__MembershipResponse, default initialized and not managed by a soap context
	virtual _eoddata1__MembershipResponse *soap_alloc(void) const { return SOAP_NEW(_eoddata1__MembershipResponse); }
	         _eoddata1__MembershipResponse() { _eoddata1__MembershipResponse::soap_default(NULL); }
	virtual ~_eoddata1__MembershipResponse() { }
	friend SOAP_FMAC1 _eoddata1__MembershipResponse * SOAP_FMAC2 soap_instantiate__eoddata1__MembershipResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:256 */
#ifndef SOAP_TYPE_eoddata__eoddata1__ExchangeList
#define SOAP_TYPE_eoddata__eoddata1__ExchangeList (45)
/* eoddata1:ExchangeList complex type: */
class SOAP_CMAC _eoddata1__ExchangeList
{
public:
	std::string *Token;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__ExchangeList (45)
	virtual int soap_type(void) const { return 45; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__ExchangeList, default initialized and not managed by a soap context
	virtual _eoddata1__ExchangeList *soap_alloc(void) const { return SOAP_NEW(_eoddata1__ExchangeList); }
	         _eoddata1__ExchangeList() { _eoddata1__ExchangeList::soap_default(NULL); }
	virtual ~_eoddata1__ExchangeList() { }
	friend SOAP_FMAC1 _eoddata1__ExchangeList * SOAP_FMAC2 soap_instantiate__eoddata1__ExchangeList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:259 */
#ifndef SOAP_TYPE_eoddata__eoddata1__ExchangeListResponse
#define SOAP_TYPE_eoddata__eoddata1__ExchangeListResponse (46)
/* eoddata1:ExchangeListResponse complex type: */
class SOAP_CMAC _eoddata1__ExchangeListResponse
{
public:
	eoddata1__RESPONSE *ExchangeListResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type eoddata1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__ExchangeListResponse (46)
	virtual int soap_type(void) const { return 46; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__ExchangeListResponse, default initialized and not managed by a soap context
	virtual _eoddata1__ExchangeListResponse *soap_alloc(void) const { return SOAP_NEW(_eoddata1__ExchangeListResponse); }
	         _eoddata1__ExchangeListResponse() { _eoddata1__ExchangeListResponse::soap_default(NULL); }
	virtual ~_eoddata1__ExchangeListResponse() { }
	friend SOAP_FMAC1 _eoddata1__ExchangeListResponse * SOAP_FMAC2 soap_instantiate__eoddata1__ExchangeListResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:262 */
#ifndef SOAP_TYPE_eoddata__eoddata1__ExchangeGet
#define SOAP_TYPE_eoddata__eoddata1__ExchangeGet (47)
/* eoddata1:ExchangeGet complex type: */
class SOAP_CMAC _eoddata1__ExchangeGet
{
public:
	std::string *Token;	/* optional element of XSD type xsd:string */
	std::string *Exchange;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__ExchangeGet (47)
	virtual int soap_type(void) const { return 47; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__ExchangeGet, default initialized and not managed by a soap context
	virtual _eoddata1__ExchangeGet *soap_alloc(void) const { return SOAP_NEW(_eoddata1__ExchangeGet); }
	         _eoddata1__ExchangeGet() { _eoddata1__ExchangeGet::soap_default(NULL); }
	virtual ~_eoddata1__ExchangeGet() { }
	friend SOAP_FMAC1 _eoddata1__ExchangeGet * SOAP_FMAC2 soap_instantiate__eoddata1__ExchangeGet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:265 */
#ifndef SOAP_TYPE_eoddata__eoddata1__ExchangeGetResponse
#define SOAP_TYPE_eoddata__eoddata1__ExchangeGetResponse (48)
/* eoddata1:ExchangeGetResponse complex type: */
class SOAP_CMAC _eoddata1__ExchangeGetResponse
{
public:
	eoddata1__RESPONSE *ExchangeGetResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type eoddata1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__ExchangeGetResponse (48)
	virtual int soap_type(void) const { return 48; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__ExchangeGetResponse, default initialized and not managed by a soap context
	virtual _eoddata1__ExchangeGetResponse *soap_alloc(void) const { return SOAP_NEW(_eoddata1__ExchangeGetResponse); }
	         _eoddata1__ExchangeGetResponse() { _eoddata1__ExchangeGetResponse::soap_default(NULL); }
	virtual ~_eoddata1__ExchangeGetResponse() { }
	friend SOAP_FMAC1 _eoddata1__ExchangeGetResponse * SOAP_FMAC2 soap_instantiate__eoddata1__ExchangeGetResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:268 */
#ifndef SOAP_TYPE_eoddata__eoddata1__SymbolList
#define SOAP_TYPE_eoddata__eoddata1__SymbolList (49)
/* eoddata1:SymbolList complex type: */
class SOAP_CMAC _eoddata1__SymbolList
{
public:
	std::string *Token;	/* optional element of XSD type xsd:string */
	std::string *Exchange;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__SymbolList (49)
	virtual int soap_type(void) const { return 49; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__SymbolList, default initialized and not managed by a soap context
	virtual _eoddata1__SymbolList *soap_alloc(void) const { return SOAP_NEW(_eoddata1__SymbolList); }
	         _eoddata1__SymbolList() { _eoddata1__SymbolList::soap_default(NULL); }
	virtual ~_eoddata1__SymbolList() { }
	friend SOAP_FMAC1 _eoddata1__SymbolList * SOAP_FMAC2 soap_instantiate__eoddata1__SymbolList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:271 */
#ifndef SOAP_TYPE_eoddata__eoddata1__SymbolListResponse
#define SOAP_TYPE_eoddata__eoddata1__SymbolListResponse (50)
/* eoddata1:SymbolListResponse complex type: */
class SOAP_CMAC _eoddata1__SymbolListResponse
{
public:
	eoddata1__RESPONSE *SymbolListResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type eoddata1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__SymbolListResponse (50)
	virtual int soap_type(void) const { return 50; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__SymbolListResponse, default initialized and not managed by a soap context
	virtual _eoddata1__SymbolListResponse *soap_alloc(void) const { return SOAP_NEW(_eoddata1__SymbolListResponse); }
	         _eoddata1__SymbolListResponse() { _eoddata1__SymbolListResponse::soap_default(NULL); }
	virtual ~_eoddata1__SymbolListResponse() { }
	friend SOAP_FMAC1 _eoddata1__SymbolListResponse * SOAP_FMAC2 soap_instantiate__eoddata1__SymbolListResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:274 */
#ifndef SOAP_TYPE_eoddata__eoddata1__SymbolList2
#define SOAP_TYPE_eoddata__eoddata1__SymbolList2 (51)
/* eoddata1:SymbolList2 complex type: */
class SOAP_CMAC _eoddata1__SymbolList2
{
public:
	std::string *Token;	/* optional element of XSD type xsd:string */
	std::string *Exchange;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__SymbolList2 (51)
	virtual int soap_type(void) const { return 51; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__SymbolList2, default initialized and not managed by a soap context
	virtual _eoddata1__SymbolList2 *soap_alloc(void) const { return SOAP_NEW(_eoddata1__SymbolList2); }
	         _eoddata1__SymbolList2() { _eoddata1__SymbolList2::soap_default(NULL); }
	virtual ~_eoddata1__SymbolList2() { }
	friend SOAP_FMAC1 _eoddata1__SymbolList2 * SOAP_FMAC2 soap_instantiate__eoddata1__SymbolList2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:277 */
#ifndef SOAP_TYPE_eoddata__eoddata1__SymbolList2Response
#define SOAP_TYPE_eoddata__eoddata1__SymbolList2Response (52)
/* eoddata1:SymbolList2Response complex type: */
class SOAP_CMAC _eoddata1__SymbolList2Response
{
public:
	eoddata1__RESPONSE *SymbolList2Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type eoddata1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__SymbolList2Response (52)
	virtual int soap_type(void) const { return 52; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__SymbolList2Response, default initialized and not managed by a soap context
	virtual _eoddata1__SymbolList2Response *soap_alloc(void) const { return SOAP_NEW(_eoddata1__SymbolList2Response); }
	         _eoddata1__SymbolList2Response() { _eoddata1__SymbolList2Response::soap_default(NULL); }
	virtual ~_eoddata1__SymbolList2Response() { }
	friend SOAP_FMAC1 _eoddata1__SymbolList2Response * SOAP_FMAC2 soap_instantiate__eoddata1__SymbolList2Response(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:280 */
#ifndef SOAP_TYPE_eoddata__eoddata1__QuoteGet
#define SOAP_TYPE_eoddata__eoddata1__QuoteGet (53)
/* eoddata1:QuoteGet complex type: */
class SOAP_CMAC _eoddata1__QuoteGet
{
public:
	std::string *Token;	/* optional element of XSD type xsd:string */
	std::string *Exchange;	/* optional element of XSD type xsd:string */
	std::string *Symbol;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__QuoteGet (53)
	virtual int soap_type(void) const { return 53; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__QuoteGet, default initialized and not managed by a soap context
	virtual _eoddata1__QuoteGet *soap_alloc(void) const { return SOAP_NEW(_eoddata1__QuoteGet); }
	         _eoddata1__QuoteGet() { _eoddata1__QuoteGet::soap_default(NULL); }
	virtual ~_eoddata1__QuoteGet() { }
	friend SOAP_FMAC1 _eoddata1__QuoteGet * SOAP_FMAC2 soap_instantiate__eoddata1__QuoteGet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:283 */
#ifndef SOAP_TYPE_eoddata__eoddata1__QuoteGetResponse
#define SOAP_TYPE_eoddata__eoddata1__QuoteGetResponse (54)
/* eoddata1:QuoteGetResponse complex type: */
class SOAP_CMAC _eoddata1__QuoteGetResponse
{
public:
	eoddata1__RESPONSE *QuoteGetResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type eoddata1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__QuoteGetResponse (54)
	virtual int soap_type(void) const { return 54; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__QuoteGetResponse, default initialized and not managed by a soap context
	virtual _eoddata1__QuoteGetResponse *soap_alloc(void) const { return SOAP_NEW(_eoddata1__QuoteGetResponse); }
	         _eoddata1__QuoteGetResponse() { _eoddata1__QuoteGetResponse::soap_default(NULL); }
	virtual ~_eoddata1__QuoteGetResponse() { }
	friend SOAP_FMAC1 _eoddata1__QuoteGetResponse * SOAP_FMAC2 soap_instantiate__eoddata1__QuoteGetResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:286 */
#ifndef SOAP_TYPE_eoddata__eoddata1__QuoteList2
#define SOAP_TYPE_eoddata__eoddata1__QuoteList2 (55)
/* eoddata1:QuoteList2 complex type: */
class SOAP_CMAC _eoddata1__QuoteList2
{
public:
	std::string *Token;	/* optional element of XSD type xsd:string */
	std::string *Exchange;	/* optional element of XSD type xsd:string */
	std::string *Symbols;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__QuoteList2 (55)
	virtual int soap_type(void) const { return 55; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__QuoteList2, default initialized and not managed by a soap context
	virtual _eoddata1__QuoteList2 *soap_alloc(void) const { return SOAP_NEW(_eoddata1__QuoteList2); }
	         _eoddata1__QuoteList2() { _eoddata1__QuoteList2::soap_default(NULL); }
	virtual ~_eoddata1__QuoteList2() { }
	friend SOAP_FMAC1 _eoddata1__QuoteList2 * SOAP_FMAC2 soap_instantiate__eoddata1__QuoteList2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:289 */
#ifndef SOAP_TYPE_eoddata__eoddata1__QuoteList2Response
#define SOAP_TYPE_eoddata__eoddata1__QuoteList2Response (56)
/* eoddata1:QuoteList2Response complex type: */
class SOAP_CMAC _eoddata1__QuoteList2Response
{
public:
	eoddata1__RESPONSE *QuoteList2Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type eoddata1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__QuoteList2Response (56)
	virtual int soap_type(void) const { return 56; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__QuoteList2Response, default initialized and not managed by a soap context
	virtual _eoddata1__QuoteList2Response *soap_alloc(void) const { return SOAP_NEW(_eoddata1__QuoteList2Response); }
	         _eoddata1__QuoteList2Response() { _eoddata1__QuoteList2Response::soap_default(NULL); }
	virtual ~_eoddata1__QuoteList2Response() { }
	friend SOAP_FMAC1 _eoddata1__QuoteList2Response * SOAP_FMAC2 soap_instantiate__eoddata1__QuoteList2Response(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:292 */
#ifndef SOAP_TYPE_eoddata__eoddata1__SymbolGet
#define SOAP_TYPE_eoddata__eoddata1__SymbolGet (57)
/* eoddata1:SymbolGet complex type: */
class SOAP_CMAC _eoddata1__SymbolGet
{
public:
	std::string *Token;	/* optional element of XSD type xsd:string */
	std::string *Exchange;	/* optional element of XSD type xsd:string */
	std::string *Symbol;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__SymbolGet (57)
	virtual int soap_type(void) const { return 57; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__SymbolGet, default initialized and not managed by a soap context
	virtual _eoddata1__SymbolGet *soap_alloc(void) const { return SOAP_NEW(_eoddata1__SymbolGet); }
	         _eoddata1__SymbolGet() { _eoddata1__SymbolGet::soap_default(NULL); }
	virtual ~_eoddata1__SymbolGet() { }
	friend SOAP_FMAC1 _eoddata1__SymbolGet * SOAP_FMAC2 soap_instantiate__eoddata1__SymbolGet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:295 */
#ifndef SOAP_TYPE_eoddata__eoddata1__SymbolGetResponse
#define SOAP_TYPE_eoddata__eoddata1__SymbolGetResponse (58)
/* eoddata1:SymbolGetResponse complex type: */
class SOAP_CMAC _eoddata1__SymbolGetResponse
{
public:
	eoddata1__RESPONSE *SymbolGetResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type eoddata1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__SymbolGetResponse (58)
	virtual int soap_type(void) const { return 58; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__SymbolGetResponse, default initialized and not managed by a soap context
	virtual _eoddata1__SymbolGetResponse *soap_alloc(void) const { return SOAP_NEW(_eoddata1__SymbolGetResponse); }
	         _eoddata1__SymbolGetResponse() { _eoddata1__SymbolGetResponse::soap_default(NULL); }
	virtual ~_eoddata1__SymbolGetResponse() { }
	friend SOAP_FMAC1 _eoddata1__SymbolGetResponse * SOAP_FMAC2 soap_instantiate__eoddata1__SymbolGetResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:298 */
#ifndef SOAP_TYPE_eoddata__eoddata1__QuoteList
#define SOAP_TYPE_eoddata__eoddata1__QuoteList (59)
/* eoddata1:QuoteList complex type: */
class SOAP_CMAC _eoddata1__QuoteList
{
public:
	std::string *Token;	/* optional element of XSD type xsd:string */
	std::string *Exchange;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__QuoteList (59)
	virtual int soap_type(void) const { return 59; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__QuoteList, default initialized and not managed by a soap context
	virtual _eoddata1__QuoteList *soap_alloc(void) const { return SOAP_NEW(_eoddata1__QuoteList); }
	         _eoddata1__QuoteList() { _eoddata1__QuoteList::soap_default(NULL); }
	virtual ~_eoddata1__QuoteList() { }
	friend SOAP_FMAC1 _eoddata1__QuoteList * SOAP_FMAC2 soap_instantiate__eoddata1__QuoteList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:301 */
#ifndef SOAP_TYPE_eoddata__eoddata1__QuoteListResponse
#define SOAP_TYPE_eoddata__eoddata1__QuoteListResponse (60)
/* eoddata1:QuoteListResponse complex type: */
class SOAP_CMAC _eoddata1__QuoteListResponse
{
public:
	eoddata1__RESPONSE *QuoteListResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type eoddata1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__QuoteListResponse (60)
	virtual int soap_type(void) const { return 60; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__QuoteListResponse, default initialized and not managed by a soap context
	virtual _eoddata1__QuoteListResponse *soap_alloc(void) const { return SOAP_NEW(_eoddata1__QuoteListResponse); }
	         _eoddata1__QuoteListResponse() { _eoddata1__QuoteListResponse::soap_default(NULL); }
	virtual ~_eoddata1__QuoteListResponse() { }
	friend SOAP_FMAC1 _eoddata1__QuoteListResponse * SOAP_FMAC2 soap_instantiate__eoddata1__QuoteListResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:304 */
#ifndef SOAP_TYPE_eoddata__eoddata1__NewsList
#define SOAP_TYPE_eoddata__eoddata1__NewsList (61)
/* eoddata1:NewsList complex type: */
class SOAP_CMAC _eoddata1__NewsList
{
public:
	std::string *Token;	/* optional element of XSD type xsd:string */
	std::string *Exchange;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__NewsList (61)
	virtual int soap_type(void) const { return 61; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__NewsList, default initialized and not managed by a soap context
	virtual _eoddata1__NewsList *soap_alloc(void) const { return SOAP_NEW(_eoddata1__NewsList); }
	         _eoddata1__NewsList() { _eoddata1__NewsList::soap_default(NULL); }
	virtual ~_eoddata1__NewsList() { }
	friend SOAP_FMAC1 _eoddata1__NewsList * SOAP_FMAC2 soap_instantiate__eoddata1__NewsList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:307 */
#ifndef SOAP_TYPE_eoddata__eoddata1__NewsListResponse
#define SOAP_TYPE_eoddata__eoddata1__NewsListResponse (62)
/* eoddata1:NewsListResponse complex type: */
class SOAP_CMAC _eoddata1__NewsListResponse
{
public:
	eoddata1__RESPONSE *NewsListResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type eoddata1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__NewsListResponse (62)
	virtual int soap_type(void) const { return 62; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__NewsListResponse, default initialized and not managed by a soap context
	virtual _eoddata1__NewsListResponse *soap_alloc(void) const { return SOAP_NEW(_eoddata1__NewsListResponse); }
	         _eoddata1__NewsListResponse() { _eoddata1__NewsListResponse::soap_default(NULL); }
	virtual ~_eoddata1__NewsListResponse() { }
	friend SOAP_FMAC1 _eoddata1__NewsListResponse * SOAP_FMAC2 soap_instantiate__eoddata1__NewsListResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:310 */
#ifndef SOAP_TYPE_eoddata__eoddata1__NewsListBySymbol
#define SOAP_TYPE_eoddata__eoddata1__NewsListBySymbol (63)
/* eoddata1:NewsListBySymbol complex type: */
class SOAP_CMAC _eoddata1__NewsListBySymbol
{
public:
	std::string *token;	/* optional element of XSD type xsd:string */
	std::string *Exchange;	/* optional element of XSD type xsd:string */
	std::string *symbol;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__NewsListBySymbol (63)
	virtual int soap_type(void) const { return 63; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__NewsListBySymbol, default initialized and not managed by a soap context
	virtual _eoddata1__NewsListBySymbol *soap_alloc(void) const { return SOAP_NEW(_eoddata1__NewsListBySymbol); }
	         _eoddata1__NewsListBySymbol() { _eoddata1__NewsListBySymbol::soap_default(NULL); }
	virtual ~_eoddata1__NewsListBySymbol() { }
	friend SOAP_FMAC1 _eoddata1__NewsListBySymbol * SOAP_FMAC2 soap_instantiate__eoddata1__NewsListBySymbol(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:313 */
#ifndef SOAP_TYPE_eoddata__eoddata1__NewsListBySymbolResponse
#define SOAP_TYPE_eoddata__eoddata1__NewsListBySymbolResponse (64)
/* eoddata1:NewsListBySymbolResponse complex type: */
class SOAP_CMAC _eoddata1__NewsListBySymbolResponse
{
public:
	eoddata1__RESPONSE *NewsListBySymbolResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type eoddata1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__NewsListBySymbolResponse (64)
	virtual int soap_type(void) const { return 64; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__NewsListBySymbolResponse, default initialized and not managed by a soap context
	virtual _eoddata1__NewsListBySymbolResponse *soap_alloc(void) const { return SOAP_NEW(_eoddata1__NewsListBySymbolResponse); }
	         _eoddata1__NewsListBySymbolResponse() { _eoddata1__NewsListBySymbolResponse::soap_default(NULL); }
	virtual ~_eoddata1__NewsListBySymbolResponse() { }
	friend SOAP_FMAC1 _eoddata1__NewsListBySymbolResponse * SOAP_FMAC2 soap_instantiate__eoddata1__NewsListBySymbolResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:316 */
#ifndef SOAP_TYPE_eoddata__eoddata1__FundamentalList
#define SOAP_TYPE_eoddata__eoddata1__FundamentalList (65)
/* eoddata1:FundamentalList complex type: */
class SOAP_CMAC _eoddata1__FundamentalList
{
public:
	std::string *Token;	/* optional element of XSD type xsd:string */
	std::string *Exchange;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__FundamentalList (65)
	virtual int soap_type(void) const { return 65; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__FundamentalList, default initialized and not managed by a soap context
	virtual _eoddata1__FundamentalList *soap_alloc(void) const { return SOAP_NEW(_eoddata1__FundamentalList); }
	         _eoddata1__FundamentalList() { _eoddata1__FundamentalList::soap_default(NULL); }
	virtual ~_eoddata1__FundamentalList() { }
	friend SOAP_FMAC1 _eoddata1__FundamentalList * SOAP_FMAC2 soap_instantiate__eoddata1__FundamentalList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:319 */
#ifndef SOAP_TYPE_eoddata__eoddata1__FundamentalListResponse
#define SOAP_TYPE_eoddata__eoddata1__FundamentalListResponse (66)
/* eoddata1:FundamentalListResponse complex type: */
class SOAP_CMAC _eoddata1__FundamentalListResponse
{
public:
	eoddata1__RESPONSE *FundamentalListResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type eoddata1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__FundamentalListResponse (66)
	virtual int soap_type(void) const { return 66; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__FundamentalListResponse, default initialized and not managed by a soap context
	virtual _eoddata1__FundamentalListResponse *soap_alloc(void) const { return SOAP_NEW(_eoddata1__FundamentalListResponse); }
	         _eoddata1__FundamentalListResponse() { _eoddata1__FundamentalListResponse::soap_default(NULL); }
	virtual ~_eoddata1__FundamentalListResponse() { }
	friend SOAP_FMAC1 _eoddata1__FundamentalListResponse * SOAP_FMAC2 soap_instantiate__eoddata1__FundamentalListResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:322 */
#ifndef SOAP_TYPE_eoddata__eoddata1__TechnicalList
#define SOAP_TYPE_eoddata__eoddata1__TechnicalList (67)
/* eoddata1:TechnicalList complex type: */
class SOAP_CMAC _eoddata1__TechnicalList
{
public:
	std::string *Token;	/* optional element of XSD type xsd:string */
	std::string *Exchange;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__TechnicalList (67)
	virtual int soap_type(void) const { return 67; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__TechnicalList, default initialized and not managed by a soap context
	virtual _eoddata1__TechnicalList *soap_alloc(void) const { return SOAP_NEW(_eoddata1__TechnicalList); }
	         _eoddata1__TechnicalList() { _eoddata1__TechnicalList::soap_default(NULL); }
	virtual ~_eoddata1__TechnicalList() { }
	friend SOAP_FMAC1 _eoddata1__TechnicalList * SOAP_FMAC2 soap_instantiate__eoddata1__TechnicalList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:325 */
#ifndef SOAP_TYPE_eoddata__eoddata1__TechnicalListResponse
#define SOAP_TYPE_eoddata__eoddata1__TechnicalListResponse (68)
/* eoddata1:TechnicalListResponse complex type: */
class SOAP_CMAC _eoddata1__TechnicalListResponse
{
public:
	eoddata1__RESPONSE *TechnicalListResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type eoddata1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__TechnicalListResponse (68)
	virtual int soap_type(void) const { return 68; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__TechnicalListResponse, default initialized and not managed by a soap context
	virtual _eoddata1__TechnicalListResponse *soap_alloc(void) const { return SOAP_NEW(_eoddata1__TechnicalListResponse); }
	         _eoddata1__TechnicalListResponse() { _eoddata1__TechnicalListResponse::soap_default(NULL); }
	virtual ~_eoddata1__TechnicalListResponse() { }
	friend SOAP_FMAC1 _eoddata1__TechnicalListResponse * SOAP_FMAC2 soap_instantiate__eoddata1__TechnicalListResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:328 */
#ifndef SOAP_TYPE_eoddata__eoddata1__QuoteListByDate
#define SOAP_TYPE_eoddata__eoddata1__QuoteListByDate (69)
/* eoddata1:QuoteListByDate complex type: */
class SOAP_CMAC _eoddata1__QuoteListByDate
{
public:
	std::string *Token;	/* optional element of XSD type xsd:string */
	std::string *Exchange;	/* optional element of XSD type xsd:string */
	std::string *QuoteDate;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__QuoteListByDate (69)
	virtual int soap_type(void) const { return 69; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__QuoteListByDate, default initialized and not managed by a soap context
	virtual _eoddata1__QuoteListByDate *soap_alloc(void) const { return SOAP_NEW(_eoddata1__QuoteListByDate); }
	         _eoddata1__QuoteListByDate() { _eoddata1__QuoteListByDate::soap_default(NULL); }
	virtual ~_eoddata1__QuoteListByDate() { }
	friend SOAP_FMAC1 _eoddata1__QuoteListByDate * SOAP_FMAC2 soap_instantiate__eoddata1__QuoteListByDate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:331 */
#ifndef SOAP_TYPE_eoddata__eoddata1__QuoteListByDateResponse
#define SOAP_TYPE_eoddata__eoddata1__QuoteListByDateResponse (70)
/* eoddata1:QuoteListByDateResponse complex type: */
class SOAP_CMAC _eoddata1__QuoteListByDateResponse
{
public:
	eoddata1__RESPONSE *QuoteListByDateResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type eoddata1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__QuoteListByDateResponse (70)
	virtual int soap_type(void) const { return 70; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__QuoteListByDateResponse, default initialized and not managed by a soap context
	virtual _eoddata1__QuoteListByDateResponse *soap_alloc(void) const { return SOAP_NEW(_eoddata1__QuoteListByDateResponse); }
	         _eoddata1__QuoteListByDateResponse() { _eoddata1__QuoteListByDateResponse::soap_default(NULL); }
	virtual ~_eoddata1__QuoteListByDateResponse() { }
	friend SOAP_FMAC1 _eoddata1__QuoteListByDateResponse * SOAP_FMAC2 soap_instantiate__eoddata1__QuoteListByDateResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:334 */
#ifndef SOAP_TYPE_eoddata__eoddata1__QuoteListByDate2
#define SOAP_TYPE_eoddata__eoddata1__QuoteListByDate2 (71)
/* eoddata1:QuoteListByDate2 complex type: */
class SOAP_CMAC _eoddata1__QuoteListByDate2
{
public:
	std::string *Token;	/* optional element of XSD type xsd:string */
	std::string *Exchange;	/* optional element of XSD type xsd:string */
	std::string *QuoteDate;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__QuoteListByDate2 (71)
	virtual int soap_type(void) const { return 71; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__QuoteListByDate2, default initialized and not managed by a soap context
	virtual _eoddata1__QuoteListByDate2 *soap_alloc(void) const { return SOAP_NEW(_eoddata1__QuoteListByDate2); }
	         _eoddata1__QuoteListByDate2() { _eoddata1__QuoteListByDate2::soap_default(NULL); }
	virtual ~_eoddata1__QuoteListByDate2() { }
	friend SOAP_FMAC1 _eoddata1__QuoteListByDate2 * SOAP_FMAC2 soap_instantiate__eoddata1__QuoteListByDate2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:337 */
#ifndef SOAP_TYPE_eoddata__eoddata1__QuoteListByDate2Response
#define SOAP_TYPE_eoddata__eoddata1__QuoteListByDate2Response (72)
/* eoddata1:QuoteListByDate2Response complex type: */
class SOAP_CMAC _eoddata1__QuoteListByDate2Response
{
public:
	eoddata1__RESPONSE *QuoteListByDate2Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type eoddata1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__QuoteListByDate2Response (72)
	virtual int soap_type(void) const { return 72; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__QuoteListByDate2Response, default initialized and not managed by a soap context
	virtual _eoddata1__QuoteListByDate2Response *soap_alloc(void) const { return SOAP_NEW(_eoddata1__QuoteListByDate2Response); }
	         _eoddata1__QuoteListByDate2Response() { _eoddata1__QuoteListByDate2Response::soap_default(NULL); }
	virtual ~_eoddata1__QuoteListByDate2Response() { }
	friend SOAP_FMAC1 _eoddata1__QuoteListByDate2Response * SOAP_FMAC2 soap_instantiate__eoddata1__QuoteListByDate2Response(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:340 */
#ifndef SOAP_TYPE_eoddata__eoddata1__SymbolHistory
#define SOAP_TYPE_eoddata__eoddata1__SymbolHistory (73)
/* eoddata1:SymbolHistory complex type: */
class SOAP_CMAC _eoddata1__SymbolHistory
{
public:
	std::string *Token;	/* optional element of XSD type xsd:string */
	std::string *Exchange;	/* optional element of XSD type xsd:string */
	std::string *Symbol;	/* optional element of XSD type xsd:string */
	std::string *StartDate;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__SymbolHistory (73)
	virtual int soap_type(void) const { return 73; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__SymbolHistory, default initialized and not managed by a soap context
	virtual _eoddata1__SymbolHistory *soap_alloc(void) const { return SOAP_NEW(_eoddata1__SymbolHistory); }
	         _eoddata1__SymbolHistory() { _eoddata1__SymbolHistory::soap_default(NULL); }
	virtual ~_eoddata1__SymbolHistory() { }
	friend SOAP_FMAC1 _eoddata1__SymbolHistory * SOAP_FMAC2 soap_instantiate__eoddata1__SymbolHistory(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:343 */
#ifndef SOAP_TYPE_eoddata__eoddata1__SymbolHistoryResponse
#define SOAP_TYPE_eoddata__eoddata1__SymbolHistoryResponse (74)
/* eoddata1:SymbolHistoryResponse complex type: */
class SOAP_CMAC _eoddata1__SymbolHistoryResponse
{
public:
	eoddata1__RESPONSE *SymbolHistoryResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type eoddata1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__SymbolHistoryResponse (74)
	virtual int soap_type(void) const { return 74; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__SymbolHistoryResponse, default initialized and not managed by a soap context
	virtual _eoddata1__SymbolHistoryResponse *soap_alloc(void) const { return SOAP_NEW(_eoddata1__SymbolHistoryResponse); }
	         _eoddata1__SymbolHistoryResponse() { _eoddata1__SymbolHistoryResponse::soap_default(NULL); }
	virtual ~_eoddata1__SymbolHistoryResponse() { }
	friend SOAP_FMAC1 _eoddata1__SymbolHistoryResponse * SOAP_FMAC2 soap_instantiate__eoddata1__SymbolHistoryResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:346 */
#ifndef SOAP_TYPE_eoddata__eoddata1__Top10Gains
#define SOAP_TYPE_eoddata__eoddata1__Top10Gains (75)
/* eoddata1:Top10Gains complex type: */
class SOAP_CMAC _eoddata1__Top10Gains
{
public:
	std::string *Token;	/* optional element of XSD type xsd:string */
	std::string *Exchange;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__Top10Gains (75)
	virtual int soap_type(void) const { return 75; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__Top10Gains, default initialized and not managed by a soap context
	virtual _eoddata1__Top10Gains *soap_alloc(void) const { return SOAP_NEW(_eoddata1__Top10Gains); }
	         _eoddata1__Top10Gains() { _eoddata1__Top10Gains::soap_default(NULL); }
	virtual ~_eoddata1__Top10Gains() { }
	friend SOAP_FMAC1 _eoddata1__Top10Gains * SOAP_FMAC2 soap_instantiate__eoddata1__Top10Gains(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:349 */
#ifndef SOAP_TYPE_eoddata__eoddata1__Top10GainsResponse
#define SOAP_TYPE_eoddata__eoddata1__Top10GainsResponse (76)
/* eoddata1:Top10GainsResponse complex type: */
class SOAP_CMAC _eoddata1__Top10GainsResponse
{
public:
	eoddata1__RESPONSE *Top10GainsResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type eoddata1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__Top10GainsResponse (76)
	virtual int soap_type(void) const { return 76; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__Top10GainsResponse, default initialized and not managed by a soap context
	virtual _eoddata1__Top10GainsResponse *soap_alloc(void) const { return SOAP_NEW(_eoddata1__Top10GainsResponse); }
	         _eoddata1__Top10GainsResponse() { _eoddata1__Top10GainsResponse::soap_default(NULL); }
	virtual ~_eoddata1__Top10GainsResponse() { }
	friend SOAP_FMAC1 _eoddata1__Top10GainsResponse * SOAP_FMAC2 soap_instantiate__eoddata1__Top10GainsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:352 */
#ifndef SOAP_TYPE_eoddata__eoddata1__Top10Losses
#define SOAP_TYPE_eoddata__eoddata1__Top10Losses (77)
/* eoddata1:Top10Losses complex type: */
class SOAP_CMAC _eoddata1__Top10Losses
{
public:
	std::string *Token;	/* optional element of XSD type xsd:string */
	std::string *Exchange;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__Top10Losses (77)
	virtual int soap_type(void) const { return 77; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__Top10Losses, default initialized and not managed by a soap context
	virtual _eoddata1__Top10Losses *soap_alloc(void) const { return SOAP_NEW(_eoddata1__Top10Losses); }
	         _eoddata1__Top10Losses() { _eoddata1__Top10Losses::soap_default(NULL); }
	virtual ~_eoddata1__Top10Losses() { }
	friend SOAP_FMAC1 _eoddata1__Top10Losses * SOAP_FMAC2 soap_instantiate__eoddata1__Top10Losses(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:355 */
#ifndef SOAP_TYPE_eoddata__eoddata1__Top10LossesResponse
#define SOAP_TYPE_eoddata__eoddata1__Top10LossesResponse (78)
/* eoddata1:Top10LossesResponse complex type: */
class SOAP_CMAC _eoddata1__Top10LossesResponse
{
public:
	eoddata1__RESPONSE *Top10LossesResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type eoddata1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__Top10LossesResponse (78)
	virtual int soap_type(void) const { return 78; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__Top10LossesResponse, default initialized and not managed by a soap context
	virtual _eoddata1__Top10LossesResponse *soap_alloc(void) const { return SOAP_NEW(_eoddata1__Top10LossesResponse); }
	         _eoddata1__Top10LossesResponse() { _eoddata1__Top10LossesResponse::soap_default(NULL); }
	virtual ~_eoddata1__Top10LossesResponse() { }
	friend SOAP_FMAC1 _eoddata1__Top10LossesResponse * SOAP_FMAC2 soap_instantiate__eoddata1__Top10LossesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:358 */
#ifndef SOAP_TYPE_eoddata__eoddata1__SymbolChart
#define SOAP_TYPE_eoddata__eoddata1__SymbolChart (79)
/* eoddata1:SymbolChart complex type: */
class SOAP_CMAC _eoddata1__SymbolChart
{
public:
	std::string *Token;	/* optional element of XSD type xsd:string */
	std::string *Exchange;	/* optional element of XSD type xsd:string */
	std::string *Symbol;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__SymbolChart (79)
	virtual int soap_type(void) const { return 79; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__SymbolChart, default initialized and not managed by a soap context
	virtual _eoddata1__SymbolChart *soap_alloc(void) const { return SOAP_NEW(_eoddata1__SymbolChart); }
	         _eoddata1__SymbolChart() { _eoddata1__SymbolChart::soap_default(NULL); }
	virtual ~_eoddata1__SymbolChart() { }
	friend SOAP_FMAC1 _eoddata1__SymbolChart * SOAP_FMAC2 soap_instantiate__eoddata1__SymbolChart(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:361 */
#ifndef SOAP_TYPE_eoddata__eoddata1__SymbolChartResponse
#define SOAP_TYPE_eoddata__eoddata1__SymbolChartResponse (80)
/* eoddata1:SymbolChartResponse complex type: */
class SOAP_CMAC _eoddata1__SymbolChartResponse
{
public:
	eoddata1__RESPONSE *SymbolChartResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type eoddata1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__SymbolChartResponse (80)
	virtual int soap_type(void) const { return 80; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__SymbolChartResponse, default initialized and not managed by a soap context
	virtual _eoddata1__SymbolChartResponse *soap_alloc(void) const { return SOAP_NEW(_eoddata1__SymbolChartResponse); }
	         _eoddata1__SymbolChartResponse() { _eoddata1__SymbolChartResponse::soap_default(NULL); }
	virtual ~_eoddata1__SymbolChartResponse() { }
	friend SOAP_FMAC1 _eoddata1__SymbolChartResponse * SOAP_FMAC2 soap_instantiate__eoddata1__SymbolChartResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:364 */
#ifndef SOAP_TYPE_eoddata__eoddata1__ExchangeMonths
#define SOAP_TYPE_eoddata__eoddata1__ExchangeMonths (81)
/* eoddata1:ExchangeMonths complex type: */
class SOAP_CMAC _eoddata1__ExchangeMonths
{
public:
	std::string *Token;	/* optional element of XSD type xsd:string */
	std::string *Exchange;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__ExchangeMonths (81)
	virtual int soap_type(void) const { return 81; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__ExchangeMonths, default initialized and not managed by a soap context
	virtual _eoddata1__ExchangeMonths *soap_alloc(void) const { return SOAP_NEW(_eoddata1__ExchangeMonths); }
	         _eoddata1__ExchangeMonths() { _eoddata1__ExchangeMonths::soap_default(NULL); }
	virtual ~_eoddata1__ExchangeMonths() { }
	friend SOAP_FMAC1 _eoddata1__ExchangeMonths * SOAP_FMAC2 soap_instantiate__eoddata1__ExchangeMonths(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:367 */
#ifndef SOAP_TYPE_eoddata__eoddata1__ExchangeMonthsResponse
#define SOAP_TYPE_eoddata__eoddata1__ExchangeMonthsResponse (82)
/* eoddata1:ExchangeMonthsResponse complex type: */
class SOAP_CMAC _eoddata1__ExchangeMonthsResponse
{
public:
	eoddata1__RESPONSE *ExchangeMonthsResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type eoddata1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__ExchangeMonthsResponse (82)
	virtual int soap_type(void) const { return 82; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__ExchangeMonthsResponse, default initialized and not managed by a soap context
	virtual _eoddata1__ExchangeMonthsResponse *soap_alloc(void) const { return SOAP_NEW(_eoddata1__ExchangeMonthsResponse); }
	         _eoddata1__ExchangeMonthsResponse() { _eoddata1__ExchangeMonthsResponse::soap_default(NULL); }
	virtual ~_eoddata1__ExchangeMonthsResponse() { }
	friend SOAP_FMAC1 _eoddata1__ExchangeMonthsResponse * SOAP_FMAC2 soap_instantiate__eoddata1__ExchangeMonthsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:370 */
#ifndef SOAP_TYPE_eoddata__eoddata1__SplitListByExchange
#define SOAP_TYPE_eoddata__eoddata1__SplitListByExchange (83)
/* eoddata1:SplitListByExchange complex type: */
class SOAP_CMAC _eoddata1__SplitListByExchange
{
public:
	std::string *Token;	/* optional element of XSD type xsd:string */
	std::string *Exchange;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__SplitListByExchange (83)
	virtual int soap_type(void) const { return 83; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__SplitListByExchange, default initialized and not managed by a soap context
	virtual _eoddata1__SplitListByExchange *soap_alloc(void) const { return SOAP_NEW(_eoddata1__SplitListByExchange); }
	         _eoddata1__SplitListByExchange() { _eoddata1__SplitListByExchange::soap_default(NULL); }
	virtual ~_eoddata1__SplitListByExchange() { }
	friend SOAP_FMAC1 _eoddata1__SplitListByExchange * SOAP_FMAC2 soap_instantiate__eoddata1__SplitListByExchange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:373 */
#ifndef SOAP_TYPE_eoddata__eoddata1__SplitListByExchangeResponse
#define SOAP_TYPE_eoddata__eoddata1__SplitListByExchangeResponse (84)
/* eoddata1:SplitListByExchangeResponse complex type: */
class SOAP_CMAC _eoddata1__SplitListByExchangeResponse
{
public:
	eoddata1__RESPONSE *SplitListByExchangeResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type eoddata1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__SplitListByExchangeResponse (84)
	virtual int soap_type(void) const { return 84; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__SplitListByExchangeResponse, default initialized and not managed by a soap context
	virtual _eoddata1__SplitListByExchangeResponse *soap_alloc(void) const { return SOAP_NEW(_eoddata1__SplitListByExchangeResponse); }
	         _eoddata1__SplitListByExchangeResponse() { _eoddata1__SplitListByExchangeResponse::soap_default(NULL); }
	virtual ~_eoddata1__SplitListByExchangeResponse() { }
	friend SOAP_FMAC1 _eoddata1__SplitListByExchangeResponse * SOAP_FMAC2 soap_instantiate__eoddata1__SplitListByExchangeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:376 */
#ifndef SOAP_TYPE_eoddata__eoddata1__SplitListBySymbol
#define SOAP_TYPE_eoddata__eoddata1__SplitListBySymbol (85)
/* eoddata1:SplitListBySymbol complex type: */
class SOAP_CMAC _eoddata1__SplitListBySymbol
{
public:
	std::string *Token;	/* optional element of XSD type xsd:string */
	std::string *Exchange;	/* optional element of XSD type xsd:string */
	std::string *Symbol;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__SplitListBySymbol (85)
	virtual int soap_type(void) const { return 85; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__SplitListBySymbol, default initialized and not managed by a soap context
	virtual _eoddata1__SplitListBySymbol *soap_alloc(void) const { return SOAP_NEW(_eoddata1__SplitListBySymbol); }
	         _eoddata1__SplitListBySymbol() { _eoddata1__SplitListBySymbol::soap_default(NULL); }
	virtual ~_eoddata1__SplitListBySymbol() { }
	friend SOAP_FMAC1 _eoddata1__SplitListBySymbol * SOAP_FMAC2 soap_instantiate__eoddata1__SplitListBySymbol(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:379 */
#ifndef SOAP_TYPE_eoddata__eoddata1__SplitListBySymbolResponse
#define SOAP_TYPE_eoddata__eoddata1__SplitListBySymbolResponse (86)
/* eoddata1:SplitListBySymbolResponse complex type: */
class SOAP_CMAC _eoddata1__SplitListBySymbolResponse
{
public:
	eoddata1__RESPONSE *SplitListBySymbolResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type eoddata1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__SplitListBySymbolResponse (86)
	virtual int soap_type(void) const { return 86; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__SplitListBySymbolResponse, default initialized and not managed by a soap context
	virtual _eoddata1__SplitListBySymbolResponse *soap_alloc(void) const { return SOAP_NEW(_eoddata1__SplitListBySymbolResponse); }
	         _eoddata1__SplitListBySymbolResponse() { _eoddata1__SplitListBySymbolResponse::soap_default(NULL); }
	virtual ~_eoddata1__SplitListBySymbolResponse() { }
	friend SOAP_FMAC1 _eoddata1__SplitListBySymbolResponse * SOAP_FMAC2 soap_instantiate__eoddata1__SplitListBySymbolResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:382 */
#ifndef SOAP_TYPE_eoddata__eoddata1__CountryList
#define SOAP_TYPE_eoddata__eoddata1__CountryList (87)
/* eoddata1:CountryList complex type: */
class SOAP_CMAC _eoddata1__CountryList
{
public:
	std::string *Token;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__CountryList (87)
	virtual int soap_type(void) const { return 87; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__CountryList, default initialized and not managed by a soap context
	virtual _eoddata1__CountryList *soap_alloc(void) const { return SOAP_NEW(_eoddata1__CountryList); }
	         _eoddata1__CountryList() { _eoddata1__CountryList::soap_default(NULL); }
	virtual ~_eoddata1__CountryList() { }
	friend SOAP_FMAC1 _eoddata1__CountryList * SOAP_FMAC2 soap_instantiate__eoddata1__CountryList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:385 */
#ifndef SOAP_TYPE_eoddata__eoddata1__CountryListResponse
#define SOAP_TYPE_eoddata__eoddata1__CountryListResponse (88)
/* eoddata1:CountryListResponse complex type: */
class SOAP_CMAC _eoddata1__CountryListResponse
{
public:
	eoddata1__RESPONSE *CountryListResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type eoddata1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__CountryListResponse (88)
	virtual int soap_type(void) const { return 88; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__CountryListResponse, default initialized and not managed by a soap context
	virtual _eoddata1__CountryListResponse *soap_alloc(void) const { return SOAP_NEW(_eoddata1__CountryListResponse); }
	         _eoddata1__CountryListResponse() { _eoddata1__CountryListResponse::soap_default(NULL); }
	virtual ~_eoddata1__CountryListResponse() { }
	friend SOAP_FMAC1 _eoddata1__CountryListResponse * SOAP_FMAC2 soap_instantiate__eoddata1__CountryListResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:388 */
#ifndef SOAP_TYPE_eoddata__eoddata1__SymbolHistoryPeriod
#define SOAP_TYPE_eoddata__eoddata1__SymbolHistoryPeriod (89)
/* eoddata1:SymbolHistoryPeriod complex type: */
class SOAP_CMAC _eoddata1__SymbolHistoryPeriod
{
public:
	std::string *Token;	/* optional element of XSD type xsd:string */
	std::string *Exchange;	/* optional element of XSD type xsd:string */
	std::string *Symbol;	/* optional element of XSD type xsd:string */
	std::string *Date;	/* optional element of XSD type xsd:string */
	std::string *Period;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__SymbolHistoryPeriod (89)
	virtual int soap_type(void) const { return 89; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__SymbolHistoryPeriod, default initialized and not managed by a soap context
	virtual _eoddata1__SymbolHistoryPeriod *soap_alloc(void) const { return SOAP_NEW(_eoddata1__SymbolHistoryPeriod); }
	         _eoddata1__SymbolHistoryPeriod() { _eoddata1__SymbolHistoryPeriod::soap_default(NULL); }
	virtual ~_eoddata1__SymbolHistoryPeriod() { }
	friend SOAP_FMAC1 _eoddata1__SymbolHistoryPeriod * SOAP_FMAC2 soap_instantiate__eoddata1__SymbolHistoryPeriod(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:391 */
#ifndef SOAP_TYPE_eoddata__eoddata1__SymbolHistoryPeriodResponse
#define SOAP_TYPE_eoddata__eoddata1__SymbolHistoryPeriodResponse (90)
/* eoddata1:SymbolHistoryPeriodResponse complex type: */
class SOAP_CMAC _eoddata1__SymbolHistoryPeriodResponse
{
public:
	eoddata1__RESPONSE *SymbolHistoryPeriodResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type eoddata1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__SymbolHistoryPeriodResponse (90)
	virtual int soap_type(void) const { return 90; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__SymbolHistoryPeriodResponse, default initialized and not managed by a soap context
	virtual _eoddata1__SymbolHistoryPeriodResponse *soap_alloc(void) const { return SOAP_NEW(_eoddata1__SymbolHistoryPeriodResponse); }
	         _eoddata1__SymbolHistoryPeriodResponse() { _eoddata1__SymbolHistoryPeriodResponse::soap_default(NULL); }
	virtual ~_eoddata1__SymbolHistoryPeriodResponse() { }
	friend SOAP_FMAC1 _eoddata1__SymbolHistoryPeriodResponse * SOAP_FMAC2 soap_instantiate__eoddata1__SymbolHistoryPeriodResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:394 */
#ifndef SOAP_TYPE_eoddata__eoddata1__SymbolHistoryPeriodByDateRange
#define SOAP_TYPE_eoddata__eoddata1__SymbolHistoryPeriodByDateRange (91)
/* eoddata1:SymbolHistoryPeriodByDateRange complex type: */
class SOAP_CMAC _eoddata1__SymbolHistoryPeriodByDateRange
{
public:
	std::string *Token;	/* optional element of XSD type xsd:string */
	std::string *Exchange;	/* optional element of XSD type xsd:string */
	std::string *Symbol;	/* optional element of XSD type xsd:string */
	std::string *StartDate;	/* optional element of XSD type xsd:string */
	std::string *EndDate;	/* optional element of XSD type xsd:string */
	std::string *Period;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__SymbolHistoryPeriodByDateRange (91)
	virtual int soap_type(void) const { return 91; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__SymbolHistoryPeriodByDateRange, default initialized and not managed by a soap context
	virtual _eoddata1__SymbolHistoryPeriodByDateRange *soap_alloc(void) const { return SOAP_NEW(_eoddata1__SymbolHistoryPeriodByDateRange); }
	         _eoddata1__SymbolHistoryPeriodByDateRange() { _eoddata1__SymbolHistoryPeriodByDateRange::soap_default(NULL); }
	virtual ~_eoddata1__SymbolHistoryPeriodByDateRange() { }
	friend SOAP_FMAC1 _eoddata1__SymbolHistoryPeriodByDateRange * SOAP_FMAC2 soap_instantiate__eoddata1__SymbolHistoryPeriodByDateRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:397 */
#ifndef SOAP_TYPE_eoddata__eoddata1__SymbolHistoryPeriodByDateRangeResponse
#define SOAP_TYPE_eoddata__eoddata1__SymbolHistoryPeriodByDateRangeResponse (92)
/* eoddata1:SymbolHistoryPeriodByDateRangeResponse complex type: */
class SOAP_CMAC _eoddata1__SymbolHistoryPeriodByDateRangeResponse
{
public:
	eoddata1__RESPONSE *SymbolHistoryPeriodByDateRangeResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type eoddata1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__SymbolHistoryPeriodByDateRangeResponse (92)
	virtual int soap_type(void) const { return 92; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__SymbolHistoryPeriodByDateRangeResponse, default initialized and not managed by a soap context
	virtual _eoddata1__SymbolHistoryPeriodByDateRangeResponse *soap_alloc(void) const { return SOAP_NEW(_eoddata1__SymbolHistoryPeriodByDateRangeResponse); }
	         _eoddata1__SymbolHistoryPeriodByDateRangeResponse() { _eoddata1__SymbolHistoryPeriodByDateRangeResponse::soap_default(NULL); }
	virtual ~_eoddata1__SymbolHistoryPeriodByDateRangeResponse() { }
	friend SOAP_FMAC1 _eoddata1__SymbolHistoryPeriodByDateRangeResponse * SOAP_FMAC2 soap_instantiate__eoddata1__SymbolHistoryPeriodByDateRangeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:400 */
#ifndef SOAP_TYPE_eoddata__eoddata1__QuoteListByDatePeriod
#define SOAP_TYPE_eoddata__eoddata1__QuoteListByDatePeriod (93)
/* eoddata1:QuoteListByDatePeriod complex type: */
class SOAP_CMAC _eoddata1__QuoteListByDatePeriod
{
public:
	std::string *Token;	/* optional element of XSD type xsd:string */
	std::string *Exchange;	/* optional element of XSD type xsd:string */
	std::string *QuoteDate;	/* optional element of XSD type xsd:string */
	std::string *Period;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__QuoteListByDatePeriod (93)
	virtual int soap_type(void) const { return 93; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__QuoteListByDatePeriod, default initialized and not managed by a soap context
	virtual _eoddata1__QuoteListByDatePeriod *soap_alloc(void) const { return SOAP_NEW(_eoddata1__QuoteListByDatePeriod); }
	         _eoddata1__QuoteListByDatePeriod() { _eoddata1__QuoteListByDatePeriod::soap_default(NULL); }
	virtual ~_eoddata1__QuoteListByDatePeriod() { }
	friend SOAP_FMAC1 _eoddata1__QuoteListByDatePeriod * SOAP_FMAC2 soap_instantiate__eoddata1__QuoteListByDatePeriod(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:403 */
#ifndef SOAP_TYPE_eoddata__eoddata1__QuoteListByDatePeriodResponse
#define SOAP_TYPE_eoddata__eoddata1__QuoteListByDatePeriodResponse (94)
/* eoddata1:QuoteListByDatePeriodResponse complex type: */
class SOAP_CMAC _eoddata1__QuoteListByDatePeriodResponse
{
public:
	eoddata1__RESPONSE *QuoteListByDatePeriodResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type eoddata1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__QuoteListByDatePeriodResponse (94)
	virtual int soap_type(void) const { return 94; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__QuoteListByDatePeriodResponse, default initialized and not managed by a soap context
	virtual _eoddata1__QuoteListByDatePeriodResponse *soap_alloc(void) const { return SOAP_NEW(_eoddata1__QuoteListByDatePeriodResponse); }
	         _eoddata1__QuoteListByDatePeriodResponse() { _eoddata1__QuoteListByDatePeriodResponse::soap_default(NULL); }
	virtual ~_eoddata1__QuoteListByDatePeriodResponse() { }
	friend SOAP_FMAC1 _eoddata1__QuoteListByDatePeriodResponse * SOAP_FMAC2 soap_instantiate__eoddata1__QuoteListByDatePeriodResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:406 */
#ifndef SOAP_TYPE_eoddata__eoddata1__QuoteListByDatePeriod2
#define SOAP_TYPE_eoddata__eoddata1__QuoteListByDatePeriod2 (95)
/* eoddata1:QuoteListByDatePeriod2 complex type: */
class SOAP_CMAC _eoddata1__QuoteListByDatePeriod2
{
public:
	std::string *Token;	/* optional element of XSD type xsd:string */
	std::string *Exchange;	/* optional element of XSD type xsd:string */
	std::string *QuoteDate;	/* optional element of XSD type xsd:string */
	std::string *Period;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__QuoteListByDatePeriod2 (95)
	virtual int soap_type(void) const { return 95; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__QuoteListByDatePeriod2, default initialized and not managed by a soap context
	virtual _eoddata1__QuoteListByDatePeriod2 *soap_alloc(void) const { return SOAP_NEW(_eoddata1__QuoteListByDatePeriod2); }
	         _eoddata1__QuoteListByDatePeriod2() { _eoddata1__QuoteListByDatePeriod2::soap_default(NULL); }
	virtual ~_eoddata1__QuoteListByDatePeriod2() { }
	friend SOAP_FMAC1 _eoddata1__QuoteListByDatePeriod2 * SOAP_FMAC2 soap_instantiate__eoddata1__QuoteListByDatePeriod2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:409 */
#ifndef SOAP_TYPE_eoddata__eoddata1__QuoteListByDatePeriod2Response
#define SOAP_TYPE_eoddata__eoddata1__QuoteListByDatePeriod2Response (96)
/* eoddata1:QuoteListByDatePeriod2Response complex type: */
class SOAP_CMAC _eoddata1__QuoteListByDatePeriod2Response
{
public:
	eoddata1__RESPONSE *QuoteListByDatePeriod2Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type eoddata1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__QuoteListByDatePeriod2Response (96)
	virtual int soap_type(void) const { return 96; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__QuoteListByDatePeriod2Response, default initialized and not managed by a soap context
	virtual _eoddata1__QuoteListByDatePeriod2Response *soap_alloc(void) const { return SOAP_NEW(_eoddata1__QuoteListByDatePeriod2Response); }
	         _eoddata1__QuoteListByDatePeriod2Response() { _eoddata1__QuoteListByDatePeriod2Response::soap_default(NULL); }
	virtual ~_eoddata1__QuoteListByDatePeriod2Response() { }
	friend SOAP_FMAC1 _eoddata1__QuoteListByDatePeriod2Response * SOAP_FMAC2 soap_instantiate__eoddata1__QuoteListByDatePeriod2Response(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:412 */
#ifndef SOAP_TYPE_eoddata__eoddata1__SymbolChangesByExchange
#define SOAP_TYPE_eoddata__eoddata1__SymbolChangesByExchange (97)
/* eoddata1:SymbolChangesByExchange complex type: */
class SOAP_CMAC _eoddata1__SymbolChangesByExchange
{
public:
	std::string *Token;	/* optional element of XSD type xsd:string */
	std::string *Exchange;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__SymbolChangesByExchange (97)
	virtual int soap_type(void) const { return 97; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__SymbolChangesByExchange, default initialized and not managed by a soap context
	virtual _eoddata1__SymbolChangesByExchange *soap_alloc(void) const { return SOAP_NEW(_eoddata1__SymbolChangesByExchange); }
	         _eoddata1__SymbolChangesByExchange() { _eoddata1__SymbolChangesByExchange::soap_default(NULL); }
	virtual ~_eoddata1__SymbolChangesByExchange() { }
	friend SOAP_FMAC1 _eoddata1__SymbolChangesByExchange * SOAP_FMAC2 soap_instantiate__eoddata1__SymbolChangesByExchange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:415 */
#ifndef SOAP_TYPE_eoddata__eoddata1__SymbolChangesByExchangeResponse
#define SOAP_TYPE_eoddata__eoddata1__SymbolChangesByExchangeResponse (98)
/* eoddata1:SymbolChangesByExchangeResponse complex type: */
class SOAP_CMAC _eoddata1__SymbolChangesByExchangeResponse
{
public:
	eoddata1__RESPONSE *SymbolChangesByExchangeResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type eoddata1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__SymbolChangesByExchangeResponse (98)
	virtual int soap_type(void) const { return 98; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__SymbolChangesByExchangeResponse, default initialized and not managed by a soap context
	virtual _eoddata1__SymbolChangesByExchangeResponse *soap_alloc(void) const { return SOAP_NEW(_eoddata1__SymbolChangesByExchangeResponse); }
	         _eoddata1__SymbolChangesByExchangeResponse() { _eoddata1__SymbolChangesByExchangeResponse::soap_default(NULL); }
	virtual ~_eoddata1__SymbolChangesByExchangeResponse() { }
	friend SOAP_FMAC1 _eoddata1__SymbolChangesByExchangeResponse * SOAP_FMAC2 soap_instantiate__eoddata1__SymbolChangesByExchangeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:418 */
#ifndef SOAP_TYPE_eoddata__eoddata1__DataClientLatestVersion
#define SOAP_TYPE_eoddata__eoddata1__DataClientLatestVersion (99)
/* eoddata1:DataClientLatestVersion complex type: */
class SOAP_CMAC _eoddata1__DataClientLatestVersion
{
public:
	std::string *Token;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__DataClientLatestVersion (99)
	virtual int soap_type(void) const { return 99; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__DataClientLatestVersion, default initialized and not managed by a soap context
	virtual _eoddata1__DataClientLatestVersion *soap_alloc(void) const { return SOAP_NEW(_eoddata1__DataClientLatestVersion); }
	         _eoddata1__DataClientLatestVersion() { _eoddata1__DataClientLatestVersion::soap_default(NULL); }
	virtual ~_eoddata1__DataClientLatestVersion() { }
	friend SOAP_FMAC1 _eoddata1__DataClientLatestVersion * SOAP_FMAC2 soap_instantiate__eoddata1__DataClientLatestVersion(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:421 */
#ifndef SOAP_TYPE_eoddata__eoddata1__DataClientLatestVersionResponse
#define SOAP_TYPE_eoddata__eoddata1__DataClientLatestVersionResponse (100)
/* eoddata1:DataClientLatestVersionResponse complex type: */
class SOAP_CMAC _eoddata1__DataClientLatestVersionResponse
{
public:
	eoddata1__RESPONSE *DataClientLatestVersionResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type eoddata1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__DataClientLatestVersionResponse (100)
	virtual int soap_type(void) const { return 100; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__DataClientLatestVersionResponse, default initialized and not managed by a soap context
	virtual _eoddata1__DataClientLatestVersionResponse *soap_alloc(void) const { return SOAP_NEW(_eoddata1__DataClientLatestVersionResponse); }
	         _eoddata1__DataClientLatestVersionResponse() { _eoddata1__DataClientLatestVersionResponse::soap_default(NULL); }
	virtual ~_eoddata1__DataClientLatestVersionResponse() { }
	friend SOAP_FMAC1 _eoddata1__DataClientLatestVersionResponse * SOAP_FMAC2 soap_instantiate__eoddata1__DataClientLatestVersionResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:424 */
#ifndef SOAP_TYPE_eoddata__eoddata1__DataFormats
#define SOAP_TYPE_eoddata__eoddata1__DataFormats (101)
/* eoddata1:DataFormats complex type: */
class SOAP_CMAC _eoddata1__DataFormats
{
public:
	std::string *Token;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__DataFormats (101)
	virtual int soap_type(void) const { return 101; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__DataFormats, default initialized and not managed by a soap context
	virtual _eoddata1__DataFormats *soap_alloc(void) const { return SOAP_NEW(_eoddata1__DataFormats); }
	         _eoddata1__DataFormats() { _eoddata1__DataFormats::soap_default(NULL); }
	virtual ~_eoddata1__DataFormats() { }
	friend SOAP_FMAC1 _eoddata1__DataFormats * SOAP_FMAC2 soap_instantiate__eoddata1__DataFormats(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:427 */
#ifndef SOAP_TYPE_eoddata__eoddata1__DataFormatsResponse
#define SOAP_TYPE_eoddata__eoddata1__DataFormatsResponse (102)
/* eoddata1:DataFormatsResponse complex type: */
class SOAP_CMAC _eoddata1__DataFormatsResponse
{
public:
	eoddata1__RESPONSE *DataFormatsResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type eoddata1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__DataFormatsResponse (102)
	virtual int soap_type(void) const { return 102; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__DataFormatsResponse, default initialized and not managed by a soap context
	virtual _eoddata1__DataFormatsResponse *soap_alloc(void) const { return SOAP_NEW(_eoddata1__DataFormatsResponse); }
	         _eoddata1__DataFormatsResponse() { _eoddata1__DataFormatsResponse::soap_default(NULL); }
	virtual ~_eoddata1__DataFormatsResponse() { }
	friend SOAP_FMAC1 _eoddata1__DataFormatsResponse * SOAP_FMAC2 soap_instantiate__eoddata1__DataFormatsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:430 */
#ifndef SOAP_TYPE_eoddata__eoddata1__UpdateDataFormat
#define SOAP_TYPE_eoddata__eoddata1__UpdateDataFormat (103)
/* eoddata1:UpdateDataFormat complex type: */
class SOAP_CMAC _eoddata1__UpdateDataFormat
{
public:
	std::string *Token;	/* optional element of XSD type xsd:string */
	std::string *DataFormat;	/* optional element of XSD type xsd:string */
	bool IncludeHeader;	/* required element of XSD type xsd:boolean */
	bool IncludeSuffix;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__UpdateDataFormat (103)
	virtual int soap_type(void) const { return 103; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__UpdateDataFormat, default initialized and not managed by a soap context
	virtual _eoddata1__UpdateDataFormat *soap_alloc(void) const { return SOAP_NEW(_eoddata1__UpdateDataFormat); }
	         _eoddata1__UpdateDataFormat() { _eoddata1__UpdateDataFormat::soap_default(NULL); }
	virtual ~_eoddata1__UpdateDataFormat() { }
	friend SOAP_FMAC1 _eoddata1__UpdateDataFormat * SOAP_FMAC2 soap_instantiate__eoddata1__UpdateDataFormat(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:433 */
#ifndef SOAP_TYPE_eoddata__eoddata1__UpdateDataFormatResponse
#define SOAP_TYPE_eoddata__eoddata1__UpdateDataFormatResponse (104)
/* eoddata1:UpdateDataFormatResponse complex type: */
class SOAP_CMAC _eoddata1__UpdateDataFormatResponse
{
public:
	eoddata1__RESPONSE *UpdateDataFormatResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type eoddata1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__UpdateDataFormatResponse (104)
	virtual int soap_type(void) const { return 104; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__UpdateDataFormatResponse, default initialized and not managed by a soap context
	virtual _eoddata1__UpdateDataFormatResponse *soap_alloc(void) const { return SOAP_NEW(_eoddata1__UpdateDataFormatResponse); }
	         _eoddata1__UpdateDataFormatResponse() { _eoddata1__UpdateDataFormatResponse::soap_default(NULL); }
	virtual ~_eoddata1__UpdateDataFormatResponse() { }
	friend SOAP_FMAC1 _eoddata1__UpdateDataFormatResponse * SOAP_FMAC2 soap_instantiate__eoddata1__UpdateDataFormatResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:436 */
#ifndef SOAP_TYPE_eoddata__eoddata1__ValidateAccess
#define SOAP_TYPE_eoddata__eoddata1__ValidateAccess (105)
/* eoddata1:ValidateAccess complex type: */
class SOAP_CMAC _eoddata1__ValidateAccess
{
public:
	std::string *Token;	/* optional element of XSD type xsd:string */
	std::string *Exchange;	/* optional element of XSD type xsd:string */
	std::string *QuoteDate;	/* optional element of XSD type xsd:string */
	std::string *Period;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__ValidateAccess (105)
	virtual int soap_type(void) const { return 105; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__ValidateAccess, default initialized and not managed by a soap context
	virtual _eoddata1__ValidateAccess *soap_alloc(void) const { return SOAP_NEW(_eoddata1__ValidateAccess); }
	         _eoddata1__ValidateAccess() { _eoddata1__ValidateAccess::soap_default(NULL); }
	virtual ~_eoddata1__ValidateAccess() { }
	friend SOAP_FMAC1 _eoddata1__ValidateAccess * SOAP_FMAC2 soap_instantiate__eoddata1__ValidateAccess(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:439 */
#ifndef SOAP_TYPE_eoddata__eoddata1__ValidateAccessResponse
#define SOAP_TYPE_eoddata__eoddata1__ValidateAccessResponse (106)
/* eoddata1:ValidateAccessResponse complex type: */
class SOAP_CMAC _eoddata1__ValidateAccessResponse
{
public:
	eoddata1__RESPONSE *ValidateAccessResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type eoddata1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_eoddata__eoddata1__ValidateAccessResponse (106)
	virtual int soap_type(void) const { return 106; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _eoddata1__ValidateAccessResponse, default initialized and not managed by a soap context
	virtual _eoddata1__ValidateAccessResponse *soap_alloc(void) const { return SOAP_NEW(_eoddata1__ValidateAccessResponse); }
	         _eoddata1__ValidateAccessResponse() { _eoddata1__ValidateAccessResponse::soap_default(NULL); }
	virtual ~_eoddata1__ValidateAccessResponse() { }
	friend SOAP_FMAC1 _eoddata1__ValidateAccessResponse * SOAP_FMAC2 soap_instantiate__eoddata1__ValidateAccessResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:3187 */
#ifndef SOAP_TYPE_eoddata___eoddata1__Login
#define SOAP_TYPE_eoddata___eoddata1__Login (158)
/* Operation wrapper: */
struct __eoddata1__Login
{
public:
	_eoddata1__Login *eoddata1__Login;	/* optional element of XSD type eoddata1:Login */
public:
	int soap_type() const { return 158; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__Login */
	         __eoddata1__Login();
	friend SOAP_FMAC1 __eoddata1__Login * SOAP_FMAC2 soap_instantiate___eoddata1__Login(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:3255 */
#ifndef SOAP_TYPE_eoddata___eoddata1__Login2
#define SOAP_TYPE_eoddata___eoddata1__Login2 (162)
/* Operation wrapper: */
struct __eoddata1__Login2
{
public:
	_eoddata1__Login2 *eoddata1__Login2;	/* optional element of XSD type eoddata1:Login2 */
public:
	int soap_type() const { return 162; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__Login2 */
	         __eoddata1__Login2();
	friend SOAP_FMAC1 __eoddata1__Login2 * SOAP_FMAC2 soap_instantiate___eoddata1__Login2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:3322 */
#ifndef SOAP_TYPE_eoddata___eoddata1__Membership
#define SOAP_TYPE_eoddata___eoddata1__Membership (166)
/* Operation wrapper: */
struct __eoddata1__Membership
{
public:
	_eoddata1__Membership *eoddata1__Membership;	/* optional element of XSD type eoddata1:Membership */
public:
	int soap_type() const { return 166; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__Membership */
	         __eoddata1__Membership();
	friend SOAP_FMAC1 __eoddata1__Membership * SOAP_FMAC2 soap_instantiate___eoddata1__Membership(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:3390 */
#ifndef SOAP_TYPE_eoddata___eoddata1__ExchangeList
#define SOAP_TYPE_eoddata___eoddata1__ExchangeList (170)
/* Operation wrapper: */
struct __eoddata1__ExchangeList
{
public:
	_eoddata1__ExchangeList *eoddata1__ExchangeList;	/* optional element of XSD type eoddata1:ExchangeList */
public:
	int soap_type() const { return 170; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__ExchangeList */
	         __eoddata1__ExchangeList();
	friend SOAP_FMAC1 __eoddata1__ExchangeList * SOAP_FMAC2 soap_instantiate___eoddata1__ExchangeList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:3458 */
#ifndef SOAP_TYPE_eoddata___eoddata1__ExchangeGet
#define SOAP_TYPE_eoddata___eoddata1__ExchangeGet (174)
/* Operation wrapper: */
struct __eoddata1__ExchangeGet
{
public:
	_eoddata1__ExchangeGet *eoddata1__ExchangeGet;	/* optional element of XSD type eoddata1:ExchangeGet */
public:
	int soap_type() const { return 174; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__ExchangeGet */
	         __eoddata1__ExchangeGet();
	friend SOAP_FMAC1 __eoddata1__ExchangeGet * SOAP_FMAC2 soap_instantiate___eoddata1__ExchangeGet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:3526 */
#ifndef SOAP_TYPE_eoddata___eoddata1__SymbolList
#define SOAP_TYPE_eoddata___eoddata1__SymbolList (178)
/* Operation wrapper: */
struct __eoddata1__SymbolList
{
public:
	_eoddata1__SymbolList *eoddata1__SymbolList;	/* optional element of XSD type eoddata1:SymbolList */
public:
	int soap_type() const { return 178; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__SymbolList */
	         __eoddata1__SymbolList();
	friend SOAP_FMAC1 __eoddata1__SymbolList * SOAP_FMAC2 soap_instantiate___eoddata1__SymbolList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:3594 */
#ifndef SOAP_TYPE_eoddata___eoddata1__SymbolList2
#define SOAP_TYPE_eoddata___eoddata1__SymbolList2 (182)
/* Operation wrapper: */
struct __eoddata1__SymbolList2
{
public:
	_eoddata1__SymbolList2 *eoddata1__SymbolList2;	/* optional element of XSD type eoddata1:SymbolList2 */
public:
	int soap_type() const { return 182; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__SymbolList2 */
	         __eoddata1__SymbolList2();
	friend SOAP_FMAC1 __eoddata1__SymbolList2 * SOAP_FMAC2 soap_instantiate___eoddata1__SymbolList2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:3662 */
#ifndef SOAP_TYPE_eoddata___eoddata1__QuoteGet
#define SOAP_TYPE_eoddata___eoddata1__QuoteGet (186)
/* Operation wrapper: */
struct __eoddata1__QuoteGet
{
public:
	_eoddata1__QuoteGet *eoddata1__QuoteGet;	/* optional element of XSD type eoddata1:QuoteGet */
public:
	int soap_type() const { return 186; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__QuoteGet */
	         __eoddata1__QuoteGet();
	friend SOAP_FMAC1 __eoddata1__QuoteGet * SOAP_FMAC2 soap_instantiate___eoddata1__QuoteGet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:3731 */
#ifndef SOAP_TYPE_eoddata___eoddata1__QuoteList2
#define SOAP_TYPE_eoddata___eoddata1__QuoteList2 (190)
/* Operation wrapper: */
struct __eoddata1__QuoteList2
{
public:
	_eoddata1__QuoteList2 *eoddata1__QuoteList2;	/* optional element of XSD type eoddata1:QuoteList2 */
public:
	int soap_type() const { return 190; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__QuoteList2 */
	         __eoddata1__QuoteList2();
	friend SOAP_FMAC1 __eoddata1__QuoteList2 * SOAP_FMAC2 soap_instantiate___eoddata1__QuoteList2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:3799 */
#ifndef SOAP_TYPE_eoddata___eoddata1__SymbolGet
#define SOAP_TYPE_eoddata___eoddata1__SymbolGet (194)
/* Operation wrapper: */
struct __eoddata1__SymbolGet
{
public:
	_eoddata1__SymbolGet *eoddata1__SymbolGet;	/* optional element of XSD type eoddata1:SymbolGet */
public:
	int soap_type() const { return 194; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__SymbolGet */
	         __eoddata1__SymbolGet();
	friend SOAP_FMAC1 __eoddata1__SymbolGet * SOAP_FMAC2 soap_instantiate___eoddata1__SymbolGet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:3867 */
#ifndef SOAP_TYPE_eoddata___eoddata1__QuoteList
#define SOAP_TYPE_eoddata___eoddata1__QuoteList (198)
/* Operation wrapper: */
struct __eoddata1__QuoteList
{
public:
	_eoddata1__QuoteList *eoddata1__QuoteList;	/* optional element of XSD type eoddata1:QuoteList */
public:
	int soap_type() const { return 198; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__QuoteList */
	         __eoddata1__QuoteList();
	friend SOAP_FMAC1 __eoddata1__QuoteList * SOAP_FMAC2 soap_instantiate___eoddata1__QuoteList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:3935 */
#ifndef SOAP_TYPE_eoddata___eoddata1__NewsList
#define SOAP_TYPE_eoddata___eoddata1__NewsList (202)
/* Operation wrapper: */
struct __eoddata1__NewsList
{
public:
	_eoddata1__NewsList *eoddata1__NewsList;	/* optional element of XSD type eoddata1:NewsList */
public:
	int soap_type() const { return 202; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__NewsList */
	         __eoddata1__NewsList();
	friend SOAP_FMAC1 __eoddata1__NewsList * SOAP_FMAC2 soap_instantiate___eoddata1__NewsList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:4004 */
#ifndef SOAP_TYPE_eoddata___eoddata1__NewsListBySymbol
#define SOAP_TYPE_eoddata___eoddata1__NewsListBySymbol (206)
/* Operation wrapper: */
struct __eoddata1__NewsListBySymbol
{
public:
	_eoddata1__NewsListBySymbol *eoddata1__NewsListBySymbol;	/* optional element of XSD type eoddata1:NewsListBySymbol */
public:
	int soap_type() const { return 206; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__NewsListBySymbol */
	         __eoddata1__NewsListBySymbol();
	friend SOAP_FMAC1 __eoddata1__NewsListBySymbol * SOAP_FMAC2 soap_instantiate___eoddata1__NewsListBySymbol(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:4072 */
#ifndef SOAP_TYPE_eoddata___eoddata1__FundamentalList
#define SOAP_TYPE_eoddata___eoddata1__FundamentalList (210)
/* Operation wrapper: */
struct __eoddata1__FundamentalList
{
public:
	_eoddata1__FundamentalList *eoddata1__FundamentalList;	/* optional element of XSD type eoddata1:FundamentalList */
public:
	int soap_type() const { return 210; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__FundamentalList */
	         __eoddata1__FundamentalList();
	friend SOAP_FMAC1 __eoddata1__FundamentalList * SOAP_FMAC2 soap_instantiate___eoddata1__FundamentalList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:4140 */
#ifndef SOAP_TYPE_eoddata___eoddata1__TechnicalList
#define SOAP_TYPE_eoddata___eoddata1__TechnicalList (214)
/* Operation wrapper: */
struct __eoddata1__TechnicalList
{
public:
	_eoddata1__TechnicalList *eoddata1__TechnicalList;	/* optional element of XSD type eoddata1:TechnicalList */
public:
	int soap_type() const { return 214; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__TechnicalList */
	         __eoddata1__TechnicalList();
	friend SOAP_FMAC1 __eoddata1__TechnicalList * SOAP_FMAC2 soap_instantiate___eoddata1__TechnicalList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:4209 */
#ifndef SOAP_TYPE_eoddata___eoddata1__QuoteListByDate
#define SOAP_TYPE_eoddata___eoddata1__QuoteListByDate (218)
/* Operation wrapper: */
struct __eoddata1__QuoteListByDate
{
public:
	_eoddata1__QuoteListByDate *eoddata1__QuoteListByDate;	/* optional element of XSD type eoddata1:QuoteListByDate */
public:
	int soap_type() const { return 218; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__QuoteListByDate */
	         __eoddata1__QuoteListByDate();
	friend SOAP_FMAC1 __eoddata1__QuoteListByDate * SOAP_FMAC2 soap_instantiate___eoddata1__QuoteListByDate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:4278 */
#ifndef SOAP_TYPE_eoddata___eoddata1__QuoteListByDate2
#define SOAP_TYPE_eoddata___eoddata1__QuoteListByDate2 (222)
/* Operation wrapper: */
struct __eoddata1__QuoteListByDate2
{
public:
	_eoddata1__QuoteListByDate2 *eoddata1__QuoteListByDate2;	/* optional element of XSD type eoddata1:QuoteListByDate2 */
public:
	int soap_type() const { return 222; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__QuoteListByDate2 */
	         __eoddata1__QuoteListByDate2();
	friend SOAP_FMAC1 __eoddata1__QuoteListByDate2 * SOAP_FMAC2 soap_instantiate___eoddata1__QuoteListByDate2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:4348 */
#ifndef SOAP_TYPE_eoddata___eoddata1__SymbolHistory
#define SOAP_TYPE_eoddata___eoddata1__SymbolHistory (226)
/* Operation wrapper: */
struct __eoddata1__SymbolHistory
{
public:
	_eoddata1__SymbolHistory *eoddata1__SymbolHistory;	/* optional element of XSD type eoddata1:SymbolHistory */
public:
	int soap_type() const { return 226; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__SymbolHistory */
	         __eoddata1__SymbolHistory();
	friend SOAP_FMAC1 __eoddata1__SymbolHistory * SOAP_FMAC2 soap_instantiate___eoddata1__SymbolHistory(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:4416 */
#ifndef SOAP_TYPE_eoddata___eoddata1__Top10Gains
#define SOAP_TYPE_eoddata___eoddata1__Top10Gains (230)
/* Operation wrapper: */
struct __eoddata1__Top10Gains
{
public:
	_eoddata1__Top10Gains *eoddata1__Top10Gains;	/* optional element of XSD type eoddata1:Top10Gains */
public:
	int soap_type() const { return 230; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__Top10Gains */
	         __eoddata1__Top10Gains();
	friend SOAP_FMAC1 __eoddata1__Top10Gains * SOAP_FMAC2 soap_instantiate___eoddata1__Top10Gains(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:4484 */
#ifndef SOAP_TYPE_eoddata___eoddata1__Top10Losses
#define SOAP_TYPE_eoddata___eoddata1__Top10Losses (234)
/* Operation wrapper: */
struct __eoddata1__Top10Losses
{
public:
	_eoddata1__Top10Losses *eoddata1__Top10Losses;	/* optional element of XSD type eoddata1:Top10Losses */
public:
	int soap_type() const { return 234; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__Top10Losses */
	         __eoddata1__Top10Losses();
	friend SOAP_FMAC1 __eoddata1__Top10Losses * SOAP_FMAC2 soap_instantiate___eoddata1__Top10Losses(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:4552 */
#ifndef SOAP_TYPE_eoddata___eoddata1__SymbolChart
#define SOAP_TYPE_eoddata___eoddata1__SymbolChart (238)
/* Operation wrapper: */
struct __eoddata1__SymbolChart
{
public:
	_eoddata1__SymbolChart *eoddata1__SymbolChart;	/* optional element of XSD type eoddata1:SymbolChart */
public:
	int soap_type() const { return 238; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__SymbolChart */
	         __eoddata1__SymbolChart();
	friend SOAP_FMAC1 __eoddata1__SymbolChart * SOAP_FMAC2 soap_instantiate___eoddata1__SymbolChart(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:4620 */
#ifndef SOAP_TYPE_eoddata___eoddata1__ExchangeMonths
#define SOAP_TYPE_eoddata___eoddata1__ExchangeMonths (242)
/* Operation wrapper: */
struct __eoddata1__ExchangeMonths
{
public:
	_eoddata1__ExchangeMonths *eoddata1__ExchangeMonths;	/* optional element of XSD type eoddata1:ExchangeMonths */
public:
	int soap_type() const { return 242; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__ExchangeMonths */
	         __eoddata1__ExchangeMonths();
	friend SOAP_FMAC1 __eoddata1__ExchangeMonths * SOAP_FMAC2 soap_instantiate___eoddata1__ExchangeMonths(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:4688 */
#ifndef SOAP_TYPE_eoddata___eoddata1__SplitListByExchange
#define SOAP_TYPE_eoddata___eoddata1__SplitListByExchange (246)
/* Operation wrapper: */
struct __eoddata1__SplitListByExchange
{
public:
	_eoddata1__SplitListByExchange *eoddata1__SplitListByExchange;	/* optional element of XSD type eoddata1:SplitListByExchange */
public:
	int soap_type() const { return 246; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__SplitListByExchange */
	         __eoddata1__SplitListByExchange();
	friend SOAP_FMAC1 __eoddata1__SplitListByExchange * SOAP_FMAC2 soap_instantiate___eoddata1__SplitListByExchange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:4756 */
#ifndef SOAP_TYPE_eoddata___eoddata1__SplitListBySymbol
#define SOAP_TYPE_eoddata___eoddata1__SplitListBySymbol (250)
/* Operation wrapper: */
struct __eoddata1__SplitListBySymbol
{
public:
	_eoddata1__SplitListBySymbol *eoddata1__SplitListBySymbol;	/* optional element of XSD type eoddata1:SplitListBySymbol */
public:
	int soap_type() const { return 250; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__SplitListBySymbol */
	         __eoddata1__SplitListBySymbol();
	friend SOAP_FMAC1 __eoddata1__SplitListBySymbol * SOAP_FMAC2 soap_instantiate___eoddata1__SplitListBySymbol(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:4824 */
#ifndef SOAP_TYPE_eoddata___eoddata1__CountryList
#define SOAP_TYPE_eoddata___eoddata1__CountryList (254)
/* Operation wrapper: */
struct __eoddata1__CountryList
{
public:
	_eoddata1__CountryList *eoddata1__CountryList;	/* optional element of XSD type eoddata1:CountryList */
public:
	int soap_type() const { return 254; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__CountryList */
	         __eoddata1__CountryList();
	friend SOAP_FMAC1 __eoddata1__CountryList * SOAP_FMAC2 soap_instantiate___eoddata1__CountryList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:4894 */
#ifndef SOAP_TYPE_eoddata___eoddata1__SymbolHistoryPeriod
#define SOAP_TYPE_eoddata___eoddata1__SymbolHistoryPeriod (258)
/* Operation wrapper: */
struct __eoddata1__SymbolHistoryPeriod
{
public:
	_eoddata1__SymbolHistoryPeriod *eoddata1__SymbolHistoryPeriod;	/* optional element of XSD type eoddata1:SymbolHistoryPeriod */
public:
	int soap_type() const { return 258; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__SymbolHistoryPeriod */
	         __eoddata1__SymbolHistoryPeriod();
	friend SOAP_FMAC1 __eoddata1__SymbolHistoryPeriod * SOAP_FMAC2 soap_instantiate___eoddata1__SymbolHistoryPeriod(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:4964 */
#ifndef SOAP_TYPE_eoddata___eoddata1__SymbolHistoryPeriodByDateRange
#define SOAP_TYPE_eoddata___eoddata1__SymbolHistoryPeriodByDateRange (262)
/* Operation wrapper: */
struct __eoddata1__SymbolHistoryPeriodByDateRange
{
public:
	_eoddata1__SymbolHistoryPeriodByDateRange *eoddata1__SymbolHistoryPeriodByDateRange;	/* optional element of XSD type eoddata1:SymbolHistoryPeriodByDateRange */
public:
	int soap_type() const { return 262; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__SymbolHistoryPeriodByDateRange */
	         __eoddata1__SymbolHistoryPeriodByDateRange();
	friend SOAP_FMAC1 __eoddata1__SymbolHistoryPeriodByDateRange * SOAP_FMAC2 soap_instantiate___eoddata1__SymbolHistoryPeriodByDateRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:5033 */
#ifndef SOAP_TYPE_eoddata___eoddata1__QuoteListByDatePeriod
#define SOAP_TYPE_eoddata___eoddata1__QuoteListByDatePeriod (266)
/* Operation wrapper: */
struct __eoddata1__QuoteListByDatePeriod
{
public:
	_eoddata1__QuoteListByDatePeriod *eoddata1__QuoteListByDatePeriod;	/* optional element of XSD type eoddata1:QuoteListByDatePeriod */
public:
	int soap_type() const { return 266; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__QuoteListByDatePeriod */
	         __eoddata1__QuoteListByDatePeriod();
	friend SOAP_FMAC1 __eoddata1__QuoteListByDatePeriod * SOAP_FMAC2 soap_instantiate___eoddata1__QuoteListByDatePeriod(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:5103 */
#ifndef SOAP_TYPE_eoddata___eoddata1__QuoteListByDatePeriod2
#define SOAP_TYPE_eoddata___eoddata1__QuoteListByDatePeriod2 (270)
/* Operation wrapper: */
struct __eoddata1__QuoteListByDatePeriod2
{
public:
	_eoddata1__QuoteListByDatePeriod2 *eoddata1__QuoteListByDatePeriod2;	/* optional element of XSD type eoddata1:QuoteListByDatePeriod2 */
public:
	int soap_type() const { return 270; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__QuoteListByDatePeriod2 */
	         __eoddata1__QuoteListByDatePeriod2();
	friend SOAP_FMAC1 __eoddata1__QuoteListByDatePeriod2 * SOAP_FMAC2 soap_instantiate___eoddata1__QuoteListByDatePeriod2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:5171 */
#ifndef SOAP_TYPE_eoddata___eoddata1__SymbolChangesByExchange
#define SOAP_TYPE_eoddata___eoddata1__SymbolChangesByExchange (274)
/* Operation wrapper: */
struct __eoddata1__SymbolChangesByExchange
{
public:
	_eoddata1__SymbolChangesByExchange *eoddata1__SymbolChangesByExchange;	/* optional element of XSD type eoddata1:SymbolChangesByExchange */
public:
	int soap_type() const { return 274; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__SymbolChangesByExchange */
	         __eoddata1__SymbolChangesByExchange();
	friend SOAP_FMAC1 __eoddata1__SymbolChangesByExchange * SOAP_FMAC2 soap_instantiate___eoddata1__SymbolChangesByExchange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:5239 */
#ifndef SOAP_TYPE_eoddata___eoddata1__DataClientLatestVersion
#define SOAP_TYPE_eoddata___eoddata1__DataClientLatestVersion (278)
/* Operation wrapper: */
struct __eoddata1__DataClientLatestVersion
{
public:
	_eoddata1__DataClientLatestVersion *eoddata1__DataClientLatestVersion;	/* optional element of XSD type eoddata1:DataClientLatestVersion */
public:
	int soap_type() const { return 278; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__DataClientLatestVersion */
	         __eoddata1__DataClientLatestVersion();
	friend SOAP_FMAC1 __eoddata1__DataClientLatestVersion * SOAP_FMAC2 soap_instantiate___eoddata1__DataClientLatestVersion(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:5307 */
#ifndef SOAP_TYPE_eoddata___eoddata1__DataFormats
#define SOAP_TYPE_eoddata___eoddata1__DataFormats (282)
/* Operation wrapper: */
struct __eoddata1__DataFormats
{
public:
	_eoddata1__DataFormats *eoddata1__DataFormats;	/* optional element of XSD type eoddata1:DataFormats */
public:
	int soap_type() const { return 282; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__DataFormats */
	         __eoddata1__DataFormats();
	friend SOAP_FMAC1 __eoddata1__DataFormats * SOAP_FMAC2 soap_instantiate___eoddata1__DataFormats(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:5375 */
#ifndef SOAP_TYPE_eoddata___eoddata1__UpdateDataFormat
#define SOAP_TYPE_eoddata___eoddata1__UpdateDataFormat (286)
/* Operation wrapper: */
struct __eoddata1__UpdateDataFormat
{
public:
	_eoddata1__UpdateDataFormat *eoddata1__UpdateDataFormat;	/* optional element of XSD type eoddata1:UpdateDataFormat */
public:
	int soap_type() const { return 286; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__UpdateDataFormat */
	         __eoddata1__UpdateDataFormat();
	friend SOAP_FMAC1 __eoddata1__UpdateDataFormat * SOAP_FMAC2 soap_instantiate___eoddata1__UpdateDataFormat(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:5444 */
#ifndef SOAP_TYPE_eoddata___eoddata1__ValidateAccess
#define SOAP_TYPE_eoddata___eoddata1__ValidateAccess (290)
/* Operation wrapper: */
struct __eoddata1__ValidateAccess
{
public:
	_eoddata1__ValidateAccess *eoddata1__ValidateAccess;	/* optional element of XSD type eoddata1:ValidateAccess */
public:
	int soap_type() const { return 290; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__ValidateAccess */
	         __eoddata1__ValidateAccess();
	friend SOAP_FMAC1 __eoddata1__ValidateAccess * SOAP_FMAC2 soap_instantiate___eoddata1__ValidateAccess(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:5512 */
#ifndef SOAP_TYPE_eoddata___eoddata1__Login_
#define SOAP_TYPE_eoddata___eoddata1__Login_ (292)
/* Operation wrapper: */
struct __eoddata1__Login_
{
public:
	_eoddata1__Login *eoddata1__Login;	/* optional element of XSD type eoddata1:Login */
public:
	int soap_type() const { return 292; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__Login_ */
	         __eoddata1__Login_();
	friend SOAP_FMAC1 __eoddata1__Login_ * SOAP_FMAC2 soap_instantiate___eoddata1__Login_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:5580 */
#ifndef SOAP_TYPE_eoddata___eoddata1__Login2_
#define SOAP_TYPE_eoddata___eoddata1__Login2_ (294)
/* Operation wrapper: */
struct __eoddata1__Login2_
{
public:
	_eoddata1__Login2 *eoddata1__Login2;	/* optional element of XSD type eoddata1:Login2 */
public:
	int soap_type() const { return 294; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__Login2_ */
	         __eoddata1__Login2_();
	friend SOAP_FMAC1 __eoddata1__Login2_ * SOAP_FMAC2 soap_instantiate___eoddata1__Login2_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:5647 */
#ifndef SOAP_TYPE_eoddata___eoddata1__Membership_
#define SOAP_TYPE_eoddata___eoddata1__Membership_ (296)
/* Operation wrapper: */
struct __eoddata1__Membership_
{
public:
	_eoddata1__Membership *eoddata1__Membership;	/* optional element of XSD type eoddata1:Membership */
public:
	int soap_type() const { return 296; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__Membership_ */
	         __eoddata1__Membership_();
	friend SOAP_FMAC1 __eoddata1__Membership_ * SOAP_FMAC2 soap_instantiate___eoddata1__Membership_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:5715 */
#ifndef SOAP_TYPE_eoddata___eoddata1__ExchangeList_
#define SOAP_TYPE_eoddata___eoddata1__ExchangeList_ (298)
/* Operation wrapper: */
struct __eoddata1__ExchangeList_
{
public:
	_eoddata1__ExchangeList *eoddata1__ExchangeList;	/* optional element of XSD type eoddata1:ExchangeList */
public:
	int soap_type() const { return 298; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__ExchangeList_ */
	         __eoddata1__ExchangeList_();
	friend SOAP_FMAC1 __eoddata1__ExchangeList_ * SOAP_FMAC2 soap_instantiate___eoddata1__ExchangeList_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:5783 */
#ifndef SOAP_TYPE_eoddata___eoddata1__ExchangeGet_
#define SOAP_TYPE_eoddata___eoddata1__ExchangeGet_ (300)
/* Operation wrapper: */
struct __eoddata1__ExchangeGet_
{
public:
	_eoddata1__ExchangeGet *eoddata1__ExchangeGet;	/* optional element of XSD type eoddata1:ExchangeGet */
public:
	int soap_type() const { return 300; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__ExchangeGet_ */
	         __eoddata1__ExchangeGet_();
	friend SOAP_FMAC1 __eoddata1__ExchangeGet_ * SOAP_FMAC2 soap_instantiate___eoddata1__ExchangeGet_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:5851 */
#ifndef SOAP_TYPE_eoddata___eoddata1__SymbolList_
#define SOAP_TYPE_eoddata___eoddata1__SymbolList_ (302)
/* Operation wrapper: */
struct __eoddata1__SymbolList_
{
public:
	_eoddata1__SymbolList *eoddata1__SymbolList;	/* optional element of XSD type eoddata1:SymbolList */
public:
	int soap_type() const { return 302; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__SymbolList_ */
	         __eoddata1__SymbolList_();
	friend SOAP_FMAC1 __eoddata1__SymbolList_ * SOAP_FMAC2 soap_instantiate___eoddata1__SymbolList_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:5919 */
#ifndef SOAP_TYPE_eoddata___eoddata1__SymbolList2_
#define SOAP_TYPE_eoddata___eoddata1__SymbolList2_ (304)
/* Operation wrapper: */
struct __eoddata1__SymbolList2_
{
public:
	_eoddata1__SymbolList2 *eoddata1__SymbolList2;	/* optional element of XSD type eoddata1:SymbolList2 */
public:
	int soap_type() const { return 304; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__SymbolList2_ */
	         __eoddata1__SymbolList2_();
	friend SOAP_FMAC1 __eoddata1__SymbolList2_ * SOAP_FMAC2 soap_instantiate___eoddata1__SymbolList2_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:5987 */
#ifndef SOAP_TYPE_eoddata___eoddata1__QuoteGet_
#define SOAP_TYPE_eoddata___eoddata1__QuoteGet_ (306)
/* Operation wrapper: */
struct __eoddata1__QuoteGet_
{
public:
	_eoddata1__QuoteGet *eoddata1__QuoteGet;	/* optional element of XSD type eoddata1:QuoteGet */
public:
	int soap_type() const { return 306; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__QuoteGet_ */
	         __eoddata1__QuoteGet_();
	friend SOAP_FMAC1 __eoddata1__QuoteGet_ * SOAP_FMAC2 soap_instantiate___eoddata1__QuoteGet_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:6056 */
#ifndef SOAP_TYPE_eoddata___eoddata1__QuoteList2_
#define SOAP_TYPE_eoddata___eoddata1__QuoteList2_ (308)
/* Operation wrapper: */
struct __eoddata1__QuoteList2_
{
public:
	_eoddata1__QuoteList2 *eoddata1__QuoteList2;	/* optional element of XSD type eoddata1:QuoteList2 */
public:
	int soap_type() const { return 308; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__QuoteList2_ */
	         __eoddata1__QuoteList2_();
	friend SOAP_FMAC1 __eoddata1__QuoteList2_ * SOAP_FMAC2 soap_instantiate___eoddata1__QuoteList2_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:6124 */
#ifndef SOAP_TYPE_eoddata___eoddata1__SymbolGet_
#define SOAP_TYPE_eoddata___eoddata1__SymbolGet_ (310)
/* Operation wrapper: */
struct __eoddata1__SymbolGet_
{
public:
	_eoddata1__SymbolGet *eoddata1__SymbolGet;	/* optional element of XSD type eoddata1:SymbolGet */
public:
	int soap_type() const { return 310; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__SymbolGet_ */
	         __eoddata1__SymbolGet_();
	friend SOAP_FMAC1 __eoddata1__SymbolGet_ * SOAP_FMAC2 soap_instantiate___eoddata1__SymbolGet_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:6192 */
#ifndef SOAP_TYPE_eoddata___eoddata1__QuoteList_
#define SOAP_TYPE_eoddata___eoddata1__QuoteList_ (312)
/* Operation wrapper: */
struct __eoddata1__QuoteList_
{
public:
	_eoddata1__QuoteList *eoddata1__QuoteList;	/* optional element of XSD type eoddata1:QuoteList */
public:
	int soap_type() const { return 312; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__QuoteList_ */
	         __eoddata1__QuoteList_();
	friend SOAP_FMAC1 __eoddata1__QuoteList_ * SOAP_FMAC2 soap_instantiate___eoddata1__QuoteList_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:6260 */
#ifndef SOAP_TYPE_eoddata___eoddata1__NewsList_
#define SOAP_TYPE_eoddata___eoddata1__NewsList_ (314)
/* Operation wrapper: */
struct __eoddata1__NewsList_
{
public:
	_eoddata1__NewsList *eoddata1__NewsList;	/* optional element of XSD type eoddata1:NewsList */
public:
	int soap_type() const { return 314; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__NewsList_ */
	         __eoddata1__NewsList_();
	friend SOAP_FMAC1 __eoddata1__NewsList_ * SOAP_FMAC2 soap_instantiate___eoddata1__NewsList_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:6329 */
#ifndef SOAP_TYPE_eoddata___eoddata1__NewsListBySymbol_
#define SOAP_TYPE_eoddata___eoddata1__NewsListBySymbol_ (316)
/* Operation wrapper: */
struct __eoddata1__NewsListBySymbol_
{
public:
	_eoddata1__NewsListBySymbol *eoddata1__NewsListBySymbol;	/* optional element of XSD type eoddata1:NewsListBySymbol */
public:
	int soap_type() const { return 316; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__NewsListBySymbol_ */
	         __eoddata1__NewsListBySymbol_();
	friend SOAP_FMAC1 __eoddata1__NewsListBySymbol_ * SOAP_FMAC2 soap_instantiate___eoddata1__NewsListBySymbol_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:6397 */
#ifndef SOAP_TYPE_eoddata___eoddata1__FundamentalList_
#define SOAP_TYPE_eoddata___eoddata1__FundamentalList_ (318)
/* Operation wrapper: */
struct __eoddata1__FundamentalList_
{
public:
	_eoddata1__FundamentalList *eoddata1__FundamentalList;	/* optional element of XSD type eoddata1:FundamentalList */
public:
	int soap_type() const { return 318; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__FundamentalList_ */
	         __eoddata1__FundamentalList_();
	friend SOAP_FMAC1 __eoddata1__FundamentalList_ * SOAP_FMAC2 soap_instantiate___eoddata1__FundamentalList_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:6465 */
#ifndef SOAP_TYPE_eoddata___eoddata1__TechnicalList_
#define SOAP_TYPE_eoddata___eoddata1__TechnicalList_ (320)
/* Operation wrapper: */
struct __eoddata1__TechnicalList_
{
public:
	_eoddata1__TechnicalList *eoddata1__TechnicalList;	/* optional element of XSD type eoddata1:TechnicalList */
public:
	int soap_type() const { return 320; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__TechnicalList_ */
	         __eoddata1__TechnicalList_();
	friend SOAP_FMAC1 __eoddata1__TechnicalList_ * SOAP_FMAC2 soap_instantiate___eoddata1__TechnicalList_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:6534 */
#ifndef SOAP_TYPE_eoddata___eoddata1__QuoteListByDate_
#define SOAP_TYPE_eoddata___eoddata1__QuoteListByDate_ (322)
/* Operation wrapper: */
struct __eoddata1__QuoteListByDate_
{
public:
	_eoddata1__QuoteListByDate *eoddata1__QuoteListByDate;	/* optional element of XSD type eoddata1:QuoteListByDate */
public:
	int soap_type() const { return 322; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__QuoteListByDate_ */
	         __eoddata1__QuoteListByDate_();
	friend SOAP_FMAC1 __eoddata1__QuoteListByDate_ * SOAP_FMAC2 soap_instantiate___eoddata1__QuoteListByDate_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:6603 */
#ifndef SOAP_TYPE_eoddata___eoddata1__QuoteListByDate2_
#define SOAP_TYPE_eoddata___eoddata1__QuoteListByDate2_ (324)
/* Operation wrapper: */
struct __eoddata1__QuoteListByDate2_
{
public:
	_eoddata1__QuoteListByDate2 *eoddata1__QuoteListByDate2;	/* optional element of XSD type eoddata1:QuoteListByDate2 */
public:
	int soap_type() const { return 324; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__QuoteListByDate2_ */
	         __eoddata1__QuoteListByDate2_();
	friend SOAP_FMAC1 __eoddata1__QuoteListByDate2_ * SOAP_FMAC2 soap_instantiate___eoddata1__QuoteListByDate2_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:6673 */
#ifndef SOAP_TYPE_eoddata___eoddata1__SymbolHistory_
#define SOAP_TYPE_eoddata___eoddata1__SymbolHistory_ (326)
/* Operation wrapper: */
struct __eoddata1__SymbolHistory_
{
public:
	_eoddata1__SymbolHistory *eoddata1__SymbolHistory;	/* optional element of XSD type eoddata1:SymbolHistory */
public:
	int soap_type() const { return 326; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__SymbolHistory_ */
	         __eoddata1__SymbolHistory_();
	friend SOAP_FMAC1 __eoddata1__SymbolHistory_ * SOAP_FMAC2 soap_instantiate___eoddata1__SymbolHistory_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:6741 */
#ifndef SOAP_TYPE_eoddata___eoddata1__Top10Gains_
#define SOAP_TYPE_eoddata___eoddata1__Top10Gains_ (328)
/* Operation wrapper: */
struct __eoddata1__Top10Gains_
{
public:
	_eoddata1__Top10Gains *eoddata1__Top10Gains;	/* optional element of XSD type eoddata1:Top10Gains */
public:
	int soap_type() const { return 328; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__Top10Gains_ */
	         __eoddata1__Top10Gains_();
	friend SOAP_FMAC1 __eoddata1__Top10Gains_ * SOAP_FMAC2 soap_instantiate___eoddata1__Top10Gains_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:6809 */
#ifndef SOAP_TYPE_eoddata___eoddata1__Top10Losses_
#define SOAP_TYPE_eoddata___eoddata1__Top10Losses_ (330)
/* Operation wrapper: */
struct __eoddata1__Top10Losses_
{
public:
	_eoddata1__Top10Losses *eoddata1__Top10Losses;	/* optional element of XSD type eoddata1:Top10Losses */
public:
	int soap_type() const { return 330; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__Top10Losses_ */
	         __eoddata1__Top10Losses_();
	friend SOAP_FMAC1 __eoddata1__Top10Losses_ * SOAP_FMAC2 soap_instantiate___eoddata1__Top10Losses_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:6877 */
#ifndef SOAP_TYPE_eoddata___eoddata1__SymbolChart_
#define SOAP_TYPE_eoddata___eoddata1__SymbolChart_ (332)
/* Operation wrapper: */
struct __eoddata1__SymbolChart_
{
public:
	_eoddata1__SymbolChart *eoddata1__SymbolChart;	/* optional element of XSD type eoddata1:SymbolChart */
public:
	int soap_type() const { return 332; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__SymbolChart_ */
	         __eoddata1__SymbolChart_();
	friend SOAP_FMAC1 __eoddata1__SymbolChart_ * SOAP_FMAC2 soap_instantiate___eoddata1__SymbolChart_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:6945 */
#ifndef SOAP_TYPE_eoddata___eoddata1__ExchangeMonths_
#define SOAP_TYPE_eoddata___eoddata1__ExchangeMonths_ (334)
/* Operation wrapper: */
struct __eoddata1__ExchangeMonths_
{
public:
	_eoddata1__ExchangeMonths *eoddata1__ExchangeMonths;	/* optional element of XSD type eoddata1:ExchangeMonths */
public:
	int soap_type() const { return 334; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__ExchangeMonths_ */
	         __eoddata1__ExchangeMonths_();
	friend SOAP_FMAC1 __eoddata1__ExchangeMonths_ * SOAP_FMAC2 soap_instantiate___eoddata1__ExchangeMonths_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:7013 */
#ifndef SOAP_TYPE_eoddata___eoddata1__SplitListByExchange_
#define SOAP_TYPE_eoddata___eoddata1__SplitListByExchange_ (336)
/* Operation wrapper: */
struct __eoddata1__SplitListByExchange_
{
public:
	_eoddata1__SplitListByExchange *eoddata1__SplitListByExchange;	/* optional element of XSD type eoddata1:SplitListByExchange */
public:
	int soap_type() const { return 336; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__SplitListByExchange_ */
	         __eoddata1__SplitListByExchange_();
	friend SOAP_FMAC1 __eoddata1__SplitListByExchange_ * SOAP_FMAC2 soap_instantiate___eoddata1__SplitListByExchange_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:7081 */
#ifndef SOAP_TYPE_eoddata___eoddata1__SplitListBySymbol_
#define SOAP_TYPE_eoddata___eoddata1__SplitListBySymbol_ (338)
/* Operation wrapper: */
struct __eoddata1__SplitListBySymbol_
{
public:
	_eoddata1__SplitListBySymbol *eoddata1__SplitListBySymbol;	/* optional element of XSD type eoddata1:SplitListBySymbol */
public:
	int soap_type() const { return 338; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__SplitListBySymbol_ */
	         __eoddata1__SplitListBySymbol_();
	friend SOAP_FMAC1 __eoddata1__SplitListBySymbol_ * SOAP_FMAC2 soap_instantiate___eoddata1__SplitListBySymbol_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:7149 */
#ifndef SOAP_TYPE_eoddata___eoddata1__CountryList_
#define SOAP_TYPE_eoddata___eoddata1__CountryList_ (340)
/* Operation wrapper: */
struct __eoddata1__CountryList_
{
public:
	_eoddata1__CountryList *eoddata1__CountryList;	/* optional element of XSD type eoddata1:CountryList */
public:
	int soap_type() const { return 340; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__CountryList_ */
	         __eoddata1__CountryList_();
	friend SOAP_FMAC1 __eoddata1__CountryList_ * SOAP_FMAC2 soap_instantiate___eoddata1__CountryList_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:7219 */
#ifndef SOAP_TYPE_eoddata___eoddata1__SymbolHistoryPeriod_
#define SOAP_TYPE_eoddata___eoddata1__SymbolHistoryPeriod_ (342)
/* Operation wrapper: */
struct __eoddata1__SymbolHistoryPeriod_
{
public:
	_eoddata1__SymbolHistoryPeriod *eoddata1__SymbolHistoryPeriod;	/* optional element of XSD type eoddata1:SymbolHistoryPeriod */
public:
	int soap_type() const { return 342; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__SymbolHistoryPeriod_ */
	         __eoddata1__SymbolHistoryPeriod_();
	friend SOAP_FMAC1 __eoddata1__SymbolHistoryPeriod_ * SOAP_FMAC2 soap_instantiate___eoddata1__SymbolHistoryPeriod_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:7289 */
#ifndef SOAP_TYPE_eoddata___eoddata1__SymbolHistoryPeriodByDateRange_
#define SOAP_TYPE_eoddata___eoddata1__SymbolHistoryPeriodByDateRange_ (344)
/* Operation wrapper: */
struct __eoddata1__SymbolHistoryPeriodByDateRange_
{
public:
	_eoddata1__SymbolHistoryPeriodByDateRange *eoddata1__SymbolHistoryPeriodByDateRange;	/* optional element of XSD type eoddata1:SymbolHistoryPeriodByDateRange */
public:
	int soap_type() const { return 344; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__SymbolHistoryPeriodByDateRange_ */
	         __eoddata1__SymbolHistoryPeriodByDateRange_();
	friend SOAP_FMAC1 __eoddata1__SymbolHistoryPeriodByDateRange_ * SOAP_FMAC2 soap_instantiate___eoddata1__SymbolHistoryPeriodByDateRange_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:7358 */
#ifndef SOAP_TYPE_eoddata___eoddata1__QuoteListByDatePeriod_
#define SOAP_TYPE_eoddata___eoddata1__QuoteListByDatePeriod_ (346)
/* Operation wrapper: */
struct __eoddata1__QuoteListByDatePeriod_
{
public:
	_eoddata1__QuoteListByDatePeriod *eoddata1__QuoteListByDatePeriod;	/* optional element of XSD type eoddata1:QuoteListByDatePeriod */
public:
	int soap_type() const { return 346; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__QuoteListByDatePeriod_ */
	         __eoddata1__QuoteListByDatePeriod_();
	friend SOAP_FMAC1 __eoddata1__QuoteListByDatePeriod_ * SOAP_FMAC2 soap_instantiate___eoddata1__QuoteListByDatePeriod_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:7428 */
#ifndef SOAP_TYPE_eoddata___eoddata1__QuoteListByDatePeriod2_
#define SOAP_TYPE_eoddata___eoddata1__QuoteListByDatePeriod2_ (348)
/* Operation wrapper: */
struct __eoddata1__QuoteListByDatePeriod2_
{
public:
	_eoddata1__QuoteListByDatePeriod2 *eoddata1__QuoteListByDatePeriod2;	/* optional element of XSD type eoddata1:QuoteListByDatePeriod2 */
public:
	int soap_type() const { return 348; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__QuoteListByDatePeriod2_ */
	         __eoddata1__QuoteListByDatePeriod2_();
	friend SOAP_FMAC1 __eoddata1__QuoteListByDatePeriod2_ * SOAP_FMAC2 soap_instantiate___eoddata1__QuoteListByDatePeriod2_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:7496 */
#ifndef SOAP_TYPE_eoddata___eoddata1__SymbolChangesByExchange_
#define SOAP_TYPE_eoddata___eoddata1__SymbolChangesByExchange_ (350)
/* Operation wrapper: */
struct __eoddata1__SymbolChangesByExchange_
{
public:
	_eoddata1__SymbolChangesByExchange *eoddata1__SymbolChangesByExchange;	/* optional element of XSD type eoddata1:SymbolChangesByExchange */
public:
	int soap_type() const { return 350; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__SymbolChangesByExchange_ */
	         __eoddata1__SymbolChangesByExchange_();
	friend SOAP_FMAC1 __eoddata1__SymbolChangesByExchange_ * SOAP_FMAC2 soap_instantiate___eoddata1__SymbolChangesByExchange_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:7564 */
#ifndef SOAP_TYPE_eoddata___eoddata1__DataClientLatestVersion_
#define SOAP_TYPE_eoddata___eoddata1__DataClientLatestVersion_ (352)
/* Operation wrapper: */
struct __eoddata1__DataClientLatestVersion_
{
public:
	_eoddata1__DataClientLatestVersion *eoddata1__DataClientLatestVersion;	/* optional element of XSD type eoddata1:DataClientLatestVersion */
public:
	int soap_type() const { return 352; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__DataClientLatestVersion_ */
	         __eoddata1__DataClientLatestVersion_();
	friend SOAP_FMAC1 __eoddata1__DataClientLatestVersion_ * SOAP_FMAC2 soap_instantiate___eoddata1__DataClientLatestVersion_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:7632 */
#ifndef SOAP_TYPE_eoddata___eoddata1__DataFormats_
#define SOAP_TYPE_eoddata___eoddata1__DataFormats_ (354)
/* Operation wrapper: */
struct __eoddata1__DataFormats_
{
public:
	_eoddata1__DataFormats *eoddata1__DataFormats;	/* optional element of XSD type eoddata1:DataFormats */
public:
	int soap_type() const { return 354; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__DataFormats_ */
	         __eoddata1__DataFormats_();
	friend SOAP_FMAC1 __eoddata1__DataFormats_ * SOAP_FMAC2 soap_instantiate___eoddata1__DataFormats_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:7700 */
#ifndef SOAP_TYPE_eoddata___eoddata1__UpdateDataFormat_
#define SOAP_TYPE_eoddata___eoddata1__UpdateDataFormat_ (356)
/* Operation wrapper: */
struct __eoddata1__UpdateDataFormat_
{
public:
	_eoddata1__UpdateDataFormat *eoddata1__UpdateDataFormat;	/* optional element of XSD type eoddata1:UpdateDataFormat */
public:
	int soap_type() const { return 356; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__UpdateDataFormat_ */
	         __eoddata1__UpdateDataFormat_();
	friend SOAP_FMAC1 __eoddata1__UpdateDataFormat_ * SOAP_FMAC2 soap_instantiate___eoddata1__UpdateDataFormat_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:7769 */
#ifndef SOAP_TYPE_eoddata___eoddata1__ValidateAccess_
#define SOAP_TYPE_eoddata___eoddata1__ValidateAccess_ (358)
/* Operation wrapper: */
struct __eoddata1__ValidateAccess_
{
public:
	_eoddata1__ValidateAccess *eoddata1__ValidateAccess;	/* optional element of XSD type eoddata1:ValidateAccess */
public:
	int soap_type() const { return 358; } /* = unique type id SOAP_TYPE_eoddata___eoddata1__ValidateAccess_ */
	         __eoddata1__ValidateAccess_();
	friend SOAP_FMAC1 __eoddata1__ValidateAccess_ * SOAP_FMAC2 soap_instantiate___eoddata1__ValidateAccess_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddata.h:8377 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_eoddata_SOAP_ENV__Header
#define SOAP_TYPE_eoddata_SOAP_ENV__Header (359)
/* SOAP Header: */
struct SOAP_ENV__Header
{
public:
	int soap_type() const { return 359; } /* = unique type id SOAP_TYPE_eoddata_SOAP_ENV__Header */
	         SOAP_ENV__Header();
	friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* eoddata.h:8377 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_eoddata_SOAP_ENV__Code
#define SOAP_TYPE_eoddata_SOAP_ENV__Code (360)
/* Type SOAP_ENV__Code is a recursive data type (in)directly referencing itself through its (base) class members */
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of XSD type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of XSD type SOAP-ENV:Code */
public:
	int soap_type() const { return 360; } /* = unique type id SOAP_TYPE_eoddata_SOAP_ENV__Code */
	         SOAP_ENV__Code();
	friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* eoddata.h:8377 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_eoddata_SOAP_ENV__Detail
#define SOAP_TYPE_eoddata_SOAP_ENV__Detail (362)
/* SOAP-ENV:Detail complex type: */
struct SOAP_ENV__Detail
{
public:
	char *__any;
	int __type;	/* any type of element <fault> (defined below)
	   WARNING: do not create a cyclic data structure graph throught this element unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
	void *fault;	/* transient (not serialized) */
public:
	int soap_type() const { return 362; } /* = unique type id SOAP_TYPE_eoddata_SOAP_ENV__Detail */
	         SOAP_ENV__Detail();
	friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* eoddata.h:8377 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_eoddata_SOAP_ENV__Reason
#define SOAP_TYPE_eoddata_SOAP_ENV__Reason (365)
/* SOAP-ENV:Reason complex type: */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of XSD type xsd:string */
public:
	int soap_type() const { return 365; } /* = unique type id SOAP_TYPE_eoddata_SOAP_ENV__Reason */
	         SOAP_ENV__Reason();
	friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* eoddata.h:8377 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_eoddata_SOAP_ENV__Fault
#define SOAP_TYPE_eoddata_SOAP_ENV__Fault (366)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of XSD type xsd:QName */
	char *faultstring;	/* optional element of XSD type xsd:string */
	char *faultactor;	/* optional element of XSD type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of XSD type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of XSD type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of XSD type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of XSD type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of XSD type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of XSD type SOAP-ENV:Detail */
public:
	int soap_type() const { return 366; } /* = unique type id SOAP_TYPE_eoddata_SOAP_ENV__Fault */
	         SOAP_ENV__Fault();
	friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* eoddata.h:1 */
#ifndef SOAP_TYPE_eoddata__QName
#define SOAP_TYPE_eoddata__QName (5)
typedef char *_QName;
#endif

/* eoddata.h:1 */
#ifndef SOAP_TYPE_eoddata__XML
#define SOAP_TYPE_eoddata__XML (6)
typedef char *_XML;
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


} // namespace eoddata


#endif

/* End of eoddataStub.h */
