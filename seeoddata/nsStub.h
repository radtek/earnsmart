/* nsStub.h
   Generated by gSOAP 2.8.28 from eoddatawebservice.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include <deque>
#include <list>
#include <vector>
#include <set>
#define SOAP_NAMESPACE_OF_ns1	"http://ws.eoddata.com/Data"

#ifndef nsStub_H
#define nsStub_H
#ifndef WITH_NOGLOBAL
#define WITH_NOGLOBAL
#endif
#include "stdsoap2.h"
#if GSOAP_VERSION != 20828
# error "GSOAP VERSION 20828 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


namespace ns {

/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes, Structs, and Unions                                               *
 *                                                                            *
\******************************************************************************/

class ns1__LOGINRESPONSE;	/* eoddatawebservice.h:154 */
class ns1__RESPONSE;	/* eoddatawebservice.h:157 */
class ns1__EXCHANGE;	/* eoddatawebservice.h:160 */
class ns1__ArrayOfEXCHANGE;	/* eoddatawebservice.h:163 */
class ns1__SYMBOL;	/* eoddatawebservice.h:166 */
class ns1__ArrayOfSYMBOL;	/* eoddatawebservice.h:169 */
class ns1__ArrayOfSYMBOL2;	/* eoddatawebservice.h:172 */
class ns1__SYMBOL2;	/* eoddatawebservice.h:175 */
class ns1__QUOTE;	/* eoddatawebservice.h:178 */
class ns1__ArrayOfQUOTE;	/* eoddatawebservice.h:181 */
class ns1__ArrayOfQUOTE2;	/* eoddatawebservice.h:184 */
class ns1__QUOTE2;	/* eoddatawebservice.h:187 */
class ns1__ArrayOfSPLIT;	/* eoddatawebservice.h:190 */
class ns1__SPLIT;	/* eoddatawebservice.h:193 */
class ns1__ArrayOfCountryBase;	/* eoddatawebservice.h:196 */
class ns1__CountryBase;	/* eoddatawebservice.h:199 */
class ns1__ArrayOfFUNDAMENTAL;	/* eoddatawebservice.h:202 */
class ns1__FUNDAMENTAL;	/* eoddatawebservice.h:205 */
class ns1__ArrayOfTECHNICAL;	/* eoddatawebservice.h:208 */
class ns1__TECHNICAL;	/* eoddatawebservice.h:211 */
class ns1__ArrayOfSYMBOLCHANGE;	/* eoddatawebservice.h:214 */
class ns1__SYMBOLCHANGE;	/* eoddatawebservice.h:217 */
class ns1__ArrayOfNEWS;	/* eoddatawebservice.h:220 */
class ns1__NEWS;	/* eoddatawebservice.h:223 */
class ns1__ArrayOfDATAFORMAT;	/* eoddatawebservice.h:226 */
class ns1__DATAFORMAT;	/* eoddatawebservice.h:229 */
class ns1__ArrayOfDATAFORMAT_USCORECOLUMN;	/* eoddatawebservice.h:232 */
class ns1__DATAFORMAT_USCORECOLUMN;	/* eoddatawebservice.h:235 */
class _ns1__Login;	/* eoddatawebservice.h:238 */
class _ns1__LoginResponse;	/* eoddatawebservice.h:241 */
class _ns1__Login2;	/* eoddatawebservice.h:244 */
class _ns1__Login2Response;	/* eoddatawebservice.h:247 */
class _ns1__Membership;	/* eoddatawebservice.h:250 */
class _ns1__MembershipResponse;	/* eoddatawebservice.h:253 */
class _ns1__ExchangeList;	/* eoddatawebservice.h:256 */
class _ns1__ExchangeListResponse;	/* eoddatawebservice.h:259 */
class _ns1__ExchangeGet;	/* eoddatawebservice.h:262 */
class _ns1__ExchangeGetResponse;	/* eoddatawebservice.h:265 */
class _ns1__SymbolList;	/* eoddatawebservice.h:268 */
class _ns1__SymbolListResponse;	/* eoddatawebservice.h:271 */
class _ns1__SymbolList2;	/* eoddatawebservice.h:274 */
class _ns1__SymbolList2Response;	/* eoddatawebservice.h:277 */
class _ns1__QuoteGet;	/* eoddatawebservice.h:280 */
class _ns1__QuoteGetResponse;	/* eoddatawebservice.h:283 */
class _ns1__QuoteList2;	/* eoddatawebservice.h:286 */
class _ns1__QuoteList2Response;	/* eoddatawebservice.h:289 */
class _ns1__SymbolGet;	/* eoddatawebservice.h:292 */
class _ns1__SymbolGetResponse;	/* eoddatawebservice.h:295 */
class _ns1__QuoteList;	/* eoddatawebservice.h:298 */
class _ns1__QuoteListResponse;	/* eoddatawebservice.h:301 */
class _ns1__NewsList;	/* eoddatawebservice.h:304 */
class _ns1__NewsListResponse;	/* eoddatawebservice.h:307 */
class _ns1__NewsListBySymbol;	/* eoddatawebservice.h:310 */
class _ns1__NewsListBySymbolResponse;	/* eoddatawebservice.h:313 */
class _ns1__FundamentalList;	/* eoddatawebservice.h:316 */
class _ns1__FundamentalListResponse;	/* eoddatawebservice.h:319 */
class _ns1__TechnicalList;	/* eoddatawebservice.h:322 */
class _ns1__TechnicalListResponse;	/* eoddatawebservice.h:325 */
class _ns1__QuoteListByDate;	/* eoddatawebservice.h:328 */
class _ns1__QuoteListByDateResponse;	/* eoddatawebservice.h:331 */
class _ns1__QuoteListByDate2;	/* eoddatawebservice.h:334 */
class _ns1__QuoteListByDate2Response;	/* eoddatawebservice.h:337 */
class _ns1__SymbolHistory;	/* eoddatawebservice.h:340 */
class _ns1__SymbolHistoryResponse;	/* eoddatawebservice.h:343 */
class _ns1__Top10Gains;	/* eoddatawebservice.h:346 */
class _ns1__Top10GainsResponse;	/* eoddatawebservice.h:349 */
class _ns1__Top10Losses;	/* eoddatawebservice.h:352 */
class _ns1__Top10LossesResponse;	/* eoddatawebservice.h:355 */
class _ns1__SymbolChart;	/* eoddatawebservice.h:358 */
class _ns1__SymbolChartResponse;	/* eoddatawebservice.h:361 */
class _ns1__ExchangeMonths;	/* eoddatawebservice.h:364 */
class _ns1__ExchangeMonthsResponse;	/* eoddatawebservice.h:367 */
class _ns1__SplitListByExchange;	/* eoddatawebservice.h:370 */
class _ns1__SplitListByExchangeResponse;	/* eoddatawebservice.h:373 */
class _ns1__SplitListBySymbol;	/* eoddatawebservice.h:376 */
class _ns1__SplitListBySymbolResponse;	/* eoddatawebservice.h:379 */
class _ns1__CountryList;	/* eoddatawebservice.h:382 */
class _ns1__CountryListResponse;	/* eoddatawebservice.h:385 */
class _ns1__SymbolHistoryPeriod;	/* eoddatawebservice.h:388 */
class _ns1__SymbolHistoryPeriodResponse;	/* eoddatawebservice.h:391 */
class _ns1__SymbolHistoryPeriodByDateRange;	/* eoddatawebservice.h:394 */
class _ns1__SymbolHistoryPeriodByDateRangeResponse;	/* eoddatawebservice.h:397 */
class _ns1__QuoteListByDatePeriod;	/* eoddatawebservice.h:400 */
class _ns1__QuoteListByDatePeriodResponse;	/* eoddatawebservice.h:403 */
class _ns1__QuoteListByDatePeriod2;	/* eoddatawebservice.h:406 */
class _ns1__QuoteListByDatePeriod2Response;	/* eoddatawebservice.h:409 */
class _ns1__SymbolChangesByExchange;	/* eoddatawebservice.h:412 */
class _ns1__SymbolChangesByExchangeResponse;	/* eoddatawebservice.h:415 */
class _ns1__DataClientLatestVersion;	/* eoddatawebservice.h:418 */
class _ns1__DataClientLatestVersionResponse;	/* eoddatawebservice.h:421 */
class _ns1__DataFormats;	/* eoddatawebservice.h:424 */
class _ns1__DataFormatsResponse;	/* eoddatawebservice.h:427 */
class _ns1__UpdateDataFormat;	/* eoddatawebservice.h:430 */
class _ns1__UpdateDataFormatResponse;	/* eoddatawebservice.h:433 */
class _ns1__ValidateAccess;	/* eoddatawebservice.h:436 */
class _ns1__ValidateAccessResponse;	/* eoddatawebservice.h:439 */
struct __ns1__Login;	/* eoddatawebservice.h:3323 */
struct __ns1__Login2;	/* eoddatawebservice.h:3391 */
struct __ns1__Membership;	/* eoddatawebservice.h:3458 */
struct __ns1__ExchangeList;	/* eoddatawebservice.h:3526 */
struct __ns1__ExchangeGet;	/* eoddatawebservice.h:3594 */
struct __ns1__SymbolList;	/* eoddatawebservice.h:3662 */
struct __ns1__SymbolList2;	/* eoddatawebservice.h:3730 */
struct __ns1__QuoteGet;	/* eoddatawebservice.h:3798 */
struct __ns1__QuoteList2;	/* eoddatawebservice.h:3867 */
struct __ns1__SymbolGet;	/* eoddatawebservice.h:3935 */
struct __ns1__QuoteList;	/* eoddatawebservice.h:4003 */
struct __ns1__NewsList;	/* eoddatawebservice.h:4071 */
struct __ns1__NewsListBySymbol;	/* eoddatawebservice.h:4140 */
struct __ns1__FundamentalList;	/* eoddatawebservice.h:4208 */
struct __ns1__TechnicalList;	/* eoddatawebservice.h:4276 */
struct __ns1__QuoteListByDate;	/* eoddatawebservice.h:4345 */
struct __ns1__QuoteListByDate2;	/* eoddatawebservice.h:4414 */
struct __ns1__SymbolHistory;	/* eoddatawebservice.h:4484 */
struct __ns1__Top10Gains;	/* eoddatawebservice.h:4552 */
struct __ns1__Top10Losses;	/* eoddatawebservice.h:4620 */
struct __ns1__SymbolChart;	/* eoddatawebservice.h:4688 */
struct __ns1__ExchangeMonths;	/* eoddatawebservice.h:4756 */
struct __ns1__SplitListByExchange;	/* eoddatawebservice.h:4824 */
struct __ns1__SplitListBySymbol;	/* eoddatawebservice.h:4892 */
struct __ns1__CountryList;	/* eoddatawebservice.h:4960 */
struct __ns1__SymbolHistoryPeriod;	/* eoddatawebservice.h:5030 */
struct __ns1__SymbolHistoryPeriodByDateRange;	/* eoddatawebservice.h:5100 */
struct __ns1__QuoteListByDatePeriod;	/* eoddatawebservice.h:5169 */
struct __ns1__QuoteListByDatePeriod2;	/* eoddatawebservice.h:5239 */
struct __ns1__SymbolChangesByExchange;	/* eoddatawebservice.h:5307 */
struct __ns1__DataClientLatestVersion;	/* eoddatawebservice.h:5375 */
struct __ns1__DataFormats;	/* eoddatawebservice.h:5443 */
struct __ns1__UpdateDataFormat;	/* eoddatawebservice.h:5511 */
struct __ns1__ValidateAccess;	/* eoddatawebservice.h:5580 */
struct __ns1__Login_;	/* eoddatawebservice.h:5648 */
struct __ns1__Login2_;	/* eoddatawebservice.h:5716 */
struct __ns1__Membership_;	/* eoddatawebservice.h:5783 */
struct __ns1__ExchangeList_;	/* eoddatawebservice.h:5851 */
struct __ns1__ExchangeGet_;	/* eoddatawebservice.h:5919 */
struct __ns1__SymbolList_;	/* eoddatawebservice.h:5987 */
struct __ns1__SymbolList2_;	/* eoddatawebservice.h:6055 */
struct __ns1__QuoteGet_;	/* eoddatawebservice.h:6123 */
struct __ns1__QuoteList2_;	/* eoddatawebservice.h:6192 */
struct __ns1__SymbolGet_;	/* eoddatawebservice.h:6260 */
struct __ns1__QuoteList_;	/* eoddatawebservice.h:6328 */
struct __ns1__NewsList_;	/* eoddatawebservice.h:6396 */
struct __ns1__NewsListBySymbol_;	/* eoddatawebservice.h:6465 */
struct __ns1__FundamentalList_;	/* eoddatawebservice.h:6533 */
struct __ns1__TechnicalList_;	/* eoddatawebservice.h:6601 */
struct __ns1__QuoteListByDate_;	/* eoddatawebservice.h:6670 */
struct __ns1__QuoteListByDate2_;	/* eoddatawebservice.h:6739 */
struct __ns1__SymbolHistory_;	/* eoddatawebservice.h:6809 */
struct __ns1__Top10Gains_;	/* eoddatawebservice.h:6877 */
struct __ns1__Top10Losses_;	/* eoddatawebservice.h:6945 */
struct __ns1__SymbolChart_;	/* eoddatawebservice.h:7013 */
struct __ns1__ExchangeMonths_;	/* eoddatawebservice.h:7081 */
struct __ns1__SplitListByExchange_;	/* eoddatawebservice.h:7149 */
struct __ns1__SplitListBySymbol_;	/* eoddatawebservice.h:7217 */
struct __ns1__CountryList_;	/* eoddatawebservice.h:7285 */
struct __ns1__SymbolHistoryPeriod_;	/* eoddatawebservice.h:7355 */
struct __ns1__SymbolHistoryPeriodByDateRange_;	/* eoddatawebservice.h:7425 */
struct __ns1__QuoteListByDatePeriod_;	/* eoddatawebservice.h:7494 */
struct __ns1__QuoteListByDatePeriod2_;	/* eoddatawebservice.h:7564 */
struct __ns1__SymbolChangesByExchange_;	/* eoddatawebservice.h:7632 */
struct __ns1__DataClientLatestVersion_;	/* eoddatawebservice.h:7700 */
struct __ns1__DataFormats_;	/* eoddatawebservice.h:7768 */
struct __ns1__UpdateDataFormat_;	/* eoddatawebservice.h:7836 */
struct __ns1__ValidateAccess_;	/* eoddatawebservice.h:7905 */
struct __ns1__LoginResponse__;	/* eoddatawebservice.h:7967 */
struct __ns1__Login2Response__;	/* eoddatawebservice.h:8029 */
struct __ns1__MembershipResponse__;	/* eoddatawebservice.h:8090 */
struct __ns1__ExchangeListResponse__;	/* eoddatawebservice.h:8152 */
struct __ns1__ExchangeGetResponse__;	/* eoddatawebservice.h:8214 */
struct __ns1__SymbolListResponse__;	/* eoddatawebservice.h:8276 */
struct __ns1__SymbolList2Response__;	/* eoddatawebservice.h:8338 */
struct __ns1__QuoteGetResponse__;	/* eoddatawebservice.h:8400 */
struct __ns1__QuoteList2Response__;	/* eoddatawebservice.h:8463 */
struct __ns1__SymbolGetResponse__;	/* eoddatawebservice.h:8525 */
struct __ns1__QuoteListResponse__;	/* eoddatawebservice.h:8587 */
struct __ns1__NewsListResponse__;	/* eoddatawebservice.h:8649 */
struct __ns1__NewsListBySymbolResponse__;	/* eoddatawebservice.h:8712 */
struct __ns1__FundamentalListResponse__;	/* eoddatawebservice.h:8774 */
struct __ns1__TechnicalListResponse__;	/* eoddatawebservice.h:8836 */
struct __ns1__QuoteListByDateResponse__;	/* eoddatawebservice.h:8899 */
struct __ns1__QuoteListByDate2Response__;	/* eoddatawebservice.h:8962 */
struct __ns1__SymbolHistoryResponse__;	/* eoddatawebservice.h:9026 */
struct __ns1__Top10GainsResponse__;	/* eoddatawebservice.h:9088 */
struct __ns1__Top10LossesResponse__;	/* eoddatawebservice.h:9150 */
struct __ns1__SymbolChartResponse__;	/* eoddatawebservice.h:9212 */
struct __ns1__ExchangeMonthsResponse__;	/* eoddatawebservice.h:9274 */
struct __ns1__SplitListByExchangeResponse__;	/* eoddatawebservice.h:9336 */
struct __ns1__SplitListBySymbolResponse__;	/* eoddatawebservice.h:9398 */
struct __ns1__CountryListResponse__;	/* eoddatawebservice.h:9460 */
struct __ns1__SymbolHistoryPeriodResponse__;	/* eoddatawebservice.h:9524 */
struct __ns1__SymbolHistoryPeriodByDateRangeResponse__;	/* eoddatawebservice.h:9588 */
struct __ns1__QuoteListByDatePeriodResponse__;	/* eoddatawebservice.h:9651 */
struct __ns1__QuoteListByDatePeriod2Response__;	/* eoddatawebservice.h:9715 */
struct __ns1__SymbolChangesByExchangeResponse__;	/* eoddatawebservice.h:9777 */
struct __ns1__DataClientLatestVersionResponse__;	/* eoddatawebservice.h:9839 */
struct __ns1__DataFormatsResponse__;	/* eoddatawebservice.h:9901 */
struct __ns1__UpdateDataFormatResponse__;	/* eoddatawebservice.h:9963 */
struct __ns1__ValidateAccessResponse__;	/* eoddatawebservice.h:10026 */
struct __ns1__Login___;	/* eoddatawebservice.h:10099 */
struct __ns1__Login2___;	/* eoddatawebservice.h:10175 */
struct __ns1__Membership___;	/* eoddatawebservice.h:10244 */
struct __ns1__ExchangeList___;	/* eoddatawebservice.h:10314 */
struct __ns1__ExchangeGet___;	/* eoddatawebservice.h:10387 */
struct __ns1__SymbolList___;	/* eoddatawebservice.h:10460 */
struct __ns1__SymbolList2___;	/* eoddatawebservice.h:10533 */
struct __ns1__QuoteGet___;	/* eoddatawebservice.h:10609 */
struct __ns1__QuoteList2___;	/* eoddatawebservice.h:10686 */
struct __ns1__SymbolGet___;	/* eoddatawebservice.h:10762 */
struct __ns1__QuoteList___;	/* eoddatawebservice.h:10835 */
struct __ns1__NewsList___;	/* eoddatawebservice.h:10908 */
struct __ns1__NewsListBySymbol___;	/* eoddatawebservice.h:10985 */
struct __ns1__FundamentalList___;	/* eoddatawebservice.h:11058 */
struct __ns1__TechnicalList___;	/* eoddatawebservice.h:11131 */
struct __ns1__QuoteListByDate___;	/* eoddatawebservice.h:11208 */
struct __ns1__QuoteListByDate2___;	/* eoddatawebservice.h:11285 */
struct __ns1__SymbolHistory___;	/* eoddatawebservice.h:11366 */
struct __ns1__Top10Gains___;	/* eoddatawebservice.h:11439 */
struct __ns1__Top10Losses___;	/* eoddatawebservice.h:11512 */
struct __ns1__SymbolChart___;	/* eoddatawebservice.h:11588 */
struct __ns1__ExchangeMonths___;	/* eoddatawebservice.h:11661 */
struct __ns1__SplitListByExchange___;	/* eoddatawebservice.h:11734 */
struct __ns1__SplitListBySymbol___;	/* eoddatawebservice.h:11810 */
struct __ns1__CountryList___;	/* eoddatawebservice.h:11880 */
struct __ns1__SymbolHistoryPeriod___;	/* eoddatawebservice.h:11964 */
struct __ns1__SymbolHistoryPeriodByDateRange___;	/* eoddatawebservice.h:12051 */
struct __ns1__QuoteListByDatePeriod___;	/* eoddatawebservice.h:12131 */
struct __ns1__QuoteListByDatePeriod2___;	/* eoddatawebservice.h:12212 */
struct __ns1__SymbolChangesByExchange___;	/* eoddatawebservice.h:12285 */
struct __ns1__DataClientLatestVersion___;	/* eoddatawebservice.h:12355 */
struct __ns1__DataFormats___;	/* eoddatawebservice.h:12425 */
struct __ns1__UpdateDataFormat___;	/* eoddatawebservice.h:12504 */
struct __ns1__ValidateAccess___;	/* eoddatawebservice.h:12584 */

/* eoddatawebservice.h:154 */
#ifndef SOAP_TYPE_ns_ns1__LOGINRESPONSE
#define SOAP_TYPE_ns_ns1__LOGINRESPONSE (11)
/* ns1:LOGINRESPONSE complex type: */
class SOAP_CMAC ns1__LOGINRESPONSE
{
public:
	std::string *Message;	/* optional attribute of XSD type xsd:string */
	std::string *Token;	/* optional attribute of XSD type xsd:string */
	std::string *DataFormat;	/* optional attribute of XSD type xsd:string */
	bool Header;	/* required attribute of XSD type xsd:boolean */
	bool Suffix;	/* required attribute of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns_ns1__LOGINRESPONSE (11)
	virtual int soap_type(void) const { return 11; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__LOGINRESPONSE, default initialized and not managed by a soap context
	virtual ns1__LOGINRESPONSE *soap_alloc(void) const { return SOAP_NEW(ns1__LOGINRESPONSE); }
	         ns1__LOGINRESPONSE() { ns1__LOGINRESPONSE::soap_default(NULL); }
	virtual ~ns1__LOGINRESPONSE() { }
	friend SOAP_FMAC1 ns1__LOGINRESPONSE * SOAP_FMAC2 soap_instantiate_ns1__LOGINRESPONSE(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:157 */
#ifndef SOAP_TYPE_ns_ns1__RESPONSE
#define SOAP_TYPE_ns_ns1__RESPONSE (12)
/* ns1:RESPONSE complex type: */
class SOAP_CMAC ns1__RESPONSE
{
public:
	ns1__EXCHANGE *EXCHANGE;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type ns1:EXCHANGE */
	ns1__ArrayOfEXCHANGE *EXCHANGES;	/* optional element of XSD type ns1:ArrayOfEXCHANGE */
	ns1__SYMBOL *SYMBOL;	/* optional element of XSD type ns1:SYMBOL */
	ns1__ArrayOfSYMBOL *SYMBOLS;	/* optional element of XSD type ns1:ArrayOfSYMBOL */
	ns1__ArrayOfSYMBOL2 *SYMBOLS2;	/* optional element of XSD type ns1:ArrayOfSYMBOL2 */
	ns1__QUOTE *QUOTE;	/* optional element of XSD type ns1:QUOTE */
	ns1__ArrayOfQUOTE *QUOTES;	/* optional element of XSD type ns1:ArrayOfQUOTE */
	ns1__ArrayOfQUOTE2 *QUOTES2;	/* optional element of XSD type ns1:ArrayOfQUOTE2 */
	ns1__ArrayOfSPLIT *SPLITS;	/* optional element of XSD type ns1:ArrayOfSPLIT */
	ns1__ArrayOfCountryBase *COUNTRIES;	/* optional element of XSD type ns1:ArrayOfCountryBase */
	ns1__ArrayOfFUNDAMENTAL *FUNDAMENTALS;	/* optional element of XSD type ns1:ArrayOfFUNDAMENTAL */
	ns1__ArrayOfTECHNICAL *TECHNICALS;	/* optional element of XSD type ns1:ArrayOfTECHNICAL */
	ns1__ArrayOfSYMBOLCHANGE *SYMBOLCHANGES;	/* optional element of XSD type ns1:ArrayOfSYMBOLCHANGE */
	ns1__ArrayOfNEWS *NEWSLIST;	/* optional element of XSD type ns1:ArrayOfNEWS */
	std::string *CHART;	/* optional element of XSD type xsd:string */
	std::string *MEMBERSHIP;	/* optional element of XSD type xsd:string */
	std::string *VERSION;	/* optional element of XSD type xsd:string */
	std::string *MONTHS;	/* optional element of XSD type xsd:string */
	ns1__ArrayOfDATAFORMAT *DATAFORMATS;	/* optional element of XSD type ns1:ArrayOfDATAFORMAT */
	std::string *Source;	/* optional attribute of XSD type xsd:string */
	std::string *Message;	/* optional attribute of XSD type xsd:string */
	time_t Date;	/* required attribute of XSD type xsd:dateTime */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns_ns1__RESPONSE (12)
	virtual int soap_type(void) const { return 12; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__RESPONSE, default initialized and not managed by a soap context
	virtual ns1__RESPONSE *soap_alloc(void) const { return SOAP_NEW(ns1__RESPONSE); }
	         ns1__RESPONSE() { ns1__RESPONSE::soap_default(NULL); }
	virtual ~ns1__RESPONSE() { }
	friend SOAP_FMAC1 ns1__RESPONSE * SOAP_FMAC2 soap_instantiate_ns1__RESPONSE(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:160 */
#ifndef SOAP_TYPE_ns_ns1__EXCHANGE
#define SOAP_TYPE_ns_ns1__EXCHANGE (13)
/* ns1:EXCHANGE complex type: */
class SOAP_CMAC ns1__EXCHANGE
{
public:
	std::string *Code;	/* optional attribute of XSD type xsd:string */
	std::string *Name;	/* optional attribute of XSD type xsd:string */
	time_t LastTradeDateTime;	/* required attribute of XSD type xsd:dateTime */
	std::string *Country;	/* optional attribute of XSD type xsd:string */
	std::string *Currency;	/* optional attribute of XSD type xsd:string */
	int Advances;	/* required attribute of XSD type xsd:int */
	int Declines;	/* required attribute of XSD type xsd:int */
	std::string *Suffix;	/* optional attribute of XSD type xsd:string */
	std::string *TimeZone;	/* optional attribute of XSD type xsd:string */
	bool IsIntraday;	/* required attribute of XSD type xsd:boolean */
	time_t IntradayStartDate;	/* required attribute of XSD type xsd:dateTime */
	bool HasIntradayProduct;	/* required attribute of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns_ns1__EXCHANGE (13)
	virtual int soap_type(void) const { return 13; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__EXCHANGE, default initialized and not managed by a soap context
	virtual ns1__EXCHANGE *soap_alloc(void) const { return SOAP_NEW(ns1__EXCHANGE); }
	         ns1__EXCHANGE() { ns1__EXCHANGE::soap_default(NULL); }
	virtual ~ns1__EXCHANGE() { }
	friend SOAP_FMAC1 ns1__EXCHANGE * SOAP_FMAC2 soap_instantiate_ns1__EXCHANGE(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:163 */
#ifndef SOAP_TYPE_ns_ns1__ArrayOfEXCHANGE
#define SOAP_TYPE_ns_ns1__ArrayOfEXCHANGE (14)
/* ns1:ArrayOfEXCHANGE complex type: */
class SOAP_CMAC ns1__ArrayOfEXCHANGE
{
public:
	std::vector<ns1__EXCHANGE *> EXCHANGE;	/* optional element of XSD type ns1:EXCHANGE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns_ns1__ArrayOfEXCHANGE (14)
	virtual int soap_type(void) const { return 14; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__ArrayOfEXCHANGE, default initialized and not managed by a soap context
	virtual ns1__ArrayOfEXCHANGE *soap_alloc(void) const { return SOAP_NEW(ns1__ArrayOfEXCHANGE); }
	         ns1__ArrayOfEXCHANGE() { ns1__ArrayOfEXCHANGE::soap_default(NULL); }
	virtual ~ns1__ArrayOfEXCHANGE() { }
	friend SOAP_FMAC1 ns1__ArrayOfEXCHANGE * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfEXCHANGE(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:166 */
#ifndef SOAP_TYPE_ns_ns1__SYMBOL
#define SOAP_TYPE_ns_ns1__SYMBOL (15)
/* ns1:SYMBOL complex type: */
class SOAP_CMAC ns1__SYMBOL
{
public:
	std::string *Code;	/* optional attribute of XSD type xsd:string */
	std::string *Name;	/* optional attribute of XSD type xsd:string */
	std::string *LongName;	/* optional attribute of XSD type xsd:string */
	time_t DateTime;	/* required attribute of XSD type xsd:dateTime */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns_ns1__SYMBOL (15)
	virtual int soap_type(void) const { return 15; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__SYMBOL, default initialized and not managed by a soap context
	virtual ns1__SYMBOL *soap_alloc(void) const { return SOAP_NEW(ns1__SYMBOL); }
	         ns1__SYMBOL() { ns1__SYMBOL::soap_default(NULL); }
	virtual ~ns1__SYMBOL() { }
	friend SOAP_FMAC1 ns1__SYMBOL * SOAP_FMAC2 soap_instantiate_ns1__SYMBOL(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:169 */
#ifndef SOAP_TYPE_ns_ns1__ArrayOfSYMBOL
#define SOAP_TYPE_ns_ns1__ArrayOfSYMBOL (16)
/* ns1:ArrayOfSYMBOL complex type: */
class SOAP_CMAC ns1__ArrayOfSYMBOL
{
public:
	std::vector<ns1__SYMBOL *> SYMBOL;	/* optional element of XSD type ns1:SYMBOL */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns_ns1__ArrayOfSYMBOL (16)
	virtual int soap_type(void) const { return 16; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__ArrayOfSYMBOL, default initialized and not managed by a soap context
	virtual ns1__ArrayOfSYMBOL *soap_alloc(void) const { return SOAP_NEW(ns1__ArrayOfSYMBOL); }
	         ns1__ArrayOfSYMBOL() { ns1__ArrayOfSYMBOL::soap_default(NULL); }
	virtual ~ns1__ArrayOfSYMBOL() { }
	friend SOAP_FMAC1 ns1__ArrayOfSYMBOL * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfSYMBOL(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:172 */
#ifndef SOAP_TYPE_ns_ns1__ArrayOfSYMBOL2
#define SOAP_TYPE_ns_ns1__ArrayOfSYMBOL2 (17)
/* ns1:ArrayOfSYMBOL2 complex type: */
class SOAP_CMAC ns1__ArrayOfSYMBOL2
{
public:
	std::vector<ns1__SYMBOL2 *> SYMBOL2;	/* optional element of XSD type ns1:SYMBOL2 */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns_ns1__ArrayOfSYMBOL2 (17)
	virtual int soap_type(void) const { return 17; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__ArrayOfSYMBOL2, default initialized and not managed by a soap context
	virtual ns1__ArrayOfSYMBOL2 *soap_alloc(void) const { return SOAP_NEW(ns1__ArrayOfSYMBOL2); }
	         ns1__ArrayOfSYMBOL2() { ns1__ArrayOfSYMBOL2::soap_default(NULL); }
	virtual ~ns1__ArrayOfSYMBOL2() { }
	friend SOAP_FMAC1 ns1__ArrayOfSYMBOL2 * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfSYMBOL2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:175 */
#ifndef SOAP_TYPE_ns_ns1__SYMBOL2
#define SOAP_TYPE_ns_ns1__SYMBOL2 (18)
/* ns1:SYMBOL2 complex type: */
class SOAP_CMAC ns1__SYMBOL2
{
public:
	std::string *c;	/* optional attribute of XSD type xsd:string */
	std::string *n;	/* optional attribute of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns_ns1__SYMBOL2 (18)
	virtual int soap_type(void) const { return 18; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__SYMBOL2, default initialized and not managed by a soap context
	virtual ns1__SYMBOL2 *soap_alloc(void) const { return SOAP_NEW(ns1__SYMBOL2); }
	         ns1__SYMBOL2() { ns1__SYMBOL2::soap_default(NULL); }
	virtual ~ns1__SYMBOL2() { }
	friend SOAP_FMAC1 ns1__SYMBOL2 * SOAP_FMAC2 soap_instantiate_ns1__SYMBOL2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:178 */
#ifndef SOAP_TYPE_ns_ns1__QUOTE
#define SOAP_TYPE_ns_ns1__QUOTE (19)
/* ns1:QUOTE complex type: */
class SOAP_CMAC ns1__QUOTE
{
public:
	std::string *Symbol;	/* optional attribute of XSD type xsd:string */
	std::string *Description;	/* optional attribute of XSD type xsd:string */
	std::string *Name;	/* optional attribute of XSD type xsd:string */
	time_t DateTime;	/* required attribute of XSD type xsd:dateTime */
	double Open;	/* required attribute of XSD type xsd:double */
	double High;	/* required attribute of XSD type xsd:double */
	double Low;	/* required attribute of XSD type xsd:double */
	double Close;	/* required attribute of XSD type xsd:double */
	LONG64 Volume;	/* required attribute of XSD type xsd:long */
	LONG64 OpenInterest;	/* required attribute of XSD type xsd:long */
	double Previous;	/* required attribute of XSD type xsd:double */
	double Change;	/* required attribute of XSD type xsd:double */
	double Bid;	/* required attribute of XSD type xsd:double */
	double Ask;	/* required attribute of XSD type xsd:double */
	double PreviousClose;	/* required attribute of XSD type xsd:double */
	double NextOpen;	/* required attribute of XSD type xsd:double */
	time_t Modified;	/* required attribute of XSD type xsd:dateTime */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns_ns1__QUOTE (19)
	virtual int soap_type(void) const { return 19; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__QUOTE, default initialized and not managed by a soap context
	virtual ns1__QUOTE *soap_alloc(void) const { return SOAP_NEW(ns1__QUOTE); }
	         ns1__QUOTE() { ns1__QUOTE::soap_default(NULL); }
	virtual ~ns1__QUOTE() { }
	friend SOAP_FMAC1 ns1__QUOTE * SOAP_FMAC2 soap_instantiate_ns1__QUOTE(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:181 */
#ifndef SOAP_TYPE_ns_ns1__ArrayOfQUOTE
#define SOAP_TYPE_ns_ns1__ArrayOfQUOTE (20)
/* ns1:ArrayOfQUOTE complex type: */
class SOAP_CMAC ns1__ArrayOfQUOTE
{
public:
	std::vector<ns1__QUOTE *> QUOTE;	/* optional element of XSD type ns1:QUOTE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns_ns1__ArrayOfQUOTE (20)
	virtual int soap_type(void) const { return 20; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__ArrayOfQUOTE, default initialized and not managed by a soap context
	virtual ns1__ArrayOfQUOTE *soap_alloc(void) const { return SOAP_NEW(ns1__ArrayOfQUOTE); }
	         ns1__ArrayOfQUOTE() { ns1__ArrayOfQUOTE::soap_default(NULL); }
	virtual ~ns1__ArrayOfQUOTE() { }
	friend SOAP_FMAC1 ns1__ArrayOfQUOTE * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfQUOTE(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:184 */
#ifndef SOAP_TYPE_ns_ns1__ArrayOfQUOTE2
#define SOAP_TYPE_ns_ns1__ArrayOfQUOTE2 (21)
/* ns1:ArrayOfQUOTE2 complex type: */
class SOAP_CMAC ns1__ArrayOfQUOTE2
{
public:
	std::vector<ns1__QUOTE2 *> QUOTE2;	/* optional element of XSD type ns1:QUOTE2 */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns_ns1__ArrayOfQUOTE2 (21)
	virtual int soap_type(void) const { return 21; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__ArrayOfQUOTE2, default initialized and not managed by a soap context
	virtual ns1__ArrayOfQUOTE2 *soap_alloc(void) const { return SOAP_NEW(ns1__ArrayOfQUOTE2); }
	         ns1__ArrayOfQUOTE2() { ns1__ArrayOfQUOTE2::soap_default(NULL); }
	virtual ~ns1__ArrayOfQUOTE2() { }
	friend SOAP_FMAC1 ns1__ArrayOfQUOTE2 * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfQUOTE2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:187 */
#ifndef SOAP_TYPE_ns_ns1__QUOTE2
#define SOAP_TYPE_ns_ns1__QUOTE2 (22)
/* ns1:QUOTE2 complex type: */
class SOAP_CMAC ns1__QUOTE2
{
public:
	std::string *s;	/* optional attribute of XSD type xsd:string */
	time_t d;	/* required attribute of XSD type xsd:dateTime */
	double o;	/* required attribute of XSD type xsd:double */
	double h;	/* required attribute of XSD type xsd:double */
	double l;	/* required attribute of XSD type xsd:double */
	double c;	/* required attribute of XSD type xsd:double */
	LONG64 v;	/* required attribute of XSD type xsd:long */
	LONG64 i;	/* required attribute of XSD type xsd:long */
	double b;	/* required attribute of XSD type xsd:double */
	double a;	/* required attribute of XSD type xsd:double */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns_ns1__QUOTE2 (22)
	virtual int soap_type(void) const { return 22; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__QUOTE2, default initialized and not managed by a soap context
	virtual ns1__QUOTE2 *soap_alloc(void) const { return SOAP_NEW(ns1__QUOTE2); }
	         ns1__QUOTE2() { ns1__QUOTE2::soap_default(NULL); }
	virtual ~ns1__QUOTE2() { }
	friend SOAP_FMAC1 ns1__QUOTE2 * SOAP_FMAC2 soap_instantiate_ns1__QUOTE2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:190 */
#ifndef SOAP_TYPE_ns_ns1__ArrayOfSPLIT
#define SOAP_TYPE_ns_ns1__ArrayOfSPLIT (23)
/* ns1:ArrayOfSPLIT complex type: */
class SOAP_CMAC ns1__ArrayOfSPLIT
{
public:
	std::vector<ns1__SPLIT *> SPLIT;	/* optional element of XSD type ns1:SPLIT */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns_ns1__ArrayOfSPLIT (23)
	virtual int soap_type(void) const { return 23; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__ArrayOfSPLIT, default initialized and not managed by a soap context
	virtual ns1__ArrayOfSPLIT *soap_alloc(void) const { return SOAP_NEW(ns1__ArrayOfSPLIT); }
	         ns1__ArrayOfSPLIT() { ns1__ArrayOfSPLIT::soap_default(NULL); }
	virtual ~ns1__ArrayOfSPLIT() { }
	friend SOAP_FMAC1 ns1__ArrayOfSPLIT * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfSPLIT(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:193 */
#ifndef SOAP_TYPE_ns_ns1__SPLIT
#define SOAP_TYPE_ns_ns1__SPLIT (24)
/* ns1:SPLIT complex type: */
class SOAP_CMAC ns1__SPLIT
{
public:
	std::string *Exchange;	/* optional attribute of XSD type xsd:string */
	std::string *Symbol;	/* optional attribute of XSD type xsd:string */
	time_t DateTime;	/* required attribute of XSD type xsd:dateTime */
	std::string *Ratio;	/* optional attribute of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns_ns1__SPLIT (24)
	virtual int soap_type(void) const { return 24; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__SPLIT, default initialized and not managed by a soap context
	virtual ns1__SPLIT *soap_alloc(void) const { return SOAP_NEW(ns1__SPLIT); }
	         ns1__SPLIT() { ns1__SPLIT::soap_default(NULL); }
	virtual ~ns1__SPLIT() { }
	friend SOAP_FMAC1 ns1__SPLIT * SOAP_FMAC2 soap_instantiate_ns1__SPLIT(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:196 */
#ifndef SOAP_TYPE_ns_ns1__ArrayOfCountryBase
#define SOAP_TYPE_ns_ns1__ArrayOfCountryBase (25)
/* ns1:ArrayOfCountryBase complex type: */
class SOAP_CMAC ns1__ArrayOfCountryBase
{
public:
	std::vector<ns1__CountryBase *> CountryBase;	/* optional element of XSD type ns1:CountryBase */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns_ns1__ArrayOfCountryBase (25)
	virtual int soap_type(void) const { return 25; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__ArrayOfCountryBase, default initialized and not managed by a soap context
	virtual ns1__ArrayOfCountryBase *soap_alloc(void) const { return SOAP_NEW(ns1__ArrayOfCountryBase); }
	         ns1__ArrayOfCountryBase() { ns1__ArrayOfCountryBase::soap_default(NULL); }
	virtual ~ns1__ArrayOfCountryBase() { }
	friend SOAP_FMAC1 ns1__ArrayOfCountryBase * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfCountryBase(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:199 */
#ifndef SOAP_TYPE_ns_ns1__CountryBase
#define SOAP_TYPE_ns_ns1__CountryBase (26)
/* ns1:CountryBase complex type: */
class SOAP_CMAC ns1__CountryBase
{
public:
	std::string *Code;	/* optional attribute of XSD type xsd:string */
	std::string *Name;	/* optional attribute of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns_ns1__CountryBase (26)
	virtual int soap_type(void) const { return 26; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__CountryBase, default initialized and not managed by a soap context
	virtual ns1__CountryBase *soap_alloc(void) const { return SOAP_NEW(ns1__CountryBase); }
	         ns1__CountryBase() { ns1__CountryBase::soap_default(NULL); }
	virtual ~ns1__CountryBase() { }
	friend SOAP_FMAC1 ns1__CountryBase * SOAP_FMAC2 soap_instantiate_ns1__CountryBase(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:202 */
#ifndef SOAP_TYPE_ns_ns1__ArrayOfFUNDAMENTAL
#define SOAP_TYPE_ns_ns1__ArrayOfFUNDAMENTAL (27)
/* ns1:ArrayOfFUNDAMENTAL complex type: */
class SOAP_CMAC ns1__ArrayOfFUNDAMENTAL
{
public:
	std::vector<ns1__FUNDAMENTAL *> FUNDAMENTAL;	/* optional element of XSD type ns1:FUNDAMENTAL */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns_ns1__ArrayOfFUNDAMENTAL (27)
	virtual int soap_type(void) const { return 27; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__ArrayOfFUNDAMENTAL, default initialized and not managed by a soap context
	virtual ns1__ArrayOfFUNDAMENTAL *soap_alloc(void) const { return SOAP_NEW(ns1__ArrayOfFUNDAMENTAL); }
	         ns1__ArrayOfFUNDAMENTAL() { ns1__ArrayOfFUNDAMENTAL::soap_default(NULL); }
	virtual ~ns1__ArrayOfFUNDAMENTAL() { }
	friend SOAP_FMAC1 ns1__ArrayOfFUNDAMENTAL * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfFUNDAMENTAL(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:205 */
#ifndef SOAP_TYPE_ns_ns1__FUNDAMENTAL
#define SOAP_TYPE_ns_ns1__FUNDAMENTAL (28)
/* ns1:FUNDAMENTAL complex type: */
class SOAP_CMAC ns1__FUNDAMENTAL
{
public:
	std::string *Symbol;	/* optional attribute of XSD type xsd:string */
	std::string *Name;	/* optional attribute of XSD type xsd:string */
	std::string *Description;	/* optional attribute of XSD type xsd:string */
	time_t DateTime;	/* required attribute of XSD type xsd:dateTime */
	std::string *Industry;	/* optional attribute of XSD type xsd:string */
	std::string *Sector;	/* optional attribute of XSD type xsd:string */
	LONG64 Shares;	/* required attribute of XSD type xsd:long */
	LONG64 MarketCap;	/* required attribute of XSD type xsd:long */
	double PE;	/* required attribute of XSD type xsd:double */
	double EPS;	/* required attribute of XSD type xsd:double */
	double NTA;	/* required attribute of XSD type xsd:double */
	double DivYield;	/* required attribute of XSD type xsd:double */
	double Dividend;	/* required attribute of XSD type xsd:double */
	time_t DividendDate;	/* required attribute of XSD type xsd:dateTime */
	double DPS;	/* required attribute of XSD type xsd:double */
	double ImputationCredits;	/* required attribute of XSD type xsd:double */
	double EBITDA;	/* required attribute of XSD type xsd:double */
	double PEG;	/* required attribute of XSD type xsd:double */
	double PtS;	/* required attribute of XSD type xsd:double */
	double PtB;	/* required attribute of XSD type xsd:double */
	double Yield;	/* required attribute of XSD type xsd:double */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns_ns1__FUNDAMENTAL (28)
	virtual int soap_type(void) const { return 28; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__FUNDAMENTAL, default initialized and not managed by a soap context
	virtual ns1__FUNDAMENTAL *soap_alloc(void) const { return SOAP_NEW(ns1__FUNDAMENTAL); }
	         ns1__FUNDAMENTAL() { ns1__FUNDAMENTAL::soap_default(NULL); }
	virtual ~ns1__FUNDAMENTAL() { }
	friend SOAP_FMAC1 ns1__FUNDAMENTAL * SOAP_FMAC2 soap_instantiate_ns1__FUNDAMENTAL(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:208 */
#ifndef SOAP_TYPE_ns_ns1__ArrayOfTECHNICAL
#define SOAP_TYPE_ns_ns1__ArrayOfTECHNICAL (29)
/* ns1:ArrayOfTECHNICAL complex type: */
class SOAP_CMAC ns1__ArrayOfTECHNICAL
{
public:
	std::vector<ns1__TECHNICAL *> TECHNICAL;	/* optional element of XSD type ns1:TECHNICAL */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns_ns1__ArrayOfTECHNICAL (29)
	virtual int soap_type(void) const { return 29; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__ArrayOfTECHNICAL, default initialized and not managed by a soap context
	virtual ns1__ArrayOfTECHNICAL *soap_alloc(void) const { return SOAP_NEW(ns1__ArrayOfTECHNICAL); }
	         ns1__ArrayOfTECHNICAL() { ns1__ArrayOfTECHNICAL::soap_default(NULL); }
	virtual ~ns1__ArrayOfTECHNICAL() { }
	friend SOAP_FMAC1 ns1__ArrayOfTECHNICAL * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfTECHNICAL(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:211 */
#ifndef SOAP_TYPE_ns_ns1__TECHNICAL
#define SOAP_TYPE_ns_ns1__TECHNICAL (30)
/* ns1:TECHNICAL complex type: */
class SOAP_CMAC ns1__TECHNICAL
{
public:
	std::string *Symbol;	/* optional attribute of XSD type xsd:string */
	std::string *Name;	/* optional attribute of XSD type xsd:string */
	std::string *Description;	/* optional attribute of XSD type xsd:string */
	time_t DateTime;	/* required attribute of XSD type xsd:dateTime */
	double Previous;	/* required attribute of XSD type xsd:double */
	double Change;	/* required attribute of XSD type xsd:double */
	int MA1;	/* required attribute of XSD type xsd:int */
	int MA2;	/* required attribute of XSD type xsd:int */
	int MA5;	/* required attribute of XSD type xsd:int */
	int MA20;	/* required attribute of XSD type xsd:int */
	int MA50;	/* required attribute of XSD type xsd:int */
	int MA100;	/* required attribute of XSD type xsd:int */
	int MA200;	/* required attribute of XSD type xsd:int */
	double MAPercent;	/* required attribute of XSD type xsd:double */
	double MAReturn;	/* required attribute of XSD type xsd:double */
	LONG64 VolumeChange;	/* required attribute of XSD type xsd:long */
	double ThreeMonthChange;	/* required attribute of XSD type xsd:double */
	double SixMonthChange;	/* required attribute of XSD type xsd:double */
	double WeekHigh;	/* required attribute of XSD type xsd:double */
	double WeekLow;	/* required attribute of XSD type xsd:double */
	double WeekChange;	/* required attribute of XSD type xsd:double */
	double AvgWeekChange;	/* required attribute of XSD type xsd:double */
	double AvgWeekVolume;	/* required attribute of XSD type xsd:double */
	double WeekVolume;	/* required attribute of XSD type xsd:double */
	double MonthHigh;	/* required attribute of XSD type xsd:double */
	double MonthLow;	/* required attribute of XSD type xsd:double */
	double MonthChange;	/* required attribute of XSD type xsd:double */
	double AvgMonthChange;	/* required attribute of XSD type xsd:double */
	double AvgMonthVolume;	/* required attribute of XSD type xsd:double */
	double MonthVolume;	/* required attribute of XSD type xsd:double */
	double YearHigh;	/* required attribute of XSD type xsd:double */
	double YearLow;	/* required attribute of XSD type xsd:double */
	double YearChange;	/* required attribute of XSD type xsd:double */
	double AvgYearChange;	/* required attribute of XSD type xsd:double */
	double AvgYearVolume;	/* required attribute of XSD type xsd:double */
	double YTDChange;	/* required attribute of XSD type xsd:double */
	double RSI14;	/* required attribute of XSD type xsd:double */
	double STO9;	/* required attribute of XSD type xsd:double */
	double WPR14;	/* required attribute of XSD type xsd:double */
	double MTM14;	/* required attribute of XSD type xsd:double */
	double ROC14;	/* required attribute of XSD type xsd:double */
	LONG64 PTC;	/* required attribute of XSD type xsd:long */
	double SAR;	/* required attribute of XSD type xsd:double */
	double Volatility;	/* required attribute of XSD type xsd:double */
	double Liquidity;	/* required attribute of XSD type xsd:double */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns_ns1__TECHNICAL (30)
	virtual int soap_type(void) const { return 30; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__TECHNICAL, default initialized and not managed by a soap context
	virtual ns1__TECHNICAL *soap_alloc(void) const { return SOAP_NEW(ns1__TECHNICAL); }
	         ns1__TECHNICAL() { ns1__TECHNICAL::soap_default(NULL); }
	virtual ~ns1__TECHNICAL() { }
	friend SOAP_FMAC1 ns1__TECHNICAL * SOAP_FMAC2 soap_instantiate_ns1__TECHNICAL(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:214 */
#ifndef SOAP_TYPE_ns_ns1__ArrayOfSYMBOLCHANGE
#define SOAP_TYPE_ns_ns1__ArrayOfSYMBOLCHANGE (31)
/* ns1:ArrayOfSYMBOLCHANGE complex type: */
class SOAP_CMAC ns1__ArrayOfSYMBOLCHANGE
{
public:
	std::vector<ns1__SYMBOLCHANGE *> SYMBOLCHANGE;	/* optional element of XSD type ns1:SYMBOLCHANGE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns_ns1__ArrayOfSYMBOLCHANGE (31)
	virtual int soap_type(void) const { return 31; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__ArrayOfSYMBOLCHANGE, default initialized and not managed by a soap context
	virtual ns1__ArrayOfSYMBOLCHANGE *soap_alloc(void) const { return SOAP_NEW(ns1__ArrayOfSYMBOLCHANGE); }
	         ns1__ArrayOfSYMBOLCHANGE() { ns1__ArrayOfSYMBOLCHANGE::soap_default(NULL); }
	virtual ~ns1__ArrayOfSYMBOLCHANGE() { }
	friend SOAP_FMAC1 ns1__ArrayOfSYMBOLCHANGE * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfSYMBOLCHANGE(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:217 */
#ifndef SOAP_TYPE_ns_ns1__SYMBOLCHANGE
#define SOAP_TYPE_ns_ns1__SYMBOLCHANGE (32)
/* ns1:SYMBOLCHANGE complex type: */
class SOAP_CMAC ns1__SYMBOLCHANGE
{
public:
	time_t DateTime;	/* required attribute of XSD type xsd:dateTime */
	std::string *OldSymbol;	/* optional attribute of XSD type xsd:string */
	std::string *NewSymbol;	/* optional attribute of XSD type xsd:string */
	std::string *ExchangeCode;	/* optional attribute of XSD type xsd:string */
	std::string *NewExchangeCode;	/* optional attribute of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns_ns1__SYMBOLCHANGE (32)
	virtual int soap_type(void) const { return 32; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__SYMBOLCHANGE, default initialized and not managed by a soap context
	virtual ns1__SYMBOLCHANGE *soap_alloc(void) const { return SOAP_NEW(ns1__SYMBOLCHANGE); }
	         ns1__SYMBOLCHANGE() { ns1__SYMBOLCHANGE::soap_default(NULL); }
	virtual ~ns1__SYMBOLCHANGE() { }
	friend SOAP_FMAC1 ns1__SYMBOLCHANGE * SOAP_FMAC2 soap_instantiate_ns1__SYMBOLCHANGE(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:220 */
#ifndef SOAP_TYPE_ns_ns1__ArrayOfNEWS
#define SOAP_TYPE_ns_ns1__ArrayOfNEWS (33)
/* ns1:ArrayOfNEWS complex type: */
class SOAP_CMAC ns1__ArrayOfNEWS
{
public:
	std::vector<ns1__NEWS *> NEWS;	/* optional element of XSD type ns1:NEWS */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns_ns1__ArrayOfNEWS (33)
	virtual int soap_type(void) const { return 33; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__ArrayOfNEWS, default initialized and not managed by a soap context
	virtual ns1__ArrayOfNEWS *soap_alloc(void) const { return SOAP_NEW(ns1__ArrayOfNEWS); }
	         ns1__ArrayOfNEWS() { ns1__ArrayOfNEWS::soap_default(NULL); }
	virtual ~ns1__ArrayOfNEWS() { }
	friend SOAP_FMAC1 ns1__ArrayOfNEWS * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfNEWS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:223 */
#ifndef SOAP_TYPE_ns_ns1__NEWS
#define SOAP_TYPE_ns_ns1__NEWS (34)
/* ns1:NEWS complex type: */
class SOAP_CMAC ns1__NEWS
{
public:
	std::string *Exchange;	/* optional attribute of XSD type xsd:string */
	std::string *Symbol;	/* optional attribute of XSD type xsd:string */
	LONG64 Id;	/* required attribute of XSD type xsd:long */
	std::string *SourceKey;	/* optional attribute of XSD type xsd:string */
	time_t DateTime;	/* required attribute of XSD type xsd:dateTime */
	std::string *Headline;	/* optional attribute of XSD type xsd:string */
	std::string *Introduction;	/* optional attribute of XSD type xsd:string */
	std::string *Story;	/* optional attribute of XSD type xsd:string */
	std::string *Caption;	/* optional attribute of XSD type xsd:string */
	int Views;	/* required attribute of XSD type xsd:int */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns_ns1__NEWS (34)
	virtual int soap_type(void) const { return 34; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__NEWS, default initialized and not managed by a soap context
	virtual ns1__NEWS *soap_alloc(void) const { return SOAP_NEW(ns1__NEWS); }
	         ns1__NEWS() { ns1__NEWS::soap_default(NULL); }
	virtual ~ns1__NEWS() { }
	friend SOAP_FMAC1 ns1__NEWS * SOAP_FMAC2 soap_instantiate_ns1__NEWS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:226 */
#ifndef SOAP_TYPE_ns_ns1__ArrayOfDATAFORMAT
#define SOAP_TYPE_ns_ns1__ArrayOfDATAFORMAT (35)
/* ns1:ArrayOfDATAFORMAT complex type: */
class SOAP_CMAC ns1__ArrayOfDATAFORMAT
{
public:
	std::vector<ns1__DATAFORMAT *> DATAFORMAT;	/* optional element of XSD type ns1:DATAFORMAT */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns_ns1__ArrayOfDATAFORMAT (35)
	virtual int soap_type(void) const { return 35; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__ArrayOfDATAFORMAT, default initialized and not managed by a soap context
	virtual ns1__ArrayOfDATAFORMAT *soap_alloc(void) const { return SOAP_NEW(ns1__ArrayOfDATAFORMAT); }
	         ns1__ArrayOfDATAFORMAT() { ns1__ArrayOfDATAFORMAT::soap_default(NULL); }
	virtual ~ns1__ArrayOfDATAFORMAT() { }
	friend SOAP_FMAC1 ns1__ArrayOfDATAFORMAT * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfDATAFORMAT(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:229 */
#ifndef SOAP_TYPE_ns_ns1__DATAFORMAT
#define SOAP_TYPE_ns_ns1__DATAFORMAT (36)
/* ns1:DATAFORMAT complex type: */
class SOAP_CMAC ns1__DATAFORMAT
{
public:
	ns1__ArrayOfDATAFORMAT_USCORECOLUMN *COLUMNS;	/* optional element of XSD type ns1:ArrayOfDATAFORMAT_COLUMN */
	std::string *Code;	/* optional attribute of XSD type xsd:string */
	std::string *Name;	/* optional attribute of XSD type xsd:string */
	std::string *Header;	/* optional attribute of XSD type xsd:string */
	std::string *DateFormat;	/* optional attribute of XSD type xsd:string */
	std::string *Extension;	/* optional attribute of XSD type xsd:string */
	bool IncludeSuffix;	/* required attribute of XSD type xsd:boolean */
	bool TabColumnSeperator;	/* required attribute of XSD type xsd:boolean */
	std::string *ColumnSeperator;	/* optional attribute of XSD type xsd:string */
	std::string *TextQualifier;	/* optional attribute of XSD type xsd:string */
	std::string *FilenamePrefix;	/* optional attribute of XSD type xsd:string */
	bool FilenameExchangeCode;	/* required attribute of XSD type xsd:boolean */
	bool FilenameDate;	/* required attribute of XSD type xsd:boolean */
	bool IncludeHeaderRow;	/* required attribute of XSD type xsd:boolean */
	std::string *HourFormat;	/* optional attribute of XSD type xsd:string */
	std::string *DateTimeSeperator;	/* optional attribute of XSD type xsd:string */
	std::string *ExchangeFilenameFormatDate;	/* optional attribute of XSD type xsd:string */
	std::string *ExchangeFilenameFormatDateRange;	/* optional attribute of XSD type xsd:string */
	std::string *SymbolFilenameFormatDate;	/* optional attribute of XSD type xsd:string */
	std::string *SymbolFilenameFormatDateRange;	/* optional attribute of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns_ns1__DATAFORMAT (36)
	virtual int soap_type(void) const { return 36; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__DATAFORMAT, default initialized and not managed by a soap context
	virtual ns1__DATAFORMAT *soap_alloc(void) const { return SOAP_NEW(ns1__DATAFORMAT); }
	         ns1__DATAFORMAT() { ns1__DATAFORMAT::soap_default(NULL); }
	virtual ~ns1__DATAFORMAT() { }
	friend SOAP_FMAC1 ns1__DATAFORMAT * SOAP_FMAC2 soap_instantiate_ns1__DATAFORMAT(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:232 */
#ifndef SOAP_TYPE_ns_ns1__ArrayOfDATAFORMAT_USCORECOLUMN
#define SOAP_TYPE_ns_ns1__ArrayOfDATAFORMAT_USCORECOLUMN (37)
/* ns1:ArrayOfDATAFORMAT_COLUMN complex type: */
class SOAP_CMAC ns1__ArrayOfDATAFORMAT_USCORECOLUMN
{
public:
	std::vector<ns1__DATAFORMAT_USCORECOLUMN *> DATAFORMAT_USCORECOLUMN;	/* optional element of XSD type ns1:DATAFORMAT_COLUMN */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns_ns1__ArrayOfDATAFORMAT_USCORECOLUMN (37)
	virtual int soap_type(void) const { return 37; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__ArrayOfDATAFORMAT_USCORECOLUMN, default initialized and not managed by a soap context
	virtual ns1__ArrayOfDATAFORMAT_USCORECOLUMN *soap_alloc(void) const { return SOAP_NEW(ns1__ArrayOfDATAFORMAT_USCORECOLUMN); }
	         ns1__ArrayOfDATAFORMAT_USCORECOLUMN() { ns1__ArrayOfDATAFORMAT_USCORECOLUMN::soap_default(NULL); }
	virtual ~ns1__ArrayOfDATAFORMAT_USCORECOLUMN() { }
	friend SOAP_FMAC1 ns1__ArrayOfDATAFORMAT_USCORECOLUMN * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfDATAFORMAT_USCORECOLUMN(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:235 */
#ifndef SOAP_TYPE_ns_ns1__DATAFORMAT_USCORECOLUMN
#define SOAP_TYPE_ns_ns1__DATAFORMAT_USCORECOLUMN (38)
/* ns1:DATAFORMAT_COLUMN complex type: */
class SOAP_CMAC ns1__DATAFORMAT_USCORECOLUMN
{
public:
	int SortOrder;	/* required attribute of XSD type xsd:int */
	std::string *Code;	/* optional attribute of XSD type xsd:string */
	std::string *DataFormat;	/* optional attribute of XSD type xsd:string */
	std::string *ColumnCode;	/* optional attribute of XSD type xsd:string */
	std::string *ColumnName;	/* optional attribute of XSD type xsd:string */
	int ColumnTypeId;	/* required attribute of XSD type xsd:int */
	std::string *ColumnType;	/* optional attribute of XSD type xsd:string */
	std::string *Header;	/* optional attribute of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns_ns1__DATAFORMAT_USCORECOLUMN (38)
	virtual int soap_type(void) const { return 38; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__DATAFORMAT_USCORECOLUMN, default initialized and not managed by a soap context
	virtual ns1__DATAFORMAT_USCORECOLUMN *soap_alloc(void) const { return SOAP_NEW(ns1__DATAFORMAT_USCORECOLUMN); }
	         ns1__DATAFORMAT_USCORECOLUMN() { ns1__DATAFORMAT_USCORECOLUMN::soap_default(NULL); }
	virtual ~ns1__DATAFORMAT_USCORECOLUMN() { }
	friend SOAP_FMAC1 ns1__DATAFORMAT_USCORECOLUMN * SOAP_FMAC2 soap_instantiate_ns1__DATAFORMAT_USCORECOLUMN(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:238 */
#ifndef SOAP_TYPE_ns__ns1__Login
#define SOAP_TYPE_ns__ns1__Login (39)
/* ns1:Login complex type: */
class SOAP_CMAC _ns1__Login
{
public:
	std::string *Username;	/* optional element of XSD type xsd:string */
	std::string *Password;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__Login (39)
	virtual int soap_type(void) const { return 39; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__Login, default initialized and not managed by a soap context
	virtual _ns1__Login *soap_alloc(void) const { return SOAP_NEW(_ns1__Login); }
	         _ns1__Login() { _ns1__Login::soap_default(NULL); }
	virtual ~_ns1__Login() { }
	friend SOAP_FMAC1 _ns1__Login * SOAP_FMAC2 soap_instantiate__ns1__Login(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:241 */
#ifndef SOAP_TYPE_ns__ns1__LoginResponse
#define SOAP_TYPE_ns__ns1__LoginResponse (40)
/* ns1:LoginResponse complex type: */
class SOAP_CMAC _ns1__LoginResponse
{
public:
	ns1__LOGINRESPONSE *LoginResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type ns1:LOGINRESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__LoginResponse (40)
	virtual int soap_type(void) const { return 40; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__LoginResponse, default initialized and not managed by a soap context
	virtual _ns1__LoginResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__LoginResponse); }
	         _ns1__LoginResponse() { _ns1__LoginResponse::soap_default(NULL); }
	virtual ~_ns1__LoginResponse() { }
	friend SOAP_FMAC1 _ns1__LoginResponse * SOAP_FMAC2 soap_instantiate__ns1__LoginResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:244 */
#ifndef SOAP_TYPE_ns__ns1__Login2
#define SOAP_TYPE_ns__ns1__Login2 (41)
/* ns1:Login2 complex type: */
class SOAP_CMAC _ns1__Login2
{
public:
	std::string *Username;	/* optional element of XSD type xsd:string */
	std::string *Password;	/* optional element of XSD type xsd:string */
	std::string *Version;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__Login2 (41)
	virtual int soap_type(void) const { return 41; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__Login2, default initialized and not managed by a soap context
	virtual _ns1__Login2 *soap_alloc(void) const { return SOAP_NEW(_ns1__Login2); }
	         _ns1__Login2() { _ns1__Login2::soap_default(NULL); }
	virtual ~_ns1__Login2() { }
	friend SOAP_FMAC1 _ns1__Login2 * SOAP_FMAC2 soap_instantiate__ns1__Login2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:247 */
#ifndef SOAP_TYPE_ns__ns1__Login2Response
#define SOAP_TYPE_ns__ns1__Login2Response (42)
/* ns1:Login2Response complex type: */
class SOAP_CMAC _ns1__Login2Response
{
public:
	ns1__LOGINRESPONSE *Login2Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type ns1:LOGINRESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__Login2Response (42)
	virtual int soap_type(void) const { return 42; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__Login2Response, default initialized and not managed by a soap context
	virtual _ns1__Login2Response *soap_alloc(void) const { return SOAP_NEW(_ns1__Login2Response); }
	         _ns1__Login2Response() { _ns1__Login2Response::soap_default(NULL); }
	virtual ~_ns1__Login2Response() { }
	friend SOAP_FMAC1 _ns1__Login2Response * SOAP_FMAC2 soap_instantiate__ns1__Login2Response(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:250 */
#ifndef SOAP_TYPE_ns__ns1__Membership
#define SOAP_TYPE_ns__ns1__Membership (43)
/* ns1:Membership complex type: */
class SOAP_CMAC _ns1__Membership
{
public:
	std::string *Token;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__Membership (43)
	virtual int soap_type(void) const { return 43; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__Membership, default initialized and not managed by a soap context
	virtual _ns1__Membership *soap_alloc(void) const { return SOAP_NEW(_ns1__Membership); }
	         _ns1__Membership() { _ns1__Membership::soap_default(NULL); }
	virtual ~_ns1__Membership() { }
	friend SOAP_FMAC1 _ns1__Membership * SOAP_FMAC2 soap_instantiate__ns1__Membership(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:253 */
#ifndef SOAP_TYPE_ns__ns1__MembershipResponse
#define SOAP_TYPE_ns__ns1__MembershipResponse (44)
/* ns1:MembershipResponse complex type: */
class SOAP_CMAC _ns1__MembershipResponse
{
public:
	ns1__RESPONSE *MembershipResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type ns1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__MembershipResponse (44)
	virtual int soap_type(void) const { return 44; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__MembershipResponse, default initialized and not managed by a soap context
	virtual _ns1__MembershipResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__MembershipResponse); }
	         _ns1__MembershipResponse() { _ns1__MembershipResponse::soap_default(NULL); }
	virtual ~_ns1__MembershipResponse() { }
	friend SOAP_FMAC1 _ns1__MembershipResponse * SOAP_FMAC2 soap_instantiate__ns1__MembershipResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:256 */
#ifndef SOAP_TYPE_ns__ns1__ExchangeList
#define SOAP_TYPE_ns__ns1__ExchangeList (45)
/* ns1:ExchangeList complex type: */
class SOAP_CMAC _ns1__ExchangeList
{
public:
	std::string *Token;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__ExchangeList (45)
	virtual int soap_type(void) const { return 45; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__ExchangeList, default initialized and not managed by a soap context
	virtual _ns1__ExchangeList *soap_alloc(void) const { return SOAP_NEW(_ns1__ExchangeList); }
	         _ns1__ExchangeList() { _ns1__ExchangeList::soap_default(NULL); }
	virtual ~_ns1__ExchangeList() { }
	friend SOAP_FMAC1 _ns1__ExchangeList * SOAP_FMAC2 soap_instantiate__ns1__ExchangeList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:259 */
#ifndef SOAP_TYPE_ns__ns1__ExchangeListResponse
#define SOAP_TYPE_ns__ns1__ExchangeListResponse (46)
/* ns1:ExchangeListResponse complex type: */
class SOAP_CMAC _ns1__ExchangeListResponse
{
public:
	ns1__RESPONSE *ExchangeListResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type ns1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__ExchangeListResponse (46)
	virtual int soap_type(void) const { return 46; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__ExchangeListResponse, default initialized and not managed by a soap context
	virtual _ns1__ExchangeListResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__ExchangeListResponse); }
	         _ns1__ExchangeListResponse() { _ns1__ExchangeListResponse::soap_default(NULL); }
	virtual ~_ns1__ExchangeListResponse() { }
	friend SOAP_FMAC1 _ns1__ExchangeListResponse * SOAP_FMAC2 soap_instantiate__ns1__ExchangeListResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:262 */
#ifndef SOAP_TYPE_ns__ns1__ExchangeGet
#define SOAP_TYPE_ns__ns1__ExchangeGet (47)
/* ns1:ExchangeGet complex type: */
class SOAP_CMAC _ns1__ExchangeGet
{
public:
	std::string *Token;	/* optional element of XSD type xsd:string */
	std::string *Exchange;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__ExchangeGet (47)
	virtual int soap_type(void) const { return 47; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__ExchangeGet, default initialized and not managed by a soap context
	virtual _ns1__ExchangeGet *soap_alloc(void) const { return SOAP_NEW(_ns1__ExchangeGet); }
	         _ns1__ExchangeGet() { _ns1__ExchangeGet::soap_default(NULL); }
	virtual ~_ns1__ExchangeGet() { }
	friend SOAP_FMAC1 _ns1__ExchangeGet * SOAP_FMAC2 soap_instantiate__ns1__ExchangeGet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:265 */
#ifndef SOAP_TYPE_ns__ns1__ExchangeGetResponse
#define SOAP_TYPE_ns__ns1__ExchangeGetResponse (48)
/* ns1:ExchangeGetResponse complex type: */
class SOAP_CMAC _ns1__ExchangeGetResponse
{
public:
	ns1__RESPONSE *ExchangeGetResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type ns1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__ExchangeGetResponse (48)
	virtual int soap_type(void) const { return 48; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__ExchangeGetResponse, default initialized and not managed by a soap context
	virtual _ns1__ExchangeGetResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__ExchangeGetResponse); }
	         _ns1__ExchangeGetResponse() { _ns1__ExchangeGetResponse::soap_default(NULL); }
	virtual ~_ns1__ExchangeGetResponse() { }
	friend SOAP_FMAC1 _ns1__ExchangeGetResponse * SOAP_FMAC2 soap_instantiate__ns1__ExchangeGetResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:268 */
#ifndef SOAP_TYPE_ns__ns1__SymbolList
#define SOAP_TYPE_ns__ns1__SymbolList (49)
/* ns1:SymbolList complex type: */
class SOAP_CMAC _ns1__SymbolList
{
public:
	std::string *Token;	/* optional element of XSD type xsd:string */
	std::string *Exchange;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__SymbolList (49)
	virtual int soap_type(void) const { return 49; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__SymbolList, default initialized and not managed by a soap context
	virtual _ns1__SymbolList *soap_alloc(void) const { return SOAP_NEW(_ns1__SymbolList); }
	         _ns1__SymbolList() { _ns1__SymbolList::soap_default(NULL); }
	virtual ~_ns1__SymbolList() { }
	friend SOAP_FMAC1 _ns1__SymbolList * SOAP_FMAC2 soap_instantiate__ns1__SymbolList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:271 */
#ifndef SOAP_TYPE_ns__ns1__SymbolListResponse
#define SOAP_TYPE_ns__ns1__SymbolListResponse (50)
/* ns1:SymbolListResponse complex type: */
class SOAP_CMAC _ns1__SymbolListResponse
{
public:
	ns1__RESPONSE *SymbolListResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type ns1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__SymbolListResponse (50)
	virtual int soap_type(void) const { return 50; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__SymbolListResponse, default initialized and not managed by a soap context
	virtual _ns1__SymbolListResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SymbolListResponse); }
	         _ns1__SymbolListResponse() { _ns1__SymbolListResponse::soap_default(NULL); }
	virtual ~_ns1__SymbolListResponse() { }
	friend SOAP_FMAC1 _ns1__SymbolListResponse * SOAP_FMAC2 soap_instantiate__ns1__SymbolListResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:274 */
#ifndef SOAP_TYPE_ns__ns1__SymbolList2
#define SOAP_TYPE_ns__ns1__SymbolList2 (51)
/* ns1:SymbolList2 complex type: */
class SOAP_CMAC _ns1__SymbolList2
{
public:
	std::string *Token;	/* optional element of XSD type xsd:string */
	std::string *Exchange;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__SymbolList2 (51)
	virtual int soap_type(void) const { return 51; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__SymbolList2, default initialized and not managed by a soap context
	virtual _ns1__SymbolList2 *soap_alloc(void) const { return SOAP_NEW(_ns1__SymbolList2); }
	         _ns1__SymbolList2() { _ns1__SymbolList2::soap_default(NULL); }
	virtual ~_ns1__SymbolList2() { }
	friend SOAP_FMAC1 _ns1__SymbolList2 * SOAP_FMAC2 soap_instantiate__ns1__SymbolList2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:277 */
#ifndef SOAP_TYPE_ns__ns1__SymbolList2Response
#define SOAP_TYPE_ns__ns1__SymbolList2Response (52)
/* ns1:SymbolList2Response complex type: */
class SOAP_CMAC _ns1__SymbolList2Response
{
public:
	ns1__RESPONSE *SymbolList2Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type ns1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__SymbolList2Response (52)
	virtual int soap_type(void) const { return 52; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__SymbolList2Response, default initialized and not managed by a soap context
	virtual _ns1__SymbolList2Response *soap_alloc(void) const { return SOAP_NEW(_ns1__SymbolList2Response); }
	         _ns1__SymbolList2Response() { _ns1__SymbolList2Response::soap_default(NULL); }
	virtual ~_ns1__SymbolList2Response() { }
	friend SOAP_FMAC1 _ns1__SymbolList2Response * SOAP_FMAC2 soap_instantiate__ns1__SymbolList2Response(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:280 */
#ifndef SOAP_TYPE_ns__ns1__QuoteGet
#define SOAP_TYPE_ns__ns1__QuoteGet (53)
/* ns1:QuoteGet complex type: */
class SOAP_CMAC _ns1__QuoteGet
{
public:
	std::string *Token;	/* optional element of XSD type xsd:string */
	std::string *Exchange;	/* optional element of XSD type xsd:string */
	std::string *Symbol;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__QuoteGet (53)
	virtual int soap_type(void) const { return 53; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__QuoteGet, default initialized and not managed by a soap context
	virtual _ns1__QuoteGet *soap_alloc(void) const { return SOAP_NEW(_ns1__QuoteGet); }
	         _ns1__QuoteGet() { _ns1__QuoteGet::soap_default(NULL); }
	virtual ~_ns1__QuoteGet() { }
	friend SOAP_FMAC1 _ns1__QuoteGet * SOAP_FMAC2 soap_instantiate__ns1__QuoteGet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:283 */
#ifndef SOAP_TYPE_ns__ns1__QuoteGetResponse
#define SOAP_TYPE_ns__ns1__QuoteGetResponse (54)
/* ns1:QuoteGetResponse complex type: */
class SOAP_CMAC _ns1__QuoteGetResponse
{
public:
	ns1__RESPONSE *QuoteGetResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type ns1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__QuoteGetResponse (54)
	virtual int soap_type(void) const { return 54; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__QuoteGetResponse, default initialized and not managed by a soap context
	virtual _ns1__QuoteGetResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__QuoteGetResponse); }
	         _ns1__QuoteGetResponse() { _ns1__QuoteGetResponse::soap_default(NULL); }
	virtual ~_ns1__QuoteGetResponse() { }
	friend SOAP_FMAC1 _ns1__QuoteGetResponse * SOAP_FMAC2 soap_instantiate__ns1__QuoteGetResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:286 */
#ifndef SOAP_TYPE_ns__ns1__QuoteList2
#define SOAP_TYPE_ns__ns1__QuoteList2 (55)
/* ns1:QuoteList2 complex type: */
class SOAP_CMAC _ns1__QuoteList2
{
public:
	std::string *Token;	/* optional element of XSD type xsd:string */
	std::string *Exchange;	/* optional element of XSD type xsd:string */
	std::string *Symbols;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__QuoteList2 (55)
	virtual int soap_type(void) const { return 55; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__QuoteList2, default initialized and not managed by a soap context
	virtual _ns1__QuoteList2 *soap_alloc(void) const { return SOAP_NEW(_ns1__QuoteList2); }
	         _ns1__QuoteList2() { _ns1__QuoteList2::soap_default(NULL); }
	virtual ~_ns1__QuoteList2() { }
	friend SOAP_FMAC1 _ns1__QuoteList2 * SOAP_FMAC2 soap_instantiate__ns1__QuoteList2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:289 */
#ifndef SOAP_TYPE_ns__ns1__QuoteList2Response
#define SOAP_TYPE_ns__ns1__QuoteList2Response (56)
/* ns1:QuoteList2Response complex type: */
class SOAP_CMAC _ns1__QuoteList2Response
{
public:
	ns1__RESPONSE *QuoteList2Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type ns1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__QuoteList2Response (56)
	virtual int soap_type(void) const { return 56; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__QuoteList2Response, default initialized and not managed by a soap context
	virtual _ns1__QuoteList2Response *soap_alloc(void) const { return SOAP_NEW(_ns1__QuoteList2Response); }
	         _ns1__QuoteList2Response() { _ns1__QuoteList2Response::soap_default(NULL); }
	virtual ~_ns1__QuoteList2Response() { }
	friend SOAP_FMAC1 _ns1__QuoteList2Response * SOAP_FMAC2 soap_instantiate__ns1__QuoteList2Response(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:292 */
#ifndef SOAP_TYPE_ns__ns1__SymbolGet
#define SOAP_TYPE_ns__ns1__SymbolGet (57)
/* ns1:SymbolGet complex type: */
class SOAP_CMAC _ns1__SymbolGet
{
public:
	std::string *Token;	/* optional element of XSD type xsd:string */
	std::string *Exchange;	/* optional element of XSD type xsd:string */
	std::string *Symbol;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__SymbolGet (57)
	virtual int soap_type(void) const { return 57; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__SymbolGet, default initialized and not managed by a soap context
	virtual _ns1__SymbolGet *soap_alloc(void) const { return SOAP_NEW(_ns1__SymbolGet); }
	         _ns1__SymbolGet() { _ns1__SymbolGet::soap_default(NULL); }
	virtual ~_ns1__SymbolGet() { }
	friend SOAP_FMAC1 _ns1__SymbolGet * SOAP_FMAC2 soap_instantiate__ns1__SymbolGet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:295 */
#ifndef SOAP_TYPE_ns__ns1__SymbolGetResponse
#define SOAP_TYPE_ns__ns1__SymbolGetResponse (58)
/* ns1:SymbolGetResponse complex type: */
class SOAP_CMAC _ns1__SymbolGetResponse
{
public:
	ns1__RESPONSE *SymbolGetResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type ns1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__SymbolGetResponse (58)
	virtual int soap_type(void) const { return 58; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__SymbolGetResponse, default initialized and not managed by a soap context
	virtual _ns1__SymbolGetResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SymbolGetResponse); }
	         _ns1__SymbolGetResponse() { _ns1__SymbolGetResponse::soap_default(NULL); }
	virtual ~_ns1__SymbolGetResponse() { }
	friend SOAP_FMAC1 _ns1__SymbolGetResponse * SOAP_FMAC2 soap_instantiate__ns1__SymbolGetResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:298 */
#ifndef SOAP_TYPE_ns__ns1__QuoteList
#define SOAP_TYPE_ns__ns1__QuoteList (59)
/* ns1:QuoteList complex type: */
class SOAP_CMAC _ns1__QuoteList
{
public:
	std::string *Token;	/* optional element of XSD type xsd:string */
	std::string *Exchange;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__QuoteList (59)
	virtual int soap_type(void) const { return 59; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__QuoteList, default initialized and not managed by a soap context
	virtual _ns1__QuoteList *soap_alloc(void) const { return SOAP_NEW(_ns1__QuoteList); }
	         _ns1__QuoteList() { _ns1__QuoteList::soap_default(NULL); }
	virtual ~_ns1__QuoteList() { }
	friend SOAP_FMAC1 _ns1__QuoteList * SOAP_FMAC2 soap_instantiate__ns1__QuoteList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:301 */
#ifndef SOAP_TYPE_ns__ns1__QuoteListResponse
#define SOAP_TYPE_ns__ns1__QuoteListResponse (60)
/* ns1:QuoteListResponse complex type: */
class SOAP_CMAC _ns1__QuoteListResponse
{
public:
	ns1__RESPONSE *QuoteListResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type ns1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__QuoteListResponse (60)
	virtual int soap_type(void) const { return 60; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__QuoteListResponse, default initialized and not managed by a soap context
	virtual _ns1__QuoteListResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__QuoteListResponse); }
	         _ns1__QuoteListResponse() { _ns1__QuoteListResponse::soap_default(NULL); }
	virtual ~_ns1__QuoteListResponse() { }
	friend SOAP_FMAC1 _ns1__QuoteListResponse * SOAP_FMAC2 soap_instantiate__ns1__QuoteListResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:304 */
#ifndef SOAP_TYPE_ns__ns1__NewsList
#define SOAP_TYPE_ns__ns1__NewsList (61)
/* ns1:NewsList complex type: */
class SOAP_CMAC _ns1__NewsList
{
public:
	std::string *Token;	/* optional element of XSD type xsd:string */
	std::string *Exchange;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__NewsList (61)
	virtual int soap_type(void) const { return 61; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__NewsList, default initialized and not managed by a soap context
	virtual _ns1__NewsList *soap_alloc(void) const { return SOAP_NEW(_ns1__NewsList); }
	         _ns1__NewsList() { _ns1__NewsList::soap_default(NULL); }
	virtual ~_ns1__NewsList() { }
	friend SOAP_FMAC1 _ns1__NewsList * SOAP_FMAC2 soap_instantiate__ns1__NewsList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:307 */
#ifndef SOAP_TYPE_ns__ns1__NewsListResponse
#define SOAP_TYPE_ns__ns1__NewsListResponse (62)
/* ns1:NewsListResponse complex type: */
class SOAP_CMAC _ns1__NewsListResponse
{
public:
	ns1__RESPONSE *NewsListResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type ns1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__NewsListResponse (62)
	virtual int soap_type(void) const { return 62; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__NewsListResponse, default initialized and not managed by a soap context
	virtual _ns1__NewsListResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__NewsListResponse); }
	         _ns1__NewsListResponse() { _ns1__NewsListResponse::soap_default(NULL); }
	virtual ~_ns1__NewsListResponse() { }
	friend SOAP_FMAC1 _ns1__NewsListResponse * SOAP_FMAC2 soap_instantiate__ns1__NewsListResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:310 */
#ifndef SOAP_TYPE_ns__ns1__NewsListBySymbol
#define SOAP_TYPE_ns__ns1__NewsListBySymbol (63)
/* ns1:NewsListBySymbol complex type: */
class SOAP_CMAC _ns1__NewsListBySymbol
{
public:
	std::string *token;	/* optional element of XSD type xsd:string */
	std::string *Exchange;	/* optional element of XSD type xsd:string */
	std::string *symbol;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__NewsListBySymbol (63)
	virtual int soap_type(void) const { return 63; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__NewsListBySymbol, default initialized and not managed by a soap context
	virtual _ns1__NewsListBySymbol *soap_alloc(void) const { return SOAP_NEW(_ns1__NewsListBySymbol); }
	         _ns1__NewsListBySymbol() { _ns1__NewsListBySymbol::soap_default(NULL); }
	virtual ~_ns1__NewsListBySymbol() { }
	friend SOAP_FMAC1 _ns1__NewsListBySymbol * SOAP_FMAC2 soap_instantiate__ns1__NewsListBySymbol(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:313 */
#ifndef SOAP_TYPE_ns__ns1__NewsListBySymbolResponse
#define SOAP_TYPE_ns__ns1__NewsListBySymbolResponse (64)
/* ns1:NewsListBySymbolResponse complex type: */
class SOAP_CMAC _ns1__NewsListBySymbolResponse
{
public:
	ns1__RESPONSE *NewsListBySymbolResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type ns1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__NewsListBySymbolResponse (64)
	virtual int soap_type(void) const { return 64; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__NewsListBySymbolResponse, default initialized and not managed by a soap context
	virtual _ns1__NewsListBySymbolResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__NewsListBySymbolResponse); }
	         _ns1__NewsListBySymbolResponse() { _ns1__NewsListBySymbolResponse::soap_default(NULL); }
	virtual ~_ns1__NewsListBySymbolResponse() { }
	friend SOAP_FMAC1 _ns1__NewsListBySymbolResponse * SOAP_FMAC2 soap_instantiate__ns1__NewsListBySymbolResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:316 */
#ifndef SOAP_TYPE_ns__ns1__FundamentalList
#define SOAP_TYPE_ns__ns1__FundamentalList (65)
/* ns1:FundamentalList complex type: */
class SOAP_CMAC _ns1__FundamentalList
{
public:
	std::string *Token;	/* optional element of XSD type xsd:string */
	std::string *Exchange;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__FundamentalList (65)
	virtual int soap_type(void) const { return 65; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__FundamentalList, default initialized and not managed by a soap context
	virtual _ns1__FundamentalList *soap_alloc(void) const { return SOAP_NEW(_ns1__FundamentalList); }
	         _ns1__FundamentalList() { _ns1__FundamentalList::soap_default(NULL); }
	virtual ~_ns1__FundamentalList() { }
	friend SOAP_FMAC1 _ns1__FundamentalList * SOAP_FMAC2 soap_instantiate__ns1__FundamentalList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:319 */
#ifndef SOAP_TYPE_ns__ns1__FundamentalListResponse
#define SOAP_TYPE_ns__ns1__FundamentalListResponse (66)
/* ns1:FundamentalListResponse complex type: */
class SOAP_CMAC _ns1__FundamentalListResponse
{
public:
	ns1__RESPONSE *FundamentalListResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type ns1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__FundamentalListResponse (66)
	virtual int soap_type(void) const { return 66; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__FundamentalListResponse, default initialized and not managed by a soap context
	virtual _ns1__FundamentalListResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__FundamentalListResponse); }
	         _ns1__FundamentalListResponse() { _ns1__FundamentalListResponse::soap_default(NULL); }
	virtual ~_ns1__FundamentalListResponse() { }
	friend SOAP_FMAC1 _ns1__FundamentalListResponse * SOAP_FMAC2 soap_instantiate__ns1__FundamentalListResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:322 */
#ifndef SOAP_TYPE_ns__ns1__TechnicalList
#define SOAP_TYPE_ns__ns1__TechnicalList (67)
/* ns1:TechnicalList complex type: */
class SOAP_CMAC _ns1__TechnicalList
{
public:
	std::string *Token;	/* optional element of XSD type xsd:string */
	std::string *Exchange;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__TechnicalList (67)
	virtual int soap_type(void) const { return 67; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__TechnicalList, default initialized and not managed by a soap context
	virtual _ns1__TechnicalList *soap_alloc(void) const { return SOAP_NEW(_ns1__TechnicalList); }
	         _ns1__TechnicalList() { _ns1__TechnicalList::soap_default(NULL); }
	virtual ~_ns1__TechnicalList() { }
	friend SOAP_FMAC1 _ns1__TechnicalList * SOAP_FMAC2 soap_instantiate__ns1__TechnicalList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:325 */
#ifndef SOAP_TYPE_ns__ns1__TechnicalListResponse
#define SOAP_TYPE_ns__ns1__TechnicalListResponse (68)
/* ns1:TechnicalListResponse complex type: */
class SOAP_CMAC _ns1__TechnicalListResponse
{
public:
	ns1__RESPONSE *TechnicalListResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type ns1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__TechnicalListResponse (68)
	virtual int soap_type(void) const { return 68; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__TechnicalListResponse, default initialized and not managed by a soap context
	virtual _ns1__TechnicalListResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__TechnicalListResponse); }
	         _ns1__TechnicalListResponse() { _ns1__TechnicalListResponse::soap_default(NULL); }
	virtual ~_ns1__TechnicalListResponse() { }
	friend SOAP_FMAC1 _ns1__TechnicalListResponse * SOAP_FMAC2 soap_instantiate__ns1__TechnicalListResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:328 */
#ifndef SOAP_TYPE_ns__ns1__QuoteListByDate
#define SOAP_TYPE_ns__ns1__QuoteListByDate (69)
/* ns1:QuoteListByDate complex type: */
class SOAP_CMAC _ns1__QuoteListByDate
{
public:
	std::string *Token;	/* optional element of XSD type xsd:string */
	std::string *Exchange;	/* optional element of XSD type xsd:string */
	std::string *QuoteDate;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__QuoteListByDate (69)
	virtual int soap_type(void) const { return 69; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__QuoteListByDate, default initialized and not managed by a soap context
	virtual _ns1__QuoteListByDate *soap_alloc(void) const { return SOAP_NEW(_ns1__QuoteListByDate); }
	         _ns1__QuoteListByDate() { _ns1__QuoteListByDate::soap_default(NULL); }
	virtual ~_ns1__QuoteListByDate() { }
	friend SOAP_FMAC1 _ns1__QuoteListByDate * SOAP_FMAC2 soap_instantiate__ns1__QuoteListByDate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:331 */
#ifndef SOAP_TYPE_ns__ns1__QuoteListByDateResponse
#define SOAP_TYPE_ns__ns1__QuoteListByDateResponse (70)
/* ns1:QuoteListByDateResponse complex type: */
class SOAP_CMAC _ns1__QuoteListByDateResponse
{
public:
	ns1__RESPONSE *QuoteListByDateResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type ns1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__QuoteListByDateResponse (70)
	virtual int soap_type(void) const { return 70; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__QuoteListByDateResponse, default initialized and not managed by a soap context
	virtual _ns1__QuoteListByDateResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__QuoteListByDateResponse); }
	         _ns1__QuoteListByDateResponse() { _ns1__QuoteListByDateResponse::soap_default(NULL); }
	virtual ~_ns1__QuoteListByDateResponse() { }
	friend SOAP_FMAC1 _ns1__QuoteListByDateResponse * SOAP_FMAC2 soap_instantiate__ns1__QuoteListByDateResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:334 */
#ifndef SOAP_TYPE_ns__ns1__QuoteListByDate2
#define SOAP_TYPE_ns__ns1__QuoteListByDate2 (71)
/* ns1:QuoteListByDate2 complex type: */
class SOAP_CMAC _ns1__QuoteListByDate2
{
public:
	std::string *Token;	/* optional element of XSD type xsd:string */
	std::string *Exchange;	/* optional element of XSD type xsd:string */
	std::string *QuoteDate;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__QuoteListByDate2 (71)
	virtual int soap_type(void) const { return 71; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__QuoteListByDate2, default initialized and not managed by a soap context
	virtual _ns1__QuoteListByDate2 *soap_alloc(void) const { return SOAP_NEW(_ns1__QuoteListByDate2); }
	         _ns1__QuoteListByDate2() { _ns1__QuoteListByDate2::soap_default(NULL); }
	virtual ~_ns1__QuoteListByDate2() { }
	friend SOAP_FMAC1 _ns1__QuoteListByDate2 * SOAP_FMAC2 soap_instantiate__ns1__QuoteListByDate2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:337 */
#ifndef SOAP_TYPE_ns__ns1__QuoteListByDate2Response
#define SOAP_TYPE_ns__ns1__QuoteListByDate2Response (72)
/* ns1:QuoteListByDate2Response complex type: */
class SOAP_CMAC _ns1__QuoteListByDate2Response
{
public:
	ns1__RESPONSE *QuoteListByDate2Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type ns1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__QuoteListByDate2Response (72)
	virtual int soap_type(void) const { return 72; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__QuoteListByDate2Response, default initialized and not managed by a soap context
	virtual _ns1__QuoteListByDate2Response *soap_alloc(void) const { return SOAP_NEW(_ns1__QuoteListByDate2Response); }
	         _ns1__QuoteListByDate2Response() { _ns1__QuoteListByDate2Response::soap_default(NULL); }
	virtual ~_ns1__QuoteListByDate2Response() { }
	friend SOAP_FMAC1 _ns1__QuoteListByDate2Response * SOAP_FMAC2 soap_instantiate__ns1__QuoteListByDate2Response(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:340 */
#ifndef SOAP_TYPE_ns__ns1__SymbolHistory
#define SOAP_TYPE_ns__ns1__SymbolHistory (73)
/* ns1:SymbolHistory complex type: */
class SOAP_CMAC _ns1__SymbolHistory
{
public:
	std::string *Token;	/* optional element of XSD type xsd:string */
	std::string *Exchange;	/* optional element of XSD type xsd:string */
	std::string *Symbol;	/* optional element of XSD type xsd:string */
	std::string *StartDate;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__SymbolHistory (73)
	virtual int soap_type(void) const { return 73; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__SymbolHistory, default initialized and not managed by a soap context
	virtual _ns1__SymbolHistory *soap_alloc(void) const { return SOAP_NEW(_ns1__SymbolHistory); }
	         _ns1__SymbolHistory() { _ns1__SymbolHistory::soap_default(NULL); }
	virtual ~_ns1__SymbolHistory() { }
	friend SOAP_FMAC1 _ns1__SymbolHistory * SOAP_FMAC2 soap_instantiate__ns1__SymbolHistory(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:343 */
#ifndef SOAP_TYPE_ns__ns1__SymbolHistoryResponse
#define SOAP_TYPE_ns__ns1__SymbolHistoryResponse (74)
/* ns1:SymbolHistoryResponse complex type: */
class SOAP_CMAC _ns1__SymbolHistoryResponse
{
public:
	ns1__RESPONSE *SymbolHistoryResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type ns1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__SymbolHistoryResponse (74)
	virtual int soap_type(void) const { return 74; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__SymbolHistoryResponse, default initialized and not managed by a soap context
	virtual _ns1__SymbolHistoryResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SymbolHistoryResponse); }
	         _ns1__SymbolHistoryResponse() { _ns1__SymbolHistoryResponse::soap_default(NULL); }
	virtual ~_ns1__SymbolHistoryResponse() { }
	friend SOAP_FMAC1 _ns1__SymbolHistoryResponse * SOAP_FMAC2 soap_instantiate__ns1__SymbolHistoryResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:346 */
#ifndef SOAP_TYPE_ns__ns1__Top10Gains
#define SOAP_TYPE_ns__ns1__Top10Gains (75)
/* ns1:Top10Gains complex type: */
class SOAP_CMAC _ns1__Top10Gains
{
public:
	std::string *Token;	/* optional element of XSD type xsd:string */
	std::string *Exchange;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__Top10Gains (75)
	virtual int soap_type(void) const { return 75; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__Top10Gains, default initialized and not managed by a soap context
	virtual _ns1__Top10Gains *soap_alloc(void) const { return SOAP_NEW(_ns1__Top10Gains); }
	         _ns1__Top10Gains() { _ns1__Top10Gains::soap_default(NULL); }
	virtual ~_ns1__Top10Gains() { }
	friend SOAP_FMAC1 _ns1__Top10Gains * SOAP_FMAC2 soap_instantiate__ns1__Top10Gains(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:349 */
#ifndef SOAP_TYPE_ns__ns1__Top10GainsResponse
#define SOAP_TYPE_ns__ns1__Top10GainsResponse (76)
/* ns1:Top10GainsResponse complex type: */
class SOAP_CMAC _ns1__Top10GainsResponse
{
public:
	ns1__RESPONSE *Top10GainsResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type ns1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__Top10GainsResponse (76)
	virtual int soap_type(void) const { return 76; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__Top10GainsResponse, default initialized and not managed by a soap context
	virtual _ns1__Top10GainsResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__Top10GainsResponse); }
	         _ns1__Top10GainsResponse() { _ns1__Top10GainsResponse::soap_default(NULL); }
	virtual ~_ns1__Top10GainsResponse() { }
	friend SOAP_FMAC1 _ns1__Top10GainsResponse * SOAP_FMAC2 soap_instantiate__ns1__Top10GainsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:352 */
#ifndef SOAP_TYPE_ns__ns1__Top10Losses
#define SOAP_TYPE_ns__ns1__Top10Losses (77)
/* ns1:Top10Losses complex type: */
class SOAP_CMAC _ns1__Top10Losses
{
public:
	std::string *Token;	/* optional element of XSD type xsd:string */
	std::string *Exchange;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__Top10Losses (77)
	virtual int soap_type(void) const { return 77; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__Top10Losses, default initialized and not managed by a soap context
	virtual _ns1__Top10Losses *soap_alloc(void) const { return SOAP_NEW(_ns1__Top10Losses); }
	         _ns1__Top10Losses() { _ns1__Top10Losses::soap_default(NULL); }
	virtual ~_ns1__Top10Losses() { }
	friend SOAP_FMAC1 _ns1__Top10Losses * SOAP_FMAC2 soap_instantiate__ns1__Top10Losses(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:355 */
#ifndef SOAP_TYPE_ns__ns1__Top10LossesResponse
#define SOAP_TYPE_ns__ns1__Top10LossesResponse (78)
/* ns1:Top10LossesResponse complex type: */
class SOAP_CMAC _ns1__Top10LossesResponse
{
public:
	ns1__RESPONSE *Top10LossesResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type ns1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__Top10LossesResponse (78)
	virtual int soap_type(void) const { return 78; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__Top10LossesResponse, default initialized and not managed by a soap context
	virtual _ns1__Top10LossesResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__Top10LossesResponse); }
	         _ns1__Top10LossesResponse() { _ns1__Top10LossesResponse::soap_default(NULL); }
	virtual ~_ns1__Top10LossesResponse() { }
	friend SOAP_FMAC1 _ns1__Top10LossesResponse * SOAP_FMAC2 soap_instantiate__ns1__Top10LossesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:358 */
#ifndef SOAP_TYPE_ns__ns1__SymbolChart
#define SOAP_TYPE_ns__ns1__SymbolChart (79)
/* ns1:SymbolChart complex type: */
class SOAP_CMAC _ns1__SymbolChart
{
public:
	std::string *Token;	/* optional element of XSD type xsd:string */
	std::string *Exchange;	/* optional element of XSD type xsd:string */
	std::string *Symbol;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__SymbolChart (79)
	virtual int soap_type(void) const { return 79; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__SymbolChart, default initialized and not managed by a soap context
	virtual _ns1__SymbolChart *soap_alloc(void) const { return SOAP_NEW(_ns1__SymbolChart); }
	         _ns1__SymbolChart() { _ns1__SymbolChart::soap_default(NULL); }
	virtual ~_ns1__SymbolChart() { }
	friend SOAP_FMAC1 _ns1__SymbolChart * SOAP_FMAC2 soap_instantiate__ns1__SymbolChart(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:361 */
#ifndef SOAP_TYPE_ns__ns1__SymbolChartResponse
#define SOAP_TYPE_ns__ns1__SymbolChartResponse (80)
/* ns1:SymbolChartResponse complex type: */
class SOAP_CMAC _ns1__SymbolChartResponse
{
public:
	ns1__RESPONSE *SymbolChartResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type ns1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__SymbolChartResponse (80)
	virtual int soap_type(void) const { return 80; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__SymbolChartResponse, default initialized and not managed by a soap context
	virtual _ns1__SymbolChartResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SymbolChartResponse); }
	         _ns1__SymbolChartResponse() { _ns1__SymbolChartResponse::soap_default(NULL); }
	virtual ~_ns1__SymbolChartResponse() { }
	friend SOAP_FMAC1 _ns1__SymbolChartResponse * SOAP_FMAC2 soap_instantiate__ns1__SymbolChartResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:364 */
#ifndef SOAP_TYPE_ns__ns1__ExchangeMonths
#define SOAP_TYPE_ns__ns1__ExchangeMonths (81)
/* ns1:ExchangeMonths complex type: */
class SOAP_CMAC _ns1__ExchangeMonths
{
public:
	std::string *Token;	/* optional element of XSD type xsd:string */
	std::string *Exchange;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__ExchangeMonths (81)
	virtual int soap_type(void) const { return 81; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__ExchangeMonths, default initialized and not managed by a soap context
	virtual _ns1__ExchangeMonths *soap_alloc(void) const { return SOAP_NEW(_ns1__ExchangeMonths); }
	         _ns1__ExchangeMonths() { _ns1__ExchangeMonths::soap_default(NULL); }
	virtual ~_ns1__ExchangeMonths() { }
	friend SOAP_FMAC1 _ns1__ExchangeMonths * SOAP_FMAC2 soap_instantiate__ns1__ExchangeMonths(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:367 */
#ifndef SOAP_TYPE_ns__ns1__ExchangeMonthsResponse
#define SOAP_TYPE_ns__ns1__ExchangeMonthsResponse (82)
/* ns1:ExchangeMonthsResponse complex type: */
class SOAP_CMAC _ns1__ExchangeMonthsResponse
{
public:
	ns1__RESPONSE *ExchangeMonthsResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type ns1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__ExchangeMonthsResponse (82)
	virtual int soap_type(void) const { return 82; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__ExchangeMonthsResponse, default initialized and not managed by a soap context
	virtual _ns1__ExchangeMonthsResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__ExchangeMonthsResponse); }
	         _ns1__ExchangeMonthsResponse() { _ns1__ExchangeMonthsResponse::soap_default(NULL); }
	virtual ~_ns1__ExchangeMonthsResponse() { }
	friend SOAP_FMAC1 _ns1__ExchangeMonthsResponse * SOAP_FMAC2 soap_instantiate__ns1__ExchangeMonthsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:370 */
#ifndef SOAP_TYPE_ns__ns1__SplitListByExchange
#define SOAP_TYPE_ns__ns1__SplitListByExchange (83)
/* ns1:SplitListByExchange complex type: */
class SOAP_CMAC _ns1__SplitListByExchange
{
public:
	std::string *Token;	/* optional element of XSD type xsd:string */
	std::string *Exchange;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__SplitListByExchange (83)
	virtual int soap_type(void) const { return 83; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__SplitListByExchange, default initialized and not managed by a soap context
	virtual _ns1__SplitListByExchange *soap_alloc(void) const { return SOAP_NEW(_ns1__SplitListByExchange); }
	         _ns1__SplitListByExchange() { _ns1__SplitListByExchange::soap_default(NULL); }
	virtual ~_ns1__SplitListByExchange() { }
	friend SOAP_FMAC1 _ns1__SplitListByExchange * SOAP_FMAC2 soap_instantiate__ns1__SplitListByExchange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:373 */
#ifndef SOAP_TYPE_ns__ns1__SplitListByExchangeResponse
#define SOAP_TYPE_ns__ns1__SplitListByExchangeResponse (84)
/* ns1:SplitListByExchangeResponse complex type: */
class SOAP_CMAC _ns1__SplitListByExchangeResponse
{
public:
	ns1__RESPONSE *SplitListByExchangeResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type ns1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__SplitListByExchangeResponse (84)
	virtual int soap_type(void) const { return 84; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__SplitListByExchangeResponse, default initialized and not managed by a soap context
	virtual _ns1__SplitListByExchangeResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SplitListByExchangeResponse); }
	         _ns1__SplitListByExchangeResponse() { _ns1__SplitListByExchangeResponse::soap_default(NULL); }
	virtual ~_ns1__SplitListByExchangeResponse() { }
	friend SOAP_FMAC1 _ns1__SplitListByExchangeResponse * SOAP_FMAC2 soap_instantiate__ns1__SplitListByExchangeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:376 */
#ifndef SOAP_TYPE_ns__ns1__SplitListBySymbol
#define SOAP_TYPE_ns__ns1__SplitListBySymbol (85)
/* ns1:SplitListBySymbol complex type: */
class SOAP_CMAC _ns1__SplitListBySymbol
{
public:
	std::string *Token;	/* optional element of XSD type xsd:string */
	std::string *Exchange;	/* optional element of XSD type xsd:string */
	std::string *Symbol;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__SplitListBySymbol (85)
	virtual int soap_type(void) const { return 85; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__SplitListBySymbol, default initialized and not managed by a soap context
	virtual _ns1__SplitListBySymbol *soap_alloc(void) const { return SOAP_NEW(_ns1__SplitListBySymbol); }
	         _ns1__SplitListBySymbol() { _ns1__SplitListBySymbol::soap_default(NULL); }
	virtual ~_ns1__SplitListBySymbol() { }
	friend SOAP_FMAC1 _ns1__SplitListBySymbol * SOAP_FMAC2 soap_instantiate__ns1__SplitListBySymbol(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:379 */
#ifndef SOAP_TYPE_ns__ns1__SplitListBySymbolResponse
#define SOAP_TYPE_ns__ns1__SplitListBySymbolResponse (86)
/* ns1:SplitListBySymbolResponse complex type: */
class SOAP_CMAC _ns1__SplitListBySymbolResponse
{
public:
	ns1__RESPONSE *SplitListBySymbolResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type ns1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__SplitListBySymbolResponse (86)
	virtual int soap_type(void) const { return 86; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__SplitListBySymbolResponse, default initialized and not managed by a soap context
	virtual _ns1__SplitListBySymbolResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SplitListBySymbolResponse); }
	         _ns1__SplitListBySymbolResponse() { _ns1__SplitListBySymbolResponse::soap_default(NULL); }
	virtual ~_ns1__SplitListBySymbolResponse() { }
	friend SOAP_FMAC1 _ns1__SplitListBySymbolResponse * SOAP_FMAC2 soap_instantiate__ns1__SplitListBySymbolResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:382 */
#ifndef SOAP_TYPE_ns__ns1__CountryList
#define SOAP_TYPE_ns__ns1__CountryList (87)
/* ns1:CountryList complex type: */
class SOAP_CMAC _ns1__CountryList
{
public:
	std::string *Token;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__CountryList (87)
	virtual int soap_type(void) const { return 87; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__CountryList, default initialized and not managed by a soap context
	virtual _ns1__CountryList *soap_alloc(void) const { return SOAP_NEW(_ns1__CountryList); }
	         _ns1__CountryList() { _ns1__CountryList::soap_default(NULL); }
	virtual ~_ns1__CountryList() { }
	friend SOAP_FMAC1 _ns1__CountryList * SOAP_FMAC2 soap_instantiate__ns1__CountryList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:385 */
#ifndef SOAP_TYPE_ns__ns1__CountryListResponse
#define SOAP_TYPE_ns__ns1__CountryListResponse (88)
/* ns1:CountryListResponse complex type: */
class SOAP_CMAC _ns1__CountryListResponse
{
public:
	ns1__RESPONSE *CountryListResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type ns1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__CountryListResponse (88)
	virtual int soap_type(void) const { return 88; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__CountryListResponse, default initialized and not managed by a soap context
	virtual _ns1__CountryListResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__CountryListResponse); }
	         _ns1__CountryListResponse() { _ns1__CountryListResponse::soap_default(NULL); }
	virtual ~_ns1__CountryListResponse() { }
	friend SOAP_FMAC1 _ns1__CountryListResponse * SOAP_FMAC2 soap_instantiate__ns1__CountryListResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:388 */
#ifndef SOAP_TYPE_ns__ns1__SymbolHistoryPeriod
#define SOAP_TYPE_ns__ns1__SymbolHistoryPeriod (89)
/* ns1:SymbolHistoryPeriod complex type: */
class SOAP_CMAC _ns1__SymbolHistoryPeriod
{
public:
	std::string *Token;	/* optional element of XSD type xsd:string */
	std::string *Exchange;	/* optional element of XSD type xsd:string */
	std::string *Symbol;	/* optional element of XSD type xsd:string */
	std::string *Date;	/* optional element of XSD type xsd:string */
	std::string *Period;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__SymbolHistoryPeriod (89)
	virtual int soap_type(void) const { return 89; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__SymbolHistoryPeriod, default initialized and not managed by a soap context
	virtual _ns1__SymbolHistoryPeriod *soap_alloc(void) const { return SOAP_NEW(_ns1__SymbolHistoryPeriod); }
	         _ns1__SymbolHistoryPeriod() { _ns1__SymbolHistoryPeriod::soap_default(NULL); }
	virtual ~_ns1__SymbolHistoryPeriod() { }
	friend SOAP_FMAC1 _ns1__SymbolHistoryPeriod * SOAP_FMAC2 soap_instantiate__ns1__SymbolHistoryPeriod(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:391 */
#ifndef SOAP_TYPE_ns__ns1__SymbolHistoryPeriodResponse
#define SOAP_TYPE_ns__ns1__SymbolHistoryPeriodResponse (90)
/* ns1:SymbolHistoryPeriodResponse complex type: */
class SOAP_CMAC _ns1__SymbolHistoryPeriodResponse
{
public:
	ns1__RESPONSE *SymbolHistoryPeriodResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type ns1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__SymbolHistoryPeriodResponse (90)
	virtual int soap_type(void) const { return 90; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__SymbolHistoryPeriodResponse, default initialized and not managed by a soap context
	virtual _ns1__SymbolHistoryPeriodResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SymbolHistoryPeriodResponse); }
	         _ns1__SymbolHistoryPeriodResponse() { _ns1__SymbolHistoryPeriodResponse::soap_default(NULL); }
	virtual ~_ns1__SymbolHistoryPeriodResponse() { }
	friend SOAP_FMAC1 _ns1__SymbolHistoryPeriodResponse * SOAP_FMAC2 soap_instantiate__ns1__SymbolHistoryPeriodResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:394 */
#ifndef SOAP_TYPE_ns__ns1__SymbolHistoryPeriodByDateRange
#define SOAP_TYPE_ns__ns1__SymbolHistoryPeriodByDateRange (91)
/* ns1:SymbolHistoryPeriodByDateRange complex type: */
class SOAP_CMAC _ns1__SymbolHistoryPeriodByDateRange
{
public:
	std::string *Token;	/* optional element of XSD type xsd:string */
	std::string *Exchange;	/* optional element of XSD type xsd:string */
	std::string *Symbol;	/* optional element of XSD type xsd:string */
	std::string *StartDate;	/* optional element of XSD type xsd:string */
	std::string *EndDate;	/* optional element of XSD type xsd:string */
	std::string *Period;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__SymbolHistoryPeriodByDateRange (91)
	virtual int soap_type(void) const { return 91; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__SymbolHistoryPeriodByDateRange, default initialized and not managed by a soap context
	virtual _ns1__SymbolHistoryPeriodByDateRange *soap_alloc(void) const { return SOAP_NEW(_ns1__SymbolHistoryPeriodByDateRange); }
	         _ns1__SymbolHistoryPeriodByDateRange() { _ns1__SymbolHistoryPeriodByDateRange::soap_default(NULL); }
	virtual ~_ns1__SymbolHistoryPeriodByDateRange() { }
	friend SOAP_FMAC1 _ns1__SymbolHistoryPeriodByDateRange * SOAP_FMAC2 soap_instantiate__ns1__SymbolHistoryPeriodByDateRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:397 */
#ifndef SOAP_TYPE_ns__ns1__SymbolHistoryPeriodByDateRangeResponse
#define SOAP_TYPE_ns__ns1__SymbolHistoryPeriodByDateRangeResponse (92)
/* ns1:SymbolHistoryPeriodByDateRangeResponse complex type: */
class SOAP_CMAC _ns1__SymbolHistoryPeriodByDateRangeResponse
{
public:
	ns1__RESPONSE *SymbolHistoryPeriodByDateRangeResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type ns1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__SymbolHistoryPeriodByDateRangeResponse (92)
	virtual int soap_type(void) const { return 92; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__SymbolHistoryPeriodByDateRangeResponse, default initialized and not managed by a soap context
	virtual _ns1__SymbolHistoryPeriodByDateRangeResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SymbolHistoryPeriodByDateRangeResponse); }
	         _ns1__SymbolHistoryPeriodByDateRangeResponse() { _ns1__SymbolHistoryPeriodByDateRangeResponse::soap_default(NULL); }
	virtual ~_ns1__SymbolHistoryPeriodByDateRangeResponse() { }
	friend SOAP_FMAC1 _ns1__SymbolHistoryPeriodByDateRangeResponse * SOAP_FMAC2 soap_instantiate__ns1__SymbolHistoryPeriodByDateRangeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:400 */
#ifndef SOAP_TYPE_ns__ns1__QuoteListByDatePeriod
#define SOAP_TYPE_ns__ns1__QuoteListByDatePeriod (93)
/* ns1:QuoteListByDatePeriod complex type: */
class SOAP_CMAC _ns1__QuoteListByDatePeriod
{
public:
	std::string *Token;	/* optional element of XSD type xsd:string */
	std::string *Exchange;	/* optional element of XSD type xsd:string */
	std::string *QuoteDate;	/* optional element of XSD type xsd:string */
	std::string *Period;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__QuoteListByDatePeriod (93)
	virtual int soap_type(void) const { return 93; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__QuoteListByDatePeriod, default initialized and not managed by a soap context
	virtual _ns1__QuoteListByDatePeriod *soap_alloc(void) const { return SOAP_NEW(_ns1__QuoteListByDatePeriod); }
	         _ns1__QuoteListByDatePeriod() { _ns1__QuoteListByDatePeriod::soap_default(NULL); }
	virtual ~_ns1__QuoteListByDatePeriod() { }
	friend SOAP_FMAC1 _ns1__QuoteListByDatePeriod * SOAP_FMAC2 soap_instantiate__ns1__QuoteListByDatePeriod(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:403 */
#ifndef SOAP_TYPE_ns__ns1__QuoteListByDatePeriodResponse
#define SOAP_TYPE_ns__ns1__QuoteListByDatePeriodResponse (94)
/* ns1:QuoteListByDatePeriodResponse complex type: */
class SOAP_CMAC _ns1__QuoteListByDatePeriodResponse
{
public:
	ns1__RESPONSE *QuoteListByDatePeriodResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type ns1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__QuoteListByDatePeriodResponse (94)
	virtual int soap_type(void) const { return 94; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__QuoteListByDatePeriodResponse, default initialized and not managed by a soap context
	virtual _ns1__QuoteListByDatePeriodResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__QuoteListByDatePeriodResponse); }
	         _ns1__QuoteListByDatePeriodResponse() { _ns1__QuoteListByDatePeriodResponse::soap_default(NULL); }
	virtual ~_ns1__QuoteListByDatePeriodResponse() { }
	friend SOAP_FMAC1 _ns1__QuoteListByDatePeriodResponse * SOAP_FMAC2 soap_instantiate__ns1__QuoteListByDatePeriodResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:406 */
#ifndef SOAP_TYPE_ns__ns1__QuoteListByDatePeriod2
#define SOAP_TYPE_ns__ns1__QuoteListByDatePeriod2 (95)
/* ns1:QuoteListByDatePeriod2 complex type: */
class SOAP_CMAC _ns1__QuoteListByDatePeriod2
{
public:
	std::string *Token;	/* optional element of XSD type xsd:string */
	std::string *Exchange;	/* optional element of XSD type xsd:string */
	std::string *QuoteDate;	/* optional element of XSD type xsd:string */
	std::string *Period;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__QuoteListByDatePeriod2 (95)
	virtual int soap_type(void) const { return 95; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__QuoteListByDatePeriod2, default initialized and not managed by a soap context
	virtual _ns1__QuoteListByDatePeriod2 *soap_alloc(void) const { return SOAP_NEW(_ns1__QuoteListByDatePeriod2); }
	         _ns1__QuoteListByDatePeriod2() { _ns1__QuoteListByDatePeriod2::soap_default(NULL); }
	virtual ~_ns1__QuoteListByDatePeriod2() { }
	friend SOAP_FMAC1 _ns1__QuoteListByDatePeriod2 * SOAP_FMAC2 soap_instantiate__ns1__QuoteListByDatePeriod2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:409 */
#ifndef SOAP_TYPE_ns__ns1__QuoteListByDatePeriod2Response
#define SOAP_TYPE_ns__ns1__QuoteListByDatePeriod2Response (96)
/* ns1:QuoteListByDatePeriod2Response complex type: */
class SOAP_CMAC _ns1__QuoteListByDatePeriod2Response
{
public:
	ns1__RESPONSE *QuoteListByDatePeriod2Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type ns1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__QuoteListByDatePeriod2Response (96)
	virtual int soap_type(void) const { return 96; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__QuoteListByDatePeriod2Response, default initialized and not managed by a soap context
	virtual _ns1__QuoteListByDatePeriod2Response *soap_alloc(void) const { return SOAP_NEW(_ns1__QuoteListByDatePeriod2Response); }
	         _ns1__QuoteListByDatePeriod2Response() { _ns1__QuoteListByDatePeriod2Response::soap_default(NULL); }
	virtual ~_ns1__QuoteListByDatePeriod2Response() { }
	friend SOAP_FMAC1 _ns1__QuoteListByDatePeriod2Response * SOAP_FMAC2 soap_instantiate__ns1__QuoteListByDatePeriod2Response(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:412 */
#ifndef SOAP_TYPE_ns__ns1__SymbolChangesByExchange
#define SOAP_TYPE_ns__ns1__SymbolChangesByExchange (97)
/* ns1:SymbolChangesByExchange complex type: */
class SOAP_CMAC _ns1__SymbolChangesByExchange
{
public:
	std::string *Token;	/* optional element of XSD type xsd:string */
	std::string *Exchange;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__SymbolChangesByExchange (97)
	virtual int soap_type(void) const { return 97; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__SymbolChangesByExchange, default initialized and not managed by a soap context
	virtual _ns1__SymbolChangesByExchange *soap_alloc(void) const { return SOAP_NEW(_ns1__SymbolChangesByExchange); }
	         _ns1__SymbolChangesByExchange() { _ns1__SymbolChangesByExchange::soap_default(NULL); }
	virtual ~_ns1__SymbolChangesByExchange() { }
	friend SOAP_FMAC1 _ns1__SymbolChangesByExchange * SOAP_FMAC2 soap_instantiate__ns1__SymbolChangesByExchange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:415 */
#ifndef SOAP_TYPE_ns__ns1__SymbolChangesByExchangeResponse
#define SOAP_TYPE_ns__ns1__SymbolChangesByExchangeResponse (98)
/* ns1:SymbolChangesByExchangeResponse complex type: */
class SOAP_CMAC _ns1__SymbolChangesByExchangeResponse
{
public:
	ns1__RESPONSE *SymbolChangesByExchangeResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type ns1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__SymbolChangesByExchangeResponse (98)
	virtual int soap_type(void) const { return 98; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__SymbolChangesByExchangeResponse, default initialized and not managed by a soap context
	virtual _ns1__SymbolChangesByExchangeResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SymbolChangesByExchangeResponse); }
	         _ns1__SymbolChangesByExchangeResponse() { _ns1__SymbolChangesByExchangeResponse::soap_default(NULL); }
	virtual ~_ns1__SymbolChangesByExchangeResponse() { }
	friend SOAP_FMAC1 _ns1__SymbolChangesByExchangeResponse * SOAP_FMAC2 soap_instantiate__ns1__SymbolChangesByExchangeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:418 */
#ifndef SOAP_TYPE_ns__ns1__DataClientLatestVersion
#define SOAP_TYPE_ns__ns1__DataClientLatestVersion (99)
/* ns1:DataClientLatestVersion complex type: */
class SOAP_CMAC _ns1__DataClientLatestVersion
{
public:
	std::string *Token;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__DataClientLatestVersion (99)
	virtual int soap_type(void) const { return 99; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__DataClientLatestVersion, default initialized and not managed by a soap context
	virtual _ns1__DataClientLatestVersion *soap_alloc(void) const { return SOAP_NEW(_ns1__DataClientLatestVersion); }
	         _ns1__DataClientLatestVersion() { _ns1__DataClientLatestVersion::soap_default(NULL); }
	virtual ~_ns1__DataClientLatestVersion() { }
	friend SOAP_FMAC1 _ns1__DataClientLatestVersion * SOAP_FMAC2 soap_instantiate__ns1__DataClientLatestVersion(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:421 */
#ifndef SOAP_TYPE_ns__ns1__DataClientLatestVersionResponse
#define SOAP_TYPE_ns__ns1__DataClientLatestVersionResponse (100)
/* ns1:DataClientLatestVersionResponse complex type: */
class SOAP_CMAC _ns1__DataClientLatestVersionResponse
{
public:
	ns1__RESPONSE *DataClientLatestVersionResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type ns1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__DataClientLatestVersionResponse (100)
	virtual int soap_type(void) const { return 100; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__DataClientLatestVersionResponse, default initialized and not managed by a soap context
	virtual _ns1__DataClientLatestVersionResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__DataClientLatestVersionResponse); }
	         _ns1__DataClientLatestVersionResponse() { _ns1__DataClientLatestVersionResponse::soap_default(NULL); }
	virtual ~_ns1__DataClientLatestVersionResponse() { }
	friend SOAP_FMAC1 _ns1__DataClientLatestVersionResponse * SOAP_FMAC2 soap_instantiate__ns1__DataClientLatestVersionResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:424 */
#ifndef SOAP_TYPE_ns__ns1__DataFormats
#define SOAP_TYPE_ns__ns1__DataFormats (101)
/* ns1:DataFormats complex type: */
class SOAP_CMAC _ns1__DataFormats
{
public:
	std::string *Token;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__DataFormats (101)
	virtual int soap_type(void) const { return 101; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__DataFormats, default initialized and not managed by a soap context
	virtual _ns1__DataFormats *soap_alloc(void) const { return SOAP_NEW(_ns1__DataFormats); }
	         _ns1__DataFormats() { _ns1__DataFormats::soap_default(NULL); }
	virtual ~_ns1__DataFormats() { }
	friend SOAP_FMAC1 _ns1__DataFormats * SOAP_FMAC2 soap_instantiate__ns1__DataFormats(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:427 */
#ifndef SOAP_TYPE_ns__ns1__DataFormatsResponse
#define SOAP_TYPE_ns__ns1__DataFormatsResponse (102)
/* ns1:DataFormatsResponse complex type: */
class SOAP_CMAC _ns1__DataFormatsResponse
{
public:
	ns1__RESPONSE *DataFormatsResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type ns1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__DataFormatsResponse (102)
	virtual int soap_type(void) const { return 102; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__DataFormatsResponse, default initialized and not managed by a soap context
	virtual _ns1__DataFormatsResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__DataFormatsResponse); }
	         _ns1__DataFormatsResponse() { _ns1__DataFormatsResponse::soap_default(NULL); }
	virtual ~_ns1__DataFormatsResponse() { }
	friend SOAP_FMAC1 _ns1__DataFormatsResponse * SOAP_FMAC2 soap_instantiate__ns1__DataFormatsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:430 */
#ifndef SOAP_TYPE_ns__ns1__UpdateDataFormat
#define SOAP_TYPE_ns__ns1__UpdateDataFormat (103)
/* ns1:UpdateDataFormat complex type: */
class SOAP_CMAC _ns1__UpdateDataFormat
{
public:
	std::string *Token;	/* optional element of XSD type xsd:string */
	std::string *DataFormat;	/* optional element of XSD type xsd:string */
	bool IncludeHeader;	/* required element of XSD type xsd:boolean */
	bool IncludeSuffix;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__UpdateDataFormat (103)
	virtual int soap_type(void) const { return 103; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__UpdateDataFormat, default initialized and not managed by a soap context
	virtual _ns1__UpdateDataFormat *soap_alloc(void) const { return SOAP_NEW(_ns1__UpdateDataFormat); }
	         _ns1__UpdateDataFormat() { _ns1__UpdateDataFormat::soap_default(NULL); }
	virtual ~_ns1__UpdateDataFormat() { }
	friend SOAP_FMAC1 _ns1__UpdateDataFormat * SOAP_FMAC2 soap_instantiate__ns1__UpdateDataFormat(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:433 */
#ifndef SOAP_TYPE_ns__ns1__UpdateDataFormatResponse
#define SOAP_TYPE_ns__ns1__UpdateDataFormatResponse (104)
/* ns1:UpdateDataFormatResponse complex type: */
class SOAP_CMAC _ns1__UpdateDataFormatResponse
{
public:
	ns1__RESPONSE *UpdateDataFormatResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type ns1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__UpdateDataFormatResponse (104)
	virtual int soap_type(void) const { return 104; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__UpdateDataFormatResponse, default initialized and not managed by a soap context
	virtual _ns1__UpdateDataFormatResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__UpdateDataFormatResponse); }
	         _ns1__UpdateDataFormatResponse() { _ns1__UpdateDataFormatResponse::soap_default(NULL); }
	virtual ~_ns1__UpdateDataFormatResponse() { }
	friend SOAP_FMAC1 _ns1__UpdateDataFormatResponse * SOAP_FMAC2 soap_instantiate__ns1__UpdateDataFormatResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:436 */
#ifndef SOAP_TYPE_ns__ns1__ValidateAccess
#define SOAP_TYPE_ns__ns1__ValidateAccess (105)
/* ns1:ValidateAccess complex type: */
class SOAP_CMAC _ns1__ValidateAccess
{
public:
	std::string *Token;	/* optional element of XSD type xsd:string */
	std::string *Exchange;	/* optional element of XSD type xsd:string */
	std::string *QuoteDate;	/* optional element of XSD type xsd:string */
	std::string *Period;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__ValidateAccess (105)
	virtual int soap_type(void) const { return 105; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__ValidateAccess, default initialized and not managed by a soap context
	virtual _ns1__ValidateAccess *soap_alloc(void) const { return SOAP_NEW(_ns1__ValidateAccess); }
	         _ns1__ValidateAccess() { _ns1__ValidateAccess::soap_default(NULL); }
	virtual ~_ns1__ValidateAccess() { }
	friend SOAP_FMAC1 _ns1__ValidateAccess * SOAP_FMAC2 soap_instantiate__ns1__ValidateAccess(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:439 */
#ifndef SOAP_TYPE_ns__ns1__ValidateAccessResponse
#define SOAP_TYPE_ns__ns1__ValidateAccessResponse (106)
/* ns1:ValidateAccessResponse complex type: */
class SOAP_CMAC _ns1__ValidateAccessResponse
{
public:
	ns1__RESPONSE *ValidateAccessResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type ns1:RESPONSE */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns__ns1__ValidateAccessResponse (106)
	virtual int soap_type(void) const { return 106; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _ns1__ValidateAccessResponse, default initialized and not managed by a soap context
	virtual _ns1__ValidateAccessResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__ValidateAccessResponse); }
	         _ns1__ValidateAccessResponse() { _ns1__ValidateAccessResponse::soap_default(NULL); }
	virtual ~_ns1__ValidateAccessResponse() { }
	friend SOAP_FMAC1 _ns1__ValidateAccessResponse * SOAP_FMAC2 soap_instantiate__ns1__ValidateAccessResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:3323 */
#ifndef SOAP_TYPE_ns___ns1__Login
#define SOAP_TYPE_ns___ns1__Login (158)
/* Operation wrapper: */
struct __ns1__Login
{
public:
	_ns1__Login *ns1__Login;	/* optional element of XSD type ns1:Login */
public:
	int soap_type() const { return 158; } /* = unique type id SOAP_TYPE_ns___ns1__Login */
	         __ns1__Login();
	friend SOAP_FMAC1 __ns1__Login * SOAP_FMAC2 soap_instantiate___ns1__Login(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:3391 */
#ifndef SOAP_TYPE_ns___ns1__Login2
#define SOAP_TYPE_ns___ns1__Login2 (162)
/* Operation wrapper: */
struct __ns1__Login2
{
public:
	_ns1__Login2 *ns1__Login2;	/* optional element of XSD type ns1:Login2 */
public:
	int soap_type() const { return 162; } /* = unique type id SOAP_TYPE_ns___ns1__Login2 */
	         __ns1__Login2();
	friend SOAP_FMAC1 __ns1__Login2 * SOAP_FMAC2 soap_instantiate___ns1__Login2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:3458 */
#ifndef SOAP_TYPE_ns___ns1__Membership
#define SOAP_TYPE_ns___ns1__Membership (166)
/* Operation wrapper: */
struct __ns1__Membership
{
public:
	_ns1__Membership *ns1__Membership;	/* optional element of XSD type ns1:Membership */
public:
	int soap_type() const { return 166; } /* = unique type id SOAP_TYPE_ns___ns1__Membership */
	         __ns1__Membership();
	friend SOAP_FMAC1 __ns1__Membership * SOAP_FMAC2 soap_instantiate___ns1__Membership(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:3526 */
#ifndef SOAP_TYPE_ns___ns1__ExchangeList
#define SOAP_TYPE_ns___ns1__ExchangeList (170)
/* Operation wrapper: */
struct __ns1__ExchangeList
{
public:
	_ns1__ExchangeList *ns1__ExchangeList;	/* optional element of XSD type ns1:ExchangeList */
public:
	int soap_type() const { return 170; } /* = unique type id SOAP_TYPE_ns___ns1__ExchangeList */
	         __ns1__ExchangeList();
	friend SOAP_FMAC1 __ns1__ExchangeList * SOAP_FMAC2 soap_instantiate___ns1__ExchangeList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:3594 */
#ifndef SOAP_TYPE_ns___ns1__ExchangeGet
#define SOAP_TYPE_ns___ns1__ExchangeGet (174)
/* Operation wrapper: */
struct __ns1__ExchangeGet
{
public:
	_ns1__ExchangeGet *ns1__ExchangeGet;	/* optional element of XSD type ns1:ExchangeGet */
public:
	int soap_type() const { return 174; } /* = unique type id SOAP_TYPE_ns___ns1__ExchangeGet */
	         __ns1__ExchangeGet();
	friend SOAP_FMAC1 __ns1__ExchangeGet * SOAP_FMAC2 soap_instantiate___ns1__ExchangeGet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:3662 */
#ifndef SOAP_TYPE_ns___ns1__SymbolList
#define SOAP_TYPE_ns___ns1__SymbolList (178)
/* Operation wrapper: */
struct __ns1__SymbolList
{
public:
	_ns1__SymbolList *ns1__SymbolList;	/* optional element of XSD type ns1:SymbolList */
public:
	int soap_type() const { return 178; } /* = unique type id SOAP_TYPE_ns___ns1__SymbolList */
	         __ns1__SymbolList();
	friend SOAP_FMAC1 __ns1__SymbolList * SOAP_FMAC2 soap_instantiate___ns1__SymbolList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:3730 */
#ifndef SOAP_TYPE_ns___ns1__SymbolList2
#define SOAP_TYPE_ns___ns1__SymbolList2 (182)
/* Operation wrapper: */
struct __ns1__SymbolList2
{
public:
	_ns1__SymbolList2 *ns1__SymbolList2;	/* optional element of XSD type ns1:SymbolList2 */
public:
	int soap_type() const { return 182; } /* = unique type id SOAP_TYPE_ns___ns1__SymbolList2 */
	         __ns1__SymbolList2();
	friend SOAP_FMAC1 __ns1__SymbolList2 * SOAP_FMAC2 soap_instantiate___ns1__SymbolList2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:3798 */
#ifndef SOAP_TYPE_ns___ns1__QuoteGet
#define SOAP_TYPE_ns___ns1__QuoteGet (186)
/* Operation wrapper: */
struct __ns1__QuoteGet
{
public:
	_ns1__QuoteGet *ns1__QuoteGet;	/* optional element of XSD type ns1:QuoteGet */
public:
	int soap_type() const { return 186; } /* = unique type id SOAP_TYPE_ns___ns1__QuoteGet */
	         __ns1__QuoteGet();
	friend SOAP_FMAC1 __ns1__QuoteGet * SOAP_FMAC2 soap_instantiate___ns1__QuoteGet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:3867 */
#ifndef SOAP_TYPE_ns___ns1__QuoteList2
#define SOAP_TYPE_ns___ns1__QuoteList2 (190)
/* Operation wrapper: */
struct __ns1__QuoteList2
{
public:
	_ns1__QuoteList2 *ns1__QuoteList2;	/* optional element of XSD type ns1:QuoteList2 */
public:
	int soap_type() const { return 190; } /* = unique type id SOAP_TYPE_ns___ns1__QuoteList2 */
	         __ns1__QuoteList2();
	friend SOAP_FMAC1 __ns1__QuoteList2 * SOAP_FMAC2 soap_instantiate___ns1__QuoteList2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:3935 */
#ifndef SOAP_TYPE_ns___ns1__SymbolGet
#define SOAP_TYPE_ns___ns1__SymbolGet (194)
/* Operation wrapper: */
struct __ns1__SymbolGet
{
public:
	_ns1__SymbolGet *ns1__SymbolGet;	/* optional element of XSD type ns1:SymbolGet */
public:
	int soap_type() const { return 194; } /* = unique type id SOAP_TYPE_ns___ns1__SymbolGet */
	         __ns1__SymbolGet();
	friend SOAP_FMAC1 __ns1__SymbolGet * SOAP_FMAC2 soap_instantiate___ns1__SymbolGet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:4003 */
#ifndef SOAP_TYPE_ns___ns1__QuoteList
#define SOAP_TYPE_ns___ns1__QuoteList (198)
/* Operation wrapper: */
struct __ns1__QuoteList
{
public:
	_ns1__QuoteList *ns1__QuoteList;	/* optional element of XSD type ns1:QuoteList */
public:
	int soap_type() const { return 198; } /* = unique type id SOAP_TYPE_ns___ns1__QuoteList */
	         __ns1__QuoteList();
	friend SOAP_FMAC1 __ns1__QuoteList * SOAP_FMAC2 soap_instantiate___ns1__QuoteList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:4071 */
#ifndef SOAP_TYPE_ns___ns1__NewsList
#define SOAP_TYPE_ns___ns1__NewsList (202)
/* Operation wrapper: */
struct __ns1__NewsList
{
public:
	_ns1__NewsList *ns1__NewsList;	/* optional element of XSD type ns1:NewsList */
public:
	int soap_type() const { return 202; } /* = unique type id SOAP_TYPE_ns___ns1__NewsList */
	         __ns1__NewsList();
	friend SOAP_FMAC1 __ns1__NewsList * SOAP_FMAC2 soap_instantiate___ns1__NewsList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:4140 */
#ifndef SOAP_TYPE_ns___ns1__NewsListBySymbol
#define SOAP_TYPE_ns___ns1__NewsListBySymbol (206)
/* Operation wrapper: */
struct __ns1__NewsListBySymbol
{
public:
	_ns1__NewsListBySymbol *ns1__NewsListBySymbol;	/* optional element of XSD type ns1:NewsListBySymbol */
public:
	int soap_type() const { return 206; } /* = unique type id SOAP_TYPE_ns___ns1__NewsListBySymbol */
	         __ns1__NewsListBySymbol();
	friend SOAP_FMAC1 __ns1__NewsListBySymbol * SOAP_FMAC2 soap_instantiate___ns1__NewsListBySymbol(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:4208 */
#ifndef SOAP_TYPE_ns___ns1__FundamentalList
#define SOAP_TYPE_ns___ns1__FundamentalList (210)
/* Operation wrapper: */
struct __ns1__FundamentalList
{
public:
	_ns1__FundamentalList *ns1__FundamentalList;	/* optional element of XSD type ns1:FundamentalList */
public:
	int soap_type() const { return 210; } /* = unique type id SOAP_TYPE_ns___ns1__FundamentalList */
	         __ns1__FundamentalList();
	friend SOAP_FMAC1 __ns1__FundamentalList * SOAP_FMAC2 soap_instantiate___ns1__FundamentalList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:4276 */
#ifndef SOAP_TYPE_ns___ns1__TechnicalList
#define SOAP_TYPE_ns___ns1__TechnicalList (214)
/* Operation wrapper: */
struct __ns1__TechnicalList
{
public:
	_ns1__TechnicalList *ns1__TechnicalList;	/* optional element of XSD type ns1:TechnicalList */
public:
	int soap_type() const { return 214; } /* = unique type id SOAP_TYPE_ns___ns1__TechnicalList */
	         __ns1__TechnicalList();
	friend SOAP_FMAC1 __ns1__TechnicalList * SOAP_FMAC2 soap_instantiate___ns1__TechnicalList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:4345 */
#ifndef SOAP_TYPE_ns___ns1__QuoteListByDate
#define SOAP_TYPE_ns___ns1__QuoteListByDate (218)
/* Operation wrapper: */
struct __ns1__QuoteListByDate
{
public:
	_ns1__QuoteListByDate *ns1__QuoteListByDate;	/* optional element of XSD type ns1:QuoteListByDate */
public:
	int soap_type() const { return 218; } /* = unique type id SOAP_TYPE_ns___ns1__QuoteListByDate */
	         __ns1__QuoteListByDate();
	friend SOAP_FMAC1 __ns1__QuoteListByDate * SOAP_FMAC2 soap_instantiate___ns1__QuoteListByDate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:4414 */
#ifndef SOAP_TYPE_ns___ns1__QuoteListByDate2
#define SOAP_TYPE_ns___ns1__QuoteListByDate2 (222)
/* Operation wrapper: */
struct __ns1__QuoteListByDate2
{
public:
	_ns1__QuoteListByDate2 *ns1__QuoteListByDate2;	/* optional element of XSD type ns1:QuoteListByDate2 */
public:
	int soap_type() const { return 222; } /* = unique type id SOAP_TYPE_ns___ns1__QuoteListByDate2 */
	         __ns1__QuoteListByDate2();
	friend SOAP_FMAC1 __ns1__QuoteListByDate2 * SOAP_FMAC2 soap_instantiate___ns1__QuoteListByDate2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:4484 */
#ifndef SOAP_TYPE_ns___ns1__SymbolHistory
#define SOAP_TYPE_ns___ns1__SymbolHistory (226)
/* Operation wrapper: */
struct __ns1__SymbolHistory
{
public:
	_ns1__SymbolHistory *ns1__SymbolHistory;	/* optional element of XSD type ns1:SymbolHistory */
public:
	int soap_type() const { return 226; } /* = unique type id SOAP_TYPE_ns___ns1__SymbolHistory */
	         __ns1__SymbolHistory();
	friend SOAP_FMAC1 __ns1__SymbolHistory * SOAP_FMAC2 soap_instantiate___ns1__SymbolHistory(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:4552 */
#ifndef SOAP_TYPE_ns___ns1__Top10Gains
#define SOAP_TYPE_ns___ns1__Top10Gains (230)
/* Operation wrapper: */
struct __ns1__Top10Gains
{
public:
	_ns1__Top10Gains *ns1__Top10Gains;	/* optional element of XSD type ns1:Top10Gains */
public:
	int soap_type() const { return 230; } /* = unique type id SOAP_TYPE_ns___ns1__Top10Gains */
	         __ns1__Top10Gains();
	friend SOAP_FMAC1 __ns1__Top10Gains * SOAP_FMAC2 soap_instantiate___ns1__Top10Gains(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:4620 */
#ifndef SOAP_TYPE_ns___ns1__Top10Losses
#define SOAP_TYPE_ns___ns1__Top10Losses (234)
/* Operation wrapper: */
struct __ns1__Top10Losses
{
public:
	_ns1__Top10Losses *ns1__Top10Losses;	/* optional element of XSD type ns1:Top10Losses */
public:
	int soap_type() const { return 234; } /* = unique type id SOAP_TYPE_ns___ns1__Top10Losses */
	         __ns1__Top10Losses();
	friend SOAP_FMAC1 __ns1__Top10Losses * SOAP_FMAC2 soap_instantiate___ns1__Top10Losses(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:4688 */
#ifndef SOAP_TYPE_ns___ns1__SymbolChart
#define SOAP_TYPE_ns___ns1__SymbolChart (238)
/* Operation wrapper: */
struct __ns1__SymbolChart
{
public:
	_ns1__SymbolChart *ns1__SymbolChart;	/* optional element of XSD type ns1:SymbolChart */
public:
	int soap_type() const { return 238; } /* = unique type id SOAP_TYPE_ns___ns1__SymbolChart */
	         __ns1__SymbolChart();
	friend SOAP_FMAC1 __ns1__SymbolChart * SOAP_FMAC2 soap_instantiate___ns1__SymbolChart(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:4756 */
#ifndef SOAP_TYPE_ns___ns1__ExchangeMonths
#define SOAP_TYPE_ns___ns1__ExchangeMonths (242)
/* Operation wrapper: */
struct __ns1__ExchangeMonths
{
public:
	_ns1__ExchangeMonths *ns1__ExchangeMonths;	/* optional element of XSD type ns1:ExchangeMonths */
public:
	int soap_type() const { return 242; } /* = unique type id SOAP_TYPE_ns___ns1__ExchangeMonths */
	         __ns1__ExchangeMonths();
	friend SOAP_FMAC1 __ns1__ExchangeMonths * SOAP_FMAC2 soap_instantiate___ns1__ExchangeMonths(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:4824 */
#ifndef SOAP_TYPE_ns___ns1__SplitListByExchange
#define SOAP_TYPE_ns___ns1__SplitListByExchange (246)
/* Operation wrapper: */
struct __ns1__SplitListByExchange
{
public:
	_ns1__SplitListByExchange *ns1__SplitListByExchange;	/* optional element of XSD type ns1:SplitListByExchange */
public:
	int soap_type() const { return 246; } /* = unique type id SOAP_TYPE_ns___ns1__SplitListByExchange */
	         __ns1__SplitListByExchange();
	friend SOAP_FMAC1 __ns1__SplitListByExchange * SOAP_FMAC2 soap_instantiate___ns1__SplitListByExchange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:4892 */
#ifndef SOAP_TYPE_ns___ns1__SplitListBySymbol
#define SOAP_TYPE_ns___ns1__SplitListBySymbol (250)
/* Operation wrapper: */
struct __ns1__SplitListBySymbol
{
public:
	_ns1__SplitListBySymbol *ns1__SplitListBySymbol;	/* optional element of XSD type ns1:SplitListBySymbol */
public:
	int soap_type() const { return 250; } /* = unique type id SOAP_TYPE_ns___ns1__SplitListBySymbol */
	         __ns1__SplitListBySymbol();
	friend SOAP_FMAC1 __ns1__SplitListBySymbol * SOAP_FMAC2 soap_instantiate___ns1__SplitListBySymbol(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:4960 */
#ifndef SOAP_TYPE_ns___ns1__CountryList
#define SOAP_TYPE_ns___ns1__CountryList (254)
/* Operation wrapper: */
struct __ns1__CountryList
{
public:
	_ns1__CountryList *ns1__CountryList;	/* optional element of XSD type ns1:CountryList */
public:
	int soap_type() const { return 254; } /* = unique type id SOAP_TYPE_ns___ns1__CountryList */
	         __ns1__CountryList();
	friend SOAP_FMAC1 __ns1__CountryList * SOAP_FMAC2 soap_instantiate___ns1__CountryList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:5030 */
#ifndef SOAP_TYPE_ns___ns1__SymbolHistoryPeriod
#define SOAP_TYPE_ns___ns1__SymbolHistoryPeriod (258)
/* Operation wrapper: */
struct __ns1__SymbolHistoryPeriod
{
public:
	_ns1__SymbolHistoryPeriod *ns1__SymbolHistoryPeriod;	/* optional element of XSD type ns1:SymbolHistoryPeriod */
public:
	int soap_type() const { return 258; } /* = unique type id SOAP_TYPE_ns___ns1__SymbolHistoryPeriod */
	         __ns1__SymbolHistoryPeriod();
	friend SOAP_FMAC1 __ns1__SymbolHistoryPeriod * SOAP_FMAC2 soap_instantiate___ns1__SymbolHistoryPeriod(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:5100 */
#ifndef SOAP_TYPE_ns___ns1__SymbolHistoryPeriodByDateRange
#define SOAP_TYPE_ns___ns1__SymbolHistoryPeriodByDateRange (262)
/* Operation wrapper: */
struct __ns1__SymbolHistoryPeriodByDateRange
{
public:
	_ns1__SymbolHistoryPeriodByDateRange *ns1__SymbolHistoryPeriodByDateRange;	/* optional element of XSD type ns1:SymbolHistoryPeriodByDateRange */
public:
	int soap_type() const { return 262; } /* = unique type id SOAP_TYPE_ns___ns1__SymbolHistoryPeriodByDateRange */
	         __ns1__SymbolHistoryPeriodByDateRange();
	friend SOAP_FMAC1 __ns1__SymbolHistoryPeriodByDateRange * SOAP_FMAC2 soap_instantiate___ns1__SymbolHistoryPeriodByDateRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:5169 */
#ifndef SOAP_TYPE_ns___ns1__QuoteListByDatePeriod
#define SOAP_TYPE_ns___ns1__QuoteListByDatePeriod (266)
/* Operation wrapper: */
struct __ns1__QuoteListByDatePeriod
{
public:
	_ns1__QuoteListByDatePeriod *ns1__QuoteListByDatePeriod;	/* optional element of XSD type ns1:QuoteListByDatePeriod */
public:
	int soap_type() const { return 266; } /* = unique type id SOAP_TYPE_ns___ns1__QuoteListByDatePeriod */
	         __ns1__QuoteListByDatePeriod();
	friend SOAP_FMAC1 __ns1__QuoteListByDatePeriod * SOAP_FMAC2 soap_instantiate___ns1__QuoteListByDatePeriod(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:5239 */
#ifndef SOAP_TYPE_ns___ns1__QuoteListByDatePeriod2
#define SOAP_TYPE_ns___ns1__QuoteListByDatePeriod2 (270)
/* Operation wrapper: */
struct __ns1__QuoteListByDatePeriod2
{
public:
	_ns1__QuoteListByDatePeriod2 *ns1__QuoteListByDatePeriod2;	/* optional element of XSD type ns1:QuoteListByDatePeriod2 */
public:
	int soap_type() const { return 270; } /* = unique type id SOAP_TYPE_ns___ns1__QuoteListByDatePeriod2 */
	         __ns1__QuoteListByDatePeriod2();
	friend SOAP_FMAC1 __ns1__QuoteListByDatePeriod2 * SOAP_FMAC2 soap_instantiate___ns1__QuoteListByDatePeriod2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:5307 */
#ifndef SOAP_TYPE_ns___ns1__SymbolChangesByExchange
#define SOAP_TYPE_ns___ns1__SymbolChangesByExchange (274)
/* Operation wrapper: */
struct __ns1__SymbolChangesByExchange
{
public:
	_ns1__SymbolChangesByExchange *ns1__SymbolChangesByExchange;	/* optional element of XSD type ns1:SymbolChangesByExchange */
public:
	int soap_type() const { return 274; } /* = unique type id SOAP_TYPE_ns___ns1__SymbolChangesByExchange */
	         __ns1__SymbolChangesByExchange();
	friend SOAP_FMAC1 __ns1__SymbolChangesByExchange * SOAP_FMAC2 soap_instantiate___ns1__SymbolChangesByExchange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:5375 */
#ifndef SOAP_TYPE_ns___ns1__DataClientLatestVersion
#define SOAP_TYPE_ns___ns1__DataClientLatestVersion (278)
/* Operation wrapper: */
struct __ns1__DataClientLatestVersion
{
public:
	_ns1__DataClientLatestVersion *ns1__DataClientLatestVersion;	/* optional element of XSD type ns1:DataClientLatestVersion */
public:
	int soap_type() const { return 278; } /* = unique type id SOAP_TYPE_ns___ns1__DataClientLatestVersion */
	         __ns1__DataClientLatestVersion();
	friend SOAP_FMAC1 __ns1__DataClientLatestVersion * SOAP_FMAC2 soap_instantiate___ns1__DataClientLatestVersion(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:5443 */
#ifndef SOAP_TYPE_ns___ns1__DataFormats
#define SOAP_TYPE_ns___ns1__DataFormats (282)
/* Operation wrapper: */
struct __ns1__DataFormats
{
public:
	_ns1__DataFormats *ns1__DataFormats;	/* optional element of XSD type ns1:DataFormats */
public:
	int soap_type() const { return 282; } /* = unique type id SOAP_TYPE_ns___ns1__DataFormats */
	         __ns1__DataFormats();
	friend SOAP_FMAC1 __ns1__DataFormats * SOAP_FMAC2 soap_instantiate___ns1__DataFormats(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:5511 */
#ifndef SOAP_TYPE_ns___ns1__UpdateDataFormat
#define SOAP_TYPE_ns___ns1__UpdateDataFormat (286)
/* Operation wrapper: */
struct __ns1__UpdateDataFormat
{
public:
	_ns1__UpdateDataFormat *ns1__UpdateDataFormat;	/* optional element of XSD type ns1:UpdateDataFormat */
public:
	int soap_type() const { return 286; } /* = unique type id SOAP_TYPE_ns___ns1__UpdateDataFormat */
	         __ns1__UpdateDataFormat();
	friend SOAP_FMAC1 __ns1__UpdateDataFormat * SOAP_FMAC2 soap_instantiate___ns1__UpdateDataFormat(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:5580 */
#ifndef SOAP_TYPE_ns___ns1__ValidateAccess
#define SOAP_TYPE_ns___ns1__ValidateAccess (290)
/* Operation wrapper: */
struct __ns1__ValidateAccess
{
public:
	_ns1__ValidateAccess *ns1__ValidateAccess;	/* optional element of XSD type ns1:ValidateAccess */
public:
	int soap_type() const { return 290; } /* = unique type id SOAP_TYPE_ns___ns1__ValidateAccess */
	         __ns1__ValidateAccess();
	friend SOAP_FMAC1 __ns1__ValidateAccess * SOAP_FMAC2 soap_instantiate___ns1__ValidateAccess(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:5648 */
#ifndef SOAP_TYPE_ns___ns1__Login_
#define SOAP_TYPE_ns___ns1__Login_ (292)
/* Operation wrapper: */
struct __ns1__Login_
{
public:
	_ns1__Login *ns1__Login;	/* optional element of XSD type ns1:Login */
public:
	int soap_type() const { return 292; } /* = unique type id SOAP_TYPE_ns___ns1__Login_ */
	         __ns1__Login_();
	friend SOAP_FMAC1 __ns1__Login_ * SOAP_FMAC2 soap_instantiate___ns1__Login_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:5716 */
#ifndef SOAP_TYPE_ns___ns1__Login2_
#define SOAP_TYPE_ns___ns1__Login2_ (294)
/* Operation wrapper: */
struct __ns1__Login2_
{
public:
	_ns1__Login2 *ns1__Login2;	/* optional element of XSD type ns1:Login2 */
public:
	int soap_type() const { return 294; } /* = unique type id SOAP_TYPE_ns___ns1__Login2_ */
	         __ns1__Login2_();
	friend SOAP_FMAC1 __ns1__Login2_ * SOAP_FMAC2 soap_instantiate___ns1__Login2_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:5783 */
#ifndef SOAP_TYPE_ns___ns1__Membership_
#define SOAP_TYPE_ns___ns1__Membership_ (296)
/* Operation wrapper: */
struct __ns1__Membership_
{
public:
	_ns1__Membership *ns1__Membership;	/* optional element of XSD type ns1:Membership */
public:
	int soap_type() const { return 296; } /* = unique type id SOAP_TYPE_ns___ns1__Membership_ */
	         __ns1__Membership_();
	friend SOAP_FMAC1 __ns1__Membership_ * SOAP_FMAC2 soap_instantiate___ns1__Membership_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:5851 */
#ifndef SOAP_TYPE_ns___ns1__ExchangeList_
#define SOAP_TYPE_ns___ns1__ExchangeList_ (298)
/* Operation wrapper: */
struct __ns1__ExchangeList_
{
public:
	_ns1__ExchangeList *ns1__ExchangeList;	/* optional element of XSD type ns1:ExchangeList */
public:
	int soap_type() const { return 298; } /* = unique type id SOAP_TYPE_ns___ns1__ExchangeList_ */
	         __ns1__ExchangeList_();
	friend SOAP_FMAC1 __ns1__ExchangeList_ * SOAP_FMAC2 soap_instantiate___ns1__ExchangeList_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:5919 */
#ifndef SOAP_TYPE_ns___ns1__ExchangeGet_
#define SOAP_TYPE_ns___ns1__ExchangeGet_ (300)
/* Operation wrapper: */
struct __ns1__ExchangeGet_
{
public:
	_ns1__ExchangeGet *ns1__ExchangeGet;	/* optional element of XSD type ns1:ExchangeGet */
public:
	int soap_type() const { return 300; } /* = unique type id SOAP_TYPE_ns___ns1__ExchangeGet_ */
	         __ns1__ExchangeGet_();
	friend SOAP_FMAC1 __ns1__ExchangeGet_ * SOAP_FMAC2 soap_instantiate___ns1__ExchangeGet_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:5987 */
#ifndef SOAP_TYPE_ns___ns1__SymbolList_
#define SOAP_TYPE_ns___ns1__SymbolList_ (302)
/* Operation wrapper: */
struct __ns1__SymbolList_
{
public:
	_ns1__SymbolList *ns1__SymbolList;	/* optional element of XSD type ns1:SymbolList */
public:
	int soap_type() const { return 302; } /* = unique type id SOAP_TYPE_ns___ns1__SymbolList_ */
	         __ns1__SymbolList_();
	friend SOAP_FMAC1 __ns1__SymbolList_ * SOAP_FMAC2 soap_instantiate___ns1__SymbolList_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:6055 */
#ifndef SOAP_TYPE_ns___ns1__SymbolList2_
#define SOAP_TYPE_ns___ns1__SymbolList2_ (304)
/* Operation wrapper: */
struct __ns1__SymbolList2_
{
public:
	_ns1__SymbolList2 *ns1__SymbolList2;	/* optional element of XSD type ns1:SymbolList2 */
public:
	int soap_type() const { return 304; } /* = unique type id SOAP_TYPE_ns___ns1__SymbolList2_ */
	         __ns1__SymbolList2_();
	friend SOAP_FMAC1 __ns1__SymbolList2_ * SOAP_FMAC2 soap_instantiate___ns1__SymbolList2_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:6123 */
#ifndef SOAP_TYPE_ns___ns1__QuoteGet_
#define SOAP_TYPE_ns___ns1__QuoteGet_ (306)
/* Operation wrapper: */
struct __ns1__QuoteGet_
{
public:
	_ns1__QuoteGet *ns1__QuoteGet;	/* optional element of XSD type ns1:QuoteGet */
public:
	int soap_type() const { return 306; } /* = unique type id SOAP_TYPE_ns___ns1__QuoteGet_ */
	         __ns1__QuoteGet_();
	friend SOAP_FMAC1 __ns1__QuoteGet_ * SOAP_FMAC2 soap_instantiate___ns1__QuoteGet_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:6192 */
#ifndef SOAP_TYPE_ns___ns1__QuoteList2_
#define SOAP_TYPE_ns___ns1__QuoteList2_ (308)
/* Operation wrapper: */
struct __ns1__QuoteList2_
{
public:
	_ns1__QuoteList2 *ns1__QuoteList2;	/* optional element of XSD type ns1:QuoteList2 */
public:
	int soap_type() const { return 308; } /* = unique type id SOAP_TYPE_ns___ns1__QuoteList2_ */
	         __ns1__QuoteList2_();
	friend SOAP_FMAC1 __ns1__QuoteList2_ * SOAP_FMAC2 soap_instantiate___ns1__QuoteList2_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:6260 */
#ifndef SOAP_TYPE_ns___ns1__SymbolGet_
#define SOAP_TYPE_ns___ns1__SymbolGet_ (310)
/* Operation wrapper: */
struct __ns1__SymbolGet_
{
public:
	_ns1__SymbolGet *ns1__SymbolGet;	/* optional element of XSD type ns1:SymbolGet */
public:
	int soap_type() const { return 310; } /* = unique type id SOAP_TYPE_ns___ns1__SymbolGet_ */
	         __ns1__SymbolGet_();
	friend SOAP_FMAC1 __ns1__SymbolGet_ * SOAP_FMAC2 soap_instantiate___ns1__SymbolGet_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:6328 */
#ifndef SOAP_TYPE_ns___ns1__QuoteList_
#define SOAP_TYPE_ns___ns1__QuoteList_ (312)
/* Operation wrapper: */
struct __ns1__QuoteList_
{
public:
	_ns1__QuoteList *ns1__QuoteList;	/* optional element of XSD type ns1:QuoteList */
public:
	int soap_type() const { return 312; } /* = unique type id SOAP_TYPE_ns___ns1__QuoteList_ */
	         __ns1__QuoteList_();
	friend SOAP_FMAC1 __ns1__QuoteList_ * SOAP_FMAC2 soap_instantiate___ns1__QuoteList_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:6396 */
#ifndef SOAP_TYPE_ns___ns1__NewsList_
#define SOAP_TYPE_ns___ns1__NewsList_ (314)
/* Operation wrapper: */
struct __ns1__NewsList_
{
public:
	_ns1__NewsList *ns1__NewsList;	/* optional element of XSD type ns1:NewsList */
public:
	int soap_type() const { return 314; } /* = unique type id SOAP_TYPE_ns___ns1__NewsList_ */
	         __ns1__NewsList_();
	friend SOAP_FMAC1 __ns1__NewsList_ * SOAP_FMAC2 soap_instantiate___ns1__NewsList_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:6465 */
#ifndef SOAP_TYPE_ns___ns1__NewsListBySymbol_
#define SOAP_TYPE_ns___ns1__NewsListBySymbol_ (316)
/* Operation wrapper: */
struct __ns1__NewsListBySymbol_
{
public:
	_ns1__NewsListBySymbol *ns1__NewsListBySymbol;	/* optional element of XSD type ns1:NewsListBySymbol */
public:
	int soap_type() const { return 316; } /* = unique type id SOAP_TYPE_ns___ns1__NewsListBySymbol_ */
	         __ns1__NewsListBySymbol_();
	friend SOAP_FMAC1 __ns1__NewsListBySymbol_ * SOAP_FMAC2 soap_instantiate___ns1__NewsListBySymbol_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:6533 */
#ifndef SOAP_TYPE_ns___ns1__FundamentalList_
#define SOAP_TYPE_ns___ns1__FundamentalList_ (318)
/* Operation wrapper: */
struct __ns1__FundamentalList_
{
public:
	_ns1__FundamentalList *ns1__FundamentalList;	/* optional element of XSD type ns1:FundamentalList */
public:
	int soap_type() const { return 318; } /* = unique type id SOAP_TYPE_ns___ns1__FundamentalList_ */
	         __ns1__FundamentalList_();
	friend SOAP_FMAC1 __ns1__FundamentalList_ * SOAP_FMAC2 soap_instantiate___ns1__FundamentalList_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:6601 */
#ifndef SOAP_TYPE_ns___ns1__TechnicalList_
#define SOAP_TYPE_ns___ns1__TechnicalList_ (320)
/* Operation wrapper: */
struct __ns1__TechnicalList_
{
public:
	_ns1__TechnicalList *ns1__TechnicalList;	/* optional element of XSD type ns1:TechnicalList */
public:
	int soap_type() const { return 320; } /* = unique type id SOAP_TYPE_ns___ns1__TechnicalList_ */
	         __ns1__TechnicalList_();
	friend SOAP_FMAC1 __ns1__TechnicalList_ * SOAP_FMAC2 soap_instantiate___ns1__TechnicalList_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:6670 */
#ifndef SOAP_TYPE_ns___ns1__QuoteListByDate_
#define SOAP_TYPE_ns___ns1__QuoteListByDate_ (322)
/* Operation wrapper: */
struct __ns1__QuoteListByDate_
{
public:
	_ns1__QuoteListByDate *ns1__QuoteListByDate;	/* optional element of XSD type ns1:QuoteListByDate */
public:
	int soap_type() const { return 322; } /* = unique type id SOAP_TYPE_ns___ns1__QuoteListByDate_ */
	         __ns1__QuoteListByDate_();
	friend SOAP_FMAC1 __ns1__QuoteListByDate_ * SOAP_FMAC2 soap_instantiate___ns1__QuoteListByDate_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:6739 */
#ifndef SOAP_TYPE_ns___ns1__QuoteListByDate2_
#define SOAP_TYPE_ns___ns1__QuoteListByDate2_ (324)
/* Operation wrapper: */
struct __ns1__QuoteListByDate2_
{
public:
	_ns1__QuoteListByDate2 *ns1__QuoteListByDate2;	/* optional element of XSD type ns1:QuoteListByDate2 */
public:
	int soap_type() const { return 324; } /* = unique type id SOAP_TYPE_ns___ns1__QuoteListByDate2_ */
	         __ns1__QuoteListByDate2_();
	friend SOAP_FMAC1 __ns1__QuoteListByDate2_ * SOAP_FMAC2 soap_instantiate___ns1__QuoteListByDate2_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:6809 */
#ifndef SOAP_TYPE_ns___ns1__SymbolHistory_
#define SOAP_TYPE_ns___ns1__SymbolHistory_ (326)
/* Operation wrapper: */
struct __ns1__SymbolHistory_
{
public:
	_ns1__SymbolHistory *ns1__SymbolHistory;	/* optional element of XSD type ns1:SymbolHistory */
public:
	int soap_type() const { return 326; } /* = unique type id SOAP_TYPE_ns___ns1__SymbolHistory_ */
	         __ns1__SymbolHistory_();
	friend SOAP_FMAC1 __ns1__SymbolHistory_ * SOAP_FMAC2 soap_instantiate___ns1__SymbolHistory_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:6877 */
#ifndef SOAP_TYPE_ns___ns1__Top10Gains_
#define SOAP_TYPE_ns___ns1__Top10Gains_ (328)
/* Operation wrapper: */
struct __ns1__Top10Gains_
{
public:
	_ns1__Top10Gains *ns1__Top10Gains;	/* optional element of XSD type ns1:Top10Gains */
public:
	int soap_type() const { return 328; } /* = unique type id SOAP_TYPE_ns___ns1__Top10Gains_ */
	         __ns1__Top10Gains_();
	friend SOAP_FMAC1 __ns1__Top10Gains_ * SOAP_FMAC2 soap_instantiate___ns1__Top10Gains_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:6945 */
#ifndef SOAP_TYPE_ns___ns1__Top10Losses_
#define SOAP_TYPE_ns___ns1__Top10Losses_ (330)
/* Operation wrapper: */
struct __ns1__Top10Losses_
{
public:
	_ns1__Top10Losses *ns1__Top10Losses;	/* optional element of XSD type ns1:Top10Losses */
public:
	int soap_type() const { return 330; } /* = unique type id SOAP_TYPE_ns___ns1__Top10Losses_ */
	         __ns1__Top10Losses_();
	friend SOAP_FMAC1 __ns1__Top10Losses_ * SOAP_FMAC2 soap_instantiate___ns1__Top10Losses_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:7013 */
#ifndef SOAP_TYPE_ns___ns1__SymbolChart_
#define SOAP_TYPE_ns___ns1__SymbolChart_ (332)
/* Operation wrapper: */
struct __ns1__SymbolChart_
{
public:
	_ns1__SymbolChart *ns1__SymbolChart;	/* optional element of XSD type ns1:SymbolChart */
public:
	int soap_type() const { return 332; } /* = unique type id SOAP_TYPE_ns___ns1__SymbolChart_ */
	         __ns1__SymbolChart_();
	friend SOAP_FMAC1 __ns1__SymbolChart_ * SOAP_FMAC2 soap_instantiate___ns1__SymbolChart_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:7081 */
#ifndef SOAP_TYPE_ns___ns1__ExchangeMonths_
#define SOAP_TYPE_ns___ns1__ExchangeMonths_ (334)
/* Operation wrapper: */
struct __ns1__ExchangeMonths_
{
public:
	_ns1__ExchangeMonths *ns1__ExchangeMonths;	/* optional element of XSD type ns1:ExchangeMonths */
public:
	int soap_type() const { return 334; } /* = unique type id SOAP_TYPE_ns___ns1__ExchangeMonths_ */
	         __ns1__ExchangeMonths_();
	friend SOAP_FMAC1 __ns1__ExchangeMonths_ * SOAP_FMAC2 soap_instantiate___ns1__ExchangeMonths_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:7149 */
#ifndef SOAP_TYPE_ns___ns1__SplitListByExchange_
#define SOAP_TYPE_ns___ns1__SplitListByExchange_ (336)
/* Operation wrapper: */
struct __ns1__SplitListByExchange_
{
public:
	_ns1__SplitListByExchange *ns1__SplitListByExchange;	/* optional element of XSD type ns1:SplitListByExchange */
public:
	int soap_type() const { return 336; } /* = unique type id SOAP_TYPE_ns___ns1__SplitListByExchange_ */
	         __ns1__SplitListByExchange_();
	friend SOAP_FMAC1 __ns1__SplitListByExchange_ * SOAP_FMAC2 soap_instantiate___ns1__SplitListByExchange_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:7217 */
#ifndef SOAP_TYPE_ns___ns1__SplitListBySymbol_
#define SOAP_TYPE_ns___ns1__SplitListBySymbol_ (338)
/* Operation wrapper: */
struct __ns1__SplitListBySymbol_
{
public:
	_ns1__SplitListBySymbol *ns1__SplitListBySymbol;	/* optional element of XSD type ns1:SplitListBySymbol */
public:
	int soap_type() const { return 338; } /* = unique type id SOAP_TYPE_ns___ns1__SplitListBySymbol_ */
	         __ns1__SplitListBySymbol_();
	friend SOAP_FMAC1 __ns1__SplitListBySymbol_ * SOAP_FMAC2 soap_instantiate___ns1__SplitListBySymbol_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:7285 */
#ifndef SOAP_TYPE_ns___ns1__CountryList_
#define SOAP_TYPE_ns___ns1__CountryList_ (340)
/* Operation wrapper: */
struct __ns1__CountryList_
{
public:
	_ns1__CountryList *ns1__CountryList;	/* optional element of XSD type ns1:CountryList */
public:
	int soap_type() const { return 340; } /* = unique type id SOAP_TYPE_ns___ns1__CountryList_ */
	         __ns1__CountryList_();
	friend SOAP_FMAC1 __ns1__CountryList_ * SOAP_FMAC2 soap_instantiate___ns1__CountryList_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:7355 */
#ifndef SOAP_TYPE_ns___ns1__SymbolHistoryPeriod_
#define SOAP_TYPE_ns___ns1__SymbolHistoryPeriod_ (342)
/* Operation wrapper: */
struct __ns1__SymbolHistoryPeriod_
{
public:
	_ns1__SymbolHistoryPeriod *ns1__SymbolHistoryPeriod;	/* optional element of XSD type ns1:SymbolHistoryPeriod */
public:
	int soap_type() const { return 342; } /* = unique type id SOAP_TYPE_ns___ns1__SymbolHistoryPeriod_ */
	         __ns1__SymbolHistoryPeriod_();
	friend SOAP_FMAC1 __ns1__SymbolHistoryPeriod_ * SOAP_FMAC2 soap_instantiate___ns1__SymbolHistoryPeriod_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:7425 */
#ifndef SOAP_TYPE_ns___ns1__SymbolHistoryPeriodByDateRange_
#define SOAP_TYPE_ns___ns1__SymbolHistoryPeriodByDateRange_ (344)
/* Operation wrapper: */
struct __ns1__SymbolHistoryPeriodByDateRange_
{
public:
	_ns1__SymbolHistoryPeriodByDateRange *ns1__SymbolHistoryPeriodByDateRange;	/* optional element of XSD type ns1:SymbolHistoryPeriodByDateRange */
public:
	int soap_type() const { return 344; } /* = unique type id SOAP_TYPE_ns___ns1__SymbolHistoryPeriodByDateRange_ */
	         __ns1__SymbolHistoryPeriodByDateRange_();
	friend SOAP_FMAC1 __ns1__SymbolHistoryPeriodByDateRange_ * SOAP_FMAC2 soap_instantiate___ns1__SymbolHistoryPeriodByDateRange_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:7494 */
#ifndef SOAP_TYPE_ns___ns1__QuoteListByDatePeriod_
#define SOAP_TYPE_ns___ns1__QuoteListByDatePeriod_ (346)
/* Operation wrapper: */
struct __ns1__QuoteListByDatePeriod_
{
public:
	_ns1__QuoteListByDatePeriod *ns1__QuoteListByDatePeriod;	/* optional element of XSD type ns1:QuoteListByDatePeriod */
public:
	int soap_type() const { return 346; } /* = unique type id SOAP_TYPE_ns___ns1__QuoteListByDatePeriod_ */
	         __ns1__QuoteListByDatePeriod_();
	friend SOAP_FMAC1 __ns1__QuoteListByDatePeriod_ * SOAP_FMAC2 soap_instantiate___ns1__QuoteListByDatePeriod_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:7564 */
#ifndef SOAP_TYPE_ns___ns1__QuoteListByDatePeriod2_
#define SOAP_TYPE_ns___ns1__QuoteListByDatePeriod2_ (348)
/* Operation wrapper: */
struct __ns1__QuoteListByDatePeriod2_
{
public:
	_ns1__QuoteListByDatePeriod2 *ns1__QuoteListByDatePeriod2;	/* optional element of XSD type ns1:QuoteListByDatePeriod2 */
public:
	int soap_type() const { return 348; } /* = unique type id SOAP_TYPE_ns___ns1__QuoteListByDatePeriod2_ */
	         __ns1__QuoteListByDatePeriod2_();
	friend SOAP_FMAC1 __ns1__QuoteListByDatePeriod2_ * SOAP_FMAC2 soap_instantiate___ns1__QuoteListByDatePeriod2_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:7632 */
#ifndef SOAP_TYPE_ns___ns1__SymbolChangesByExchange_
#define SOAP_TYPE_ns___ns1__SymbolChangesByExchange_ (350)
/* Operation wrapper: */
struct __ns1__SymbolChangesByExchange_
{
public:
	_ns1__SymbolChangesByExchange *ns1__SymbolChangesByExchange;	/* optional element of XSD type ns1:SymbolChangesByExchange */
public:
	int soap_type() const { return 350; } /* = unique type id SOAP_TYPE_ns___ns1__SymbolChangesByExchange_ */
	         __ns1__SymbolChangesByExchange_();
	friend SOAP_FMAC1 __ns1__SymbolChangesByExchange_ * SOAP_FMAC2 soap_instantiate___ns1__SymbolChangesByExchange_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:7700 */
#ifndef SOAP_TYPE_ns___ns1__DataClientLatestVersion_
#define SOAP_TYPE_ns___ns1__DataClientLatestVersion_ (352)
/* Operation wrapper: */
struct __ns1__DataClientLatestVersion_
{
public:
	_ns1__DataClientLatestVersion *ns1__DataClientLatestVersion;	/* optional element of XSD type ns1:DataClientLatestVersion */
public:
	int soap_type() const { return 352; } /* = unique type id SOAP_TYPE_ns___ns1__DataClientLatestVersion_ */
	         __ns1__DataClientLatestVersion_();
	friend SOAP_FMAC1 __ns1__DataClientLatestVersion_ * SOAP_FMAC2 soap_instantiate___ns1__DataClientLatestVersion_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:7768 */
#ifndef SOAP_TYPE_ns___ns1__DataFormats_
#define SOAP_TYPE_ns___ns1__DataFormats_ (354)
/* Operation wrapper: */
struct __ns1__DataFormats_
{
public:
	_ns1__DataFormats *ns1__DataFormats;	/* optional element of XSD type ns1:DataFormats */
public:
	int soap_type() const { return 354; } /* = unique type id SOAP_TYPE_ns___ns1__DataFormats_ */
	         __ns1__DataFormats_();
	friend SOAP_FMAC1 __ns1__DataFormats_ * SOAP_FMAC2 soap_instantiate___ns1__DataFormats_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:7836 */
#ifndef SOAP_TYPE_ns___ns1__UpdateDataFormat_
#define SOAP_TYPE_ns___ns1__UpdateDataFormat_ (356)
/* Operation wrapper: */
struct __ns1__UpdateDataFormat_
{
public:
	_ns1__UpdateDataFormat *ns1__UpdateDataFormat;	/* optional element of XSD type ns1:UpdateDataFormat */
public:
	int soap_type() const { return 356; } /* = unique type id SOAP_TYPE_ns___ns1__UpdateDataFormat_ */
	         __ns1__UpdateDataFormat_();
	friend SOAP_FMAC1 __ns1__UpdateDataFormat_ * SOAP_FMAC2 soap_instantiate___ns1__UpdateDataFormat_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:7905 */
#ifndef SOAP_TYPE_ns___ns1__ValidateAccess_
#define SOAP_TYPE_ns___ns1__ValidateAccess_ (358)
/* Operation wrapper: */
struct __ns1__ValidateAccess_
{
public:
	_ns1__ValidateAccess *ns1__ValidateAccess;	/* optional element of XSD type ns1:ValidateAccess */
public:
	int soap_type() const { return 358; } /* = unique type id SOAP_TYPE_ns___ns1__ValidateAccess_ */
	         __ns1__ValidateAccess_();
	friend SOAP_FMAC1 __ns1__ValidateAccess_ * SOAP_FMAC2 soap_instantiate___ns1__ValidateAccess_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:7967 */
#ifndef SOAP_TYPE_ns___ns1__LoginResponse__
#define SOAP_TYPE_ns___ns1__LoginResponse__ (361)
/* Operation wrapper: */
struct __ns1__LoginResponse__
{
public:
	int soap_type() const { return 361; } /* = unique type id SOAP_TYPE_ns___ns1__LoginResponse__ */
	         __ns1__LoginResponse__();
	friend SOAP_FMAC1 __ns1__LoginResponse__ * SOAP_FMAC2 soap_instantiate___ns1__LoginResponse__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:8029 */
#ifndef SOAP_TYPE_ns___ns1__Login2Response__
#define SOAP_TYPE_ns___ns1__Login2Response__ (363)
/* Operation wrapper: */
struct __ns1__Login2Response__
{
public:
	int soap_type() const { return 363; } /* = unique type id SOAP_TYPE_ns___ns1__Login2Response__ */
	         __ns1__Login2Response__();
	friend SOAP_FMAC1 __ns1__Login2Response__ * SOAP_FMAC2 soap_instantiate___ns1__Login2Response__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:8090 */
#ifndef SOAP_TYPE_ns___ns1__MembershipResponse__
#define SOAP_TYPE_ns___ns1__MembershipResponse__ (366)
/* Operation wrapper: */
struct __ns1__MembershipResponse__
{
public:
	int soap_type() const { return 366; } /* = unique type id SOAP_TYPE_ns___ns1__MembershipResponse__ */
	         __ns1__MembershipResponse__();
	friend SOAP_FMAC1 __ns1__MembershipResponse__ * SOAP_FMAC2 soap_instantiate___ns1__MembershipResponse__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:8152 */
#ifndef SOAP_TYPE_ns___ns1__ExchangeListResponse__
#define SOAP_TYPE_ns___ns1__ExchangeListResponse__ (368)
/* Operation wrapper: */
struct __ns1__ExchangeListResponse__
{
public:
	int soap_type() const { return 368; } /* = unique type id SOAP_TYPE_ns___ns1__ExchangeListResponse__ */
	         __ns1__ExchangeListResponse__();
	friend SOAP_FMAC1 __ns1__ExchangeListResponse__ * SOAP_FMAC2 soap_instantiate___ns1__ExchangeListResponse__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:8214 */
#ifndef SOAP_TYPE_ns___ns1__ExchangeGetResponse__
#define SOAP_TYPE_ns___ns1__ExchangeGetResponse__ (370)
/* Operation wrapper: */
struct __ns1__ExchangeGetResponse__
{
public:
	int soap_type() const { return 370; } /* = unique type id SOAP_TYPE_ns___ns1__ExchangeGetResponse__ */
	         __ns1__ExchangeGetResponse__();
	friend SOAP_FMAC1 __ns1__ExchangeGetResponse__ * SOAP_FMAC2 soap_instantiate___ns1__ExchangeGetResponse__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:8276 */
#ifndef SOAP_TYPE_ns___ns1__SymbolListResponse__
#define SOAP_TYPE_ns___ns1__SymbolListResponse__ (372)
/* Operation wrapper: */
struct __ns1__SymbolListResponse__
{
public:
	int soap_type() const { return 372; } /* = unique type id SOAP_TYPE_ns___ns1__SymbolListResponse__ */
	         __ns1__SymbolListResponse__();
	friend SOAP_FMAC1 __ns1__SymbolListResponse__ * SOAP_FMAC2 soap_instantiate___ns1__SymbolListResponse__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:8338 */
#ifndef SOAP_TYPE_ns___ns1__SymbolList2Response__
#define SOAP_TYPE_ns___ns1__SymbolList2Response__ (374)
/* Operation wrapper: */
struct __ns1__SymbolList2Response__
{
public:
	int soap_type() const { return 374; } /* = unique type id SOAP_TYPE_ns___ns1__SymbolList2Response__ */
	         __ns1__SymbolList2Response__();
	friend SOAP_FMAC1 __ns1__SymbolList2Response__ * SOAP_FMAC2 soap_instantiate___ns1__SymbolList2Response__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:8400 */
#ifndef SOAP_TYPE_ns___ns1__QuoteGetResponse__
#define SOAP_TYPE_ns___ns1__QuoteGetResponse__ (376)
/* Operation wrapper: */
struct __ns1__QuoteGetResponse__
{
public:
	int soap_type() const { return 376; } /* = unique type id SOAP_TYPE_ns___ns1__QuoteGetResponse__ */
	         __ns1__QuoteGetResponse__();
	friend SOAP_FMAC1 __ns1__QuoteGetResponse__ * SOAP_FMAC2 soap_instantiate___ns1__QuoteGetResponse__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:8463 */
#ifndef SOAP_TYPE_ns___ns1__QuoteList2Response__
#define SOAP_TYPE_ns___ns1__QuoteList2Response__ (378)
/* Operation wrapper: */
struct __ns1__QuoteList2Response__
{
public:
	int soap_type() const { return 378; } /* = unique type id SOAP_TYPE_ns___ns1__QuoteList2Response__ */
	         __ns1__QuoteList2Response__();
	friend SOAP_FMAC1 __ns1__QuoteList2Response__ * SOAP_FMAC2 soap_instantiate___ns1__QuoteList2Response__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:8525 */
#ifndef SOAP_TYPE_ns___ns1__SymbolGetResponse__
#define SOAP_TYPE_ns___ns1__SymbolGetResponse__ (380)
/* Operation wrapper: */
struct __ns1__SymbolGetResponse__
{
public:
	int soap_type() const { return 380; } /* = unique type id SOAP_TYPE_ns___ns1__SymbolGetResponse__ */
	         __ns1__SymbolGetResponse__();
	friend SOAP_FMAC1 __ns1__SymbolGetResponse__ * SOAP_FMAC2 soap_instantiate___ns1__SymbolGetResponse__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:8587 */
#ifndef SOAP_TYPE_ns___ns1__QuoteListResponse__
#define SOAP_TYPE_ns___ns1__QuoteListResponse__ (382)
/* Operation wrapper: */
struct __ns1__QuoteListResponse__
{
public:
	int soap_type() const { return 382; } /* = unique type id SOAP_TYPE_ns___ns1__QuoteListResponse__ */
	         __ns1__QuoteListResponse__();
	friend SOAP_FMAC1 __ns1__QuoteListResponse__ * SOAP_FMAC2 soap_instantiate___ns1__QuoteListResponse__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:8649 */
#ifndef SOAP_TYPE_ns___ns1__NewsListResponse__
#define SOAP_TYPE_ns___ns1__NewsListResponse__ (384)
/* Operation wrapper: */
struct __ns1__NewsListResponse__
{
public:
	int soap_type() const { return 384; } /* = unique type id SOAP_TYPE_ns___ns1__NewsListResponse__ */
	         __ns1__NewsListResponse__();
	friend SOAP_FMAC1 __ns1__NewsListResponse__ * SOAP_FMAC2 soap_instantiate___ns1__NewsListResponse__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:8712 */
#ifndef SOAP_TYPE_ns___ns1__NewsListBySymbolResponse__
#define SOAP_TYPE_ns___ns1__NewsListBySymbolResponse__ (386)
/* Operation wrapper: */
struct __ns1__NewsListBySymbolResponse__
{
public:
	int soap_type() const { return 386; } /* = unique type id SOAP_TYPE_ns___ns1__NewsListBySymbolResponse__ */
	         __ns1__NewsListBySymbolResponse__();
	friend SOAP_FMAC1 __ns1__NewsListBySymbolResponse__ * SOAP_FMAC2 soap_instantiate___ns1__NewsListBySymbolResponse__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:8774 */
#ifndef SOAP_TYPE_ns___ns1__FundamentalListResponse__
#define SOAP_TYPE_ns___ns1__FundamentalListResponse__ (388)
/* Operation wrapper: */
struct __ns1__FundamentalListResponse__
{
public:
	int soap_type() const { return 388; } /* = unique type id SOAP_TYPE_ns___ns1__FundamentalListResponse__ */
	         __ns1__FundamentalListResponse__();
	friend SOAP_FMAC1 __ns1__FundamentalListResponse__ * SOAP_FMAC2 soap_instantiate___ns1__FundamentalListResponse__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:8836 */
#ifndef SOAP_TYPE_ns___ns1__TechnicalListResponse__
#define SOAP_TYPE_ns___ns1__TechnicalListResponse__ (390)
/* Operation wrapper: */
struct __ns1__TechnicalListResponse__
{
public:
	int soap_type() const { return 390; } /* = unique type id SOAP_TYPE_ns___ns1__TechnicalListResponse__ */
	         __ns1__TechnicalListResponse__();
	friend SOAP_FMAC1 __ns1__TechnicalListResponse__ * SOAP_FMAC2 soap_instantiate___ns1__TechnicalListResponse__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:8899 */
#ifndef SOAP_TYPE_ns___ns1__QuoteListByDateResponse__
#define SOAP_TYPE_ns___ns1__QuoteListByDateResponse__ (392)
/* Operation wrapper: */
struct __ns1__QuoteListByDateResponse__
{
public:
	int soap_type() const { return 392; } /* = unique type id SOAP_TYPE_ns___ns1__QuoteListByDateResponse__ */
	         __ns1__QuoteListByDateResponse__();
	friend SOAP_FMAC1 __ns1__QuoteListByDateResponse__ * SOAP_FMAC2 soap_instantiate___ns1__QuoteListByDateResponse__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:8962 */
#ifndef SOAP_TYPE_ns___ns1__QuoteListByDate2Response__
#define SOAP_TYPE_ns___ns1__QuoteListByDate2Response__ (394)
/* Operation wrapper: */
struct __ns1__QuoteListByDate2Response__
{
public:
	int soap_type() const { return 394; } /* = unique type id SOAP_TYPE_ns___ns1__QuoteListByDate2Response__ */
	         __ns1__QuoteListByDate2Response__();
	friend SOAP_FMAC1 __ns1__QuoteListByDate2Response__ * SOAP_FMAC2 soap_instantiate___ns1__QuoteListByDate2Response__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:9026 */
#ifndef SOAP_TYPE_ns___ns1__SymbolHistoryResponse__
#define SOAP_TYPE_ns___ns1__SymbolHistoryResponse__ (396)
/* Operation wrapper: */
struct __ns1__SymbolHistoryResponse__
{
public:
	int soap_type() const { return 396; } /* = unique type id SOAP_TYPE_ns___ns1__SymbolHistoryResponse__ */
	         __ns1__SymbolHistoryResponse__();
	friend SOAP_FMAC1 __ns1__SymbolHistoryResponse__ * SOAP_FMAC2 soap_instantiate___ns1__SymbolHistoryResponse__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:9088 */
#ifndef SOAP_TYPE_ns___ns1__Top10GainsResponse__
#define SOAP_TYPE_ns___ns1__Top10GainsResponse__ (398)
/* Operation wrapper: */
struct __ns1__Top10GainsResponse__
{
public:
	int soap_type() const { return 398; } /* = unique type id SOAP_TYPE_ns___ns1__Top10GainsResponse__ */
	         __ns1__Top10GainsResponse__();
	friend SOAP_FMAC1 __ns1__Top10GainsResponse__ * SOAP_FMAC2 soap_instantiate___ns1__Top10GainsResponse__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:9150 */
#ifndef SOAP_TYPE_ns___ns1__Top10LossesResponse__
#define SOAP_TYPE_ns___ns1__Top10LossesResponse__ (400)
/* Operation wrapper: */
struct __ns1__Top10LossesResponse__
{
public:
	int soap_type() const { return 400; } /* = unique type id SOAP_TYPE_ns___ns1__Top10LossesResponse__ */
	         __ns1__Top10LossesResponse__();
	friend SOAP_FMAC1 __ns1__Top10LossesResponse__ * SOAP_FMAC2 soap_instantiate___ns1__Top10LossesResponse__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:9212 */
#ifndef SOAP_TYPE_ns___ns1__SymbolChartResponse__
#define SOAP_TYPE_ns___ns1__SymbolChartResponse__ (402)
/* Operation wrapper: */
struct __ns1__SymbolChartResponse__
{
public:
	int soap_type() const { return 402; } /* = unique type id SOAP_TYPE_ns___ns1__SymbolChartResponse__ */
	         __ns1__SymbolChartResponse__();
	friend SOAP_FMAC1 __ns1__SymbolChartResponse__ * SOAP_FMAC2 soap_instantiate___ns1__SymbolChartResponse__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:9274 */
#ifndef SOAP_TYPE_ns___ns1__ExchangeMonthsResponse__
#define SOAP_TYPE_ns___ns1__ExchangeMonthsResponse__ (404)
/* Operation wrapper: */
struct __ns1__ExchangeMonthsResponse__
{
public:
	int soap_type() const { return 404; } /* = unique type id SOAP_TYPE_ns___ns1__ExchangeMonthsResponse__ */
	         __ns1__ExchangeMonthsResponse__();
	friend SOAP_FMAC1 __ns1__ExchangeMonthsResponse__ * SOAP_FMAC2 soap_instantiate___ns1__ExchangeMonthsResponse__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:9336 */
#ifndef SOAP_TYPE_ns___ns1__SplitListByExchangeResponse__
#define SOAP_TYPE_ns___ns1__SplitListByExchangeResponse__ (406)
/* Operation wrapper: */
struct __ns1__SplitListByExchangeResponse__
{
public:
	int soap_type() const { return 406; } /* = unique type id SOAP_TYPE_ns___ns1__SplitListByExchangeResponse__ */
	         __ns1__SplitListByExchangeResponse__();
	friend SOAP_FMAC1 __ns1__SplitListByExchangeResponse__ * SOAP_FMAC2 soap_instantiate___ns1__SplitListByExchangeResponse__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:9398 */
#ifndef SOAP_TYPE_ns___ns1__SplitListBySymbolResponse__
#define SOAP_TYPE_ns___ns1__SplitListBySymbolResponse__ (408)
/* Operation wrapper: */
struct __ns1__SplitListBySymbolResponse__
{
public:
	int soap_type() const { return 408; } /* = unique type id SOAP_TYPE_ns___ns1__SplitListBySymbolResponse__ */
	         __ns1__SplitListBySymbolResponse__();
	friend SOAP_FMAC1 __ns1__SplitListBySymbolResponse__ * SOAP_FMAC2 soap_instantiate___ns1__SplitListBySymbolResponse__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:9460 */
#ifndef SOAP_TYPE_ns___ns1__CountryListResponse__
#define SOAP_TYPE_ns___ns1__CountryListResponse__ (410)
/* Operation wrapper: */
struct __ns1__CountryListResponse__
{
public:
	int soap_type() const { return 410; } /* = unique type id SOAP_TYPE_ns___ns1__CountryListResponse__ */
	         __ns1__CountryListResponse__();
	friend SOAP_FMAC1 __ns1__CountryListResponse__ * SOAP_FMAC2 soap_instantiate___ns1__CountryListResponse__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:9524 */
#ifndef SOAP_TYPE_ns___ns1__SymbolHistoryPeriodResponse__
#define SOAP_TYPE_ns___ns1__SymbolHistoryPeriodResponse__ (412)
/* Operation wrapper: */
struct __ns1__SymbolHistoryPeriodResponse__
{
public:
	int soap_type() const { return 412; } /* = unique type id SOAP_TYPE_ns___ns1__SymbolHistoryPeriodResponse__ */
	         __ns1__SymbolHistoryPeriodResponse__();
	friend SOAP_FMAC1 __ns1__SymbolHistoryPeriodResponse__ * SOAP_FMAC2 soap_instantiate___ns1__SymbolHistoryPeriodResponse__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:9588 */
#ifndef SOAP_TYPE_ns___ns1__SymbolHistoryPeriodByDateRangeResponse__
#define SOAP_TYPE_ns___ns1__SymbolHistoryPeriodByDateRangeResponse__ (414)
/* Operation wrapper: */
struct __ns1__SymbolHistoryPeriodByDateRangeResponse__
{
public:
	int soap_type() const { return 414; } /* = unique type id SOAP_TYPE_ns___ns1__SymbolHistoryPeriodByDateRangeResponse__ */
	         __ns1__SymbolHistoryPeriodByDateRangeResponse__();
	friend SOAP_FMAC1 __ns1__SymbolHistoryPeriodByDateRangeResponse__ * SOAP_FMAC2 soap_instantiate___ns1__SymbolHistoryPeriodByDateRangeResponse__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:9651 */
#ifndef SOAP_TYPE_ns___ns1__QuoteListByDatePeriodResponse__
#define SOAP_TYPE_ns___ns1__QuoteListByDatePeriodResponse__ (416)
/* Operation wrapper: */
struct __ns1__QuoteListByDatePeriodResponse__
{
public:
	int soap_type() const { return 416; } /* = unique type id SOAP_TYPE_ns___ns1__QuoteListByDatePeriodResponse__ */
	         __ns1__QuoteListByDatePeriodResponse__();
	friend SOAP_FMAC1 __ns1__QuoteListByDatePeriodResponse__ * SOAP_FMAC2 soap_instantiate___ns1__QuoteListByDatePeriodResponse__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:9715 */
#ifndef SOAP_TYPE_ns___ns1__QuoteListByDatePeriod2Response__
#define SOAP_TYPE_ns___ns1__QuoteListByDatePeriod2Response__ (418)
/* Operation wrapper: */
struct __ns1__QuoteListByDatePeriod2Response__
{
public:
	int soap_type() const { return 418; } /* = unique type id SOAP_TYPE_ns___ns1__QuoteListByDatePeriod2Response__ */
	         __ns1__QuoteListByDatePeriod2Response__();
	friend SOAP_FMAC1 __ns1__QuoteListByDatePeriod2Response__ * SOAP_FMAC2 soap_instantiate___ns1__QuoteListByDatePeriod2Response__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:9777 */
#ifndef SOAP_TYPE_ns___ns1__SymbolChangesByExchangeResponse__
#define SOAP_TYPE_ns___ns1__SymbolChangesByExchangeResponse__ (420)
/* Operation wrapper: */
struct __ns1__SymbolChangesByExchangeResponse__
{
public:
	int soap_type() const { return 420; } /* = unique type id SOAP_TYPE_ns___ns1__SymbolChangesByExchangeResponse__ */
	         __ns1__SymbolChangesByExchangeResponse__();
	friend SOAP_FMAC1 __ns1__SymbolChangesByExchangeResponse__ * SOAP_FMAC2 soap_instantiate___ns1__SymbolChangesByExchangeResponse__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:9839 */
#ifndef SOAP_TYPE_ns___ns1__DataClientLatestVersionResponse__
#define SOAP_TYPE_ns___ns1__DataClientLatestVersionResponse__ (422)
/* Operation wrapper: */
struct __ns1__DataClientLatestVersionResponse__
{
public:
	int soap_type() const { return 422; } /* = unique type id SOAP_TYPE_ns___ns1__DataClientLatestVersionResponse__ */
	         __ns1__DataClientLatestVersionResponse__();
	friend SOAP_FMAC1 __ns1__DataClientLatestVersionResponse__ * SOAP_FMAC2 soap_instantiate___ns1__DataClientLatestVersionResponse__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:9901 */
#ifndef SOAP_TYPE_ns___ns1__DataFormatsResponse__
#define SOAP_TYPE_ns___ns1__DataFormatsResponse__ (424)
/* Operation wrapper: */
struct __ns1__DataFormatsResponse__
{
public:
	int soap_type() const { return 424; } /* = unique type id SOAP_TYPE_ns___ns1__DataFormatsResponse__ */
	         __ns1__DataFormatsResponse__();
	friend SOAP_FMAC1 __ns1__DataFormatsResponse__ * SOAP_FMAC2 soap_instantiate___ns1__DataFormatsResponse__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:9963 */
#ifndef SOAP_TYPE_ns___ns1__UpdateDataFormatResponse__
#define SOAP_TYPE_ns___ns1__UpdateDataFormatResponse__ (426)
/* Operation wrapper: */
struct __ns1__UpdateDataFormatResponse__
{
public:
	int soap_type() const { return 426; } /* = unique type id SOAP_TYPE_ns___ns1__UpdateDataFormatResponse__ */
	         __ns1__UpdateDataFormatResponse__();
	friend SOAP_FMAC1 __ns1__UpdateDataFormatResponse__ * SOAP_FMAC2 soap_instantiate___ns1__UpdateDataFormatResponse__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:10026 */
#ifndef SOAP_TYPE_ns___ns1__ValidateAccessResponse__
#define SOAP_TYPE_ns___ns1__ValidateAccessResponse__ (428)
/* Operation wrapper: */
struct __ns1__ValidateAccessResponse__
{
public:
	int soap_type() const { return 428; } /* = unique type id SOAP_TYPE_ns___ns1__ValidateAccessResponse__ */
	         __ns1__ValidateAccessResponse__();
	friend SOAP_FMAC1 __ns1__ValidateAccessResponse__ * SOAP_FMAC2 soap_instantiate___ns1__ValidateAccessResponse__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:10099 */
#ifndef SOAP_TYPE_ns___ns1__Login___
#define SOAP_TYPE_ns___ns1__Login___ (430)
/* Operation wrapper: */
struct __ns1__Login___
{
public:
	std::string Username;	/* required element of XSD type xsd:string */
	std::string Password;	/* required element of XSD type xsd:string */
public:
	int soap_type() const { return 430; } /* = unique type id SOAP_TYPE_ns___ns1__Login___ */
	         __ns1__Login___();
	friend SOAP_FMAC1 __ns1__Login___ * SOAP_FMAC2 soap_instantiate___ns1__Login___(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:10175 */
#ifndef SOAP_TYPE_ns___ns1__Login2___
#define SOAP_TYPE_ns___ns1__Login2___ (432)
/* Operation wrapper: */
struct __ns1__Login2___
{
public:
	std::string Username;	/* required element of XSD type xsd:string */
	std::string Password;	/* required element of XSD type xsd:string */
	std::string Version;	/* required element of XSD type xsd:string */
public:
	int soap_type() const { return 432; } /* = unique type id SOAP_TYPE_ns___ns1__Login2___ */
	         __ns1__Login2___();
	friend SOAP_FMAC1 __ns1__Login2___ * SOAP_FMAC2 soap_instantiate___ns1__Login2___(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:10244 */
#ifndef SOAP_TYPE_ns___ns1__Membership___
#define SOAP_TYPE_ns___ns1__Membership___ (434)
/* Operation wrapper: */
struct __ns1__Membership___
{
public:
	std::string Token;	/* required element of XSD type xsd:string */
public:
	int soap_type() const { return 434; } /* = unique type id SOAP_TYPE_ns___ns1__Membership___ */
	         __ns1__Membership___();
	friend SOAP_FMAC1 __ns1__Membership___ * SOAP_FMAC2 soap_instantiate___ns1__Membership___(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:10314 */
#ifndef SOAP_TYPE_ns___ns1__ExchangeList___
#define SOAP_TYPE_ns___ns1__ExchangeList___ (436)
/* Operation wrapper: */
struct __ns1__ExchangeList___
{
public:
	std::string Token;	/* required element of XSD type xsd:string */
public:
	int soap_type() const { return 436; } /* = unique type id SOAP_TYPE_ns___ns1__ExchangeList___ */
	         __ns1__ExchangeList___();
	friend SOAP_FMAC1 __ns1__ExchangeList___ * SOAP_FMAC2 soap_instantiate___ns1__ExchangeList___(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:10387 */
#ifndef SOAP_TYPE_ns___ns1__ExchangeGet___
#define SOAP_TYPE_ns___ns1__ExchangeGet___ (438)
/* Operation wrapper: */
struct __ns1__ExchangeGet___
{
public:
	std::string Token;	/* required element of XSD type xsd:string */
	std::string Exchange;	/* required element of XSD type xsd:string */
public:
	int soap_type() const { return 438; } /* = unique type id SOAP_TYPE_ns___ns1__ExchangeGet___ */
	         __ns1__ExchangeGet___();
	friend SOAP_FMAC1 __ns1__ExchangeGet___ * SOAP_FMAC2 soap_instantiate___ns1__ExchangeGet___(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:10460 */
#ifndef SOAP_TYPE_ns___ns1__SymbolList___
#define SOAP_TYPE_ns___ns1__SymbolList___ (440)
/* Operation wrapper: */
struct __ns1__SymbolList___
{
public:
	std::string Token;	/* required element of XSD type xsd:string */
	std::string Exchange;	/* required element of XSD type xsd:string */
public:
	int soap_type() const { return 440; } /* = unique type id SOAP_TYPE_ns___ns1__SymbolList___ */
	         __ns1__SymbolList___();
	friend SOAP_FMAC1 __ns1__SymbolList___ * SOAP_FMAC2 soap_instantiate___ns1__SymbolList___(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:10533 */
#ifndef SOAP_TYPE_ns___ns1__SymbolList2___
#define SOAP_TYPE_ns___ns1__SymbolList2___ (442)
/* Operation wrapper: */
struct __ns1__SymbolList2___
{
public:
	std::string Token;	/* required element of XSD type xsd:string */
	std::string Exchange;	/* required element of XSD type xsd:string */
public:
	int soap_type() const { return 442; } /* = unique type id SOAP_TYPE_ns___ns1__SymbolList2___ */
	         __ns1__SymbolList2___();
	friend SOAP_FMAC1 __ns1__SymbolList2___ * SOAP_FMAC2 soap_instantiate___ns1__SymbolList2___(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:10609 */
#ifndef SOAP_TYPE_ns___ns1__QuoteGet___
#define SOAP_TYPE_ns___ns1__QuoteGet___ (444)
/* Operation wrapper: */
struct __ns1__QuoteGet___
{
public:
	std::string Token;	/* required element of XSD type xsd:string */
	std::string Exchange;	/* required element of XSD type xsd:string */
	std::string Symbol;	/* required element of XSD type xsd:string */
public:
	int soap_type() const { return 444; } /* = unique type id SOAP_TYPE_ns___ns1__QuoteGet___ */
	         __ns1__QuoteGet___();
	friend SOAP_FMAC1 __ns1__QuoteGet___ * SOAP_FMAC2 soap_instantiate___ns1__QuoteGet___(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:10686 */
#ifndef SOAP_TYPE_ns___ns1__QuoteList2___
#define SOAP_TYPE_ns___ns1__QuoteList2___ (446)
/* Operation wrapper: */
struct __ns1__QuoteList2___
{
public:
	std::string Token;	/* required element of XSD type xsd:string */
	std::string Exchange;	/* required element of XSD type xsd:string */
	std::string Symbols;	/* required element of XSD type xsd:string */
public:
	int soap_type() const { return 446; } /* = unique type id SOAP_TYPE_ns___ns1__QuoteList2___ */
	         __ns1__QuoteList2___();
	friend SOAP_FMAC1 __ns1__QuoteList2___ * SOAP_FMAC2 soap_instantiate___ns1__QuoteList2___(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:10762 */
#ifndef SOAP_TYPE_ns___ns1__SymbolGet___
#define SOAP_TYPE_ns___ns1__SymbolGet___ (448)
/* Operation wrapper: */
struct __ns1__SymbolGet___
{
public:
	std::string Token;	/* required element of XSD type xsd:string */
	std::string Exchange;	/* required element of XSD type xsd:string */
	std::string Symbol;	/* required element of XSD type xsd:string */
public:
	int soap_type() const { return 448; } /* = unique type id SOAP_TYPE_ns___ns1__SymbolGet___ */
	         __ns1__SymbolGet___();
	friend SOAP_FMAC1 __ns1__SymbolGet___ * SOAP_FMAC2 soap_instantiate___ns1__SymbolGet___(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:10835 */
#ifndef SOAP_TYPE_ns___ns1__QuoteList___
#define SOAP_TYPE_ns___ns1__QuoteList___ (450)
/* Operation wrapper: */
struct __ns1__QuoteList___
{
public:
	std::string Token;	/* required element of XSD type xsd:string */
	std::string Exchange;	/* required element of XSD type xsd:string */
public:
	int soap_type() const { return 450; } /* = unique type id SOAP_TYPE_ns___ns1__QuoteList___ */
	         __ns1__QuoteList___();
	friend SOAP_FMAC1 __ns1__QuoteList___ * SOAP_FMAC2 soap_instantiate___ns1__QuoteList___(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:10908 */
#ifndef SOAP_TYPE_ns___ns1__NewsList___
#define SOAP_TYPE_ns___ns1__NewsList___ (452)
/* Operation wrapper: */
struct __ns1__NewsList___
{
public:
	std::string Token;	/* required element of XSD type xsd:string */
	std::string Exchange;	/* required element of XSD type xsd:string */
public:
	int soap_type() const { return 452; } /* = unique type id SOAP_TYPE_ns___ns1__NewsList___ */
	         __ns1__NewsList___();
	friend SOAP_FMAC1 __ns1__NewsList___ * SOAP_FMAC2 soap_instantiate___ns1__NewsList___(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:10985 */
#ifndef SOAP_TYPE_ns___ns1__NewsListBySymbol___
#define SOAP_TYPE_ns___ns1__NewsListBySymbol___ (454)
/* Operation wrapper: */
struct __ns1__NewsListBySymbol___
{
public:
	std::string token;	/* required element of XSD type xsd:string */
	std::string Exchange;	/* required element of XSD type xsd:string */
	std::string symbol;	/* required element of XSD type xsd:string */
public:
	int soap_type() const { return 454; } /* = unique type id SOAP_TYPE_ns___ns1__NewsListBySymbol___ */
	         __ns1__NewsListBySymbol___();
	friend SOAP_FMAC1 __ns1__NewsListBySymbol___ * SOAP_FMAC2 soap_instantiate___ns1__NewsListBySymbol___(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:11058 */
#ifndef SOAP_TYPE_ns___ns1__FundamentalList___
#define SOAP_TYPE_ns___ns1__FundamentalList___ (456)
/* Operation wrapper: */
struct __ns1__FundamentalList___
{
public:
	std::string Token;	/* required element of XSD type xsd:string */
	std::string Exchange;	/* required element of XSD type xsd:string */
public:
	int soap_type() const { return 456; } /* = unique type id SOAP_TYPE_ns___ns1__FundamentalList___ */
	         __ns1__FundamentalList___();
	friend SOAP_FMAC1 __ns1__FundamentalList___ * SOAP_FMAC2 soap_instantiate___ns1__FundamentalList___(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:11131 */
#ifndef SOAP_TYPE_ns___ns1__TechnicalList___
#define SOAP_TYPE_ns___ns1__TechnicalList___ (458)
/* Operation wrapper: */
struct __ns1__TechnicalList___
{
public:
	std::string Token;	/* required element of XSD type xsd:string */
	std::string Exchange;	/* required element of XSD type xsd:string */
public:
	int soap_type() const { return 458; } /* = unique type id SOAP_TYPE_ns___ns1__TechnicalList___ */
	         __ns1__TechnicalList___();
	friend SOAP_FMAC1 __ns1__TechnicalList___ * SOAP_FMAC2 soap_instantiate___ns1__TechnicalList___(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:11208 */
#ifndef SOAP_TYPE_ns___ns1__QuoteListByDate___
#define SOAP_TYPE_ns___ns1__QuoteListByDate___ (460)
/* Operation wrapper: */
struct __ns1__QuoteListByDate___
{
public:
	std::string Token;	/* required element of XSD type xsd:string */
	std::string Exchange;	/* required element of XSD type xsd:string */
	std::string QuoteDate;	/* required element of XSD type xsd:string */
public:
	int soap_type() const { return 460; } /* = unique type id SOAP_TYPE_ns___ns1__QuoteListByDate___ */
	         __ns1__QuoteListByDate___();
	friend SOAP_FMAC1 __ns1__QuoteListByDate___ * SOAP_FMAC2 soap_instantiate___ns1__QuoteListByDate___(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:11285 */
#ifndef SOAP_TYPE_ns___ns1__QuoteListByDate2___
#define SOAP_TYPE_ns___ns1__QuoteListByDate2___ (462)
/* Operation wrapper: */
struct __ns1__QuoteListByDate2___
{
public:
	std::string Token;	/* required element of XSD type xsd:string */
	std::string Exchange;	/* required element of XSD type xsd:string */
	std::string QuoteDate;	/* required element of XSD type xsd:string */
public:
	int soap_type() const { return 462; } /* = unique type id SOAP_TYPE_ns___ns1__QuoteListByDate2___ */
	         __ns1__QuoteListByDate2___();
	friend SOAP_FMAC1 __ns1__QuoteListByDate2___ * SOAP_FMAC2 soap_instantiate___ns1__QuoteListByDate2___(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:11366 */
#ifndef SOAP_TYPE_ns___ns1__SymbolHistory___
#define SOAP_TYPE_ns___ns1__SymbolHistory___ (464)
/* Operation wrapper: */
struct __ns1__SymbolHistory___
{
public:
	std::string Token;	/* required element of XSD type xsd:string */
	std::string Exchange;	/* required element of XSD type xsd:string */
	std::string Symbol;	/* required element of XSD type xsd:string */
	std::string StartDate;	/* required element of XSD type xsd:string */
public:
	int soap_type() const { return 464; } /* = unique type id SOAP_TYPE_ns___ns1__SymbolHistory___ */
	         __ns1__SymbolHistory___();
	friend SOAP_FMAC1 __ns1__SymbolHistory___ * SOAP_FMAC2 soap_instantiate___ns1__SymbolHistory___(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:11439 */
#ifndef SOAP_TYPE_ns___ns1__Top10Gains___
#define SOAP_TYPE_ns___ns1__Top10Gains___ (466)
/* Operation wrapper: */
struct __ns1__Top10Gains___
{
public:
	std::string Token;	/* required element of XSD type xsd:string */
	std::string Exchange;	/* required element of XSD type xsd:string */
public:
	int soap_type() const { return 466; } /* = unique type id SOAP_TYPE_ns___ns1__Top10Gains___ */
	         __ns1__Top10Gains___();
	friend SOAP_FMAC1 __ns1__Top10Gains___ * SOAP_FMAC2 soap_instantiate___ns1__Top10Gains___(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:11512 */
#ifndef SOAP_TYPE_ns___ns1__Top10Losses___
#define SOAP_TYPE_ns___ns1__Top10Losses___ (468)
/* Operation wrapper: */
struct __ns1__Top10Losses___
{
public:
	std::string Token;	/* required element of XSD type xsd:string */
	std::string Exchange;	/* required element of XSD type xsd:string */
public:
	int soap_type() const { return 468; } /* = unique type id SOAP_TYPE_ns___ns1__Top10Losses___ */
	         __ns1__Top10Losses___();
	friend SOAP_FMAC1 __ns1__Top10Losses___ * SOAP_FMAC2 soap_instantiate___ns1__Top10Losses___(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:11588 */
#ifndef SOAP_TYPE_ns___ns1__SymbolChart___
#define SOAP_TYPE_ns___ns1__SymbolChart___ (470)
/* Operation wrapper: */
struct __ns1__SymbolChart___
{
public:
	std::string Token;	/* required element of XSD type xsd:string */
	std::string Exchange;	/* required element of XSD type xsd:string */
	std::string Symbol;	/* required element of XSD type xsd:string */
public:
	int soap_type() const { return 470; } /* = unique type id SOAP_TYPE_ns___ns1__SymbolChart___ */
	         __ns1__SymbolChart___();
	friend SOAP_FMAC1 __ns1__SymbolChart___ * SOAP_FMAC2 soap_instantiate___ns1__SymbolChart___(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:11661 */
#ifndef SOAP_TYPE_ns___ns1__ExchangeMonths___
#define SOAP_TYPE_ns___ns1__ExchangeMonths___ (472)
/* Operation wrapper: */
struct __ns1__ExchangeMonths___
{
public:
	std::string Token;	/* required element of XSD type xsd:string */
	std::string Exchange;	/* required element of XSD type xsd:string */
public:
	int soap_type() const { return 472; } /* = unique type id SOAP_TYPE_ns___ns1__ExchangeMonths___ */
	         __ns1__ExchangeMonths___();
	friend SOAP_FMAC1 __ns1__ExchangeMonths___ * SOAP_FMAC2 soap_instantiate___ns1__ExchangeMonths___(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:11734 */
#ifndef SOAP_TYPE_ns___ns1__SplitListByExchange___
#define SOAP_TYPE_ns___ns1__SplitListByExchange___ (474)
/* Operation wrapper: */
struct __ns1__SplitListByExchange___
{
public:
	std::string Token;	/* required element of XSD type xsd:string */
	std::string Exchange;	/* required element of XSD type xsd:string */
public:
	int soap_type() const { return 474; } /* = unique type id SOAP_TYPE_ns___ns1__SplitListByExchange___ */
	         __ns1__SplitListByExchange___();
	friend SOAP_FMAC1 __ns1__SplitListByExchange___ * SOAP_FMAC2 soap_instantiate___ns1__SplitListByExchange___(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:11810 */
#ifndef SOAP_TYPE_ns___ns1__SplitListBySymbol___
#define SOAP_TYPE_ns___ns1__SplitListBySymbol___ (476)
/* Operation wrapper: */
struct __ns1__SplitListBySymbol___
{
public:
	std::string Token;	/* required element of XSD type xsd:string */
	std::string Exchange;	/* required element of XSD type xsd:string */
	std::string Symbol;	/* required element of XSD type xsd:string */
public:
	int soap_type() const { return 476; } /* = unique type id SOAP_TYPE_ns___ns1__SplitListBySymbol___ */
	         __ns1__SplitListBySymbol___();
	friend SOAP_FMAC1 __ns1__SplitListBySymbol___ * SOAP_FMAC2 soap_instantiate___ns1__SplitListBySymbol___(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:11880 */
#ifndef SOAP_TYPE_ns___ns1__CountryList___
#define SOAP_TYPE_ns___ns1__CountryList___ (478)
/* Operation wrapper: */
struct __ns1__CountryList___
{
public:
	std::string Token;	/* required element of XSD type xsd:string */
public:
	int soap_type() const { return 478; } /* = unique type id SOAP_TYPE_ns___ns1__CountryList___ */
	         __ns1__CountryList___();
	friend SOAP_FMAC1 __ns1__CountryList___ * SOAP_FMAC2 soap_instantiate___ns1__CountryList___(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:11964 */
#ifndef SOAP_TYPE_ns___ns1__SymbolHistoryPeriod___
#define SOAP_TYPE_ns___ns1__SymbolHistoryPeriod___ (480)
/* Operation wrapper: */
struct __ns1__SymbolHistoryPeriod___
{
public:
	std::string Token;	/* required element of XSD type xsd:string */
	std::string Exchange;	/* required element of XSD type xsd:string */
	std::string Symbol;	/* required element of XSD type xsd:string */
	std::string Date;	/* required element of XSD type xsd:string */
	std::string Period;	/* required element of XSD type xsd:string */
public:
	int soap_type() const { return 480; } /* = unique type id SOAP_TYPE_ns___ns1__SymbolHistoryPeriod___ */
	         __ns1__SymbolHistoryPeriod___();
	friend SOAP_FMAC1 __ns1__SymbolHistoryPeriod___ * SOAP_FMAC2 soap_instantiate___ns1__SymbolHistoryPeriod___(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:12051 */
#ifndef SOAP_TYPE_ns___ns1__SymbolHistoryPeriodByDateRange___
#define SOAP_TYPE_ns___ns1__SymbolHistoryPeriodByDateRange___ (482)
/* Operation wrapper: */
struct __ns1__SymbolHistoryPeriodByDateRange___
{
public:
	std::string Token;	/* required element of XSD type xsd:string */
	std::string Exchange;	/* required element of XSD type xsd:string */
	std::string Symbol;	/* required element of XSD type xsd:string */
	std::string StartDate;	/* required element of XSD type xsd:string */
	std::string EndDate;	/* required element of XSD type xsd:string */
	std::string Period;	/* required element of XSD type xsd:string */
public:
	int soap_type() const { return 482; } /* = unique type id SOAP_TYPE_ns___ns1__SymbolHistoryPeriodByDateRange___ */
	         __ns1__SymbolHistoryPeriodByDateRange___();
	friend SOAP_FMAC1 __ns1__SymbolHistoryPeriodByDateRange___ * SOAP_FMAC2 soap_instantiate___ns1__SymbolHistoryPeriodByDateRange___(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:12131 */
#ifndef SOAP_TYPE_ns___ns1__QuoteListByDatePeriod___
#define SOAP_TYPE_ns___ns1__QuoteListByDatePeriod___ (484)
/* Operation wrapper: */
struct __ns1__QuoteListByDatePeriod___
{
public:
	std::string Token;	/* required element of XSD type xsd:string */
	std::string Exchange;	/* required element of XSD type xsd:string */
	std::string QuoteDate;	/* required element of XSD type xsd:string */
	std::string Period;	/* required element of XSD type xsd:string */
public:
	int soap_type() const { return 484; } /* = unique type id SOAP_TYPE_ns___ns1__QuoteListByDatePeriod___ */
	         __ns1__QuoteListByDatePeriod___();
	friend SOAP_FMAC1 __ns1__QuoteListByDatePeriod___ * SOAP_FMAC2 soap_instantiate___ns1__QuoteListByDatePeriod___(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:12212 */
#ifndef SOAP_TYPE_ns___ns1__QuoteListByDatePeriod2___
#define SOAP_TYPE_ns___ns1__QuoteListByDatePeriod2___ (486)
/* Operation wrapper: */
struct __ns1__QuoteListByDatePeriod2___
{
public:
	std::string Token;	/* required element of XSD type xsd:string */
	std::string Exchange;	/* required element of XSD type xsd:string */
	std::string QuoteDate;	/* required element of XSD type xsd:string */
	std::string Period;	/* required element of XSD type xsd:string */
public:
	int soap_type() const { return 486; } /* = unique type id SOAP_TYPE_ns___ns1__QuoteListByDatePeriod2___ */
	         __ns1__QuoteListByDatePeriod2___();
	friend SOAP_FMAC1 __ns1__QuoteListByDatePeriod2___ * SOAP_FMAC2 soap_instantiate___ns1__QuoteListByDatePeriod2___(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:12285 */
#ifndef SOAP_TYPE_ns___ns1__SymbolChangesByExchange___
#define SOAP_TYPE_ns___ns1__SymbolChangesByExchange___ (488)
/* Operation wrapper: */
struct __ns1__SymbolChangesByExchange___
{
public:
	std::string Token;	/* required element of XSD type xsd:string */
	std::string Exchange;	/* required element of XSD type xsd:string */
public:
	int soap_type() const { return 488; } /* = unique type id SOAP_TYPE_ns___ns1__SymbolChangesByExchange___ */
	         __ns1__SymbolChangesByExchange___();
	friend SOAP_FMAC1 __ns1__SymbolChangesByExchange___ * SOAP_FMAC2 soap_instantiate___ns1__SymbolChangesByExchange___(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:12355 */
#ifndef SOAP_TYPE_ns___ns1__DataClientLatestVersion___
#define SOAP_TYPE_ns___ns1__DataClientLatestVersion___ (490)
/* Operation wrapper: */
struct __ns1__DataClientLatestVersion___
{
public:
	std::string Token;	/* required element of XSD type xsd:string */
public:
	int soap_type() const { return 490; } /* = unique type id SOAP_TYPE_ns___ns1__DataClientLatestVersion___ */
	         __ns1__DataClientLatestVersion___();
	friend SOAP_FMAC1 __ns1__DataClientLatestVersion___ * SOAP_FMAC2 soap_instantiate___ns1__DataClientLatestVersion___(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:12425 */
#ifndef SOAP_TYPE_ns___ns1__DataFormats___
#define SOAP_TYPE_ns___ns1__DataFormats___ (492)
/* Operation wrapper: */
struct __ns1__DataFormats___
{
public:
	std::string Token;	/* required element of XSD type xsd:string */
public:
	int soap_type() const { return 492; } /* = unique type id SOAP_TYPE_ns___ns1__DataFormats___ */
	         __ns1__DataFormats___();
	friend SOAP_FMAC1 __ns1__DataFormats___ * SOAP_FMAC2 soap_instantiate___ns1__DataFormats___(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:12504 */
#ifndef SOAP_TYPE_ns___ns1__UpdateDataFormat___
#define SOAP_TYPE_ns___ns1__UpdateDataFormat___ (494)
/* Operation wrapper: */
struct __ns1__UpdateDataFormat___
{
public:
	std::string Token;	/* required element of XSD type xsd:string */
	std::string DataFormat;	/* required element of XSD type xsd:string */
	std::string IncludeHeader;	/* required element of XSD type xsd:string */
	std::string IncludeSuffix;	/* required element of XSD type xsd:string */
public:
	int soap_type() const { return 494; } /* = unique type id SOAP_TYPE_ns___ns1__UpdateDataFormat___ */
	         __ns1__UpdateDataFormat___();
	friend SOAP_FMAC1 __ns1__UpdateDataFormat___ * SOAP_FMAC2 soap_instantiate___ns1__UpdateDataFormat___(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:12584 */
#ifndef SOAP_TYPE_ns___ns1__ValidateAccess___
#define SOAP_TYPE_ns___ns1__ValidateAccess___ (496)
/* Operation wrapper: */
struct __ns1__ValidateAccess___
{
public:
	std::string Token;	/* required element of XSD type xsd:string */
	std::string Exchange;	/* required element of XSD type xsd:string */
	std::string QuoteDate;	/* required element of XSD type xsd:string */
	std::string Period;	/* required element of XSD type xsd:string */
public:
	int soap_type() const { return 496; } /* = unique type id SOAP_TYPE_ns___ns1__ValidateAccess___ */
	         __ns1__ValidateAccess___();
	friend SOAP_FMAC1 __ns1__ValidateAccess___ * SOAP_FMAC2 soap_instantiate___ns1__ValidateAccess___(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eoddatawebservice.h:13192 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_ns_SOAP_ENV__Header
#define SOAP_TYPE_ns_SOAP_ENV__Header (497)
/* SOAP Header: */
struct SOAP_ENV__Header
{
public:
	int soap_type() const { return 497; } /* = unique type id SOAP_TYPE_ns_SOAP_ENV__Header */
	         SOAP_ENV__Header();
	friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* eoddatawebservice.h:13192 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_ns_SOAP_ENV__Code
#define SOAP_TYPE_ns_SOAP_ENV__Code (498)
/* Type SOAP_ENV__Code is a recursive data type (in)directly referencing itself through its (base) class members */
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of XSD type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of XSD type SOAP-ENV:Code */
public:
	int soap_type() const { return 498; } /* = unique type id SOAP_TYPE_ns_SOAP_ENV__Code */
	         SOAP_ENV__Code();
	friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* eoddatawebservice.h:13192 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_ns_SOAP_ENV__Detail
#define SOAP_TYPE_ns_SOAP_ENV__Detail (500)
/* SOAP-ENV:Detail complex type: */
struct SOAP_ENV__Detail
{
public:
	char *__any;
	int __type;	/* any type of element <fault> (defined below)
	   WARNING: do not create a cyclic data structure graph throught this element unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
	void *fault;	/* transient (not serialized) */
public:
	int soap_type() const { return 500; } /* = unique type id SOAP_TYPE_ns_SOAP_ENV__Detail */
	         SOAP_ENV__Detail();
	friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* eoddatawebservice.h:13192 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_ns_SOAP_ENV__Reason
#define SOAP_TYPE_ns_SOAP_ENV__Reason (503)
/* SOAP-ENV:Reason complex type: */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of XSD type xsd:string */
public:
	int soap_type() const { return 503; } /* = unique type id SOAP_TYPE_ns_SOAP_ENV__Reason */
	         SOAP_ENV__Reason();
	friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* eoddatawebservice.h:13192 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_ns_SOAP_ENV__Fault
#define SOAP_TYPE_ns_SOAP_ENV__Fault (504)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of XSD type xsd:QName */
	char *faultstring;	/* optional element of XSD type xsd:string */
	char *faultactor;	/* optional element of XSD type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of XSD type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of XSD type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of XSD type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of XSD type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of XSD type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of XSD type SOAP-ENV:Detail */
public:
	int soap_type() const { return 504; } /* = unique type id SOAP_TYPE_ns_SOAP_ENV__Fault */
	         SOAP_ENV__Fault();
	friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* eoddatawebservice.h:1 */
#ifndef SOAP_TYPE_ns__QName
#define SOAP_TYPE_ns__QName (5)
typedef char *_QName;
#endif

/* eoddatawebservice.h:1 */
#ifndef SOAP_TYPE_ns__XML
#define SOAP_TYPE_ns__XML (6)
typedef char *_XML;
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


} // namespace ns


#endif

/* End of nsStub.h */
