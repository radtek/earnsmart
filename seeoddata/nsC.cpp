/* nsC.cpp
   Generated by gSOAP 2.8.28 from eoddatawebservice.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "nsH.h"

namespace ns {

SOAP_SOURCE_STAMP("@(#) nsC.cpp ver 2.8.28 2016-06-13 10:48:37 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap);
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap);
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = soap_new_SOAP_ENV__Detail(soap);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if ((soap->error && soap->error != SOAP_TAG_MISMATCH) || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_ns_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_ns_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_ns_LONG64:
		return soap_in_LONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_ns_double:
		return soap_in_double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_ns_dateTime:
		return soap_in_dateTime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_ns_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_ns_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_ns_ns1__DATAFORMAT_USCORECOLUMN:
		return soap_in_ns1__DATAFORMAT_USCORECOLUMN(soap, NULL, NULL, "ns1:DATAFORMAT_COLUMN");
	case SOAP_TYPE_ns_ns1__ArrayOfDATAFORMAT_USCORECOLUMN:
		return soap_in_ns1__ArrayOfDATAFORMAT_USCORECOLUMN(soap, NULL, NULL, "ns1:ArrayOfDATAFORMAT_COLUMN");
	case SOAP_TYPE_ns_ns1__DATAFORMAT:
		return soap_in_ns1__DATAFORMAT(soap, NULL, NULL, "ns1:DATAFORMAT");
	case SOAP_TYPE_ns_ns1__ArrayOfDATAFORMAT:
		return soap_in_ns1__ArrayOfDATAFORMAT(soap, NULL, NULL, "ns1:ArrayOfDATAFORMAT");
	case SOAP_TYPE_ns_ns1__NEWS:
		return soap_in_ns1__NEWS(soap, NULL, NULL, "ns1:NEWS");
	case SOAP_TYPE_ns_ns1__ArrayOfNEWS:
		return soap_in_ns1__ArrayOfNEWS(soap, NULL, NULL, "ns1:ArrayOfNEWS");
	case SOAP_TYPE_ns_ns1__SYMBOLCHANGE:
		return soap_in_ns1__SYMBOLCHANGE(soap, NULL, NULL, "ns1:SYMBOLCHANGE");
	case SOAP_TYPE_ns_ns1__ArrayOfSYMBOLCHANGE:
		return soap_in_ns1__ArrayOfSYMBOLCHANGE(soap, NULL, NULL, "ns1:ArrayOfSYMBOLCHANGE");
	case SOAP_TYPE_ns_ns1__TECHNICAL:
		return soap_in_ns1__TECHNICAL(soap, NULL, NULL, "ns1:TECHNICAL");
	case SOAP_TYPE_ns_ns1__ArrayOfTECHNICAL:
		return soap_in_ns1__ArrayOfTECHNICAL(soap, NULL, NULL, "ns1:ArrayOfTECHNICAL");
	case SOAP_TYPE_ns_ns1__FUNDAMENTAL:
		return soap_in_ns1__FUNDAMENTAL(soap, NULL, NULL, "ns1:FUNDAMENTAL");
	case SOAP_TYPE_ns_ns1__ArrayOfFUNDAMENTAL:
		return soap_in_ns1__ArrayOfFUNDAMENTAL(soap, NULL, NULL, "ns1:ArrayOfFUNDAMENTAL");
	case SOAP_TYPE_ns_ns1__CountryBase:
		return soap_in_ns1__CountryBase(soap, NULL, NULL, "ns1:CountryBase");
	case SOAP_TYPE_ns_ns1__ArrayOfCountryBase:
		return soap_in_ns1__ArrayOfCountryBase(soap, NULL, NULL, "ns1:ArrayOfCountryBase");
	case SOAP_TYPE_ns_ns1__SPLIT:
		return soap_in_ns1__SPLIT(soap, NULL, NULL, "ns1:SPLIT");
	case SOAP_TYPE_ns_ns1__ArrayOfSPLIT:
		return soap_in_ns1__ArrayOfSPLIT(soap, NULL, NULL, "ns1:ArrayOfSPLIT");
	case SOAP_TYPE_ns_ns1__QUOTE2:
		return soap_in_ns1__QUOTE2(soap, NULL, NULL, "ns1:QUOTE2");
	case SOAP_TYPE_ns_ns1__ArrayOfQUOTE2:
		return soap_in_ns1__ArrayOfQUOTE2(soap, NULL, NULL, "ns1:ArrayOfQUOTE2");
	case SOAP_TYPE_ns_ns1__ArrayOfQUOTE:
		return soap_in_ns1__ArrayOfQUOTE(soap, NULL, NULL, "ns1:ArrayOfQUOTE");
	case SOAP_TYPE_ns_ns1__QUOTE:
		return soap_in_ns1__QUOTE(soap, NULL, NULL, "ns1:QUOTE");
	case SOAP_TYPE_ns_ns1__SYMBOL2:
		return soap_in_ns1__SYMBOL2(soap, NULL, NULL, "ns1:SYMBOL2");
	case SOAP_TYPE_ns_ns1__ArrayOfSYMBOL2:
		return soap_in_ns1__ArrayOfSYMBOL2(soap, NULL, NULL, "ns1:ArrayOfSYMBOL2");
	case SOAP_TYPE_ns_ns1__ArrayOfSYMBOL:
		return soap_in_ns1__ArrayOfSYMBOL(soap, NULL, NULL, "ns1:ArrayOfSYMBOL");
	case SOAP_TYPE_ns_ns1__SYMBOL:
		return soap_in_ns1__SYMBOL(soap, NULL, NULL, "ns1:SYMBOL");
	case SOAP_TYPE_ns_ns1__ArrayOfEXCHANGE:
		return soap_in_ns1__ArrayOfEXCHANGE(soap, NULL, NULL, "ns1:ArrayOfEXCHANGE");
	case SOAP_TYPE_ns_ns1__EXCHANGE:
		return soap_in_ns1__EXCHANGE(soap, NULL, NULL, "ns1:EXCHANGE");
	case SOAP_TYPE_ns_ns1__RESPONSE:
		return soap_in_ns1__RESPONSE(soap, NULL, NULL, "ns1:RESPONSE");
	case SOAP_TYPE_ns_ns1__LOGINRESPONSE:
		return soap_in_ns1__LOGINRESPONSE(soap, NULL, NULL, "ns1:LOGINRESPONSE");
	case SOAP_TYPE_ns_PointerTo_ns1__ValidateAccess:
		return soap_in_PointerTo_ns1__ValidateAccess(soap, NULL, NULL, "ns1:ValidateAccess");
	case SOAP_TYPE_ns_PointerTo_ns1__UpdateDataFormat:
		return soap_in_PointerTo_ns1__UpdateDataFormat(soap, NULL, NULL, "ns1:UpdateDataFormat");
	case SOAP_TYPE_ns_PointerTo_ns1__DataFormats:
		return soap_in_PointerTo_ns1__DataFormats(soap, NULL, NULL, "ns1:DataFormats");
	case SOAP_TYPE_ns_PointerTo_ns1__DataClientLatestVersion:
		return soap_in_PointerTo_ns1__DataClientLatestVersion(soap, NULL, NULL, "ns1:DataClientLatestVersion");
	case SOAP_TYPE_ns_PointerTo_ns1__SymbolChangesByExchange:
		return soap_in_PointerTo_ns1__SymbolChangesByExchange(soap, NULL, NULL, "ns1:SymbolChangesByExchange");
	case SOAP_TYPE_ns_PointerTo_ns1__QuoteListByDatePeriod2:
		return soap_in_PointerTo_ns1__QuoteListByDatePeriod2(soap, NULL, NULL, "ns1:QuoteListByDatePeriod2");
	case SOAP_TYPE_ns_PointerTo_ns1__QuoteListByDatePeriod:
		return soap_in_PointerTo_ns1__QuoteListByDatePeriod(soap, NULL, NULL, "ns1:QuoteListByDatePeriod");
	case SOAP_TYPE_ns_PointerTo_ns1__SymbolHistoryPeriodByDateRange:
		return soap_in_PointerTo_ns1__SymbolHistoryPeriodByDateRange(soap, NULL, NULL, "ns1:SymbolHistoryPeriodByDateRange");
	case SOAP_TYPE_ns_PointerTo_ns1__SymbolHistoryPeriod:
		return soap_in_PointerTo_ns1__SymbolHistoryPeriod(soap, NULL, NULL, "ns1:SymbolHistoryPeriod");
	case SOAP_TYPE_ns_PointerTo_ns1__CountryList:
		return soap_in_PointerTo_ns1__CountryList(soap, NULL, NULL, "ns1:CountryList");
	case SOAP_TYPE_ns_PointerTo_ns1__SplitListBySymbol:
		return soap_in_PointerTo_ns1__SplitListBySymbol(soap, NULL, NULL, "ns1:SplitListBySymbol");
	case SOAP_TYPE_ns_PointerTo_ns1__SplitListByExchange:
		return soap_in_PointerTo_ns1__SplitListByExchange(soap, NULL, NULL, "ns1:SplitListByExchange");
	case SOAP_TYPE_ns_PointerTo_ns1__ExchangeMonths:
		return soap_in_PointerTo_ns1__ExchangeMonths(soap, NULL, NULL, "ns1:ExchangeMonths");
	case SOAP_TYPE_ns_PointerTo_ns1__SymbolChart:
		return soap_in_PointerTo_ns1__SymbolChart(soap, NULL, NULL, "ns1:SymbolChart");
	case SOAP_TYPE_ns_PointerTo_ns1__Top10Losses:
		return soap_in_PointerTo_ns1__Top10Losses(soap, NULL, NULL, "ns1:Top10Losses");
	case SOAP_TYPE_ns_PointerTo_ns1__Top10Gains:
		return soap_in_PointerTo_ns1__Top10Gains(soap, NULL, NULL, "ns1:Top10Gains");
	case SOAP_TYPE_ns_PointerTo_ns1__SymbolHistory:
		return soap_in_PointerTo_ns1__SymbolHistory(soap, NULL, NULL, "ns1:SymbolHistory");
	case SOAP_TYPE_ns_PointerTo_ns1__QuoteListByDate2:
		return soap_in_PointerTo_ns1__QuoteListByDate2(soap, NULL, NULL, "ns1:QuoteListByDate2");
	case SOAP_TYPE_ns_PointerTo_ns1__QuoteListByDate:
		return soap_in_PointerTo_ns1__QuoteListByDate(soap, NULL, NULL, "ns1:QuoteListByDate");
	case SOAP_TYPE_ns_PointerTo_ns1__TechnicalList:
		return soap_in_PointerTo_ns1__TechnicalList(soap, NULL, NULL, "ns1:TechnicalList");
	case SOAP_TYPE_ns_PointerTo_ns1__FundamentalList:
		return soap_in_PointerTo_ns1__FundamentalList(soap, NULL, NULL, "ns1:FundamentalList");
	case SOAP_TYPE_ns_PointerTo_ns1__NewsListBySymbol:
		return soap_in_PointerTo_ns1__NewsListBySymbol(soap, NULL, NULL, "ns1:NewsListBySymbol");
	case SOAP_TYPE_ns_PointerTo_ns1__NewsList:
		return soap_in_PointerTo_ns1__NewsList(soap, NULL, NULL, "ns1:NewsList");
	case SOAP_TYPE_ns_PointerTo_ns1__QuoteList:
		return soap_in_PointerTo_ns1__QuoteList(soap, NULL, NULL, "ns1:QuoteList");
	case SOAP_TYPE_ns_PointerTo_ns1__SymbolGet:
		return soap_in_PointerTo_ns1__SymbolGet(soap, NULL, NULL, "ns1:SymbolGet");
	case SOAP_TYPE_ns_PointerTo_ns1__QuoteList2:
		return soap_in_PointerTo_ns1__QuoteList2(soap, NULL, NULL, "ns1:QuoteList2");
	case SOAP_TYPE_ns_PointerTo_ns1__QuoteGet:
		return soap_in_PointerTo_ns1__QuoteGet(soap, NULL, NULL, "ns1:QuoteGet");
	case SOAP_TYPE_ns_PointerTo_ns1__SymbolList2:
		return soap_in_PointerTo_ns1__SymbolList2(soap, NULL, NULL, "ns1:SymbolList2");
	case SOAP_TYPE_ns_PointerTo_ns1__SymbolList:
		return soap_in_PointerTo_ns1__SymbolList(soap, NULL, NULL, "ns1:SymbolList");
	case SOAP_TYPE_ns_PointerTo_ns1__ExchangeGet:
		return soap_in_PointerTo_ns1__ExchangeGet(soap, NULL, NULL, "ns1:ExchangeGet");
	case SOAP_TYPE_ns_PointerTo_ns1__ExchangeList:
		return soap_in_PointerTo_ns1__ExchangeList(soap, NULL, NULL, "ns1:ExchangeList");
	case SOAP_TYPE_ns_PointerTo_ns1__Membership:
		return soap_in_PointerTo_ns1__Membership(soap, NULL, NULL, "ns1:Membership");
	case SOAP_TYPE_ns_PointerTo_ns1__Login2:
		return soap_in_PointerTo_ns1__Login2(soap, NULL, NULL, "ns1:Login2");
	case SOAP_TYPE_ns_PointerTo_ns1__Login:
		return soap_in_PointerTo_ns1__Login(soap, NULL, NULL, "ns1:Login");
	case SOAP_TYPE_ns_PointerTons1__RESPONSE:
		return soap_in_PointerTons1__RESPONSE(soap, NULL, NULL, "ns1:RESPONSE");
	case SOAP_TYPE_ns_PointerTons1__LOGINRESPONSE:
		return soap_in_PointerTons1__LOGINRESPONSE(soap, NULL, NULL, "ns1:LOGINRESPONSE");
	case SOAP_TYPE_ns_PointerTons1__DATAFORMAT_USCORECOLUMN:
		return soap_in_PointerTons1__DATAFORMAT_USCORECOLUMN(soap, NULL, NULL, "ns1:DATAFORMAT_COLUMN");
	case SOAP_TYPE_ns_PointerTons1__ArrayOfDATAFORMAT_USCORECOLUMN:
		return soap_in_PointerTons1__ArrayOfDATAFORMAT_USCORECOLUMN(soap, NULL, NULL, "ns1:ArrayOfDATAFORMAT_COLUMN");
	case SOAP_TYPE_ns_PointerTons1__DATAFORMAT:
		return soap_in_PointerTons1__DATAFORMAT(soap, NULL, NULL, "ns1:DATAFORMAT");
	case SOAP_TYPE_ns_PointerTons1__NEWS:
		return soap_in_PointerTons1__NEWS(soap, NULL, NULL, "ns1:NEWS");
	case SOAP_TYPE_ns_PointerTons1__SYMBOLCHANGE:
		return soap_in_PointerTons1__SYMBOLCHANGE(soap, NULL, NULL, "ns1:SYMBOLCHANGE");
	case SOAP_TYPE_ns_PointerTons1__TECHNICAL:
		return soap_in_PointerTons1__TECHNICAL(soap, NULL, NULL, "ns1:TECHNICAL");
	case SOAP_TYPE_ns_PointerTons1__FUNDAMENTAL:
		return soap_in_PointerTons1__FUNDAMENTAL(soap, NULL, NULL, "ns1:FUNDAMENTAL");
	case SOAP_TYPE_ns_PointerTons1__CountryBase:
		return soap_in_PointerTons1__CountryBase(soap, NULL, NULL, "ns1:CountryBase");
	case SOAP_TYPE_ns_PointerTons1__SPLIT:
		return soap_in_PointerTons1__SPLIT(soap, NULL, NULL, "ns1:SPLIT");
	case SOAP_TYPE_ns_PointerTons1__QUOTE2:
		return soap_in_PointerTons1__QUOTE2(soap, NULL, NULL, "ns1:QUOTE2");
	case SOAP_TYPE_ns_PointerTons1__SYMBOL2:
		return soap_in_PointerTons1__SYMBOL2(soap, NULL, NULL, "ns1:SYMBOL2");
	case SOAP_TYPE_ns_PointerTons1__ArrayOfDATAFORMAT:
		return soap_in_PointerTons1__ArrayOfDATAFORMAT(soap, NULL, NULL, "ns1:ArrayOfDATAFORMAT");
	case SOAP_TYPE_ns_PointerTons1__ArrayOfNEWS:
		return soap_in_PointerTons1__ArrayOfNEWS(soap, NULL, NULL, "ns1:ArrayOfNEWS");
	case SOAP_TYPE_ns_PointerTons1__ArrayOfSYMBOLCHANGE:
		return soap_in_PointerTons1__ArrayOfSYMBOLCHANGE(soap, NULL, NULL, "ns1:ArrayOfSYMBOLCHANGE");
	case SOAP_TYPE_ns_PointerTons1__ArrayOfTECHNICAL:
		return soap_in_PointerTons1__ArrayOfTECHNICAL(soap, NULL, NULL, "ns1:ArrayOfTECHNICAL");
	case SOAP_TYPE_ns_PointerTons1__ArrayOfFUNDAMENTAL:
		return soap_in_PointerTons1__ArrayOfFUNDAMENTAL(soap, NULL, NULL, "ns1:ArrayOfFUNDAMENTAL");
	case SOAP_TYPE_ns_PointerTons1__ArrayOfCountryBase:
		return soap_in_PointerTons1__ArrayOfCountryBase(soap, NULL, NULL, "ns1:ArrayOfCountryBase");
	case SOAP_TYPE_ns_PointerTons1__ArrayOfSPLIT:
		return soap_in_PointerTons1__ArrayOfSPLIT(soap, NULL, NULL, "ns1:ArrayOfSPLIT");
	case SOAP_TYPE_ns_PointerTons1__ArrayOfQUOTE2:
		return soap_in_PointerTons1__ArrayOfQUOTE2(soap, NULL, NULL, "ns1:ArrayOfQUOTE2");
	case SOAP_TYPE_ns_PointerTons1__ArrayOfQUOTE:
		return soap_in_PointerTons1__ArrayOfQUOTE(soap, NULL, NULL, "ns1:ArrayOfQUOTE");
	case SOAP_TYPE_ns_PointerTons1__QUOTE:
		return soap_in_PointerTons1__QUOTE(soap, NULL, NULL, "ns1:QUOTE");
	case SOAP_TYPE_ns_PointerTons1__ArrayOfSYMBOL2:
		return soap_in_PointerTons1__ArrayOfSYMBOL2(soap, NULL, NULL, "ns1:ArrayOfSYMBOL2");
	case SOAP_TYPE_ns_PointerTons1__ArrayOfSYMBOL:
		return soap_in_PointerTons1__ArrayOfSYMBOL(soap, NULL, NULL, "ns1:ArrayOfSYMBOL");
	case SOAP_TYPE_ns_PointerTons1__SYMBOL:
		return soap_in_PointerTons1__SYMBOL(soap, NULL, NULL, "ns1:SYMBOL");
	case SOAP_TYPE_ns_PointerTons1__ArrayOfEXCHANGE:
		return soap_in_PointerTons1__ArrayOfEXCHANGE(soap, NULL, NULL, "ns1:ArrayOfEXCHANGE");
	case SOAP_TYPE_ns_PointerTons1__EXCHANGE:
		return soap_in_PointerTons1__EXCHANGE(soap, NULL, NULL, "ns1:EXCHANGE");
	case SOAP_TYPE_ns_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_ns__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_ns_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_ns_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DATAFORMAT_COLUMN"))
		{	*type = SOAP_TYPE_ns_ns1__DATAFORMAT_USCORECOLUMN;
			return soap_in_ns1__DATAFORMAT_USCORECOLUMN(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfDATAFORMAT_COLUMN"))
		{	*type = SOAP_TYPE_ns_ns1__ArrayOfDATAFORMAT_USCORECOLUMN;
			return soap_in_ns1__ArrayOfDATAFORMAT_USCORECOLUMN(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DATAFORMAT"))
		{	*type = SOAP_TYPE_ns_ns1__DATAFORMAT;
			return soap_in_ns1__DATAFORMAT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfDATAFORMAT"))
		{	*type = SOAP_TYPE_ns_ns1__ArrayOfDATAFORMAT;
			return soap_in_ns1__ArrayOfDATAFORMAT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:NEWS"))
		{	*type = SOAP_TYPE_ns_ns1__NEWS;
			return soap_in_ns1__NEWS(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfNEWS"))
		{	*type = SOAP_TYPE_ns_ns1__ArrayOfNEWS;
			return soap_in_ns1__ArrayOfNEWS(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SYMBOLCHANGE"))
		{	*type = SOAP_TYPE_ns_ns1__SYMBOLCHANGE;
			return soap_in_ns1__SYMBOLCHANGE(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfSYMBOLCHANGE"))
		{	*type = SOAP_TYPE_ns_ns1__ArrayOfSYMBOLCHANGE;
			return soap_in_ns1__ArrayOfSYMBOLCHANGE(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TECHNICAL"))
		{	*type = SOAP_TYPE_ns_ns1__TECHNICAL;
			return soap_in_ns1__TECHNICAL(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfTECHNICAL"))
		{	*type = SOAP_TYPE_ns_ns1__ArrayOfTECHNICAL;
			return soap_in_ns1__ArrayOfTECHNICAL(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:FUNDAMENTAL"))
		{	*type = SOAP_TYPE_ns_ns1__FUNDAMENTAL;
			return soap_in_ns1__FUNDAMENTAL(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfFUNDAMENTAL"))
		{	*type = SOAP_TYPE_ns_ns1__ArrayOfFUNDAMENTAL;
			return soap_in_ns1__ArrayOfFUNDAMENTAL(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CountryBase"))
		{	*type = SOAP_TYPE_ns_ns1__CountryBase;
			return soap_in_ns1__CountryBase(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfCountryBase"))
		{	*type = SOAP_TYPE_ns_ns1__ArrayOfCountryBase;
			return soap_in_ns1__ArrayOfCountryBase(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SPLIT"))
		{	*type = SOAP_TYPE_ns_ns1__SPLIT;
			return soap_in_ns1__SPLIT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfSPLIT"))
		{	*type = SOAP_TYPE_ns_ns1__ArrayOfSPLIT;
			return soap_in_ns1__ArrayOfSPLIT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:QUOTE2"))
		{	*type = SOAP_TYPE_ns_ns1__QUOTE2;
			return soap_in_ns1__QUOTE2(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfQUOTE2"))
		{	*type = SOAP_TYPE_ns_ns1__ArrayOfQUOTE2;
			return soap_in_ns1__ArrayOfQUOTE2(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfQUOTE"))
		{	*type = SOAP_TYPE_ns_ns1__ArrayOfQUOTE;
			return soap_in_ns1__ArrayOfQUOTE(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:QUOTE"))
		{	*type = SOAP_TYPE_ns_ns1__QUOTE;
			return soap_in_ns1__QUOTE(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SYMBOL2"))
		{	*type = SOAP_TYPE_ns_ns1__SYMBOL2;
			return soap_in_ns1__SYMBOL2(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfSYMBOL2"))
		{	*type = SOAP_TYPE_ns_ns1__ArrayOfSYMBOL2;
			return soap_in_ns1__ArrayOfSYMBOL2(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfSYMBOL"))
		{	*type = SOAP_TYPE_ns_ns1__ArrayOfSYMBOL;
			return soap_in_ns1__ArrayOfSYMBOL(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SYMBOL"))
		{	*type = SOAP_TYPE_ns_ns1__SYMBOL;
			return soap_in_ns1__SYMBOL(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfEXCHANGE"))
		{	*type = SOAP_TYPE_ns_ns1__ArrayOfEXCHANGE;
			return soap_in_ns1__ArrayOfEXCHANGE(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:EXCHANGE"))
		{	*type = SOAP_TYPE_ns_ns1__EXCHANGE;
			return soap_in_ns1__EXCHANGE(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RESPONSE"))
		{	*type = SOAP_TYPE_ns_ns1__RESPONSE;
			return soap_in_ns1__RESPONSE(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:LOGINRESPONSE"))
		{	*type = SOAP_TYPE_ns_ns1__LOGINRESPONSE;
			return soap_in_ns1__LOGINRESPONSE(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_ns_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_ns_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_ns_LONG64;
			return soap_in_LONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_ns_double;
			return soap_in_double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_ns_dateTime;
			return soap_in_dateTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_ns_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE_ns__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_ns_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:ValidateAccessResponse"))
		{	*type = SOAP_TYPE_ns__ns1__ValidateAccessResponse;
			return soap_in__ns1__ValidateAccessResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ValidateAccess"))
		{	*type = SOAP_TYPE_ns__ns1__ValidateAccess;
			return soap_in__ns1__ValidateAccess(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpdateDataFormatResponse"))
		{	*type = SOAP_TYPE_ns__ns1__UpdateDataFormatResponse;
			return soap_in__ns1__UpdateDataFormatResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpdateDataFormat"))
		{	*type = SOAP_TYPE_ns__ns1__UpdateDataFormat;
			return soap_in__ns1__UpdateDataFormat(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DataFormatsResponse"))
		{	*type = SOAP_TYPE_ns__ns1__DataFormatsResponse;
			return soap_in__ns1__DataFormatsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DataFormats"))
		{	*type = SOAP_TYPE_ns__ns1__DataFormats;
			return soap_in__ns1__DataFormats(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DataClientLatestVersionResponse"))
		{	*type = SOAP_TYPE_ns__ns1__DataClientLatestVersionResponse;
			return soap_in__ns1__DataClientLatestVersionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DataClientLatestVersion"))
		{	*type = SOAP_TYPE_ns__ns1__DataClientLatestVersion;
			return soap_in__ns1__DataClientLatestVersion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SymbolChangesByExchangeResponse"))
		{	*type = SOAP_TYPE_ns__ns1__SymbolChangesByExchangeResponse;
			return soap_in__ns1__SymbolChangesByExchangeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SymbolChangesByExchange"))
		{	*type = SOAP_TYPE_ns__ns1__SymbolChangesByExchange;
			return soap_in__ns1__SymbolChangesByExchange(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:QuoteListByDatePeriod2Response"))
		{	*type = SOAP_TYPE_ns__ns1__QuoteListByDatePeriod2Response;
			return soap_in__ns1__QuoteListByDatePeriod2Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:QuoteListByDatePeriod2"))
		{	*type = SOAP_TYPE_ns__ns1__QuoteListByDatePeriod2;
			return soap_in__ns1__QuoteListByDatePeriod2(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:QuoteListByDatePeriodResponse"))
		{	*type = SOAP_TYPE_ns__ns1__QuoteListByDatePeriodResponse;
			return soap_in__ns1__QuoteListByDatePeriodResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:QuoteListByDatePeriod"))
		{	*type = SOAP_TYPE_ns__ns1__QuoteListByDatePeriod;
			return soap_in__ns1__QuoteListByDatePeriod(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SymbolHistoryPeriodByDateRangeResponse"))
		{	*type = SOAP_TYPE_ns__ns1__SymbolHistoryPeriodByDateRangeResponse;
			return soap_in__ns1__SymbolHistoryPeriodByDateRangeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SymbolHistoryPeriodByDateRange"))
		{	*type = SOAP_TYPE_ns__ns1__SymbolHistoryPeriodByDateRange;
			return soap_in__ns1__SymbolHistoryPeriodByDateRange(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SymbolHistoryPeriodResponse"))
		{	*type = SOAP_TYPE_ns__ns1__SymbolHistoryPeriodResponse;
			return soap_in__ns1__SymbolHistoryPeriodResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SymbolHistoryPeriod"))
		{	*type = SOAP_TYPE_ns__ns1__SymbolHistoryPeriod;
			return soap_in__ns1__SymbolHistoryPeriod(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CountryListResponse"))
		{	*type = SOAP_TYPE_ns__ns1__CountryListResponse;
			return soap_in__ns1__CountryListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CountryList"))
		{	*type = SOAP_TYPE_ns__ns1__CountryList;
			return soap_in__ns1__CountryList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SplitListBySymbolResponse"))
		{	*type = SOAP_TYPE_ns__ns1__SplitListBySymbolResponse;
			return soap_in__ns1__SplitListBySymbolResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SplitListBySymbol"))
		{	*type = SOAP_TYPE_ns__ns1__SplitListBySymbol;
			return soap_in__ns1__SplitListBySymbol(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SplitListByExchangeResponse"))
		{	*type = SOAP_TYPE_ns__ns1__SplitListByExchangeResponse;
			return soap_in__ns1__SplitListByExchangeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SplitListByExchange"))
		{	*type = SOAP_TYPE_ns__ns1__SplitListByExchange;
			return soap_in__ns1__SplitListByExchange(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ExchangeMonthsResponse"))
		{	*type = SOAP_TYPE_ns__ns1__ExchangeMonthsResponse;
			return soap_in__ns1__ExchangeMonthsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ExchangeMonths"))
		{	*type = SOAP_TYPE_ns__ns1__ExchangeMonths;
			return soap_in__ns1__ExchangeMonths(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SymbolChartResponse"))
		{	*type = SOAP_TYPE_ns__ns1__SymbolChartResponse;
			return soap_in__ns1__SymbolChartResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SymbolChart"))
		{	*type = SOAP_TYPE_ns__ns1__SymbolChart;
			return soap_in__ns1__SymbolChart(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Top10LossesResponse"))
		{	*type = SOAP_TYPE_ns__ns1__Top10LossesResponse;
			return soap_in__ns1__Top10LossesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Top10Losses"))
		{	*type = SOAP_TYPE_ns__ns1__Top10Losses;
			return soap_in__ns1__Top10Losses(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Top10GainsResponse"))
		{	*type = SOAP_TYPE_ns__ns1__Top10GainsResponse;
			return soap_in__ns1__Top10GainsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Top10Gains"))
		{	*type = SOAP_TYPE_ns__ns1__Top10Gains;
			return soap_in__ns1__Top10Gains(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SymbolHistoryResponse"))
		{	*type = SOAP_TYPE_ns__ns1__SymbolHistoryResponse;
			return soap_in__ns1__SymbolHistoryResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SymbolHistory"))
		{	*type = SOAP_TYPE_ns__ns1__SymbolHistory;
			return soap_in__ns1__SymbolHistory(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:QuoteListByDate2Response"))
		{	*type = SOAP_TYPE_ns__ns1__QuoteListByDate2Response;
			return soap_in__ns1__QuoteListByDate2Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:QuoteListByDate2"))
		{	*type = SOAP_TYPE_ns__ns1__QuoteListByDate2;
			return soap_in__ns1__QuoteListByDate2(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:QuoteListByDateResponse"))
		{	*type = SOAP_TYPE_ns__ns1__QuoteListByDateResponse;
			return soap_in__ns1__QuoteListByDateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:QuoteListByDate"))
		{	*type = SOAP_TYPE_ns__ns1__QuoteListByDate;
			return soap_in__ns1__QuoteListByDate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TechnicalListResponse"))
		{	*type = SOAP_TYPE_ns__ns1__TechnicalListResponse;
			return soap_in__ns1__TechnicalListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TechnicalList"))
		{	*type = SOAP_TYPE_ns__ns1__TechnicalList;
			return soap_in__ns1__TechnicalList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:FundamentalListResponse"))
		{	*type = SOAP_TYPE_ns__ns1__FundamentalListResponse;
			return soap_in__ns1__FundamentalListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:FundamentalList"))
		{	*type = SOAP_TYPE_ns__ns1__FundamentalList;
			return soap_in__ns1__FundamentalList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:NewsListBySymbolResponse"))
		{	*type = SOAP_TYPE_ns__ns1__NewsListBySymbolResponse;
			return soap_in__ns1__NewsListBySymbolResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:NewsListBySymbol"))
		{	*type = SOAP_TYPE_ns__ns1__NewsListBySymbol;
			return soap_in__ns1__NewsListBySymbol(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:NewsListResponse"))
		{	*type = SOAP_TYPE_ns__ns1__NewsListResponse;
			return soap_in__ns1__NewsListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:NewsList"))
		{	*type = SOAP_TYPE_ns__ns1__NewsList;
			return soap_in__ns1__NewsList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:QuoteListResponse"))
		{	*type = SOAP_TYPE_ns__ns1__QuoteListResponse;
			return soap_in__ns1__QuoteListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:QuoteList"))
		{	*type = SOAP_TYPE_ns__ns1__QuoteList;
			return soap_in__ns1__QuoteList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SymbolGetResponse"))
		{	*type = SOAP_TYPE_ns__ns1__SymbolGetResponse;
			return soap_in__ns1__SymbolGetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SymbolGet"))
		{	*type = SOAP_TYPE_ns__ns1__SymbolGet;
			return soap_in__ns1__SymbolGet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:QuoteList2Response"))
		{	*type = SOAP_TYPE_ns__ns1__QuoteList2Response;
			return soap_in__ns1__QuoteList2Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:QuoteList2"))
		{	*type = SOAP_TYPE_ns__ns1__QuoteList2;
			return soap_in__ns1__QuoteList2(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:QuoteGetResponse"))
		{	*type = SOAP_TYPE_ns__ns1__QuoteGetResponse;
			return soap_in__ns1__QuoteGetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:QuoteGet"))
		{	*type = SOAP_TYPE_ns__ns1__QuoteGet;
			return soap_in__ns1__QuoteGet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SymbolList2Response"))
		{	*type = SOAP_TYPE_ns__ns1__SymbolList2Response;
			return soap_in__ns1__SymbolList2Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SymbolList2"))
		{	*type = SOAP_TYPE_ns__ns1__SymbolList2;
			return soap_in__ns1__SymbolList2(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SymbolListResponse"))
		{	*type = SOAP_TYPE_ns__ns1__SymbolListResponse;
			return soap_in__ns1__SymbolListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SymbolList"))
		{	*type = SOAP_TYPE_ns__ns1__SymbolList;
			return soap_in__ns1__SymbolList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ExchangeGetResponse"))
		{	*type = SOAP_TYPE_ns__ns1__ExchangeGetResponse;
			return soap_in__ns1__ExchangeGetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ExchangeGet"))
		{	*type = SOAP_TYPE_ns__ns1__ExchangeGet;
			return soap_in__ns1__ExchangeGet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ExchangeListResponse"))
		{	*type = SOAP_TYPE_ns__ns1__ExchangeListResponse;
			return soap_in__ns1__ExchangeListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ExchangeList"))
		{	*type = SOAP_TYPE_ns__ns1__ExchangeList;
			return soap_in__ns1__ExchangeList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MembershipResponse"))
		{	*type = SOAP_TYPE_ns__ns1__MembershipResponse;
			return soap_in__ns1__MembershipResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Membership"))
		{	*type = SOAP_TYPE_ns__ns1__Membership;
			return soap_in__ns1__Membership(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Login2Response"))
		{	*type = SOAP_TYPE_ns__ns1__Login2Response;
			return soap_in__ns1__Login2Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Login2"))
		{	*type = SOAP_TYPE_ns__ns1__Login2;
			return soap_in__ns1__Login2(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:LoginResponse"))
		{	*type = SOAP_TYPE_ns__ns1__LoginResponse;
			return soap_in__ns1__LoginResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Login"))
		{	*type = SOAP_TYPE_ns__ns1__Login;
			return soap_in__ns1__Login(soap, NULL, NULL, NULL);
		}
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level = %u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_ns_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_ns_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_ns_LONG64:
		return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_ns_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_ns_dateTime:
		return soap_out_dateTime(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_ns_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_ns_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_ns__ns1__ValidateAccessResponse:
		return ((_ns1__ValidateAccessResponse *)ptr)->soap_out(soap, "ns1:ValidateAccessResponse", id, NULL);
	case SOAP_TYPE_ns__ns1__ValidateAccess:
		return ((_ns1__ValidateAccess *)ptr)->soap_out(soap, "ns1:ValidateAccess", id, NULL);
	case SOAP_TYPE_ns__ns1__UpdateDataFormatResponse:
		return ((_ns1__UpdateDataFormatResponse *)ptr)->soap_out(soap, "ns1:UpdateDataFormatResponse", id, NULL);
	case SOAP_TYPE_ns__ns1__UpdateDataFormat:
		return ((_ns1__UpdateDataFormat *)ptr)->soap_out(soap, "ns1:UpdateDataFormat", id, NULL);
	case SOAP_TYPE_ns__ns1__DataFormatsResponse:
		return ((_ns1__DataFormatsResponse *)ptr)->soap_out(soap, "ns1:DataFormatsResponse", id, NULL);
	case SOAP_TYPE_ns__ns1__DataFormats:
		return ((_ns1__DataFormats *)ptr)->soap_out(soap, "ns1:DataFormats", id, NULL);
	case SOAP_TYPE_ns__ns1__DataClientLatestVersionResponse:
		return ((_ns1__DataClientLatestVersionResponse *)ptr)->soap_out(soap, "ns1:DataClientLatestVersionResponse", id, NULL);
	case SOAP_TYPE_ns__ns1__DataClientLatestVersion:
		return ((_ns1__DataClientLatestVersion *)ptr)->soap_out(soap, "ns1:DataClientLatestVersion", id, NULL);
	case SOAP_TYPE_ns__ns1__SymbolChangesByExchangeResponse:
		return ((_ns1__SymbolChangesByExchangeResponse *)ptr)->soap_out(soap, "ns1:SymbolChangesByExchangeResponse", id, NULL);
	case SOAP_TYPE_ns__ns1__SymbolChangesByExchange:
		return ((_ns1__SymbolChangesByExchange *)ptr)->soap_out(soap, "ns1:SymbolChangesByExchange", id, NULL);
	case SOAP_TYPE_ns__ns1__QuoteListByDatePeriod2Response:
		return ((_ns1__QuoteListByDatePeriod2Response *)ptr)->soap_out(soap, "ns1:QuoteListByDatePeriod2Response", id, NULL);
	case SOAP_TYPE_ns__ns1__QuoteListByDatePeriod2:
		return ((_ns1__QuoteListByDatePeriod2 *)ptr)->soap_out(soap, "ns1:QuoteListByDatePeriod2", id, NULL);
	case SOAP_TYPE_ns__ns1__QuoteListByDatePeriodResponse:
		return ((_ns1__QuoteListByDatePeriodResponse *)ptr)->soap_out(soap, "ns1:QuoteListByDatePeriodResponse", id, NULL);
	case SOAP_TYPE_ns__ns1__QuoteListByDatePeriod:
		return ((_ns1__QuoteListByDatePeriod *)ptr)->soap_out(soap, "ns1:QuoteListByDatePeriod", id, NULL);
	case SOAP_TYPE_ns__ns1__SymbolHistoryPeriodByDateRangeResponse:
		return ((_ns1__SymbolHistoryPeriodByDateRangeResponse *)ptr)->soap_out(soap, "ns1:SymbolHistoryPeriodByDateRangeResponse", id, NULL);
	case SOAP_TYPE_ns__ns1__SymbolHistoryPeriodByDateRange:
		return ((_ns1__SymbolHistoryPeriodByDateRange *)ptr)->soap_out(soap, "ns1:SymbolHistoryPeriodByDateRange", id, NULL);
	case SOAP_TYPE_ns__ns1__SymbolHistoryPeriodResponse:
		return ((_ns1__SymbolHistoryPeriodResponse *)ptr)->soap_out(soap, "ns1:SymbolHistoryPeriodResponse", id, NULL);
	case SOAP_TYPE_ns__ns1__SymbolHistoryPeriod:
		return ((_ns1__SymbolHistoryPeriod *)ptr)->soap_out(soap, "ns1:SymbolHistoryPeriod", id, NULL);
	case SOAP_TYPE_ns__ns1__CountryListResponse:
		return ((_ns1__CountryListResponse *)ptr)->soap_out(soap, "ns1:CountryListResponse", id, NULL);
	case SOAP_TYPE_ns__ns1__CountryList:
		return ((_ns1__CountryList *)ptr)->soap_out(soap, "ns1:CountryList", id, NULL);
	case SOAP_TYPE_ns__ns1__SplitListBySymbolResponse:
		return ((_ns1__SplitListBySymbolResponse *)ptr)->soap_out(soap, "ns1:SplitListBySymbolResponse", id, NULL);
	case SOAP_TYPE_ns__ns1__SplitListBySymbol:
		return ((_ns1__SplitListBySymbol *)ptr)->soap_out(soap, "ns1:SplitListBySymbol", id, NULL);
	case SOAP_TYPE_ns__ns1__SplitListByExchangeResponse:
		return ((_ns1__SplitListByExchangeResponse *)ptr)->soap_out(soap, "ns1:SplitListByExchangeResponse", id, NULL);
	case SOAP_TYPE_ns__ns1__SplitListByExchange:
		return ((_ns1__SplitListByExchange *)ptr)->soap_out(soap, "ns1:SplitListByExchange", id, NULL);
	case SOAP_TYPE_ns__ns1__ExchangeMonthsResponse:
		return ((_ns1__ExchangeMonthsResponse *)ptr)->soap_out(soap, "ns1:ExchangeMonthsResponse", id, NULL);
	case SOAP_TYPE_ns__ns1__ExchangeMonths:
		return ((_ns1__ExchangeMonths *)ptr)->soap_out(soap, "ns1:ExchangeMonths", id, NULL);
	case SOAP_TYPE_ns__ns1__SymbolChartResponse:
		return ((_ns1__SymbolChartResponse *)ptr)->soap_out(soap, "ns1:SymbolChartResponse", id, NULL);
	case SOAP_TYPE_ns__ns1__SymbolChart:
		return ((_ns1__SymbolChart *)ptr)->soap_out(soap, "ns1:SymbolChart", id, NULL);
	case SOAP_TYPE_ns__ns1__Top10LossesResponse:
		return ((_ns1__Top10LossesResponse *)ptr)->soap_out(soap, "ns1:Top10LossesResponse", id, NULL);
	case SOAP_TYPE_ns__ns1__Top10Losses:
		return ((_ns1__Top10Losses *)ptr)->soap_out(soap, "ns1:Top10Losses", id, NULL);
	case SOAP_TYPE_ns__ns1__Top10GainsResponse:
		return ((_ns1__Top10GainsResponse *)ptr)->soap_out(soap, "ns1:Top10GainsResponse", id, NULL);
	case SOAP_TYPE_ns__ns1__Top10Gains:
		return ((_ns1__Top10Gains *)ptr)->soap_out(soap, "ns1:Top10Gains", id, NULL);
	case SOAP_TYPE_ns__ns1__SymbolHistoryResponse:
		return ((_ns1__SymbolHistoryResponse *)ptr)->soap_out(soap, "ns1:SymbolHistoryResponse", id, NULL);
	case SOAP_TYPE_ns__ns1__SymbolHistory:
		return ((_ns1__SymbolHistory *)ptr)->soap_out(soap, "ns1:SymbolHistory", id, NULL);
	case SOAP_TYPE_ns__ns1__QuoteListByDate2Response:
		return ((_ns1__QuoteListByDate2Response *)ptr)->soap_out(soap, "ns1:QuoteListByDate2Response", id, NULL);
	case SOAP_TYPE_ns__ns1__QuoteListByDate2:
		return ((_ns1__QuoteListByDate2 *)ptr)->soap_out(soap, "ns1:QuoteListByDate2", id, NULL);
	case SOAP_TYPE_ns__ns1__QuoteListByDateResponse:
		return ((_ns1__QuoteListByDateResponse *)ptr)->soap_out(soap, "ns1:QuoteListByDateResponse", id, NULL);
	case SOAP_TYPE_ns__ns1__QuoteListByDate:
		return ((_ns1__QuoteListByDate *)ptr)->soap_out(soap, "ns1:QuoteListByDate", id, NULL);
	case SOAP_TYPE_ns__ns1__TechnicalListResponse:
		return ((_ns1__TechnicalListResponse *)ptr)->soap_out(soap, "ns1:TechnicalListResponse", id, NULL);
	case SOAP_TYPE_ns__ns1__TechnicalList:
		return ((_ns1__TechnicalList *)ptr)->soap_out(soap, "ns1:TechnicalList", id, NULL);
	case SOAP_TYPE_ns__ns1__FundamentalListResponse:
		return ((_ns1__FundamentalListResponse *)ptr)->soap_out(soap, "ns1:FundamentalListResponse", id, NULL);
	case SOAP_TYPE_ns__ns1__FundamentalList:
		return ((_ns1__FundamentalList *)ptr)->soap_out(soap, "ns1:FundamentalList", id, NULL);
	case SOAP_TYPE_ns__ns1__NewsListBySymbolResponse:
		return ((_ns1__NewsListBySymbolResponse *)ptr)->soap_out(soap, "ns1:NewsListBySymbolResponse", id, NULL);
	case SOAP_TYPE_ns__ns1__NewsListBySymbol:
		return ((_ns1__NewsListBySymbol *)ptr)->soap_out(soap, "ns1:NewsListBySymbol", id, NULL);
	case SOAP_TYPE_ns__ns1__NewsListResponse:
		return ((_ns1__NewsListResponse *)ptr)->soap_out(soap, "ns1:NewsListResponse", id, NULL);
	case SOAP_TYPE_ns__ns1__NewsList:
		return ((_ns1__NewsList *)ptr)->soap_out(soap, "ns1:NewsList", id, NULL);
	case SOAP_TYPE_ns__ns1__QuoteListResponse:
		return ((_ns1__QuoteListResponse *)ptr)->soap_out(soap, "ns1:QuoteListResponse", id, NULL);
	case SOAP_TYPE_ns__ns1__QuoteList:
		return ((_ns1__QuoteList *)ptr)->soap_out(soap, "ns1:QuoteList", id, NULL);
	case SOAP_TYPE_ns__ns1__SymbolGetResponse:
		return ((_ns1__SymbolGetResponse *)ptr)->soap_out(soap, "ns1:SymbolGetResponse", id, NULL);
	case SOAP_TYPE_ns__ns1__SymbolGet:
		return ((_ns1__SymbolGet *)ptr)->soap_out(soap, "ns1:SymbolGet", id, NULL);
	case SOAP_TYPE_ns__ns1__QuoteList2Response:
		return ((_ns1__QuoteList2Response *)ptr)->soap_out(soap, "ns1:QuoteList2Response", id, NULL);
	case SOAP_TYPE_ns__ns1__QuoteList2:
		return ((_ns1__QuoteList2 *)ptr)->soap_out(soap, "ns1:QuoteList2", id, NULL);
	case SOAP_TYPE_ns__ns1__QuoteGetResponse:
		return ((_ns1__QuoteGetResponse *)ptr)->soap_out(soap, "ns1:QuoteGetResponse", id, NULL);
	case SOAP_TYPE_ns__ns1__QuoteGet:
		return ((_ns1__QuoteGet *)ptr)->soap_out(soap, "ns1:QuoteGet", id, NULL);
	case SOAP_TYPE_ns__ns1__SymbolList2Response:
		return ((_ns1__SymbolList2Response *)ptr)->soap_out(soap, "ns1:SymbolList2Response", id, NULL);
	case SOAP_TYPE_ns__ns1__SymbolList2:
		return ((_ns1__SymbolList2 *)ptr)->soap_out(soap, "ns1:SymbolList2", id, NULL);
	case SOAP_TYPE_ns__ns1__SymbolListResponse:
		return ((_ns1__SymbolListResponse *)ptr)->soap_out(soap, "ns1:SymbolListResponse", id, NULL);
	case SOAP_TYPE_ns__ns1__SymbolList:
		return ((_ns1__SymbolList *)ptr)->soap_out(soap, "ns1:SymbolList", id, NULL);
	case SOAP_TYPE_ns__ns1__ExchangeGetResponse:
		return ((_ns1__ExchangeGetResponse *)ptr)->soap_out(soap, "ns1:ExchangeGetResponse", id, NULL);
	case SOAP_TYPE_ns__ns1__ExchangeGet:
		return ((_ns1__ExchangeGet *)ptr)->soap_out(soap, "ns1:ExchangeGet", id, NULL);
	case SOAP_TYPE_ns__ns1__ExchangeListResponse:
		return ((_ns1__ExchangeListResponse *)ptr)->soap_out(soap, "ns1:ExchangeListResponse", id, NULL);
	case SOAP_TYPE_ns__ns1__ExchangeList:
		return ((_ns1__ExchangeList *)ptr)->soap_out(soap, "ns1:ExchangeList", id, NULL);
	case SOAP_TYPE_ns__ns1__MembershipResponse:
		return ((_ns1__MembershipResponse *)ptr)->soap_out(soap, "ns1:MembershipResponse", id, NULL);
	case SOAP_TYPE_ns__ns1__Membership:
		return ((_ns1__Membership *)ptr)->soap_out(soap, "ns1:Membership", id, NULL);
	case SOAP_TYPE_ns__ns1__Login2Response:
		return ((_ns1__Login2Response *)ptr)->soap_out(soap, "ns1:Login2Response", id, NULL);
	case SOAP_TYPE_ns__ns1__Login2:
		return ((_ns1__Login2 *)ptr)->soap_out(soap, "ns1:Login2", id, NULL);
	case SOAP_TYPE_ns__ns1__LoginResponse:
		return ((_ns1__LoginResponse *)ptr)->soap_out(soap, "ns1:LoginResponse", id, NULL);
	case SOAP_TYPE_ns__ns1__Login:
		return ((_ns1__Login *)ptr)->soap_out(soap, "ns1:Login", id, NULL);
	case SOAP_TYPE_ns_ns1__DATAFORMAT_USCORECOLUMN:
		return ((ns1__DATAFORMAT_USCORECOLUMN *)ptr)->soap_out(soap, tag, id, "ns1:DATAFORMAT_COLUMN");
	case SOAP_TYPE_ns_ns1__ArrayOfDATAFORMAT_USCORECOLUMN:
		return ((ns1__ArrayOfDATAFORMAT_USCORECOLUMN *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfDATAFORMAT_COLUMN");
	case SOAP_TYPE_ns_ns1__DATAFORMAT:
		return ((ns1__DATAFORMAT *)ptr)->soap_out(soap, tag, id, "ns1:DATAFORMAT");
	case SOAP_TYPE_ns_ns1__ArrayOfDATAFORMAT:
		return ((ns1__ArrayOfDATAFORMAT *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfDATAFORMAT");
	case SOAP_TYPE_ns_ns1__NEWS:
		return ((ns1__NEWS *)ptr)->soap_out(soap, tag, id, "ns1:NEWS");
	case SOAP_TYPE_ns_ns1__ArrayOfNEWS:
		return ((ns1__ArrayOfNEWS *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfNEWS");
	case SOAP_TYPE_ns_ns1__SYMBOLCHANGE:
		return ((ns1__SYMBOLCHANGE *)ptr)->soap_out(soap, tag, id, "ns1:SYMBOLCHANGE");
	case SOAP_TYPE_ns_ns1__ArrayOfSYMBOLCHANGE:
		return ((ns1__ArrayOfSYMBOLCHANGE *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfSYMBOLCHANGE");
	case SOAP_TYPE_ns_ns1__TECHNICAL:
		return ((ns1__TECHNICAL *)ptr)->soap_out(soap, tag, id, "ns1:TECHNICAL");
	case SOAP_TYPE_ns_ns1__ArrayOfTECHNICAL:
		return ((ns1__ArrayOfTECHNICAL *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfTECHNICAL");
	case SOAP_TYPE_ns_ns1__FUNDAMENTAL:
		return ((ns1__FUNDAMENTAL *)ptr)->soap_out(soap, tag, id, "ns1:FUNDAMENTAL");
	case SOAP_TYPE_ns_ns1__ArrayOfFUNDAMENTAL:
		return ((ns1__ArrayOfFUNDAMENTAL *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfFUNDAMENTAL");
	case SOAP_TYPE_ns_ns1__CountryBase:
		return ((ns1__CountryBase *)ptr)->soap_out(soap, tag, id, "ns1:CountryBase");
	case SOAP_TYPE_ns_ns1__ArrayOfCountryBase:
		return ((ns1__ArrayOfCountryBase *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfCountryBase");
	case SOAP_TYPE_ns_ns1__SPLIT:
		return ((ns1__SPLIT *)ptr)->soap_out(soap, tag, id, "ns1:SPLIT");
	case SOAP_TYPE_ns_ns1__ArrayOfSPLIT:
		return ((ns1__ArrayOfSPLIT *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfSPLIT");
	case SOAP_TYPE_ns_ns1__QUOTE2:
		return ((ns1__QUOTE2 *)ptr)->soap_out(soap, tag, id, "ns1:QUOTE2");
	case SOAP_TYPE_ns_ns1__ArrayOfQUOTE2:
		return ((ns1__ArrayOfQUOTE2 *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfQUOTE2");
	case SOAP_TYPE_ns_ns1__ArrayOfQUOTE:
		return ((ns1__ArrayOfQUOTE *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfQUOTE");
	case SOAP_TYPE_ns_ns1__QUOTE:
		return ((ns1__QUOTE *)ptr)->soap_out(soap, tag, id, "ns1:QUOTE");
	case SOAP_TYPE_ns_ns1__SYMBOL2:
		return ((ns1__SYMBOL2 *)ptr)->soap_out(soap, tag, id, "ns1:SYMBOL2");
	case SOAP_TYPE_ns_ns1__ArrayOfSYMBOL2:
		return ((ns1__ArrayOfSYMBOL2 *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfSYMBOL2");
	case SOAP_TYPE_ns_ns1__ArrayOfSYMBOL:
		return ((ns1__ArrayOfSYMBOL *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfSYMBOL");
	case SOAP_TYPE_ns_ns1__SYMBOL:
		return ((ns1__SYMBOL *)ptr)->soap_out(soap, tag, id, "ns1:SYMBOL");
	case SOAP_TYPE_ns_ns1__ArrayOfEXCHANGE:
		return ((ns1__ArrayOfEXCHANGE *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfEXCHANGE");
	case SOAP_TYPE_ns_ns1__EXCHANGE:
		return ((ns1__EXCHANGE *)ptr)->soap_out(soap, tag, id, "ns1:EXCHANGE");
	case SOAP_TYPE_ns_ns1__RESPONSE:
		return ((ns1__RESPONSE *)ptr)->soap_out(soap, tag, id, "ns1:RESPONSE");
	case SOAP_TYPE_ns_ns1__LOGINRESPONSE:
		return ((ns1__LOGINRESPONSE *)ptr)->soap_out(soap, tag, id, "ns1:LOGINRESPONSE");
	case SOAP_TYPE_ns_PointerTo_ns1__ValidateAccess:
		return soap_out_PointerTo_ns1__ValidateAccess(soap, tag, id, (_ns1__ValidateAccess *const*)ptr, "ns1:ValidateAccess");
	case SOAP_TYPE_ns_PointerTo_ns1__UpdateDataFormat:
		return soap_out_PointerTo_ns1__UpdateDataFormat(soap, tag, id, (_ns1__UpdateDataFormat *const*)ptr, "ns1:UpdateDataFormat");
	case SOAP_TYPE_ns_PointerTo_ns1__DataFormats:
		return soap_out_PointerTo_ns1__DataFormats(soap, tag, id, (_ns1__DataFormats *const*)ptr, "ns1:DataFormats");
	case SOAP_TYPE_ns_PointerTo_ns1__DataClientLatestVersion:
		return soap_out_PointerTo_ns1__DataClientLatestVersion(soap, tag, id, (_ns1__DataClientLatestVersion *const*)ptr, "ns1:DataClientLatestVersion");
	case SOAP_TYPE_ns_PointerTo_ns1__SymbolChangesByExchange:
		return soap_out_PointerTo_ns1__SymbolChangesByExchange(soap, tag, id, (_ns1__SymbolChangesByExchange *const*)ptr, "ns1:SymbolChangesByExchange");
	case SOAP_TYPE_ns_PointerTo_ns1__QuoteListByDatePeriod2:
		return soap_out_PointerTo_ns1__QuoteListByDatePeriod2(soap, tag, id, (_ns1__QuoteListByDatePeriod2 *const*)ptr, "ns1:QuoteListByDatePeriod2");
	case SOAP_TYPE_ns_PointerTo_ns1__QuoteListByDatePeriod:
		return soap_out_PointerTo_ns1__QuoteListByDatePeriod(soap, tag, id, (_ns1__QuoteListByDatePeriod *const*)ptr, "ns1:QuoteListByDatePeriod");
	case SOAP_TYPE_ns_PointerTo_ns1__SymbolHistoryPeriodByDateRange:
		return soap_out_PointerTo_ns1__SymbolHistoryPeriodByDateRange(soap, tag, id, (_ns1__SymbolHistoryPeriodByDateRange *const*)ptr, "ns1:SymbolHistoryPeriodByDateRange");
	case SOAP_TYPE_ns_PointerTo_ns1__SymbolHistoryPeriod:
		return soap_out_PointerTo_ns1__SymbolHistoryPeriod(soap, tag, id, (_ns1__SymbolHistoryPeriod *const*)ptr, "ns1:SymbolHistoryPeriod");
	case SOAP_TYPE_ns_PointerTo_ns1__CountryList:
		return soap_out_PointerTo_ns1__CountryList(soap, tag, id, (_ns1__CountryList *const*)ptr, "ns1:CountryList");
	case SOAP_TYPE_ns_PointerTo_ns1__SplitListBySymbol:
		return soap_out_PointerTo_ns1__SplitListBySymbol(soap, tag, id, (_ns1__SplitListBySymbol *const*)ptr, "ns1:SplitListBySymbol");
	case SOAP_TYPE_ns_PointerTo_ns1__SplitListByExchange:
		return soap_out_PointerTo_ns1__SplitListByExchange(soap, tag, id, (_ns1__SplitListByExchange *const*)ptr, "ns1:SplitListByExchange");
	case SOAP_TYPE_ns_PointerTo_ns1__ExchangeMonths:
		return soap_out_PointerTo_ns1__ExchangeMonths(soap, tag, id, (_ns1__ExchangeMonths *const*)ptr, "ns1:ExchangeMonths");
	case SOAP_TYPE_ns_PointerTo_ns1__SymbolChart:
		return soap_out_PointerTo_ns1__SymbolChart(soap, tag, id, (_ns1__SymbolChart *const*)ptr, "ns1:SymbolChart");
	case SOAP_TYPE_ns_PointerTo_ns1__Top10Losses:
		return soap_out_PointerTo_ns1__Top10Losses(soap, tag, id, (_ns1__Top10Losses *const*)ptr, "ns1:Top10Losses");
	case SOAP_TYPE_ns_PointerTo_ns1__Top10Gains:
		return soap_out_PointerTo_ns1__Top10Gains(soap, tag, id, (_ns1__Top10Gains *const*)ptr, "ns1:Top10Gains");
	case SOAP_TYPE_ns_PointerTo_ns1__SymbolHistory:
		return soap_out_PointerTo_ns1__SymbolHistory(soap, tag, id, (_ns1__SymbolHistory *const*)ptr, "ns1:SymbolHistory");
	case SOAP_TYPE_ns_PointerTo_ns1__QuoteListByDate2:
		return soap_out_PointerTo_ns1__QuoteListByDate2(soap, tag, id, (_ns1__QuoteListByDate2 *const*)ptr, "ns1:QuoteListByDate2");
	case SOAP_TYPE_ns_PointerTo_ns1__QuoteListByDate:
		return soap_out_PointerTo_ns1__QuoteListByDate(soap, tag, id, (_ns1__QuoteListByDate *const*)ptr, "ns1:QuoteListByDate");
	case SOAP_TYPE_ns_PointerTo_ns1__TechnicalList:
		return soap_out_PointerTo_ns1__TechnicalList(soap, tag, id, (_ns1__TechnicalList *const*)ptr, "ns1:TechnicalList");
	case SOAP_TYPE_ns_PointerTo_ns1__FundamentalList:
		return soap_out_PointerTo_ns1__FundamentalList(soap, tag, id, (_ns1__FundamentalList *const*)ptr, "ns1:FundamentalList");
	case SOAP_TYPE_ns_PointerTo_ns1__NewsListBySymbol:
		return soap_out_PointerTo_ns1__NewsListBySymbol(soap, tag, id, (_ns1__NewsListBySymbol *const*)ptr, "ns1:NewsListBySymbol");
	case SOAP_TYPE_ns_PointerTo_ns1__NewsList:
		return soap_out_PointerTo_ns1__NewsList(soap, tag, id, (_ns1__NewsList *const*)ptr, "ns1:NewsList");
	case SOAP_TYPE_ns_PointerTo_ns1__QuoteList:
		return soap_out_PointerTo_ns1__QuoteList(soap, tag, id, (_ns1__QuoteList *const*)ptr, "ns1:QuoteList");
	case SOAP_TYPE_ns_PointerTo_ns1__SymbolGet:
		return soap_out_PointerTo_ns1__SymbolGet(soap, tag, id, (_ns1__SymbolGet *const*)ptr, "ns1:SymbolGet");
	case SOAP_TYPE_ns_PointerTo_ns1__QuoteList2:
		return soap_out_PointerTo_ns1__QuoteList2(soap, tag, id, (_ns1__QuoteList2 *const*)ptr, "ns1:QuoteList2");
	case SOAP_TYPE_ns_PointerTo_ns1__QuoteGet:
		return soap_out_PointerTo_ns1__QuoteGet(soap, tag, id, (_ns1__QuoteGet *const*)ptr, "ns1:QuoteGet");
	case SOAP_TYPE_ns_PointerTo_ns1__SymbolList2:
		return soap_out_PointerTo_ns1__SymbolList2(soap, tag, id, (_ns1__SymbolList2 *const*)ptr, "ns1:SymbolList2");
	case SOAP_TYPE_ns_PointerTo_ns1__SymbolList:
		return soap_out_PointerTo_ns1__SymbolList(soap, tag, id, (_ns1__SymbolList *const*)ptr, "ns1:SymbolList");
	case SOAP_TYPE_ns_PointerTo_ns1__ExchangeGet:
		return soap_out_PointerTo_ns1__ExchangeGet(soap, tag, id, (_ns1__ExchangeGet *const*)ptr, "ns1:ExchangeGet");
	case SOAP_TYPE_ns_PointerTo_ns1__ExchangeList:
		return soap_out_PointerTo_ns1__ExchangeList(soap, tag, id, (_ns1__ExchangeList *const*)ptr, "ns1:ExchangeList");
	case SOAP_TYPE_ns_PointerTo_ns1__Membership:
		return soap_out_PointerTo_ns1__Membership(soap, tag, id, (_ns1__Membership *const*)ptr, "ns1:Membership");
	case SOAP_TYPE_ns_PointerTo_ns1__Login2:
		return soap_out_PointerTo_ns1__Login2(soap, tag, id, (_ns1__Login2 *const*)ptr, "ns1:Login2");
	case SOAP_TYPE_ns_PointerTo_ns1__Login:
		return soap_out_PointerTo_ns1__Login(soap, tag, id, (_ns1__Login *const*)ptr, "ns1:Login");
	case SOAP_TYPE_ns_PointerTons1__RESPONSE:
		return soap_out_PointerTons1__RESPONSE(soap, tag, id, (ns1__RESPONSE *const*)ptr, "ns1:RESPONSE");
	case SOAP_TYPE_ns_PointerTons1__LOGINRESPONSE:
		return soap_out_PointerTons1__LOGINRESPONSE(soap, tag, id, (ns1__LOGINRESPONSE *const*)ptr, "ns1:LOGINRESPONSE");
	case SOAP_TYPE_ns_PointerTons1__DATAFORMAT_USCORECOLUMN:
		return soap_out_PointerTons1__DATAFORMAT_USCORECOLUMN(soap, tag, id, (ns1__DATAFORMAT_USCORECOLUMN *const*)ptr, "ns1:DATAFORMAT_COLUMN");
	case SOAP_TYPE_ns_PointerTons1__ArrayOfDATAFORMAT_USCORECOLUMN:
		return soap_out_PointerTons1__ArrayOfDATAFORMAT_USCORECOLUMN(soap, tag, id, (ns1__ArrayOfDATAFORMAT_USCORECOLUMN *const*)ptr, "ns1:ArrayOfDATAFORMAT_COLUMN");
	case SOAP_TYPE_ns_PointerTons1__DATAFORMAT:
		return soap_out_PointerTons1__DATAFORMAT(soap, tag, id, (ns1__DATAFORMAT *const*)ptr, "ns1:DATAFORMAT");
	case SOAP_TYPE_ns_PointerTons1__NEWS:
		return soap_out_PointerTons1__NEWS(soap, tag, id, (ns1__NEWS *const*)ptr, "ns1:NEWS");
	case SOAP_TYPE_ns_PointerTons1__SYMBOLCHANGE:
		return soap_out_PointerTons1__SYMBOLCHANGE(soap, tag, id, (ns1__SYMBOLCHANGE *const*)ptr, "ns1:SYMBOLCHANGE");
	case SOAP_TYPE_ns_PointerTons1__TECHNICAL:
		return soap_out_PointerTons1__TECHNICAL(soap, tag, id, (ns1__TECHNICAL *const*)ptr, "ns1:TECHNICAL");
	case SOAP_TYPE_ns_PointerTons1__FUNDAMENTAL:
		return soap_out_PointerTons1__FUNDAMENTAL(soap, tag, id, (ns1__FUNDAMENTAL *const*)ptr, "ns1:FUNDAMENTAL");
	case SOAP_TYPE_ns_PointerTons1__CountryBase:
		return soap_out_PointerTons1__CountryBase(soap, tag, id, (ns1__CountryBase *const*)ptr, "ns1:CountryBase");
	case SOAP_TYPE_ns_PointerTons1__SPLIT:
		return soap_out_PointerTons1__SPLIT(soap, tag, id, (ns1__SPLIT *const*)ptr, "ns1:SPLIT");
	case SOAP_TYPE_ns_PointerTons1__QUOTE2:
		return soap_out_PointerTons1__QUOTE2(soap, tag, id, (ns1__QUOTE2 *const*)ptr, "ns1:QUOTE2");
	case SOAP_TYPE_ns_PointerTons1__SYMBOL2:
		return soap_out_PointerTons1__SYMBOL2(soap, tag, id, (ns1__SYMBOL2 *const*)ptr, "ns1:SYMBOL2");
	case SOAP_TYPE_ns_PointerTons1__ArrayOfDATAFORMAT:
		return soap_out_PointerTons1__ArrayOfDATAFORMAT(soap, tag, id, (ns1__ArrayOfDATAFORMAT *const*)ptr, "ns1:ArrayOfDATAFORMAT");
	case SOAP_TYPE_ns_PointerTons1__ArrayOfNEWS:
		return soap_out_PointerTons1__ArrayOfNEWS(soap, tag, id, (ns1__ArrayOfNEWS *const*)ptr, "ns1:ArrayOfNEWS");
	case SOAP_TYPE_ns_PointerTons1__ArrayOfSYMBOLCHANGE:
		return soap_out_PointerTons1__ArrayOfSYMBOLCHANGE(soap, tag, id, (ns1__ArrayOfSYMBOLCHANGE *const*)ptr, "ns1:ArrayOfSYMBOLCHANGE");
	case SOAP_TYPE_ns_PointerTons1__ArrayOfTECHNICAL:
		return soap_out_PointerTons1__ArrayOfTECHNICAL(soap, tag, id, (ns1__ArrayOfTECHNICAL *const*)ptr, "ns1:ArrayOfTECHNICAL");
	case SOAP_TYPE_ns_PointerTons1__ArrayOfFUNDAMENTAL:
		return soap_out_PointerTons1__ArrayOfFUNDAMENTAL(soap, tag, id, (ns1__ArrayOfFUNDAMENTAL *const*)ptr, "ns1:ArrayOfFUNDAMENTAL");
	case SOAP_TYPE_ns_PointerTons1__ArrayOfCountryBase:
		return soap_out_PointerTons1__ArrayOfCountryBase(soap, tag, id, (ns1__ArrayOfCountryBase *const*)ptr, "ns1:ArrayOfCountryBase");
	case SOAP_TYPE_ns_PointerTons1__ArrayOfSPLIT:
		return soap_out_PointerTons1__ArrayOfSPLIT(soap, tag, id, (ns1__ArrayOfSPLIT *const*)ptr, "ns1:ArrayOfSPLIT");
	case SOAP_TYPE_ns_PointerTons1__ArrayOfQUOTE2:
		return soap_out_PointerTons1__ArrayOfQUOTE2(soap, tag, id, (ns1__ArrayOfQUOTE2 *const*)ptr, "ns1:ArrayOfQUOTE2");
	case SOAP_TYPE_ns_PointerTons1__ArrayOfQUOTE:
		return soap_out_PointerTons1__ArrayOfQUOTE(soap, tag, id, (ns1__ArrayOfQUOTE *const*)ptr, "ns1:ArrayOfQUOTE");
	case SOAP_TYPE_ns_PointerTons1__QUOTE:
		return soap_out_PointerTons1__QUOTE(soap, tag, id, (ns1__QUOTE *const*)ptr, "ns1:QUOTE");
	case SOAP_TYPE_ns_PointerTons1__ArrayOfSYMBOL2:
		return soap_out_PointerTons1__ArrayOfSYMBOL2(soap, tag, id, (ns1__ArrayOfSYMBOL2 *const*)ptr, "ns1:ArrayOfSYMBOL2");
	case SOAP_TYPE_ns_PointerTons1__ArrayOfSYMBOL:
		return soap_out_PointerTons1__ArrayOfSYMBOL(soap, tag, id, (ns1__ArrayOfSYMBOL *const*)ptr, "ns1:ArrayOfSYMBOL");
	case SOAP_TYPE_ns_PointerTons1__SYMBOL:
		return soap_out_PointerTons1__SYMBOL(soap, tag, id, (ns1__SYMBOL *const*)ptr, "ns1:SYMBOL");
	case SOAP_TYPE_ns_PointerTons1__ArrayOfEXCHANGE:
		return soap_out_PointerTons1__ArrayOfEXCHANGE(soap, tag, id, (ns1__ArrayOfEXCHANGE *const*)ptr, "ns1:ArrayOfEXCHANGE");
	case SOAP_TYPE_ns_PointerTons1__EXCHANGE:
		return soap_out_PointerTons1__EXCHANGE(soap, tag, id, (ns1__EXCHANGE *const*)ptr, "ns1:EXCHANGE");
	case SOAP_TYPE_ns_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE_ns__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_ns_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_ns_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns__ns1__ValidateAccessResponse:
		((_ns1__ValidateAccessResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__ValidateAccess:
		((_ns1__ValidateAccess *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__UpdateDataFormatResponse:
		((_ns1__UpdateDataFormatResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__UpdateDataFormat:
		((_ns1__UpdateDataFormat *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__DataFormatsResponse:
		((_ns1__DataFormatsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__DataFormats:
		((_ns1__DataFormats *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__DataClientLatestVersionResponse:
		((_ns1__DataClientLatestVersionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__DataClientLatestVersion:
		((_ns1__DataClientLatestVersion *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__SymbolChangesByExchangeResponse:
		((_ns1__SymbolChangesByExchangeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__SymbolChangesByExchange:
		((_ns1__SymbolChangesByExchange *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__QuoteListByDatePeriod2Response:
		((_ns1__QuoteListByDatePeriod2Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__QuoteListByDatePeriod2:
		((_ns1__QuoteListByDatePeriod2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__QuoteListByDatePeriodResponse:
		((_ns1__QuoteListByDatePeriodResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__QuoteListByDatePeriod:
		((_ns1__QuoteListByDatePeriod *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__SymbolHistoryPeriodByDateRangeResponse:
		((_ns1__SymbolHistoryPeriodByDateRangeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__SymbolHistoryPeriodByDateRange:
		((_ns1__SymbolHistoryPeriodByDateRange *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__SymbolHistoryPeriodResponse:
		((_ns1__SymbolHistoryPeriodResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__SymbolHistoryPeriod:
		((_ns1__SymbolHistoryPeriod *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__CountryListResponse:
		((_ns1__CountryListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__CountryList:
		((_ns1__CountryList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__SplitListBySymbolResponse:
		((_ns1__SplitListBySymbolResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__SplitListBySymbol:
		((_ns1__SplitListBySymbol *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__SplitListByExchangeResponse:
		((_ns1__SplitListByExchangeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__SplitListByExchange:
		((_ns1__SplitListByExchange *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__ExchangeMonthsResponse:
		((_ns1__ExchangeMonthsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__ExchangeMonths:
		((_ns1__ExchangeMonths *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__SymbolChartResponse:
		((_ns1__SymbolChartResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__SymbolChart:
		((_ns1__SymbolChart *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__Top10LossesResponse:
		((_ns1__Top10LossesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__Top10Losses:
		((_ns1__Top10Losses *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__Top10GainsResponse:
		((_ns1__Top10GainsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__Top10Gains:
		((_ns1__Top10Gains *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__SymbolHistoryResponse:
		((_ns1__SymbolHistoryResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__SymbolHistory:
		((_ns1__SymbolHistory *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__QuoteListByDate2Response:
		((_ns1__QuoteListByDate2Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__QuoteListByDate2:
		((_ns1__QuoteListByDate2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__QuoteListByDateResponse:
		((_ns1__QuoteListByDateResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__QuoteListByDate:
		((_ns1__QuoteListByDate *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__TechnicalListResponse:
		((_ns1__TechnicalListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__TechnicalList:
		((_ns1__TechnicalList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__FundamentalListResponse:
		((_ns1__FundamentalListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__FundamentalList:
		((_ns1__FundamentalList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__NewsListBySymbolResponse:
		((_ns1__NewsListBySymbolResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__NewsListBySymbol:
		((_ns1__NewsListBySymbol *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__NewsListResponse:
		((_ns1__NewsListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__NewsList:
		((_ns1__NewsList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__QuoteListResponse:
		((_ns1__QuoteListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__QuoteList:
		((_ns1__QuoteList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__SymbolGetResponse:
		((_ns1__SymbolGetResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__SymbolGet:
		((_ns1__SymbolGet *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__QuoteList2Response:
		((_ns1__QuoteList2Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__QuoteList2:
		((_ns1__QuoteList2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__QuoteGetResponse:
		((_ns1__QuoteGetResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__QuoteGet:
		((_ns1__QuoteGet *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__SymbolList2Response:
		((_ns1__SymbolList2Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__SymbolList2:
		((_ns1__SymbolList2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__SymbolListResponse:
		((_ns1__SymbolListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__SymbolList:
		((_ns1__SymbolList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__ExchangeGetResponse:
		((_ns1__ExchangeGetResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__ExchangeGet:
		((_ns1__ExchangeGet *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__ExchangeListResponse:
		((_ns1__ExchangeListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__ExchangeList:
		((_ns1__ExchangeList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__MembershipResponse:
		((_ns1__MembershipResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__Membership:
		((_ns1__Membership *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__Login2Response:
		((_ns1__Login2Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__Login2:
		((_ns1__Login2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__LoginResponse:
		((_ns1__LoginResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ns1__Login:
		((_ns1__Login *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns_ns1__DATAFORMAT_USCORECOLUMN:
		((ns1__DATAFORMAT_USCORECOLUMN *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns_ns1__ArrayOfDATAFORMAT_USCORECOLUMN:
		((ns1__ArrayOfDATAFORMAT_USCORECOLUMN *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns_ns1__DATAFORMAT:
		((ns1__DATAFORMAT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns_ns1__ArrayOfDATAFORMAT:
		((ns1__ArrayOfDATAFORMAT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns_ns1__NEWS:
		((ns1__NEWS *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns_ns1__ArrayOfNEWS:
		((ns1__ArrayOfNEWS *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns_ns1__SYMBOLCHANGE:
		((ns1__SYMBOLCHANGE *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns_ns1__ArrayOfSYMBOLCHANGE:
		((ns1__ArrayOfSYMBOLCHANGE *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns_ns1__TECHNICAL:
		((ns1__TECHNICAL *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns_ns1__ArrayOfTECHNICAL:
		((ns1__ArrayOfTECHNICAL *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns_ns1__FUNDAMENTAL:
		((ns1__FUNDAMENTAL *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns_ns1__ArrayOfFUNDAMENTAL:
		((ns1__ArrayOfFUNDAMENTAL *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns_ns1__CountryBase:
		((ns1__CountryBase *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns_ns1__ArrayOfCountryBase:
		((ns1__ArrayOfCountryBase *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns_ns1__SPLIT:
		((ns1__SPLIT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns_ns1__ArrayOfSPLIT:
		((ns1__ArrayOfSPLIT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns_ns1__QUOTE2:
		((ns1__QUOTE2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns_ns1__ArrayOfQUOTE2:
		((ns1__ArrayOfQUOTE2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns_ns1__ArrayOfQUOTE:
		((ns1__ArrayOfQUOTE *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns_ns1__QUOTE:
		((ns1__QUOTE *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns_ns1__SYMBOL2:
		((ns1__SYMBOL2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns_ns1__ArrayOfSYMBOL2:
		((ns1__ArrayOfSYMBOL2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns_ns1__ArrayOfSYMBOL:
		((ns1__ArrayOfSYMBOL *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns_ns1__SYMBOL:
		((ns1__SYMBOL *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns_ns1__ArrayOfEXCHANGE:
		((ns1__ArrayOfEXCHANGE *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns_ns1__EXCHANGE:
		((ns1__EXCHANGE *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns_ns1__RESPONSE:
		((ns1__RESPONSE *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns_ns1__LOGINRESPONSE:
		((ns1__LOGINRESPONSE *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns___ns1__ValidateAccess___:
		soap_serialize___ns1__ValidateAccess___(soap, (const struct __ns1__ValidateAccess___ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__UpdateDataFormat___:
		soap_serialize___ns1__UpdateDataFormat___(soap, (const struct __ns1__UpdateDataFormat___ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__DataFormats___:
		soap_serialize___ns1__DataFormats___(soap, (const struct __ns1__DataFormats___ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__DataClientLatestVersion___:
		soap_serialize___ns1__DataClientLatestVersion___(soap, (const struct __ns1__DataClientLatestVersion___ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__SymbolChangesByExchange___:
		soap_serialize___ns1__SymbolChangesByExchange___(soap, (const struct __ns1__SymbolChangesByExchange___ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__QuoteListByDatePeriod2___:
		soap_serialize___ns1__QuoteListByDatePeriod2___(soap, (const struct __ns1__QuoteListByDatePeriod2___ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__QuoteListByDatePeriod___:
		soap_serialize___ns1__QuoteListByDatePeriod___(soap, (const struct __ns1__QuoteListByDatePeriod___ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__SymbolHistoryPeriodByDateRange___:
		soap_serialize___ns1__SymbolHistoryPeriodByDateRange___(soap, (const struct __ns1__SymbolHistoryPeriodByDateRange___ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__SymbolHistoryPeriod___:
		soap_serialize___ns1__SymbolHistoryPeriod___(soap, (const struct __ns1__SymbolHistoryPeriod___ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__CountryList___:
		soap_serialize___ns1__CountryList___(soap, (const struct __ns1__CountryList___ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__SplitListBySymbol___:
		soap_serialize___ns1__SplitListBySymbol___(soap, (const struct __ns1__SplitListBySymbol___ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__SplitListByExchange___:
		soap_serialize___ns1__SplitListByExchange___(soap, (const struct __ns1__SplitListByExchange___ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__ExchangeMonths___:
		soap_serialize___ns1__ExchangeMonths___(soap, (const struct __ns1__ExchangeMonths___ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__SymbolChart___:
		soap_serialize___ns1__SymbolChart___(soap, (const struct __ns1__SymbolChart___ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__Top10Losses___:
		soap_serialize___ns1__Top10Losses___(soap, (const struct __ns1__Top10Losses___ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__Top10Gains___:
		soap_serialize___ns1__Top10Gains___(soap, (const struct __ns1__Top10Gains___ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__SymbolHistory___:
		soap_serialize___ns1__SymbolHistory___(soap, (const struct __ns1__SymbolHistory___ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__QuoteListByDate2___:
		soap_serialize___ns1__QuoteListByDate2___(soap, (const struct __ns1__QuoteListByDate2___ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__QuoteListByDate___:
		soap_serialize___ns1__QuoteListByDate___(soap, (const struct __ns1__QuoteListByDate___ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__TechnicalList___:
		soap_serialize___ns1__TechnicalList___(soap, (const struct __ns1__TechnicalList___ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__FundamentalList___:
		soap_serialize___ns1__FundamentalList___(soap, (const struct __ns1__FundamentalList___ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__NewsListBySymbol___:
		soap_serialize___ns1__NewsListBySymbol___(soap, (const struct __ns1__NewsListBySymbol___ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__NewsList___:
		soap_serialize___ns1__NewsList___(soap, (const struct __ns1__NewsList___ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__QuoteList___:
		soap_serialize___ns1__QuoteList___(soap, (const struct __ns1__QuoteList___ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__SymbolGet___:
		soap_serialize___ns1__SymbolGet___(soap, (const struct __ns1__SymbolGet___ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__QuoteList2___:
		soap_serialize___ns1__QuoteList2___(soap, (const struct __ns1__QuoteList2___ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__QuoteGet___:
		soap_serialize___ns1__QuoteGet___(soap, (const struct __ns1__QuoteGet___ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__SymbolList2___:
		soap_serialize___ns1__SymbolList2___(soap, (const struct __ns1__SymbolList2___ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__SymbolList___:
		soap_serialize___ns1__SymbolList___(soap, (const struct __ns1__SymbolList___ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__ExchangeGet___:
		soap_serialize___ns1__ExchangeGet___(soap, (const struct __ns1__ExchangeGet___ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__ExchangeList___:
		soap_serialize___ns1__ExchangeList___(soap, (const struct __ns1__ExchangeList___ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__Membership___:
		soap_serialize___ns1__Membership___(soap, (const struct __ns1__Membership___ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__Login2___:
		soap_serialize___ns1__Login2___(soap, (const struct __ns1__Login2___ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__Login___:
		soap_serialize___ns1__Login___(soap, (const struct __ns1__Login___ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__ValidateAccessResponse__:
		soap_serialize___ns1__ValidateAccessResponse__(soap, (const struct __ns1__ValidateAccessResponse__ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__UpdateDataFormatResponse__:
		soap_serialize___ns1__UpdateDataFormatResponse__(soap, (const struct __ns1__UpdateDataFormatResponse__ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__DataFormatsResponse__:
		soap_serialize___ns1__DataFormatsResponse__(soap, (const struct __ns1__DataFormatsResponse__ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__DataClientLatestVersionResponse__:
		soap_serialize___ns1__DataClientLatestVersionResponse__(soap, (const struct __ns1__DataClientLatestVersionResponse__ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__SymbolChangesByExchangeResponse__:
		soap_serialize___ns1__SymbolChangesByExchangeResponse__(soap, (const struct __ns1__SymbolChangesByExchangeResponse__ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__QuoteListByDatePeriod2Response__:
		soap_serialize___ns1__QuoteListByDatePeriod2Response__(soap, (const struct __ns1__QuoteListByDatePeriod2Response__ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__QuoteListByDatePeriodResponse__:
		soap_serialize___ns1__QuoteListByDatePeriodResponse__(soap, (const struct __ns1__QuoteListByDatePeriodResponse__ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__SymbolHistoryPeriodByDateRangeResponse__:
		soap_serialize___ns1__SymbolHistoryPeriodByDateRangeResponse__(soap, (const struct __ns1__SymbolHistoryPeriodByDateRangeResponse__ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__SymbolHistoryPeriodResponse__:
		soap_serialize___ns1__SymbolHistoryPeriodResponse__(soap, (const struct __ns1__SymbolHistoryPeriodResponse__ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__CountryListResponse__:
		soap_serialize___ns1__CountryListResponse__(soap, (const struct __ns1__CountryListResponse__ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__SplitListBySymbolResponse__:
		soap_serialize___ns1__SplitListBySymbolResponse__(soap, (const struct __ns1__SplitListBySymbolResponse__ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__SplitListByExchangeResponse__:
		soap_serialize___ns1__SplitListByExchangeResponse__(soap, (const struct __ns1__SplitListByExchangeResponse__ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__ExchangeMonthsResponse__:
		soap_serialize___ns1__ExchangeMonthsResponse__(soap, (const struct __ns1__ExchangeMonthsResponse__ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__SymbolChartResponse__:
		soap_serialize___ns1__SymbolChartResponse__(soap, (const struct __ns1__SymbolChartResponse__ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__Top10LossesResponse__:
		soap_serialize___ns1__Top10LossesResponse__(soap, (const struct __ns1__Top10LossesResponse__ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__Top10GainsResponse__:
		soap_serialize___ns1__Top10GainsResponse__(soap, (const struct __ns1__Top10GainsResponse__ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__SymbolHistoryResponse__:
		soap_serialize___ns1__SymbolHistoryResponse__(soap, (const struct __ns1__SymbolHistoryResponse__ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__QuoteListByDate2Response__:
		soap_serialize___ns1__QuoteListByDate2Response__(soap, (const struct __ns1__QuoteListByDate2Response__ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__QuoteListByDateResponse__:
		soap_serialize___ns1__QuoteListByDateResponse__(soap, (const struct __ns1__QuoteListByDateResponse__ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__TechnicalListResponse__:
		soap_serialize___ns1__TechnicalListResponse__(soap, (const struct __ns1__TechnicalListResponse__ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__FundamentalListResponse__:
		soap_serialize___ns1__FundamentalListResponse__(soap, (const struct __ns1__FundamentalListResponse__ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__NewsListBySymbolResponse__:
		soap_serialize___ns1__NewsListBySymbolResponse__(soap, (const struct __ns1__NewsListBySymbolResponse__ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__NewsListResponse__:
		soap_serialize___ns1__NewsListResponse__(soap, (const struct __ns1__NewsListResponse__ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__QuoteListResponse__:
		soap_serialize___ns1__QuoteListResponse__(soap, (const struct __ns1__QuoteListResponse__ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__SymbolGetResponse__:
		soap_serialize___ns1__SymbolGetResponse__(soap, (const struct __ns1__SymbolGetResponse__ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__QuoteList2Response__:
		soap_serialize___ns1__QuoteList2Response__(soap, (const struct __ns1__QuoteList2Response__ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__QuoteGetResponse__:
		soap_serialize___ns1__QuoteGetResponse__(soap, (const struct __ns1__QuoteGetResponse__ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__SymbolList2Response__:
		soap_serialize___ns1__SymbolList2Response__(soap, (const struct __ns1__SymbolList2Response__ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__SymbolListResponse__:
		soap_serialize___ns1__SymbolListResponse__(soap, (const struct __ns1__SymbolListResponse__ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__ExchangeGetResponse__:
		soap_serialize___ns1__ExchangeGetResponse__(soap, (const struct __ns1__ExchangeGetResponse__ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__ExchangeListResponse__:
		soap_serialize___ns1__ExchangeListResponse__(soap, (const struct __ns1__ExchangeListResponse__ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__MembershipResponse__:
		soap_serialize___ns1__MembershipResponse__(soap, (const struct __ns1__MembershipResponse__ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__Login2Response__:
		soap_serialize___ns1__Login2Response__(soap, (const struct __ns1__Login2Response__ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__LoginResponse__:
		soap_serialize___ns1__LoginResponse__(soap, (const struct __ns1__LoginResponse__ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__ValidateAccess_:
		soap_serialize___ns1__ValidateAccess_(soap, (const struct __ns1__ValidateAccess_ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__UpdateDataFormat_:
		soap_serialize___ns1__UpdateDataFormat_(soap, (const struct __ns1__UpdateDataFormat_ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__DataFormats_:
		soap_serialize___ns1__DataFormats_(soap, (const struct __ns1__DataFormats_ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__DataClientLatestVersion_:
		soap_serialize___ns1__DataClientLatestVersion_(soap, (const struct __ns1__DataClientLatestVersion_ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__SymbolChangesByExchange_:
		soap_serialize___ns1__SymbolChangesByExchange_(soap, (const struct __ns1__SymbolChangesByExchange_ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__QuoteListByDatePeriod2_:
		soap_serialize___ns1__QuoteListByDatePeriod2_(soap, (const struct __ns1__QuoteListByDatePeriod2_ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__QuoteListByDatePeriod_:
		soap_serialize___ns1__QuoteListByDatePeriod_(soap, (const struct __ns1__QuoteListByDatePeriod_ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__SymbolHistoryPeriodByDateRange_:
		soap_serialize___ns1__SymbolHistoryPeriodByDateRange_(soap, (const struct __ns1__SymbolHistoryPeriodByDateRange_ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__SymbolHistoryPeriod_:
		soap_serialize___ns1__SymbolHistoryPeriod_(soap, (const struct __ns1__SymbolHistoryPeriod_ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__CountryList_:
		soap_serialize___ns1__CountryList_(soap, (const struct __ns1__CountryList_ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__SplitListBySymbol_:
		soap_serialize___ns1__SplitListBySymbol_(soap, (const struct __ns1__SplitListBySymbol_ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__SplitListByExchange_:
		soap_serialize___ns1__SplitListByExchange_(soap, (const struct __ns1__SplitListByExchange_ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__ExchangeMonths_:
		soap_serialize___ns1__ExchangeMonths_(soap, (const struct __ns1__ExchangeMonths_ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__SymbolChart_:
		soap_serialize___ns1__SymbolChart_(soap, (const struct __ns1__SymbolChart_ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__Top10Losses_:
		soap_serialize___ns1__Top10Losses_(soap, (const struct __ns1__Top10Losses_ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__Top10Gains_:
		soap_serialize___ns1__Top10Gains_(soap, (const struct __ns1__Top10Gains_ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__SymbolHistory_:
		soap_serialize___ns1__SymbolHistory_(soap, (const struct __ns1__SymbolHistory_ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__QuoteListByDate2_:
		soap_serialize___ns1__QuoteListByDate2_(soap, (const struct __ns1__QuoteListByDate2_ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__QuoteListByDate_:
		soap_serialize___ns1__QuoteListByDate_(soap, (const struct __ns1__QuoteListByDate_ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__TechnicalList_:
		soap_serialize___ns1__TechnicalList_(soap, (const struct __ns1__TechnicalList_ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__FundamentalList_:
		soap_serialize___ns1__FundamentalList_(soap, (const struct __ns1__FundamentalList_ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__NewsListBySymbol_:
		soap_serialize___ns1__NewsListBySymbol_(soap, (const struct __ns1__NewsListBySymbol_ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__NewsList_:
		soap_serialize___ns1__NewsList_(soap, (const struct __ns1__NewsList_ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__QuoteList_:
		soap_serialize___ns1__QuoteList_(soap, (const struct __ns1__QuoteList_ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__SymbolGet_:
		soap_serialize___ns1__SymbolGet_(soap, (const struct __ns1__SymbolGet_ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__QuoteList2_:
		soap_serialize___ns1__QuoteList2_(soap, (const struct __ns1__QuoteList2_ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__QuoteGet_:
		soap_serialize___ns1__QuoteGet_(soap, (const struct __ns1__QuoteGet_ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__SymbolList2_:
		soap_serialize___ns1__SymbolList2_(soap, (const struct __ns1__SymbolList2_ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__SymbolList_:
		soap_serialize___ns1__SymbolList_(soap, (const struct __ns1__SymbolList_ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__ExchangeGet_:
		soap_serialize___ns1__ExchangeGet_(soap, (const struct __ns1__ExchangeGet_ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__ExchangeList_:
		soap_serialize___ns1__ExchangeList_(soap, (const struct __ns1__ExchangeList_ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__Membership_:
		soap_serialize___ns1__Membership_(soap, (const struct __ns1__Membership_ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__Login2_:
		soap_serialize___ns1__Login2_(soap, (const struct __ns1__Login2_ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__Login_:
		soap_serialize___ns1__Login_(soap, (const struct __ns1__Login_ *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__ValidateAccess:
		soap_serialize___ns1__ValidateAccess(soap, (const struct __ns1__ValidateAccess *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__UpdateDataFormat:
		soap_serialize___ns1__UpdateDataFormat(soap, (const struct __ns1__UpdateDataFormat *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__DataFormats:
		soap_serialize___ns1__DataFormats(soap, (const struct __ns1__DataFormats *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__DataClientLatestVersion:
		soap_serialize___ns1__DataClientLatestVersion(soap, (const struct __ns1__DataClientLatestVersion *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__SymbolChangesByExchange:
		soap_serialize___ns1__SymbolChangesByExchange(soap, (const struct __ns1__SymbolChangesByExchange *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__QuoteListByDatePeriod2:
		soap_serialize___ns1__QuoteListByDatePeriod2(soap, (const struct __ns1__QuoteListByDatePeriod2 *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__QuoteListByDatePeriod:
		soap_serialize___ns1__QuoteListByDatePeriod(soap, (const struct __ns1__QuoteListByDatePeriod *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__SymbolHistoryPeriodByDateRange:
		soap_serialize___ns1__SymbolHistoryPeriodByDateRange(soap, (const struct __ns1__SymbolHistoryPeriodByDateRange *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__SymbolHistoryPeriod:
		soap_serialize___ns1__SymbolHistoryPeriod(soap, (const struct __ns1__SymbolHistoryPeriod *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__CountryList:
		soap_serialize___ns1__CountryList(soap, (const struct __ns1__CountryList *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__SplitListBySymbol:
		soap_serialize___ns1__SplitListBySymbol(soap, (const struct __ns1__SplitListBySymbol *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__SplitListByExchange:
		soap_serialize___ns1__SplitListByExchange(soap, (const struct __ns1__SplitListByExchange *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__ExchangeMonths:
		soap_serialize___ns1__ExchangeMonths(soap, (const struct __ns1__ExchangeMonths *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__SymbolChart:
		soap_serialize___ns1__SymbolChart(soap, (const struct __ns1__SymbolChart *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__Top10Losses:
		soap_serialize___ns1__Top10Losses(soap, (const struct __ns1__Top10Losses *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__Top10Gains:
		soap_serialize___ns1__Top10Gains(soap, (const struct __ns1__Top10Gains *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__SymbolHistory:
		soap_serialize___ns1__SymbolHistory(soap, (const struct __ns1__SymbolHistory *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__QuoteListByDate2:
		soap_serialize___ns1__QuoteListByDate2(soap, (const struct __ns1__QuoteListByDate2 *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__QuoteListByDate:
		soap_serialize___ns1__QuoteListByDate(soap, (const struct __ns1__QuoteListByDate *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__TechnicalList:
		soap_serialize___ns1__TechnicalList(soap, (const struct __ns1__TechnicalList *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__FundamentalList:
		soap_serialize___ns1__FundamentalList(soap, (const struct __ns1__FundamentalList *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__NewsListBySymbol:
		soap_serialize___ns1__NewsListBySymbol(soap, (const struct __ns1__NewsListBySymbol *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__NewsList:
		soap_serialize___ns1__NewsList(soap, (const struct __ns1__NewsList *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__QuoteList:
		soap_serialize___ns1__QuoteList(soap, (const struct __ns1__QuoteList *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__SymbolGet:
		soap_serialize___ns1__SymbolGet(soap, (const struct __ns1__SymbolGet *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__QuoteList2:
		soap_serialize___ns1__QuoteList2(soap, (const struct __ns1__QuoteList2 *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__QuoteGet:
		soap_serialize___ns1__QuoteGet(soap, (const struct __ns1__QuoteGet *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__SymbolList2:
		soap_serialize___ns1__SymbolList2(soap, (const struct __ns1__SymbolList2 *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__SymbolList:
		soap_serialize___ns1__SymbolList(soap, (const struct __ns1__SymbolList *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__ExchangeGet:
		soap_serialize___ns1__ExchangeGet(soap, (const struct __ns1__ExchangeGet *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__ExchangeList:
		soap_serialize___ns1__ExchangeList(soap, (const struct __ns1__ExchangeList *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__Membership:
		soap_serialize___ns1__Membership(soap, (const struct __ns1__Membership *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__Login2:
		soap_serialize___ns1__Login2(soap, (const struct __ns1__Login2 *)ptr);
		break;
	case SOAP_TYPE_ns___ns1__Login:
		soap_serialize___ns1__Login(soap, (const struct __ns1__Login *)ptr);
		break;
	case SOAP_TYPE_ns_PointerTo_ns1__ValidateAccess:
		soap_serialize_PointerTo_ns1__ValidateAccess(soap, (_ns1__ValidateAccess *const*)ptr);
		break;
	case SOAP_TYPE_ns_PointerTo_ns1__UpdateDataFormat:
		soap_serialize_PointerTo_ns1__UpdateDataFormat(soap, (_ns1__UpdateDataFormat *const*)ptr);
		break;
	case SOAP_TYPE_ns_PointerTo_ns1__DataFormats:
		soap_serialize_PointerTo_ns1__DataFormats(soap, (_ns1__DataFormats *const*)ptr);
		break;
	case SOAP_TYPE_ns_PointerTo_ns1__DataClientLatestVersion:
		soap_serialize_PointerTo_ns1__DataClientLatestVersion(soap, (_ns1__DataClientLatestVersion *const*)ptr);
		break;
	case SOAP_TYPE_ns_PointerTo_ns1__SymbolChangesByExchange:
		soap_serialize_PointerTo_ns1__SymbolChangesByExchange(soap, (_ns1__SymbolChangesByExchange *const*)ptr);
		break;
	case SOAP_TYPE_ns_PointerTo_ns1__QuoteListByDatePeriod2:
		soap_serialize_PointerTo_ns1__QuoteListByDatePeriod2(soap, (_ns1__QuoteListByDatePeriod2 *const*)ptr);
		break;
	case SOAP_TYPE_ns_PointerTo_ns1__QuoteListByDatePeriod:
		soap_serialize_PointerTo_ns1__QuoteListByDatePeriod(soap, (_ns1__QuoteListByDatePeriod *const*)ptr);
		break;
	case SOAP_TYPE_ns_PointerTo_ns1__SymbolHistoryPeriodByDateRange:
		soap_serialize_PointerTo_ns1__SymbolHistoryPeriodByDateRange(soap, (_ns1__SymbolHistoryPeriodByDateRange *const*)ptr);
		break;
	case SOAP_TYPE_ns_PointerTo_ns1__SymbolHistoryPeriod:
		soap_serialize_PointerTo_ns1__SymbolHistoryPeriod(soap, (_ns1__SymbolHistoryPeriod *const*)ptr);
		break;
	case SOAP_TYPE_ns_PointerTo_ns1__CountryList:
		soap_serialize_PointerTo_ns1__CountryList(soap, (_ns1__CountryList *const*)ptr);
		break;
	case SOAP_TYPE_ns_PointerTo_ns1__SplitListBySymbol:
		soap_serialize_PointerTo_ns1__SplitListBySymbol(soap, (_ns1__SplitListBySymbol *const*)ptr);
		break;
	case SOAP_TYPE_ns_PointerTo_ns1__SplitListByExchange:
		soap_serialize_PointerTo_ns1__SplitListByExchange(soap, (_ns1__SplitListByExchange *const*)ptr);
		break;
	case SOAP_TYPE_ns_PointerTo_ns1__ExchangeMonths:
		soap_serialize_PointerTo_ns1__ExchangeMonths(soap, (_ns1__ExchangeMonths *const*)ptr);
		break;
	case SOAP_TYPE_ns_PointerTo_ns1__SymbolChart:
		soap_serialize_PointerTo_ns1__SymbolChart(soap, (_ns1__SymbolChart *const*)ptr);
		break;
	case SOAP_TYPE_ns_PointerTo_ns1__Top10Losses:
		soap_serialize_PointerTo_ns1__Top10Losses(soap, (_ns1__Top10Losses *const*)ptr);
		break;
	case SOAP_TYPE_ns_PointerTo_ns1__Top10Gains:
		soap_serialize_PointerTo_ns1__Top10Gains(soap, (_ns1__Top10Gains *const*)ptr);
		break;
	case SOAP_TYPE_ns_PointerTo_ns1__SymbolHistory:
		soap_serialize_PointerTo_ns1__SymbolHistory(soap, (_ns1__SymbolHistory *const*)ptr);
		break;
	case SOAP_TYPE_ns_PointerTo_ns1__QuoteListByDate2:
		soap_serialize_PointerTo_ns1__QuoteListByDate2(soap, (_ns1__QuoteListByDate2 *const*)ptr);
		break;
	case SOAP_TYPE_ns_PointerTo_ns1__QuoteListByDate:
		soap_serialize_PointerTo_ns1__QuoteListByDate(soap, (_ns1__QuoteListByDate *const*)ptr);
		break;
	case SOAP_TYPE_ns_PointerTo_ns1__TechnicalList:
		soap_serialize_PointerTo_ns1__TechnicalList(soap, (_ns1__TechnicalList *const*)ptr);
		break;
	case SOAP_TYPE_ns_PointerTo_ns1__FundamentalList:
		soap_serialize_PointerTo_ns1__FundamentalList(soap, (_ns1__FundamentalList *const*)ptr);
		break;
	case SOAP_TYPE_ns_PointerTo_ns1__NewsListBySymbol:
		soap_serialize_PointerTo_ns1__NewsListBySymbol(soap, (_ns1__NewsListBySymbol *const*)ptr);
		break;
	case SOAP_TYPE_ns_PointerTo_ns1__NewsList:
		soap_serialize_PointerTo_ns1__NewsList(soap, (_ns1__NewsList *const*)ptr);
		break;
	case SOAP_TYPE_ns_PointerTo_ns1__QuoteList:
		soap_serialize_PointerTo_ns1__QuoteList(soap, (_ns1__QuoteList *const*)ptr);
		break;
	case SOAP_TYPE_ns_PointerTo_ns1__SymbolGet:
		soap_serialize_PointerTo_ns1__SymbolGet(soap, (_ns1__SymbolGet *const*)ptr);
		break;
	case SOAP_TYPE_ns_PointerTo_ns1__QuoteList2:
		soap_serialize_PointerTo_ns1__QuoteList2(soap, (_ns1__QuoteList2 *const*)ptr);
		break;
	case SOAP_TYPE_ns_PointerTo_ns1__QuoteGet:
		soap_serialize_PointerTo_ns1__QuoteGet(soap, (_ns1__QuoteGet *const*)ptr);
		break;
	case SOAP_TYPE_ns_PointerTo_ns1__SymbolList2:
		soap_serialize_PointerTo_ns1__SymbolList2(soap, (_ns1__SymbolList2 *const*)ptr);
		break;
	case SOAP_TYPE_ns_PointerTo_ns1__SymbolList:
		soap_serialize_PointerTo_ns1__SymbolList(soap, (_ns1__SymbolList *const*)ptr);
		break;
	case SOAP_TYPE_ns_PointerTo_ns1__ExchangeGet:
		soap_serialize_PointerTo_ns1__ExchangeGet(soap, (_ns1__ExchangeGet *const*)ptr);
		break;
	case SOAP_TYPE_ns_PointerTo_ns1__ExchangeList:
		soap_serialize_PointerTo_ns1__ExchangeList(soap, (_ns1__ExchangeList *const*)ptr);
		break;
	case SOAP_TYPE_ns_PointerTo_ns1__Membership:
		soap_serialize_PointerTo_ns1__Membership(soap, (_ns1__Membership *const*)ptr);
		break;
	case SOAP_TYPE_ns_PointerTo_ns1__Login2:
		soap_serialize_PointerTo_ns1__Login2(soap, (_ns1__Login2 *const*)ptr);
		break;
	case SOAP_TYPE_ns_PointerTo_ns1__Login:
		soap_serialize_PointerTo_ns1__Login(soap, (_ns1__Login *const*)ptr);
		break;
	case SOAP_TYPE_ns_PointerTons1__RESPONSE:
		soap_serialize_PointerTons1__RESPONSE(soap, (ns1__RESPONSE *const*)ptr);
		break;
	case SOAP_TYPE_ns_PointerTons1__LOGINRESPONSE:
		soap_serialize_PointerTons1__LOGINRESPONSE(soap, (ns1__LOGINRESPONSE *const*)ptr);
		break;
	case SOAP_TYPE_ns_PointerTons1__DATAFORMAT_USCORECOLUMN:
		soap_serialize_PointerTons1__DATAFORMAT_USCORECOLUMN(soap, (ns1__DATAFORMAT_USCORECOLUMN *const*)ptr);
		break;
	case SOAP_TYPE_ns_PointerTons1__ArrayOfDATAFORMAT_USCORECOLUMN:
		soap_serialize_PointerTons1__ArrayOfDATAFORMAT_USCORECOLUMN(soap, (ns1__ArrayOfDATAFORMAT_USCORECOLUMN *const*)ptr);
		break;
	case SOAP_TYPE_ns_PointerTons1__DATAFORMAT:
		soap_serialize_PointerTons1__DATAFORMAT(soap, (ns1__DATAFORMAT *const*)ptr);
		break;
	case SOAP_TYPE_ns_PointerTons1__NEWS:
		soap_serialize_PointerTons1__NEWS(soap, (ns1__NEWS *const*)ptr);
		break;
	case SOAP_TYPE_ns_PointerTons1__SYMBOLCHANGE:
		soap_serialize_PointerTons1__SYMBOLCHANGE(soap, (ns1__SYMBOLCHANGE *const*)ptr);
		break;
	case SOAP_TYPE_ns_PointerTons1__TECHNICAL:
		soap_serialize_PointerTons1__TECHNICAL(soap, (ns1__TECHNICAL *const*)ptr);
		break;
	case SOAP_TYPE_ns_PointerTons1__FUNDAMENTAL:
		soap_serialize_PointerTons1__FUNDAMENTAL(soap, (ns1__FUNDAMENTAL *const*)ptr);
		break;
	case SOAP_TYPE_ns_PointerTons1__CountryBase:
		soap_serialize_PointerTons1__CountryBase(soap, (ns1__CountryBase *const*)ptr);
		break;
	case SOAP_TYPE_ns_PointerTons1__SPLIT:
		soap_serialize_PointerTons1__SPLIT(soap, (ns1__SPLIT *const*)ptr);
		break;
	case SOAP_TYPE_ns_PointerTons1__QUOTE2:
		soap_serialize_PointerTons1__QUOTE2(soap, (ns1__QUOTE2 *const*)ptr);
		break;
	case SOAP_TYPE_ns_PointerTons1__SYMBOL2:
		soap_serialize_PointerTons1__SYMBOL2(soap, (ns1__SYMBOL2 *const*)ptr);
		break;
	case SOAP_TYPE_ns_PointerTons1__ArrayOfDATAFORMAT:
		soap_serialize_PointerTons1__ArrayOfDATAFORMAT(soap, (ns1__ArrayOfDATAFORMAT *const*)ptr);
		break;
	case SOAP_TYPE_ns_PointerTons1__ArrayOfNEWS:
		soap_serialize_PointerTons1__ArrayOfNEWS(soap, (ns1__ArrayOfNEWS *const*)ptr);
		break;
	case SOAP_TYPE_ns_PointerTons1__ArrayOfSYMBOLCHANGE:
		soap_serialize_PointerTons1__ArrayOfSYMBOLCHANGE(soap, (ns1__ArrayOfSYMBOLCHANGE *const*)ptr);
		break;
	case SOAP_TYPE_ns_PointerTons1__ArrayOfTECHNICAL:
		soap_serialize_PointerTons1__ArrayOfTECHNICAL(soap, (ns1__ArrayOfTECHNICAL *const*)ptr);
		break;
	case SOAP_TYPE_ns_PointerTons1__ArrayOfFUNDAMENTAL:
		soap_serialize_PointerTons1__ArrayOfFUNDAMENTAL(soap, (ns1__ArrayOfFUNDAMENTAL *const*)ptr);
		break;
	case SOAP_TYPE_ns_PointerTons1__ArrayOfCountryBase:
		soap_serialize_PointerTons1__ArrayOfCountryBase(soap, (ns1__ArrayOfCountryBase *const*)ptr);
		break;
	case SOAP_TYPE_ns_PointerTons1__ArrayOfSPLIT:
		soap_serialize_PointerTons1__ArrayOfSPLIT(soap, (ns1__ArrayOfSPLIT *const*)ptr);
		break;
	case SOAP_TYPE_ns_PointerTons1__ArrayOfQUOTE2:
		soap_serialize_PointerTons1__ArrayOfQUOTE2(soap, (ns1__ArrayOfQUOTE2 *const*)ptr);
		break;
	case SOAP_TYPE_ns_PointerTons1__ArrayOfQUOTE:
		soap_serialize_PointerTons1__ArrayOfQUOTE(soap, (ns1__ArrayOfQUOTE *const*)ptr);
		break;
	case SOAP_TYPE_ns_PointerTons1__QUOTE:
		soap_serialize_PointerTons1__QUOTE(soap, (ns1__QUOTE *const*)ptr);
		break;
	case SOAP_TYPE_ns_PointerTons1__ArrayOfSYMBOL2:
		soap_serialize_PointerTons1__ArrayOfSYMBOL2(soap, (ns1__ArrayOfSYMBOL2 *const*)ptr);
		break;
	case SOAP_TYPE_ns_PointerTons1__ArrayOfSYMBOL:
		soap_serialize_PointerTons1__ArrayOfSYMBOL(soap, (ns1__ArrayOfSYMBOL *const*)ptr);
		break;
	case SOAP_TYPE_ns_PointerTons1__SYMBOL:
		soap_serialize_PointerTons1__SYMBOL(soap, (ns1__SYMBOL *const*)ptr);
		break;
	case SOAP_TYPE_ns_PointerTons1__ArrayOfEXCHANGE:
		soap_serialize_PointerTons1__ArrayOfEXCHANGE(soap, (ns1__ArrayOfEXCHANGE *const*)ptr);
		break;
	case SOAP_TYPE_ns_PointerTons1__EXCHANGE:
		soap_serialize_PointerTons1__EXCHANGE(soap, (ns1__EXCHANGE *const*)ptr);
		break;
	case SOAP_TYPE_ns_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_ns__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_ns_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 ns_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_ns_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns_ns1__LOGINRESPONSE:
		return (void*)soap_instantiate_ns1__LOGINRESPONSE(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns_ns1__RESPONSE:
		return (void*)soap_instantiate_ns1__RESPONSE(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns_ns1__EXCHANGE:
		return (void*)soap_instantiate_ns1__EXCHANGE(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns_ns1__ArrayOfEXCHANGE:
		return (void*)soap_instantiate_ns1__ArrayOfEXCHANGE(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns_ns1__SYMBOL:
		return (void*)soap_instantiate_ns1__SYMBOL(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns_ns1__ArrayOfSYMBOL:
		return (void*)soap_instantiate_ns1__ArrayOfSYMBOL(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns_ns1__ArrayOfSYMBOL2:
		return (void*)soap_instantiate_ns1__ArrayOfSYMBOL2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns_ns1__SYMBOL2:
		return (void*)soap_instantiate_ns1__SYMBOL2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns_ns1__QUOTE:
		return (void*)soap_instantiate_ns1__QUOTE(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns_ns1__ArrayOfQUOTE:
		return (void*)soap_instantiate_ns1__ArrayOfQUOTE(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns_ns1__ArrayOfQUOTE2:
		return (void*)soap_instantiate_ns1__ArrayOfQUOTE2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns_ns1__QUOTE2:
		return (void*)soap_instantiate_ns1__QUOTE2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns_ns1__ArrayOfSPLIT:
		return (void*)soap_instantiate_ns1__ArrayOfSPLIT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns_ns1__SPLIT:
		return (void*)soap_instantiate_ns1__SPLIT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns_ns1__ArrayOfCountryBase:
		return (void*)soap_instantiate_ns1__ArrayOfCountryBase(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns_ns1__CountryBase:
		return (void*)soap_instantiate_ns1__CountryBase(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns_ns1__ArrayOfFUNDAMENTAL:
		return (void*)soap_instantiate_ns1__ArrayOfFUNDAMENTAL(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns_ns1__FUNDAMENTAL:
		return (void*)soap_instantiate_ns1__FUNDAMENTAL(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns_ns1__ArrayOfTECHNICAL:
		return (void*)soap_instantiate_ns1__ArrayOfTECHNICAL(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns_ns1__TECHNICAL:
		return (void*)soap_instantiate_ns1__TECHNICAL(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns_ns1__ArrayOfSYMBOLCHANGE:
		return (void*)soap_instantiate_ns1__ArrayOfSYMBOLCHANGE(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns_ns1__SYMBOLCHANGE:
		return (void*)soap_instantiate_ns1__SYMBOLCHANGE(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns_ns1__ArrayOfNEWS:
		return (void*)soap_instantiate_ns1__ArrayOfNEWS(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns_ns1__NEWS:
		return (void*)soap_instantiate_ns1__NEWS(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns_ns1__ArrayOfDATAFORMAT:
		return (void*)soap_instantiate_ns1__ArrayOfDATAFORMAT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns_ns1__DATAFORMAT:
		return (void*)soap_instantiate_ns1__DATAFORMAT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns_ns1__ArrayOfDATAFORMAT_USCORECOLUMN:
		return (void*)soap_instantiate_ns1__ArrayOfDATAFORMAT_USCORECOLUMN(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns_ns1__DATAFORMAT_USCORECOLUMN:
		return (void*)soap_instantiate_ns1__DATAFORMAT_USCORECOLUMN(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__Login:
		return (void*)soap_instantiate__ns1__Login(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__LoginResponse:
		return (void*)soap_instantiate__ns1__LoginResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__Login2:
		return (void*)soap_instantiate__ns1__Login2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__Login2Response:
		return (void*)soap_instantiate__ns1__Login2Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__Membership:
		return (void*)soap_instantiate__ns1__Membership(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__MembershipResponse:
		return (void*)soap_instantiate__ns1__MembershipResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__ExchangeList:
		return (void*)soap_instantiate__ns1__ExchangeList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__ExchangeListResponse:
		return (void*)soap_instantiate__ns1__ExchangeListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__ExchangeGet:
		return (void*)soap_instantiate__ns1__ExchangeGet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__ExchangeGetResponse:
		return (void*)soap_instantiate__ns1__ExchangeGetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__SymbolList:
		return (void*)soap_instantiate__ns1__SymbolList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__SymbolListResponse:
		return (void*)soap_instantiate__ns1__SymbolListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__SymbolList2:
		return (void*)soap_instantiate__ns1__SymbolList2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__SymbolList2Response:
		return (void*)soap_instantiate__ns1__SymbolList2Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__QuoteGet:
		return (void*)soap_instantiate__ns1__QuoteGet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__QuoteGetResponse:
		return (void*)soap_instantiate__ns1__QuoteGetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__QuoteList2:
		return (void*)soap_instantiate__ns1__QuoteList2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__QuoteList2Response:
		return (void*)soap_instantiate__ns1__QuoteList2Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__SymbolGet:
		return (void*)soap_instantiate__ns1__SymbolGet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__SymbolGetResponse:
		return (void*)soap_instantiate__ns1__SymbolGetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__QuoteList:
		return (void*)soap_instantiate__ns1__QuoteList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__QuoteListResponse:
		return (void*)soap_instantiate__ns1__QuoteListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__NewsList:
		return (void*)soap_instantiate__ns1__NewsList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__NewsListResponse:
		return (void*)soap_instantiate__ns1__NewsListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__NewsListBySymbol:
		return (void*)soap_instantiate__ns1__NewsListBySymbol(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__NewsListBySymbolResponse:
		return (void*)soap_instantiate__ns1__NewsListBySymbolResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__FundamentalList:
		return (void*)soap_instantiate__ns1__FundamentalList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__FundamentalListResponse:
		return (void*)soap_instantiate__ns1__FundamentalListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__TechnicalList:
		return (void*)soap_instantiate__ns1__TechnicalList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__TechnicalListResponse:
		return (void*)soap_instantiate__ns1__TechnicalListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__QuoteListByDate:
		return (void*)soap_instantiate__ns1__QuoteListByDate(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__QuoteListByDateResponse:
		return (void*)soap_instantiate__ns1__QuoteListByDateResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__QuoteListByDate2:
		return (void*)soap_instantiate__ns1__QuoteListByDate2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__QuoteListByDate2Response:
		return (void*)soap_instantiate__ns1__QuoteListByDate2Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__SymbolHistory:
		return (void*)soap_instantiate__ns1__SymbolHistory(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__SymbolHistoryResponse:
		return (void*)soap_instantiate__ns1__SymbolHistoryResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__Top10Gains:
		return (void*)soap_instantiate__ns1__Top10Gains(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__Top10GainsResponse:
		return (void*)soap_instantiate__ns1__Top10GainsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__Top10Losses:
		return (void*)soap_instantiate__ns1__Top10Losses(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__Top10LossesResponse:
		return (void*)soap_instantiate__ns1__Top10LossesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__SymbolChart:
		return (void*)soap_instantiate__ns1__SymbolChart(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__SymbolChartResponse:
		return (void*)soap_instantiate__ns1__SymbolChartResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__ExchangeMonths:
		return (void*)soap_instantiate__ns1__ExchangeMonths(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__ExchangeMonthsResponse:
		return (void*)soap_instantiate__ns1__ExchangeMonthsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__SplitListByExchange:
		return (void*)soap_instantiate__ns1__SplitListByExchange(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__SplitListByExchangeResponse:
		return (void*)soap_instantiate__ns1__SplitListByExchangeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__SplitListBySymbol:
		return (void*)soap_instantiate__ns1__SplitListBySymbol(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__SplitListBySymbolResponse:
		return (void*)soap_instantiate__ns1__SplitListBySymbolResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__CountryList:
		return (void*)soap_instantiate__ns1__CountryList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__CountryListResponse:
		return (void*)soap_instantiate__ns1__CountryListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__SymbolHistoryPeriod:
		return (void*)soap_instantiate__ns1__SymbolHistoryPeriod(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__SymbolHistoryPeriodResponse:
		return (void*)soap_instantiate__ns1__SymbolHistoryPeriodResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__SymbolHistoryPeriodByDateRange:
		return (void*)soap_instantiate__ns1__SymbolHistoryPeriodByDateRange(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__SymbolHistoryPeriodByDateRangeResponse:
		return (void*)soap_instantiate__ns1__SymbolHistoryPeriodByDateRangeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__QuoteListByDatePeriod:
		return (void*)soap_instantiate__ns1__QuoteListByDatePeriod(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__QuoteListByDatePeriodResponse:
		return (void*)soap_instantiate__ns1__QuoteListByDatePeriodResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__QuoteListByDatePeriod2:
		return (void*)soap_instantiate__ns1__QuoteListByDatePeriod2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__QuoteListByDatePeriod2Response:
		return (void*)soap_instantiate__ns1__QuoteListByDatePeriod2Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__SymbolChangesByExchange:
		return (void*)soap_instantiate__ns1__SymbolChangesByExchange(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__SymbolChangesByExchangeResponse:
		return (void*)soap_instantiate__ns1__SymbolChangesByExchangeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__DataClientLatestVersion:
		return (void*)soap_instantiate__ns1__DataClientLatestVersion(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__DataClientLatestVersionResponse:
		return (void*)soap_instantiate__ns1__DataClientLatestVersionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__DataFormats:
		return (void*)soap_instantiate__ns1__DataFormats(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__DataFormatsResponse:
		return (void*)soap_instantiate__ns1__DataFormatsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__UpdateDataFormat:
		return (void*)soap_instantiate__ns1__UpdateDataFormat(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__UpdateDataFormatResponse:
		return (void*)soap_instantiate__ns1__UpdateDataFormatResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__ValidateAccess:
		return (void*)soap_instantiate__ns1__ValidateAccess(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ns1__ValidateAccessResponse:
		return (void*)soap_instantiate__ns1__ValidateAccessResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__Login:
		return (void*)soap_instantiate___ns1__Login(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__Login2:
		return (void*)soap_instantiate___ns1__Login2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__Membership:
		return (void*)soap_instantiate___ns1__Membership(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__ExchangeList:
		return (void*)soap_instantiate___ns1__ExchangeList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__ExchangeGet:
		return (void*)soap_instantiate___ns1__ExchangeGet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__SymbolList:
		return (void*)soap_instantiate___ns1__SymbolList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__SymbolList2:
		return (void*)soap_instantiate___ns1__SymbolList2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__QuoteGet:
		return (void*)soap_instantiate___ns1__QuoteGet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__QuoteList2:
		return (void*)soap_instantiate___ns1__QuoteList2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__SymbolGet:
		return (void*)soap_instantiate___ns1__SymbolGet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__QuoteList:
		return (void*)soap_instantiate___ns1__QuoteList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__NewsList:
		return (void*)soap_instantiate___ns1__NewsList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__NewsListBySymbol:
		return (void*)soap_instantiate___ns1__NewsListBySymbol(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__FundamentalList:
		return (void*)soap_instantiate___ns1__FundamentalList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__TechnicalList:
		return (void*)soap_instantiate___ns1__TechnicalList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__QuoteListByDate:
		return (void*)soap_instantiate___ns1__QuoteListByDate(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__QuoteListByDate2:
		return (void*)soap_instantiate___ns1__QuoteListByDate2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__SymbolHistory:
		return (void*)soap_instantiate___ns1__SymbolHistory(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__Top10Gains:
		return (void*)soap_instantiate___ns1__Top10Gains(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__Top10Losses:
		return (void*)soap_instantiate___ns1__Top10Losses(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__SymbolChart:
		return (void*)soap_instantiate___ns1__SymbolChart(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__ExchangeMonths:
		return (void*)soap_instantiate___ns1__ExchangeMonths(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__SplitListByExchange:
		return (void*)soap_instantiate___ns1__SplitListByExchange(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__SplitListBySymbol:
		return (void*)soap_instantiate___ns1__SplitListBySymbol(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__CountryList:
		return (void*)soap_instantiate___ns1__CountryList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__SymbolHistoryPeriod:
		return (void*)soap_instantiate___ns1__SymbolHistoryPeriod(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__SymbolHistoryPeriodByDateRange:
		return (void*)soap_instantiate___ns1__SymbolHistoryPeriodByDateRange(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__QuoteListByDatePeriod:
		return (void*)soap_instantiate___ns1__QuoteListByDatePeriod(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__QuoteListByDatePeriod2:
		return (void*)soap_instantiate___ns1__QuoteListByDatePeriod2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__SymbolChangesByExchange:
		return (void*)soap_instantiate___ns1__SymbolChangesByExchange(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__DataClientLatestVersion:
		return (void*)soap_instantiate___ns1__DataClientLatestVersion(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__DataFormats:
		return (void*)soap_instantiate___ns1__DataFormats(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__UpdateDataFormat:
		return (void*)soap_instantiate___ns1__UpdateDataFormat(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__ValidateAccess:
		return (void*)soap_instantiate___ns1__ValidateAccess(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__Login_:
		return (void*)soap_instantiate___ns1__Login_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__Login2_:
		return (void*)soap_instantiate___ns1__Login2_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__Membership_:
		return (void*)soap_instantiate___ns1__Membership_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__ExchangeList_:
		return (void*)soap_instantiate___ns1__ExchangeList_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__ExchangeGet_:
		return (void*)soap_instantiate___ns1__ExchangeGet_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__SymbolList_:
		return (void*)soap_instantiate___ns1__SymbolList_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__SymbolList2_:
		return (void*)soap_instantiate___ns1__SymbolList2_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__QuoteGet_:
		return (void*)soap_instantiate___ns1__QuoteGet_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__QuoteList2_:
		return (void*)soap_instantiate___ns1__QuoteList2_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__SymbolGet_:
		return (void*)soap_instantiate___ns1__SymbolGet_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__QuoteList_:
		return (void*)soap_instantiate___ns1__QuoteList_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__NewsList_:
		return (void*)soap_instantiate___ns1__NewsList_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__NewsListBySymbol_:
		return (void*)soap_instantiate___ns1__NewsListBySymbol_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__FundamentalList_:
		return (void*)soap_instantiate___ns1__FundamentalList_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__TechnicalList_:
		return (void*)soap_instantiate___ns1__TechnicalList_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__QuoteListByDate_:
		return (void*)soap_instantiate___ns1__QuoteListByDate_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__QuoteListByDate2_:
		return (void*)soap_instantiate___ns1__QuoteListByDate2_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__SymbolHistory_:
		return (void*)soap_instantiate___ns1__SymbolHistory_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__Top10Gains_:
		return (void*)soap_instantiate___ns1__Top10Gains_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__Top10Losses_:
		return (void*)soap_instantiate___ns1__Top10Losses_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__SymbolChart_:
		return (void*)soap_instantiate___ns1__SymbolChart_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__ExchangeMonths_:
		return (void*)soap_instantiate___ns1__ExchangeMonths_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__SplitListByExchange_:
		return (void*)soap_instantiate___ns1__SplitListByExchange_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__SplitListBySymbol_:
		return (void*)soap_instantiate___ns1__SplitListBySymbol_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__CountryList_:
		return (void*)soap_instantiate___ns1__CountryList_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__SymbolHistoryPeriod_:
		return (void*)soap_instantiate___ns1__SymbolHistoryPeriod_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__SymbolHistoryPeriodByDateRange_:
		return (void*)soap_instantiate___ns1__SymbolHistoryPeriodByDateRange_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__QuoteListByDatePeriod_:
		return (void*)soap_instantiate___ns1__QuoteListByDatePeriod_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__QuoteListByDatePeriod2_:
		return (void*)soap_instantiate___ns1__QuoteListByDatePeriod2_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__SymbolChangesByExchange_:
		return (void*)soap_instantiate___ns1__SymbolChangesByExchange_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__DataClientLatestVersion_:
		return (void*)soap_instantiate___ns1__DataClientLatestVersion_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__DataFormats_:
		return (void*)soap_instantiate___ns1__DataFormats_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__UpdateDataFormat_:
		return (void*)soap_instantiate___ns1__UpdateDataFormat_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__ValidateAccess_:
		return (void*)soap_instantiate___ns1__ValidateAccess_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__LoginResponse__:
		return (void*)soap_instantiate___ns1__LoginResponse__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__Login2Response__:
		return (void*)soap_instantiate___ns1__Login2Response__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__MembershipResponse__:
		return (void*)soap_instantiate___ns1__MembershipResponse__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__ExchangeListResponse__:
		return (void*)soap_instantiate___ns1__ExchangeListResponse__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__ExchangeGetResponse__:
		return (void*)soap_instantiate___ns1__ExchangeGetResponse__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__SymbolListResponse__:
		return (void*)soap_instantiate___ns1__SymbolListResponse__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__SymbolList2Response__:
		return (void*)soap_instantiate___ns1__SymbolList2Response__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__QuoteGetResponse__:
		return (void*)soap_instantiate___ns1__QuoteGetResponse__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__QuoteList2Response__:
		return (void*)soap_instantiate___ns1__QuoteList2Response__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__SymbolGetResponse__:
		return (void*)soap_instantiate___ns1__SymbolGetResponse__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__QuoteListResponse__:
		return (void*)soap_instantiate___ns1__QuoteListResponse__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__NewsListResponse__:
		return (void*)soap_instantiate___ns1__NewsListResponse__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__NewsListBySymbolResponse__:
		return (void*)soap_instantiate___ns1__NewsListBySymbolResponse__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__FundamentalListResponse__:
		return (void*)soap_instantiate___ns1__FundamentalListResponse__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__TechnicalListResponse__:
		return (void*)soap_instantiate___ns1__TechnicalListResponse__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__QuoteListByDateResponse__:
		return (void*)soap_instantiate___ns1__QuoteListByDateResponse__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__QuoteListByDate2Response__:
		return (void*)soap_instantiate___ns1__QuoteListByDate2Response__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__SymbolHistoryResponse__:
		return (void*)soap_instantiate___ns1__SymbolHistoryResponse__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__Top10GainsResponse__:
		return (void*)soap_instantiate___ns1__Top10GainsResponse__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__Top10LossesResponse__:
		return (void*)soap_instantiate___ns1__Top10LossesResponse__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__SymbolChartResponse__:
		return (void*)soap_instantiate___ns1__SymbolChartResponse__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__ExchangeMonthsResponse__:
		return (void*)soap_instantiate___ns1__ExchangeMonthsResponse__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__SplitListByExchangeResponse__:
		return (void*)soap_instantiate___ns1__SplitListByExchangeResponse__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__SplitListBySymbolResponse__:
		return (void*)soap_instantiate___ns1__SplitListBySymbolResponse__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__CountryListResponse__:
		return (void*)soap_instantiate___ns1__CountryListResponse__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__SymbolHistoryPeriodResponse__:
		return (void*)soap_instantiate___ns1__SymbolHistoryPeriodResponse__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__SymbolHistoryPeriodByDateRangeResponse__:
		return (void*)soap_instantiate___ns1__SymbolHistoryPeriodByDateRangeResponse__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__QuoteListByDatePeriodResponse__:
		return (void*)soap_instantiate___ns1__QuoteListByDatePeriodResponse__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__QuoteListByDatePeriod2Response__:
		return (void*)soap_instantiate___ns1__QuoteListByDatePeriod2Response__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__SymbolChangesByExchangeResponse__:
		return (void*)soap_instantiate___ns1__SymbolChangesByExchangeResponse__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__DataClientLatestVersionResponse__:
		return (void*)soap_instantiate___ns1__DataClientLatestVersionResponse__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__DataFormatsResponse__:
		return (void*)soap_instantiate___ns1__DataFormatsResponse__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__UpdateDataFormatResponse__:
		return (void*)soap_instantiate___ns1__UpdateDataFormatResponse__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__ValidateAccessResponse__:
		return (void*)soap_instantiate___ns1__ValidateAccessResponse__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__Login___:
		return (void*)soap_instantiate___ns1__Login___(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__Login2___:
		return (void*)soap_instantiate___ns1__Login2___(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__Membership___:
		return (void*)soap_instantiate___ns1__Membership___(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__ExchangeList___:
		return (void*)soap_instantiate___ns1__ExchangeList___(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__ExchangeGet___:
		return (void*)soap_instantiate___ns1__ExchangeGet___(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__SymbolList___:
		return (void*)soap_instantiate___ns1__SymbolList___(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__SymbolList2___:
		return (void*)soap_instantiate___ns1__SymbolList2___(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__QuoteGet___:
		return (void*)soap_instantiate___ns1__QuoteGet___(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__QuoteList2___:
		return (void*)soap_instantiate___ns1__QuoteList2___(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__SymbolGet___:
		return (void*)soap_instantiate___ns1__SymbolGet___(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__QuoteList___:
		return (void*)soap_instantiate___ns1__QuoteList___(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__NewsList___:
		return (void*)soap_instantiate___ns1__NewsList___(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__NewsListBySymbol___:
		return (void*)soap_instantiate___ns1__NewsListBySymbol___(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__FundamentalList___:
		return (void*)soap_instantiate___ns1__FundamentalList___(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__TechnicalList___:
		return (void*)soap_instantiate___ns1__TechnicalList___(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__QuoteListByDate___:
		return (void*)soap_instantiate___ns1__QuoteListByDate___(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__QuoteListByDate2___:
		return (void*)soap_instantiate___ns1__QuoteListByDate2___(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__SymbolHistory___:
		return (void*)soap_instantiate___ns1__SymbolHistory___(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__Top10Gains___:
		return (void*)soap_instantiate___ns1__Top10Gains___(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__Top10Losses___:
		return (void*)soap_instantiate___ns1__Top10Losses___(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__SymbolChart___:
		return (void*)soap_instantiate___ns1__SymbolChart___(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__ExchangeMonths___:
		return (void*)soap_instantiate___ns1__ExchangeMonths___(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__SplitListByExchange___:
		return (void*)soap_instantiate___ns1__SplitListByExchange___(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__SplitListBySymbol___:
		return (void*)soap_instantiate___ns1__SplitListBySymbol___(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__CountryList___:
		return (void*)soap_instantiate___ns1__CountryList___(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__SymbolHistoryPeriod___:
		return (void*)soap_instantiate___ns1__SymbolHistoryPeriod___(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__SymbolHistoryPeriodByDateRange___:
		return (void*)soap_instantiate___ns1__SymbolHistoryPeriodByDateRange___(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__QuoteListByDatePeriod___:
		return (void*)soap_instantiate___ns1__QuoteListByDatePeriod___(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__QuoteListByDatePeriod2___:
		return (void*)soap_instantiate___ns1__QuoteListByDatePeriod2___(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__SymbolChangesByExchange___:
		return (void*)soap_instantiate___ns1__SymbolChangesByExchange___(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__DataClientLatestVersion___:
		return (void*)soap_instantiate___ns1__DataClientLatestVersion___(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__DataFormats___:
		return (void*)soap_instantiate___ns1__DataFormats___(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__UpdateDataFormat___:
		return (void*)soap_instantiate___ns1__UpdateDataFormat___(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns___ns1__ValidateAccess___:
		return (void*)soap_instantiate___ns1__ValidateAccess___(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_ns_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_ns_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_ns_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_ns_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_ns_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__DATAFORMAT_USCORECOLUMN:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__DATAFORMAT_USCORECOLUMN(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__DATAFORMAT:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__DATAFORMAT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__NEWS:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__NEWS(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__SYMBOLCHANGE:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__SYMBOLCHANGE(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__TECHNICAL:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__TECHNICAL(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__FUNDAMENTAL:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__FUNDAMENTAL(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__CountryBase:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__CountryBase(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__SPLIT:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__SPLIT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__QUOTE2:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__QUOTE2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__QUOTE:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__QUOTE(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__SYMBOL2:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__SYMBOL2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__SYMBOL:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__SYMBOL(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__EXCHANGE:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__EXCHANGE(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 ns_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_ns_std__string:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::string*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::string*>(p->ptr));
		break;
	case SOAP_TYPE_ns_ns1__LOGINRESPONSE:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__LOGINRESPONSE*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__LOGINRESPONSE*>(p->ptr));
		break;
	case SOAP_TYPE_ns_ns1__RESPONSE:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__RESPONSE*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__RESPONSE*>(p->ptr));
		break;
	case SOAP_TYPE_ns_ns1__EXCHANGE:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__EXCHANGE*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__EXCHANGE*>(p->ptr));
		break;
	case SOAP_TYPE_ns_ns1__ArrayOfEXCHANGE:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__ArrayOfEXCHANGE*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__ArrayOfEXCHANGE*>(p->ptr));
		break;
	case SOAP_TYPE_ns_ns1__SYMBOL:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__SYMBOL*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__SYMBOL*>(p->ptr));
		break;
	case SOAP_TYPE_ns_ns1__ArrayOfSYMBOL:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__ArrayOfSYMBOL*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__ArrayOfSYMBOL*>(p->ptr));
		break;
	case SOAP_TYPE_ns_ns1__ArrayOfSYMBOL2:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__ArrayOfSYMBOL2*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__ArrayOfSYMBOL2*>(p->ptr));
		break;
	case SOAP_TYPE_ns_ns1__SYMBOL2:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__SYMBOL2*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__SYMBOL2*>(p->ptr));
		break;
	case SOAP_TYPE_ns_ns1__QUOTE:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__QUOTE*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__QUOTE*>(p->ptr));
		break;
	case SOAP_TYPE_ns_ns1__ArrayOfQUOTE:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__ArrayOfQUOTE*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__ArrayOfQUOTE*>(p->ptr));
		break;
	case SOAP_TYPE_ns_ns1__ArrayOfQUOTE2:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__ArrayOfQUOTE2*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__ArrayOfQUOTE2*>(p->ptr));
		break;
	case SOAP_TYPE_ns_ns1__QUOTE2:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__QUOTE2*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__QUOTE2*>(p->ptr));
		break;
	case SOAP_TYPE_ns_ns1__ArrayOfSPLIT:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__ArrayOfSPLIT*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__ArrayOfSPLIT*>(p->ptr));
		break;
	case SOAP_TYPE_ns_ns1__SPLIT:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__SPLIT*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__SPLIT*>(p->ptr));
		break;
	case SOAP_TYPE_ns_ns1__ArrayOfCountryBase:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__ArrayOfCountryBase*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__ArrayOfCountryBase*>(p->ptr));
		break;
	case SOAP_TYPE_ns_ns1__CountryBase:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__CountryBase*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__CountryBase*>(p->ptr));
		break;
	case SOAP_TYPE_ns_ns1__ArrayOfFUNDAMENTAL:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__ArrayOfFUNDAMENTAL*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__ArrayOfFUNDAMENTAL*>(p->ptr));
		break;
	case SOAP_TYPE_ns_ns1__FUNDAMENTAL:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__FUNDAMENTAL*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__FUNDAMENTAL*>(p->ptr));
		break;
	case SOAP_TYPE_ns_ns1__ArrayOfTECHNICAL:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__ArrayOfTECHNICAL*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__ArrayOfTECHNICAL*>(p->ptr));
		break;
	case SOAP_TYPE_ns_ns1__TECHNICAL:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__TECHNICAL*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__TECHNICAL*>(p->ptr));
		break;
	case SOAP_TYPE_ns_ns1__ArrayOfSYMBOLCHANGE:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__ArrayOfSYMBOLCHANGE*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__ArrayOfSYMBOLCHANGE*>(p->ptr));
		break;
	case SOAP_TYPE_ns_ns1__SYMBOLCHANGE:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__SYMBOLCHANGE*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__SYMBOLCHANGE*>(p->ptr));
		break;
	case SOAP_TYPE_ns_ns1__ArrayOfNEWS:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__ArrayOfNEWS*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__ArrayOfNEWS*>(p->ptr));
		break;
	case SOAP_TYPE_ns_ns1__NEWS:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__NEWS*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__NEWS*>(p->ptr));
		break;
	case SOAP_TYPE_ns_ns1__ArrayOfDATAFORMAT:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__ArrayOfDATAFORMAT*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__ArrayOfDATAFORMAT*>(p->ptr));
		break;
	case SOAP_TYPE_ns_ns1__DATAFORMAT:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__DATAFORMAT*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__DATAFORMAT*>(p->ptr));
		break;
	case SOAP_TYPE_ns_ns1__ArrayOfDATAFORMAT_USCORECOLUMN:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__ArrayOfDATAFORMAT_USCORECOLUMN*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__ArrayOfDATAFORMAT_USCORECOLUMN*>(p->ptr));
		break;
	case SOAP_TYPE_ns_ns1__DATAFORMAT_USCORECOLUMN:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__DATAFORMAT_USCORECOLUMN*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__DATAFORMAT_USCORECOLUMN*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__Login:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__Login*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__Login*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__LoginResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__LoginResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__LoginResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__Login2:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__Login2*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__Login2*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__Login2Response:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__Login2Response*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__Login2Response*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__Membership:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__Membership*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__Membership*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__MembershipResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__MembershipResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__MembershipResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__ExchangeList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__ExchangeList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__ExchangeList*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__ExchangeListResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__ExchangeListResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__ExchangeListResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__ExchangeGet:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__ExchangeGet*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__ExchangeGet*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__ExchangeGetResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__ExchangeGetResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__ExchangeGetResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__SymbolList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SymbolList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SymbolList*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__SymbolListResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SymbolListResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SymbolListResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__SymbolList2:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SymbolList2*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SymbolList2*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__SymbolList2Response:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SymbolList2Response*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SymbolList2Response*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__QuoteGet:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__QuoteGet*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__QuoteGet*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__QuoteGetResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__QuoteGetResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__QuoteGetResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__QuoteList2:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__QuoteList2*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__QuoteList2*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__QuoteList2Response:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__QuoteList2Response*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__QuoteList2Response*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__SymbolGet:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SymbolGet*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SymbolGet*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__SymbolGetResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SymbolGetResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SymbolGetResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__QuoteList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__QuoteList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__QuoteList*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__QuoteListResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__QuoteListResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__QuoteListResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__NewsList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__NewsList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__NewsList*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__NewsListResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__NewsListResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__NewsListResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__NewsListBySymbol:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__NewsListBySymbol*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__NewsListBySymbol*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__NewsListBySymbolResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__NewsListBySymbolResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__NewsListBySymbolResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__FundamentalList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__FundamentalList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__FundamentalList*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__FundamentalListResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__FundamentalListResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__FundamentalListResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__TechnicalList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__TechnicalList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__TechnicalList*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__TechnicalListResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__TechnicalListResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__TechnicalListResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__QuoteListByDate:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__QuoteListByDate*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__QuoteListByDate*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__QuoteListByDateResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__QuoteListByDateResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__QuoteListByDateResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__QuoteListByDate2:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__QuoteListByDate2*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__QuoteListByDate2*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__QuoteListByDate2Response:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__QuoteListByDate2Response*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__QuoteListByDate2Response*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__SymbolHistory:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SymbolHistory*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SymbolHistory*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__SymbolHistoryResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SymbolHistoryResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SymbolHistoryResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__Top10Gains:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__Top10Gains*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__Top10Gains*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__Top10GainsResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__Top10GainsResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__Top10GainsResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__Top10Losses:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__Top10Losses*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__Top10Losses*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__Top10LossesResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__Top10LossesResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__Top10LossesResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__SymbolChart:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SymbolChart*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SymbolChart*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__SymbolChartResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SymbolChartResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SymbolChartResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__ExchangeMonths:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__ExchangeMonths*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__ExchangeMonths*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__ExchangeMonthsResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__ExchangeMonthsResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__ExchangeMonthsResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__SplitListByExchange:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SplitListByExchange*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SplitListByExchange*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__SplitListByExchangeResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SplitListByExchangeResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SplitListByExchangeResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__SplitListBySymbol:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SplitListBySymbol*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SplitListBySymbol*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__SplitListBySymbolResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SplitListBySymbolResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SplitListBySymbolResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__CountryList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__CountryList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__CountryList*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__CountryListResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__CountryListResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__CountryListResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__SymbolHistoryPeriod:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SymbolHistoryPeriod*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SymbolHistoryPeriod*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__SymbolHistoryPeriodResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SymbolHistoryPeriodResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SymbolHistoryPeriodResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__SymbolHistoryPeriodByDateRange:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SymbolHistoryPeriodByDateRange*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SymbolHistoryPeriodByDateRange*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__SymbolHistoryPeriodByDateRangeResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SymbolHistoryPeriodByDateRangeResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SymbolHistoryPeriodByDateRangeResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__QuoteListByDatePeriod:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__QuoteListByDatePeriod*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__QuoteListByDatePeriod*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__QuoteListByDatePeriodResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__QuoteListByDatePeriodResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__QuoteListByDatePeriodResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__QuoteListByDatePeriod2:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__QuoteListByDatePeriod2*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__QuoteListByDatePeriod2*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__QuoteListByDatePeriod2Response:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__QuoteListByDatePeriod2Response*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__QuoteListByDatePeriod2Response*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__SymbolChangesByExchange:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SymbolChangesByExchange*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SymbolChangesByExchange*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__SymbolChangesByExchangeResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SymbolChangesByExchangeResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SymbolChangesByExchangeResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__DataClientLatestVersion:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__DataClientLatestVersion*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__DataClientLatestVersion*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__DataClientLatestVersionResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__DataClientLatestVersionResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__DataClientLatestVersionResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__DataFormats:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__DataFormats*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__DataFormats*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__DataFormatsResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__DataFormatsResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__DataFormatsResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__UpdateDataFormat:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__UpdateDataFormat*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__UpdateDataFormat*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__UpdateDataFormatResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__UpdateDataFormatResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__UpdateDataFormatResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__ValidateAccess:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__ValidateAccess*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__ValidateAccess*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ns1__ValidateAccessResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__ValidateAccessResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__ValidateAccessResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__Login:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__Login*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__Login*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__Login2:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__Login2*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__Login2*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__Membership:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__Membership*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__Membership*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__ExchangeList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__ExchangeList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__ExchangeList*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__ExchangeGet:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__ExchangeGet*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__ExchangeGet*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__SymbolList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SymbolList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SymbolList*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__SymbolList2:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SymbolList2*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SymbolList2*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__QuoteGet:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__QuoteGet*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__QuoteGet*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__QuoteList2:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__QuoteList2*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__QuoteList2*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__SymbolGet:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SymbolGet*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SymbolGet*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__QuoteList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__QuoteList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__QuoteList*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__NewsList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__NewsList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__NewsList*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__NewsListBySymbol:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__NewsListBySymbol*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__NewsListBySymbol*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__FundamentalList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__FundamentalList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__FundamentalList*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__TechnicalList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__TechnicalList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__TechnicalList*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__QuoteListByDate:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__QuoteListByDate*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__QuoteListByDate*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__QuoteListByDate2:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__QuoteListByDate2*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__QuoteListByDate2*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__SymbolHistory:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SymbolHistory*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SymbolHistory*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__Top10Gains:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__Top10Gains*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__Top10Gains*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__Top10Losses:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__Top10Losses*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__Top10Losses*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__SymbolChart:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SymbolChart*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SymbolChart*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__ExchangeMonths:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__ExchangeMonths*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__ExchangeMonths*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__SplitListByExchange:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SplitListByExchange*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SplitListByExchange*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__SplitListBySymbol:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SplitListBySymbol*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SplitListBySymbol*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__CountryList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__CountryList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__CountryList*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__SymbolHistoryPeriod:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SymbolHistoryPeriod*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SymbolHistoryPeriod*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__SymbolHistoryPeriodByDateRange:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SymbolHistoryPeriodByDateRange*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SymbolHistoryPeriodByDateRange*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__QuoteListByDatePeriod:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__QuoteListByDatePeriod*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__QuoteListByDatePeriod*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__QuoteListByDatePeriod2:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__QuoteListByDatePeriod2*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__QuoteListByDatePeriod2*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__SymbolChangesByExchange:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SymbolChangesByExchange*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SymbolChangesByExchange*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__DataClientLatestVersion:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__DataClientLatestVersion*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__DataClientLatestVersion*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__DataFormats:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__DataFormats*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__DataFormats*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__UpdateDataFormat:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__UpdateDataFormat*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__UpdateDataFormat*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__ValidateAccess:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__ValidateAccess*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__ValidateAccess*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__Login_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__Login_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__Login_*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__Login2_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__Login2_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__Login2_*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__Membership_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__Membership_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__Membership_*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__ExchangeList_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__ExchangeList_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__ExchangeList_*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__ExchangeGet_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__ExchangeGet_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__ExchangeGet_*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__SymbolList_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SymbolList_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SymbolList_*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__SymbolList2_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SymbolList2_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SymbolList2_*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__QuoteGet_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__QuoteGet_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__QuoteGet_*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__QuoteList2_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__QuoteList2_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__QuoteList2_*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__SymbolGet_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SymbolGet_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SymbolGet_*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__QuoteList_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__QuoteList_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__QuoteList_*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__NewsList_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__NewsList_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__NewsList_*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__NewsListBySymbol_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__NewsListBySymbol_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__NewsListBySymbol_*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__FundamentalList_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__FundamentalList_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__FundamentalList_*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__TechnicalList_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__TechnicalList_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__TechnicalList_*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__QuoteListByDate_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__QuoteListByDate_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__QuoteListByDate_*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__QuoteListByDate2_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__QuoteListByDate2_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__QuoteListByDate2_*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__SymbolHistory_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SymbolHistory_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SymbolHistory_*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__Top10Gains_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__Top10Gains_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__Top10Gains_*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__Top10Losses_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__Top10Losses_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__Top10Losses_*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__SymbolChart_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SymbolChart_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SymbolChart_*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__ExchangeMonths_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__ExchangeMonths_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__ExchangeMonths_*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__SplitListByExchange_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SplitListByExchange_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SplitListByExchange_*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__SplitListBySymbol_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SplitListBySymbol_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SplitListBySymbol_*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__CountryList_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__CountryList_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__CountryList_*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__SymbolHistoryPeriod_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SymbolHistoryPeriod_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SymbolHistoryPeriod_*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__SymbolHistoryPeriodByDateRange_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SymbolHistoryPeriodByDateRange_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SymbolHistoryPeriodByDateRange_*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__QuoteListByDatePeriod_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__QuoteListByDatePeriod_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__QuoteListByDatePeriod_*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__QuoteListByDatePeriod2_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__QuoteListByDatePeriod2_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__QuoteListByDatePeriod2_*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__SymbolChangesByExchange_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SymbolChangesByExchange_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SymbolChangesByExchange_*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__DataClientLatestVersion_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__DataClientLatestVersion_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__DataClientLatestVersion_*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__DataFormats_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__DataFormats_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__DataFormats_*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__UpdateDataFormat_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__UpdateDataFormat_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__UpdateDataFormat_*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__ValidateAccess_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__ValidateAccess_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__ValidateAccess_*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__LoginResponse__:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__LoginResponse__*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__LoginResponse__*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__Login2Response__:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__Login2Response__*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__Login2Response__*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__MembershipResponse__:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__MembershipResponse__*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__MembershipResponse__*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__ExchangeListResponse__:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__ExchangeListResponse__*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__ExchangeListResponse__*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__ExchangeGetResponse__:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__ExchangeGetResponse__*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__ExchangeGetResponse__*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__SymbolListResponse__:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SymbolListResponse__*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SymbolListResponse__*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__SymbolList2Response__:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SymbolList2Response__*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SymbolList2Response__*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__QuoteGetResponse__:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__QuoteGetResponse__*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__QuoteGetResponse__*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__QuoteList2Response__:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__QuoteList2Response__*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__QuoteList2Response__*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__SymbolGetResponse__:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SymbolGetResponse__*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SymbolGetResponse__*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__QuoteListResponse__:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__QuoteListResponse__*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__QuoteListResponse__*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__NewsListResponse__:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__NewsListResponse__*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__NewsListResponse__*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__NewsListBySymbolResponse__:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__NewsListBySymbolResponse__*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__NewsListBySymbolResponse__*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__FundamentalListResponse__:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__FundamentalListResponse__*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__FundamentalListResponse__*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__TechnicalListResponse__:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__TechnicalListResponse__*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__TechnicalListResponse__*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__QuoteListByDateResponse__:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__QuoteListByDateResponse__*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__QuoteListByDateResponse__*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__QuoteListByDate2Response__:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__QuoteListByDate2Response__*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__QuoteListByDate2Response__*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__SymbolHistoryResponse__:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SymbolHistoryResponse__*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SymbolHistoryResponse__*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__Top10GainsResponse__:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__Top10GainsResponse__*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__Top10GainsResponse__*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__Top10LossesResponse__:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__Top10LossesResponse__*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__Top10LossesResponse__*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__SymbolChartResponse__:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SymbolChartResponse__*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SymbolChartResponse__*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__ExchangeMonthsResponse__:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__ExchangeMonthsResponse__*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__ExchangeMonthsResponse__*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__SplitListByExchangeResponse__:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SplitListByExchangeResponse__*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SplitListByExchangeResponse__*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__SplitListBySymbolResponse__:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SplitListBySymbolResponse__*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SplitListBySymbolResponse__*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__CountryListResponse__:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__CountryListResponse__*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__CountryListResponse__*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__SymbolHistoryPeriodResponse__:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SymbolHistoryPeriodResponse__*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SymbolHistoryPeriodResponse__*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__SymbolHistoryPeriodByDateRangeResponse__:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SymbolHistoryPeriodByDateRangeResponse__*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SymbolHistoryPeriodByDateRangeResponse__*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__QuoteListByDatePeriodResponse__:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__QuoteListByDatePeriodResponse__*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__QuoteListByDatePeriodResponse__*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__QuoteListByDatePeriod2Response__:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__QuoteListByDatePeriod2Response__*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__QuoteListByDatePeriod2Response__*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__SymbolChangesByExchangeResponse__:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SymbolChangesByExchangeResponse__*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SymbolChangesByExchangeResponse__*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__DataClientLatestVersionResponse__:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__DataClientLatestVersionResponse__*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__DataClientLatestVersionResponse__*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__DataFormatsResponse__:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__DataFormatsResponse__*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__DataFormatsResponse__*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__UpdateDataFormatResponse__:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__UpdateDataFormatResponse__*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__UpdateDataFormatResponse__*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__ValidateAccessResponse__:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__ValidateAccessResponse__*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__ValidateAccessResponse__*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__Login___:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__Login___*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__Login___*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__Login2___:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__Login2___*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__Login2___*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__Membership___:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__Membership___*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__Membership___*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__ExchangeList___:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__ExchangeList___*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__ExchangeList___*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__ExchangeGet___:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__ExchangeGet___*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__ExchangeGet___*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__SymbolList___:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SymbolList___*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SymbolList___*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__SymbolList2___:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SymbolList2___*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SymbolList2___*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__QuoteGet___:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__QuoteGet___*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__QuoteGet___*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__QuoteList2___:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__QuoteList2___*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__QuoteList2___*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__SymbolGet___:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SymbolGet___*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SymbolGet___*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__QuoteList___:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__QuoteList___*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__QuoteList___*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__NewsList___:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__NewsList___*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__NewsList___*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__NewsListBySymbol___:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__NewsListBySymbol___*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__NewsListBySymbol___*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__FundamentalList___:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__FundamentalList___*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__FundamentalList___*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__TechnicalList___:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__TechnicalList___*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__TechnicalList___*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__QuoteListByDate___:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__QuoteListByDate___*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__QuoteListByDate___*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__QuoteListByDate2___:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__QuoteListByDate2___*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__QuoteListByDate2___*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__SymbolHistory___:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SymbolHistory___*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SymbolHistory___*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__Top10Gains___:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__Top10Gains___*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__Top10Gains___*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__Top10Losses___:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__Top10Losses___*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__Top10Losses___*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__SymbolChart___:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SymbolChart___*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SymbolChart___*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__ExchangeMonths___:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__ExchangeMonths___*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__ExchangeMonths___*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__SplitListByExchange___:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SplitListByExchange___*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SplitListByExchange___*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__SplitListBySymbol___:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SplitListBySymbol___*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SplitListBySymbol___*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__CountryList___:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__CountryList___*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__CountryList___*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__SymbolHistoryPeriod___:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SymbolHistoryPeriod___*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SymbolHistoryPeriod___*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__SymbolHistoryPeriodByDateRange___:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SymbolHistoryPeriodByDateRange___*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SymbolHistoryPeriodByDateRange___*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__QuoteListByDatePeriod___:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__QuoteListByDatePeriod___*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__QuoteListByDatePeriod___*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__QuoteListByDatePeriod2___:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__QuoteListByDatePeriod2___*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__QuoteListByDatePeriod2___*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__SymbolChangesByExchange___:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SymbolChangesByExchange___*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SymbolChangesByExchange___*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__DataClientLatestVersion___:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__DataClientLatestVersion___*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__DataClientLatestVersion___*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__DataFormats___:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__DataFormats___*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__DataFormats___*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__UpdateDataFormat___:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__UpdateDataFormat___*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__UpdateDataFormat___*>(p->ptr));
		break;
	case SOAP_TYPE_ns___ns1__ValidateAccess___:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__ValidateAccess___*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__ValidateAccess___*>(p->ptr));
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_ns_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Header*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Header*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_ns_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Code*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Code*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_ns_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Detail*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Detail*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_ns_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Reason*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Reason*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_ns_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Fault*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Fault*>(p->ptr));
		break;
#endif
	case SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__DATAFORMAT_USCORECOLUMN:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns1__DATAFORMAT_USCORECOLUMN *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns1__DATAFORMAT_USCORECOLUMN *> *>(p->ptr));
		break;
	case SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__DATAFORMAT:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns1__DATAFORMAT *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns1__DATAFORMAT *> *>(p->ptr));
		break;
	case SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__NEWS:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns1__NEWS *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns1__NEWS *> *>(p->ptr));
		break;
	case SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__SYMBOLCHANGE:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns1__SYMBOLCHANGE *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns1__SYMBOLCHANGE *> *>(p->ptr));
		break;
	case SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__TECHNICAL:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns1__TECHNICAL *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns1__TECHNICAL *> *>(p->ptr));
		break;
	case SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__FUNDAMENTAL:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns1__FUNDAMENTAL *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns1__FUNDAMENTAL *> *>(p->ptr));
		break;
	case SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__CountryBase:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns1__CountryBase *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns1__CountryBase *> *>(p->ptr));
		break;
	case SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__SPLIT:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns1__SPLIT *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns1__SPLIT *> *>(p->ptr));
		break;
	case SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__QUOTE2:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns1__QUOTE2 *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns1__QUOTE2 *> *>(p->ptr));
		break;
	case SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__QUOTE:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns1__QUOTE *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns1__QUOTE *> *>(p->ptr));
		break;
	case SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__SYMBOL2:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns1__SYMBOL2 *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns1__SYMBOL2 *> *>(p->ptr));
		break;
	case SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__SYMBOL:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns1__SYMBOL *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns1__SYMBOL *> *>(p->ptr));
		break;
	case SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__EXCHANGE:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns1__EXCHANGE *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns1__EXCHANGE *> *>(p->ptr));
		break;
	default:
		return SOAP_ERR;
	}
	return SOAP_OK;
}

#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 int SOAP_FMAC4 ns_fbase(int t, int b)
{
	do
	{	switch (t)
		{
		default: return 0;
		}
	}
	while (t != b);
	return 1;
}
#ifdef WIN32
#pragma warning(pop)
#endif

#ifndef WITH_NOIDREF
#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 void SOAP_FMAC4 ns_finsert(struct soap *soap, int t, int tt, void *p, size_t index, const void *q, void **x)
{
	(void)soap; (void)t; (void)p; (void)index; (void)q; (void)x; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__DATAFORMAT_USCORECOLUMN:
		if (t == SOAP_TYPE_ns_ns1__DATAFORMAT_USCORECOLUMN)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__DATAFORMAT_USCORECOLUMN *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__DATAFORMAT_USCORECOLUMN *> *)p)[index] = *(ns1__DATAFORMAT_USCORECOLUMN **)q;
		}
		break;
	case SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__DATAFORMAT:
		if (t == SOAP_TYPE_ns_ns1__DATAFORMAT)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__DATAFORMAT *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__DATAFORMAT *> *)p)[index] = *(ns1__DATAFORMAT **)q;
		}
		break;
	case SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__NEWS:
		if (t == SOAP_TYPE_ns_ns1__NEWS)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__NEWS *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__NEWS *> *)p)[index] = *(ns1__NEWS **)q;
		}
		break;
	case SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__SYMBOLCHANGE:
		if (t == SOAP_TYPE_ns_ns1__SYMBOLCHANGE)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__SYMBOLCHANGE *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__SYMBOLCHANGE *> *)p)[index] = *(ns1__SYMBOLCHANGE **)q;
		}
		break;
	case SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__TECHNICAL:
		if (t == SOAP_TYPE_ns_ns1__TECHNICAL)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__TECHNICAL *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__TECHNICAL *> *)p)[index] = *(ns1__TECHNICAL **)q;
		}
		break;
	case SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__FUNDAMENTAL:
		if (t == SOAP_TYPE_ns_ns1__FUNDAMENTAL)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__FUNDAMENTAL *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__FUNDAMENTAL *> *)p)[index] = *(ns1__FUNDAMENTAL **)q;
		}
		break;
	case SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__CountryBase:
		if (t == SOAP_TYPE_ns_ns1__CountryBase)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__CountryBase *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__CountryBase *> *)p)[index] = *(ns1__CountryBase **)q;
		}
		break;
	case SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__SPLIT:
		if (t == SOAP_TYPE_ns_ns1__SPLIT)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__SPLIT *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__SPLIT *> *)p)[index] = *(ns1__SPLIT **)q;
		}
		break;
	case SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__QUOTE2:
		if (t == SOAP_TYPE_ns_ns1__QUOTE2)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__QUOTE2 *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__QUOTE2 *> *)p)[index] = *(ns1__QUOTE2 **)q;
		}
		break;
	case SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__QUOTE:
		if (t == SOAP_TYPE_ns_ns1__QUOTE)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__QUOTE *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__QUOTE *> *)p)[index] = *(ns1__QUOTE **)q;
		}
		break;
	case SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__SYMBOL2:
		if (t == SOAP_TYPE_ns_ns1__SYMBOL2)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__SYMBOL2 *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__SYMBOL2 *> *)p)[index] = *(ns1__SYMBOL2 **)q;
		}
		break;
	case SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__SYMBOL:
		if (t == SOAP_TYPE_ns_ns1__SYMBOL)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__SYMBOL *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__SYMBOL *> *)p)[index] = *(ns1__SYMBOL **)q;
		}
		break;
	case SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__EXCHANGE:
		if (t == SOAP_TYPE_ns_ns1__EXCHANGE)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__EXCHANGE *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__EXCHANGE *> *)p)[index] = *(ns1__EXCHANGE **)q;
		}
		break;
	case SOAP_TYPE_ns_std__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns_ns1__LOGINRESPONSE:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__LOGINRESPONSE type=%d location=%p object=%p\n", t, p, q));
		*(ns1__LOGINRESPONSE*)p = *(ns1__LOGINRESPONSE*)q;
		break;
	case SOAP_TYPE_ns_ns1__RESPONSE:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__RESPONSE type=%d location=%p object=%p\n", t, p, q));
		*(ns1__RESPONSE*)p = *(ns1__RESPONSE*)q;
		break;
	case SOAP_TYPE_ns_ns1__EXCHANGE:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__EXCHANGE type=%d location=%p object=%p\n", t, p, q));
		*(ns1__EXCHANGE*)p = *(ns1__EXCHANGE*)q;
		break;
	case SOAP_TYPE_ns_ns1__ArrayOfEXCHANGE:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ArrayOfEXCHANGE type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ArrayOfEXCHANGE*)p = *(ns1__ArrayOfEXCHANGE*)q;
		break;
	case SOAP_TYPE_ns_ns1__SYMBOL:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__SYMBOL type=%d location=%p object=%p\n", t, p, q));
		*(ns1__SYMBOL*)p = *(ns1__SYMBOL*)q;
		break;
	case SOAP_TYPE_ns_ns1__ArrayOfSYMBOL:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ArrayOfSYMBOL type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ArrayOfSYMBOL*)p = *(ns1__ArrayOfSYMBOL*)q;
		break;
	case SOAP_TYPE_ns_ns1__ArrayOfSYMBOL2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ArrayOfSYMBOL2 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ArrayOfSYMBOL2*)p = *(ns1__ArrayOfSYMBOL2*)q;
		break;
	case SOAP_TYPE_ns_ns1__SYMBOL2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__SYMBOL2 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__SYMBOL2*)p = *(ns1__SYMBOL2*)q;
		break;
	case SOAP_TYPE_ns_ns1__QUOTE:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__QUOTE type=%d location=%p object=%p\n", t, p, q));
		*(ns1__QUOTE*)p = *(ns1__QUOTE*)q;
		break;
	case SOAP_TYPE_ns_ns1__ArrayOfQUOTE:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ArrayOfQUOTE type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ArrayOfQUOTE*)p = *(ns1__ArrayOfQUOTE*)q;
		break;
	case SOAP_TYPE_ns_ns1__ArrayOfQUOTE2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ArrayOfQUOTE2 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ArrayOfQUOTE2*)p = *(ns1__ArrayOfQUOTE2*)q;
		break;
	case SOAP_TYPE_ns_ns1__QUOTE2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__QUOTE2 type=%d location=%p object=%p\n", t, p, q));
		*(ns1__QUOTE2*)p = *(ns1__QUOTE2*)q;
		break;
	case SOAP_TYPE_ns_ns1__ArrayOfSPLIT:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ArrayOfSPLIT type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ArrayOfSPLIT*)p = *(ns1__ArrayOfSPLIT*)q;
		break;
	case SOAP_TYPE_ns_ns1__SPLIT:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__SPLIT type=%d location=%p object=%p\n", t, p, q));
		*(ns1__SPLIT*)p = *(ns1__SPLIT*)q;
		break;
	case SOAP_TYPE_ns_ns1__ArrayOfCountryBase:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ArrayOfCountryBase type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ArrayOfCountryBase*)p = *(ns1__ArrayOfCountryBase*)q;
		break;
	case SOAP_TYPE_ns_ns1__CountryBase:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__CountryBase type=%d location=%p object=%p\n", t, p, q));
		*(ns1__CountryBase*)p = *(ns1__CountryBase*)q;
		break;
	case SOAP_TYPE_ns_ns1__ArrayOfFUNDAMENTAL:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ArrayOfFUNDAMENTAL type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ArrayOfFUNDAMENTAL*)p = *(ns1__ArrayOfFUNDAMENTAL*)q;
		break;
	case SOAP_TYPE_ns_ns1__FUNDAMENTAL:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__FUNDAMENTAL type=%d location=%p object=%p\n", t, p, q));
		*(ns1__FUNDAMENTAL*)p = *(ns1__FUNDAMENTAL*)q;
		break;
	case SOAP_TYPE_ns_ns1__ArrayOfTECHNICAL:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ArrayOfTECHNICAL type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ArrayOfTECHNICAL*)p = *(ns1__ArrayOfTECHNICAL*)q;
		break;
	case SOAP_TYPE_ns_ns1__TECHNICAL:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__TECHNICAL type=%d location=%p object=%p\n", t, p, q));
		*(ns1__TECHNICAL*)p = *(ns1__TECHNICAL*)q;
		break;
	case SOAP_TYPE_ns_ns1__ArrayOfSYMBOLCHANGE:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ArrayOfSYMBOLCHANGE type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ArrayOfSYMBOLCHANGE*)p = *(ns1__ArrayOfSYMBOLCHANGE*)q;
		break;
	case SOAP_TYPE_ns_ns1__SYMBOLCHANGE:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__SYMBOLCHANGE type=%d location=%p object=%p\n", t, p, q));
		*(ns1__SYMBOLCHANGE*)p = *(ns1__SYMBOLCHANGE*)q;
		break;
	case SOAP_TYPE_ns_ns1__ArrayOfNEWS:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ArrayOfNEWS type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ArrayOfNEWS*)p = *(ns1__ArrayOfNEWS*)q;
		break;
	case SOAP_TYPE_ns_ns1__NEWS:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__NEWS type=%d location=%p object=%p\n", t, p, q));
		*(ns1__NEWS*)p = *(ns1__NEWS*)q;
		break;
	case SOAP_TYPE_ns_ns1__ArrayOfDATAFORMAT:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ArrayOfDATAFORMAT type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ArrayOfDATAFORMAT*)p = *(ns1__ArrayOfDATAFORMAT*)q;
		break;
	case SOAP_TYPE_ns_ns1__DATAFORMAT:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__DATAFORMAT type=%d location=%p object=%p\n", t, p, q));
		*(ns1__DATAFORMAT*)p = *(ns1__DATAFORMAT*)q;
		break;
	case SOAP_TYPE_ns_ns1__ArrayOfDATAFORMAT_USCORECOLUMN:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ArrayOfDATAFORMAT_USCORECOLUMN type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ArrayOfDATAFORMAT_USCORECOLUMN*)p = *(ns1__ArrayOfDATAFORMAT_USCORECOLUMN*)q;
		break;
	case SOAP_TYPE_ns_ns1__DATAFORMAT_USCORECOLUMN:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__DATAFORMAT_USCORECOLUMN type=%d location=%p object=%p\n", t, p, q));
		*(ns1__DATAFORMAT_USCORECOLUMN*)p = *(ns1__DATAFORMAT_USCORECOLUMN*)q;
		break;
	case SOAP_TYPE_ns__ns1__Login:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__Login type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__Login*)p = *(_ns1__Login*)q;
		break;
	case SOAP_TYPE_ns__ns1__LoginResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__LoginResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__LoginResponse*)p = *(_ns1__LoginResponse*)q;
		break;
	case SOAP_TYPE_ns__ns1__Login2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__Login2 type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__Login2*)p = *(_ns1__Login2*)q;
		break;
	case SOAP_TYPE_ns__ns1__Login2Response:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__Login2Response type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__Login2Response*)p = *(_ns1__Login2Response*)q;
		break;
	case SOAP_TYPE_ns__ns1__Membership:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__Membership type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__Membership*)p = *(_ns1__Membership*)q;
		break;
	case SOAP_TYPE_ns__ns1__MembershipResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__MembershipResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__MembershipResponse*)p = *(_ns1__MembershipResponse*)q;
		break;
	case SOAP_TYPE_ns__ns1__ExchangeList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ExchangeList type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ExchangeList*)p = *(_ns1__ExchangeList*)q;
		break;
	case SOAP_TYPE_ns__ns1__ExchangeListResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ExchangeListResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ExchangeListResponse*)p = *(_ns1__ExchangeListResponse*)q;
		break;
	case SOAP_TYPE_ns__ns1__ExchangeGet:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ExchangeGet type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ExchangeGet*)p = *(_ns1__ExchangeGet*)q;
		break;
	case SOAP_TYPE_ns__ns1__ExchangeGetResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ExchangeGetResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ExchangeGetResponse*)p = *(_ns1__ExchangeGetResponse*)q;
		break;
	case SOAP_TYPE_ns__ns1__SymbolList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SymbolList type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SymbolList*)p = *(_ns1__SymbolList*)q;
		break;
	case SOAP_TYPE_ns__ns1__SymbolListResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SymbolListResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SymbolListResponse*)p = *(_ns1__SymbolListResponse*)q;
		break;
	case SOAP_TYPE_ns__ns1__SymbolList2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SymbolList2 type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SymbolList2*)p = *(_ns1__SymbolList2*)q;
		break;
	case SOAP_TYPE_ns__ns1__SymbolList2Response:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SymbolList2Response type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SymbolList2Response*)p = *(_ns1__SymbolList2Response*)q;
		break;
	case SOAP_TYPE_ns__ns1__QuoteGet:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__QuoteGet type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__QuoteGet*)p = *(_ns1__QuoteGet*)q;
		break;
	case SOAP_TYPE_ns__ns1__QuoteGetResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__QuoteGetResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__QuoteGetResponse*)p = *(_ns1__QuoteGetResponse*)q;
		break;
	case SOAP_TYPE_ns__ns1__QuoteList2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__QuoteList2 type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__QuoteList2*)p = *(_ns1__QuoteList2*)q;
		break;
	case SOAP_TYPE_ns__ns1__QuoteList2Response:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__QuoteList2Response type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__QuoteList2Response*)p = *(_ns1__QuoteList2Response*)q;
		break;
	case SOAP_TYPE_ns__ns1__SymbolGet:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SymbolGet type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SymbolGet*)p = *(_ns1__SymbolGet*)q;
		break;
	case SOAP_TYPE_ns__ns1__SymbolGetResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SymbolGetResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SymbolGetResponse*)p = *(_ns1__SymbolGetResponse*)q;
		break;
	case SOAP_TYPE_ns__ns1__QuoteList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__QuoteList type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__QuoteList*)p = *(_ns1__QuoteList*)q;
		break;
	case SOAP_TYPE_ns__ns1__QuoteListResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__QuoteListResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__QuoteListResponse*)p = *(_ns1__QuoteListResponse*)q;
		break;
	case SOAP_TYPE_ns__ns1__NewsList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__NewsList type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__NewsList*)p = *(_ns1__NewsList*)q;
		break;
	case SOAP_TYPE_ns__ns1__NewsListResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__NewsListResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__NewsListResponse*)p = *(_ns1__NewsListResponse*)q;
		break;
	case SOAP_TYPE_ns__ns1__NewsListBySymbol:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__NewsListBySymbol type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__NewsListBySymbol*)p = *(_ns1__NewsListBySymbol*)q;
		break;
	case SOAP_TYPE_ns__ns1__NewsListBySymbolResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__NewsListBySymbolResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__NewsListBySymbolResponse*)p = *(_ns1__NewsListBySymbolResponse*)q;
		break;
	case SOAP_TYPE_ns__ns1__FundamentalList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__FundamentalList type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__FundamentalList*)p = *(_ns1__FundamentalList*)q;
		break;
	case SOAP_TYPE_ns__ns1__FundamentalListResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__FundamentalListResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__FundamentalListResponse*)p = *(_ns1__FundamentalListResponse*)q;
		break;
	case SOAP_TYPE_ns__ns1__TechnicalList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__TechnicalList type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__TechnicalList*)p = *(_ns1__TechnicalList*)q;
		break;
	case SOAP_TYPE_ns__ns1__TechnicalListResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__TechnicalListResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__TechnicalListResponse*)p = *(_ns1__TechnicalListResponse*)q;
		break;
	case SOAP_TYPE_ns__ns1__QuoteListByDate:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__QuoteListByDate type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__QuoteListByDate*)p = *(_ns1__QuoteListByDate*)q;
		break;
	case SOAP_TYPE_ns__ns1__QuoteListByDateResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__QuoteListByDateResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__QuoteListByDateResponse*)p = *(_ns1__QuoteListByDateResponse*)q;
		break;
	case SOAP_TYPE_ns__ns1__QuoteListByDate2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__QuoteListByDate2 type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__QuoteListByDate2*)p = *(_ns1__QuoteListByDate2*)q;
		break;
	case SOAP_TYPE_ns__ns1__QuoteListByDate2Response:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__QuoteListByDate2Response type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__QuoteListByDate2Response*)p = *(_ns1__QuoteListByDate2Response*)q;
		break;
	case SOAP_TYPE_ns__ns1__SymbolHistory:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SymbolHistory type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SymbolHistory*)p = *(_ns1__SymbolHistory*)q;
		break;
	case SOAP_TYPE_ns__ns1__SymbolHistoryResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SymbolHistoryResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SymbolHistoryResponse*)p = *(_ns1__SymbolHistoryResponse*)q;
		break;
	case SOAP_TYPE_ns__ns1__Top10Gains:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__Top10Gains type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__Top10Gains*)p = *(_ns1__Top10Gains*)q;
		break;
	case SOAP_TYPE_ns__ns1__Top10GainsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__Top10GainsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__Top10GainsResponse*)p = *(_ns1__Top10GainsResponse*)q;
		break;
	case SOAP_TYPE_ns__ns1__Top10Losses:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__Top10Losses type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__Top10Losses*)p = *(_ns1__Top10Losses*)q;
		break;
	case SOAP_TYPE_ns__ns1__Top10LossesResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__Top10LossesResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__Top10LossesResponse*)p = *(_ns1__Top10LossesResponse*)q;
		break;
	case SOAP_TYPE_ns__ns1__SymbolChart:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SymbolChart type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SymbolChart*)p = *(_ns1__SymbolChart*)q;
		break;
	case SOAP_TYPE_ns__ns1__SymbolChartResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SymbolChartResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SymbolChartResponse*)p = *(_ns1__SymbolChartResponse*)q;
		break;
	case SOAP_TYPE_ns__ns1__ExchangeMonths:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ExchangeMonths type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ExchangeMonths*)p = *(_ns1__ExchangeMonths*)q;
		break;
	case SOAP_TYPE_ns__ns1__ExchangeMonthsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ExchangeMonthsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ExchangeMonthsResponse*)p = *(_ns1__ExchangeMonthsResponse*)q;
		break;
	case SOAP_TYPE_ns__ns1__SplitListByExchange:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SplitListByExchange type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SplitListByExchange*)p = *(_ns1__SplitListByExchange*)q;
		break;
	case SOAP_TYPE_ns__ns1__SplitListByExchangeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SplitListByExchangeResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SplitListByExchangeResponse*)p = *(_ns1__SplitListByExchangeResponse*)q;
		break;
	case SOAP_TYPE_ns__ns1__SplitListBySymbol:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SplitListBySymbol type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SplitListBySymbol*)p = *(_ns1__SplitListBySymbol*)q;
		break;
	case SOAP_TYPE_ns__ns1__SplitListBySymbolResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SplitListBySymbolResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SplitListBySymbolResponse*)p = *(_ns1__SplitListBySymbolResponse*)q;
		break;
	case SOAP_TYPE_ns__ns1__CountryList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__CountryList type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__CountryList*)p = *(_ns1__CountryList*)q;
		break;
	case SOAP_TYPE_ns__ns1__CountryListResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__CountryListResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__CountryListResponse*)p = *(_ns1__CountryListResponse*)q;
		break;
	case SOAP_TYPE_ns__ns1__SymbolHistoryPeriod:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SymbolHistoryPeriod type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SymbolHistoryPeriod*)p = *(_ns1__SymbolHistoryPeriod*)q;
		break;
	case SOAP_TYPE_ns__ns1__SymbolHistoryPeriodResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SymbolHistoryPeriodResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SymbolHistoryPeriodResponse*)p = *(_ns1__SymbolHistoryPeriodResponse*)q;
		break;
	case SOAP_TYPE_ns__ns1__SymbolHistoryPeriodByDateRange:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SymbolHistoryPeriodByDateRange type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SymbolHistoryPeriodByDateRange*)p = *(_ns1__SymbolHistoryPeriodByDateRange*)q;
		break;
	case SOAP_TYPE_ns__ns1__SymbolHistoryPeriodByDateRangeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SymbolHistoryPeriodByDateRangeResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SymbolHistoryPeriodByDateRangeResponse*)p = *(_ns1__SymbolHistoryPeriodByDateRangeResponse*)q;
		break;
	case SOAP_TYPE_ns__ns1__QuoteListByDatePeriod:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__QuoteListByDatePeriod type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__QuoteListByDatePeriod*)p = *(_ns1__QuoteListByDatePeriod*)q;
		break;
	case SOAP_TYPE_ns__ns1__QuoteListByDatePeriodResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__QuoteListByDatePeriodResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__QuoteListByDatePeriodResponse*)p = *(_ns1__QuoteListByDatePeriodResponse*)q;
		break;
	case SOAP_TYPE_ns__ns1__QuoteListByDatePeriod2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__QuoteListByDatePeriod2 type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__QuoteListByDatePeriod2*)p = *(_ns1__QuoteListByDatePeriod2*)q;
		break;
	case SOAP_TYPE_ns__ns1__QuoteListByDatePeriod2Response:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__QuoteListByDatePeriod2Response type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__QuoteListByDatePeriod2Response*)p = *(_ns1__QuoteListByDatePeriod2Response*)q;
		break;
	case SOAP_TYPE_ns__ns1__SymbolChangesByExchange:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SymbolChangesByExchange type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SymbolChangesByExchange*)p = *(_ns1__SymbolChangesByExchange*)q;
		break;
	case SOAP_TYPE_ns__ns1__SymbolChangesByExchangeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SymbolChangesByExchangeResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SymbolChangesByExchangeResponse*)p = *(_ns1__SymbolChangesByExchangeResponse*)q;
		break;
	case SOAP_TYPE_ns__ns1__DataClientLatestVersion:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__DataClientLatestVersion type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__DataClientLatestVersion*)p = *(_ns1__DataClientLatestVersion*)q;
		break;
	case SOAP_TYPE_ns__ns1__DataClientLatestVersionResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__DataClientLatestVersionResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__DataClientLatestVersionResponse*)p = *(_ns1__DataClientLatestVersionResponse*)q;
		break;
	case SOAP_TYPE_ns__ns1__DataFormats:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__DataFormats type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__DataFormats*)p = *(_ns1__DataFormats*)q;
		break;
	case SOAP_TYPE_ns__ns1__DataFormatsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__DataFormatsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__DataFormatsResponse*)p = *(_ns1__DataFormatsResponse*)q;
		break;
	case SOAP_TYPE_ns__ns1__UpdateDataFormat:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__UpdateDataFormat type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__UpdateDataFormat*)p = *(_ns1__UpdateDataFormat*)q;
		break;
	case SOAP_TYPE_ns__ns1__UpdateDataFormatResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__UpdateDataFormatResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__UpdateDataFormatResponse*)p = *(_ns1__UpdateDataFormatResponse*)q;
		break;
	case SOAP_TYPE_ns__ns1__ValidateAccess:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ValidateAccess type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ValidateAccess*)p = *(_ns1__ValidateAccess*)q;
		break;
	case SOAP_TYPE_ns__ns1__ValidateAccessResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ValidateAccessResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ValidateAccessResponse*)p = *(_ns1__ValidateAccessResponse*)q;
		break;
	case SOAP_TYPE_ns___ns1__Login:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__Login type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__Login*)p = *(struct __ns1__Login*)q;
		break;
	case SOAP_TYPE_ns___ns1__Login2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__Login2 type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__Login2*)p = *(struct __ns1__Login2*)q;
		break;
	case SOAP_TYPE_ns___ns1__Membership:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__Membership type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__Membership*)p = *(struct __ns1__Membership*)q;
		break;
	case SOAP_TYPE_ns___ns1__ExchangeList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ExchangeList type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ExchangeList*)p = *(struct __ns1__ExchangeList*)q;
		break;
	case SOAP_TYPE_ns___ns1__ExchangeGet:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ExchangeGet type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ExchangeGet*)p = *(struct __ns1__ExchangeGet*)q;
		break;
	case SOAP_TYPE_ns___ns1__SymbolList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SymbolList type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SymbolList*)p = *(struct __ns1__SymbolList*)q;
		break;
	case SOAP_TYPE_ns___ns1__SymbolList2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SymbolList2 type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SymbolList2*)p = *(struct __ns1__SymbolList2*)q;
		break;
	case SOAP_TYPE_ns___ns1__QuoteGet:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__QuoteGet type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__QuoteGet*)p = *(struct __ns1__QuoteGet*)q;
		break;
	case SOAP_TYPE_ns___ns1__QuoteList2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__QuoteList2 type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__QuoteList2*)p = *(struct __ns1__QuoteList2*)q;
		break;
	case SOAP_TYPE_ns___ns1__SymbolGet:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SymbolGet type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SymbolGet*)p = *(struct __ns1__SymbolGet*)q;
		break;
	case SOAP_TYPE_ns___ns1__QuoteList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__QuoteList type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__QuoteList*)p = *(struct __ns1__QuoteList*)q;
		break;
	case SOAP_TYPE_ns___ns1__NewsList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__NewsList type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__NewsList*)p = *(struct __ns1__NewsList*)q;
		break;
	case SOAP_TYPE_ns___ns1__NewsListBySymbol:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__NewsListBySymbol type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__NewsListBySymbol*)p = *(struct __ns1__NewsListBySymbol*)q;
		break;
	case SOAP_TYPE_ns___ns1__FundamentalList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__FundamentalList type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__FundamentalList*)p = *(struct __ns1__FundamentalList*)q;
		break;
	case SOAP_TYPE_ns___ns1__TechnicalList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__TechnicalList type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__TechnicalList*)p = *(struct __ns1__TechnicalList*)q;
		break;
	case SOAP_TYPE_ns___ns1__QuoteListByDate:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__QuoteListByDate type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__QuoteListByDate*)p = *(struct __ns1__QuoteListByDate*)q;
		break;
	case SOAP_TYPE_ns___ns1__QuoteListByDate2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__QuoteListByDate2 type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__QuoteListByDate2*)p = *(struct __ns1__QuoteListByDate2*)q;
		break;
	case SOAP_TYPE_ns___ns1__SymbolHistory:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SymbolHistory type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SymbolHistory*)p = *(struct __ns1__SymbolHistory*)q;
		break;
	case SOAP_TYPE_ns___ns1__Top10Gains:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__Top10Gains type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__Top10Gains*)p = *(struct __ns1__Top10Gains*)q;
		break;
	case SOAP_TYPE_ns___ns1__Top10Losses:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__Top10Losses type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__Top10Losses*)p = *(struct __ns1__Top10Losses*)q;
		break;
	case SOAP_TYPE_ns___ns1__SymbolChart:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SymbolChart type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SymbolChart*)p = *(struct __ns1__SymbolChart*)q;
		break;
	case SOAP_TYPE_ns___ns1__ExchangeMonths:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ExchangeMonths type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ExchangeMonths*)p = *(struct __ns1__ExchangeMonths*)q;
		break;
	case SOAP_TYPE_ns___ns1__SplitListByExchange:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SplitListByExchange type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SplitListByExchange*)p = *(struct __ns1__SplitListByExchange*)q;
		break;
	case SOAP_TYPE_ns___ns1__SplitListBySymbol:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SplitListBySymbol type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SplitListBySymbol*)p = *(struct __ns1__SplitListBySymbol*)q;
		break;
	case SOAP_TYPE_ns___ns1__CountryList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__CountryList type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__CountryList*)p = *(struct __ns1__CountryList*)q;
		break;
	case SOAP_TYPE_ns___ns1__SymbolHistoryPeriod:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SymbolHistoryPeriod type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SymbolHistoryPeriod*)p = *(struct __ns1__SymbolHistoryPeriod*)q;
		break;
	case SOAP_TYPE_ns___ns1__SymbolHistoryPeriodByDateRange:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SymbolHistoryPeriodByDateRange type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SymbolHistoryPeriodByDateRange*)p = *(struct __ns1__SymbolHistoryPeriodByDateRange*)q;
		break;
	case SOAP_TYPE_ns___ns1__QuoteListByDatePeriod:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__QuoteListByDatePeriod type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__QuoteListByDatePeriod*)p = *(struct __ns1__QuoteListByDatePeriod*)q;
		break;
	case SOAP_TYPE_ns___ns1__QuoteListByDatePeriod2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__QuoteListByDatePeriod2 type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__QuoteListByDatePeriod2*)p = *(struct __ns1__QuoteListByDatePeriod2*)q;
		break;
	case SOAP_TYPE_ns___ns1__SymbolChangesByExchange:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SymbolChangesByExchange type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SymbolChangesByExchange*)p = *(struct __ns1__SymbolChangesByExchange*)q;
		break;
	case SOAP_TYPE_ns___ns1__DataClientLatestVersion:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__DataClientLatestVersion type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__DataClientLatestVersion*)p = *(struct __ns1__DataClientLatestVersion*)q;
		break;
	case SOAP_TYPE_ns___ns1__DataFormats:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__DataFormats type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__DataFormats*)p = *(struct __ns1__DataFormats*)q;
		break;
	case SOAP_TYPE_ns___ns1__UpdateDataFormat:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__UpdateDataFormat type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__UpdateDataFormat*)p = *(struct __ns1__UpdateDataFormat*)q;
		break;
	case SOAP_TYPE_ns___ns1__ValidateAccess:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ValidateAccess type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ValidateAccess*)p = *(struct __ns1__ValidateAccess*)q;
		break;
	case SOAP_TYPE_ns___ns1__Login_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__Login_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__Login_*)p = *(struct __ns1__Login_*)q;
		break;
	case SOAP_TYPE_ns___ns1__Login2_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__Login2_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__Login2_*)p = *(struct __ns1__Login2_*)q;
		break;
	case SOAP_TYPE_ns___ns1__Membership_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__Membership_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__Membership_*)p = *(struct __ns1__Membership_*)q;
		break;
	case SOAP_TYPE_ns___ns1__ExchangeList_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ExchangeList_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ExchangeList_*)p = *(struct __ns1__ExchangeList_*)q;
		break;
	case SOAP_TYPE_ns___ns1__ExchangeGet_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ExchangeGet_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ExchangeGet_*)p = *(struct __ns1__ExchangeGet_*)q;
		break;
	case SOAP_TYPE_ns___ns1__SymbolList_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SymbolList_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SymbolList_*)p = *(struct __ns1__SymbolList_*)q;
		break;
	case SOAP_TYPE_ns___ns1__SymbolList2_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SymbolList2_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SymbolList2_*)p = *(struct __ns1__SymbolList2_*)q;
		break;
	case SOAP_TYPE_ns___ns1__QuoteGet_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__QuoteGet_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__QuoteGet_*)p = *(struct __ns1__QuoteGet_*)q;
		break;
	case SOAP_TYPE_ns___ns1__QuoteList2_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__QuoteList2_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__QuoteList2_*)p = *(struct __ns1__QuoteList2_*)q;
		break;
	case SOAP_TYPE_ns___ns1__SymbolGet_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SymbolGet_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SymbolGet_*)p = *(struct __ns1__SymbolGet_*)q;
		break;
	case SOAP_TYPE_ns___ns1__QuoteList_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__QuoteList_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__QuoteList_*)p = *(struct __ns1__QuoteList_*)q;
		break;
	case SOAP_TYPE_ns___ns1__NewsList_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__NewsList_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__NewsList_*)p = *(struct __ns1__NewsList_*)q;
		break;
	case SOAP_TYPE_ns___ns1__NewsListBySymbol_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__NewsListBySymbol_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__NewsListBySymbol_*)p = *(struct __ns1__NewsListBySymbol_*)q;
		break;
	case SOAP_TYPE_ns___ns1__FundamentalList_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__FundamentalList_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__FundamentalList_*)p = *(struct __ns1__FundamentalList_*)q;
		break;
	case SOAP_TYPE_ns___ns1__TechnicalList_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__TechnicalList_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__TechnicalList_*)p = *(struct __ns1__TechnicalList_*)q;
		break;
	case SOAP_TYPE_ns___ns1__QuoteListByDate_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__QuoteListByDate_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__QuoteListByDate_*)p = *(struct __ns1__QuoteListByDate_*)q;
		break;
	case SOAP_TYPE_ns___ns1__QuoteListByDate2_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__QuoteListByDate2_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__QuoteListByDate2_*)p = *(struct __ns1__QuoteListByDate2_*)q;
		break;
	case SOAP_TYPE_ns___ns1__SymbolHistory_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SymbolHistory_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SymbolHistory_*)p = *(struct __ns1__SymbolHistory_*)q;
		break;
	case SOAP_TYPE_ns___ns1__Top10Gains_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__Top10Gains_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__Top10Gains_*)p = *(struct __ns1__Top10Gains_*)q;
		break;
	case SOAP_TYPE_ns___ns1__Top10Losses_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__Top10Losses_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__Top10Losses_*)p = *(struct __ns1__Top10Losses_*)q;
		break;
	case SOAP_TYPE_ns___ns1__SymbolChart_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SymbolChart_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SymbolChart_*)p = *(struct __ns1__SymbolChart_*)q;
		break;
	case SOAP_TYPE_ns___ns1__ExchangeMonths_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ExchangeMonths_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ExchangeMonths_*)p = *(struct __ns1__ExchangeMonths_*)q;
		break;
	case SOAP_TYPE_ns___ns1__SplitListByExchange_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SplitListByExchange_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SplitListByExchange_*)p = *(struct __ns1__SplitListByExchange_*)q;
		break;
	case SOAP_TYPE_ns___ns1__SplitListBySymbol_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SplitListBySymbol_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SplitListBySymbol_*)p = *(struct __ns1__SplitListBySymbol_*)q;
		break;
	case SOAP_TYPE_ns___ns1__CountryList_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__CountryList_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__CountryList_*)p = *(struct __ns1__CountryList_*)q;
		break;
	case SOAP_TYPE_ns___ns1__SymbolHistoryPeriod_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SymbolHistoryPeriod_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SymbolHistoryPeriod_*)p = *(struct __ns1__SymbolHistoryPeriod_*)q;
		break;
	case SOAP_TYPE_ns___ns1__SymbolHistoryPeriodByDateRange_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SymbolHistoryPeriodByDateRange_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SymbolHistoryPeriodByDateRange_*)p = *(struct __ns1__SymbolHistoryPeriodByDateRange_*)q;
		break;
	case SOAP_TYPE_ns___ns1__QuoteListByDatePeriod_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__QuoteListByDatePeriod_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__QuoteListByDatePeriod_*)p = *(struct __ns1__QuoteListByDatePeriod_*)q;
		break;
	case SOAP_TYPE_ns___ns1__QuoteListByDatePeriod2_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__QuoteListByDatePeriod2_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__QuoteListByDatePeriod2_*)p = *(struct __ns1__QuoteListByDatePeriod2_*)q;
		break;
	case SOAP_TYPE_ns___ns1__SymbolChangesByExchange_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SymbolChangesByExchange_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SymbolChangesByExchange_*)p = *(struct __ns1__SymbolChangesByExchange_*)q;
		break;
	case SOAP_TYPE_ns___ns1__DataClientLatestVersion_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__DataClientLatestVersion_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__DataClientLatestVersion_*)p = *(struct __ns1__DataClientLatestVersion_*)q;
		break;
	case SOAP_TYPE_ns___ns1__DataFormats_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__DataFormats_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__DataFormats_*)p = *(struct __ns1__DataFormats_*)q;
		break;
	case SOAP_TYPE_ns___ns1__UpdateDataFormat_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__UpdateDataFormat_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__UpdateDataFormat_*)p = *(struct __ns1__UpdateDataFormat_*)q;
		break;
	case SOAP_TYPE_ns___ns1__ValidateAccess_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ValidateAccess_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ValidateAccess_*)p = *(struct __ns1__ValidateAccess_*)q;
		break;
	case SOAP_TYPE_ns___ns1__LoginResponse__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__LoginResponse__ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__LoginResponse__*)p = *(struct __ns1__LoginResponse__*)q;
		break;
	case SOAP_TYPE_ns___ns1__Login2Response__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__Login2Response__ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__Login2Response__*)p = *(struct __ns1__Login2Response__*)q;
		break;
	case SOAP_TYPE_ns___ns1__MembershipResponse__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__MembershipResponse__ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__MembershipResponse__*)p = *(struct __ns1__MembershipResponse__*)q;
		break;
	case SOAP_TYPE_ns___ns1__ExchangeListResponse__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ExchangeListResponse__ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ExchangeListResponse__*)p = *(struct __ns1__ExchangeListResponse__*)q;
		break;
	case SOAP_TYPE_ns___ns1__ExchangeGetResponse__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ExchangeGetResponse__ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ExchangeGetResponse__*)p = *(struct __ns1__ExchangeGetResponse__*)q;
		break;
	case SOAP_TYPE_ns___ns1__SymbolListResponse__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SymbolListResponse__ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SymbolListResponse__*)p = *(struct __ns1__SymbolListResponse__*)q;
		break;
	case SOAP_TYPE_ns___ns1__SymbolList2Response__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SymbolList2Response__ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SymbolList2Response__*)p = *(struct __ns1__SymbolList2Response__*)q;
		break;
	case SOAP_TYPE_ns___ns1__QuoteGetResponse__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__QuoteGetResponse__ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__QuoteGetResponse__*)p = *(struct __ns1__QuoteGetResponse__*)q;
		break;
	case SOAP_TYPE_ns___ns1__QuoteList2Response__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__QuoteList2Response__ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__QuoteList2Response__*)p = *(struct __ns1__QuoteList2Response__*)q;
		break;
	case SOAP_TYPE_ns___ns1__SymbolGetResponse__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SymbolGetResponse__ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SymbolGetResponse__*)p = *(struct __ns1__SymbolGetResponse__*)q;
		break;
	case SOAP_TYPE_ns___ns1__QuoteListResponse__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__QuoteListResponse__ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__QuoteListResponse__*)p = *(struct __ns1__QuoteListResponse__*)q;
		break;
	case SOAP_TYPE_ns___ns1__NewsListResponse__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__NewsListResponse__ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__NewsListResponse__*)p = *(struct __ns1__NewsListResponse__*)q;
		break;
	case SOAP_TYPE_ns___ns1__NewsListBySymbolResponse__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__NewsListBySymbolResponse__ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__NewsListBySymbolResponse__*)p = *(struct __ns1__NewsListBySymbolResponse__*)q;
		break;
	case SOAP_TYPE_ns___ns1__FundamentalListResponse__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__FundamentalListResponse__ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__FundamentalListResponse__*)p = *(struct __ns1__FundamentalListResponse__*)q;
		break;
	case SOAP_TYPE_ns___ns1__TechnicalListResponse__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__TechnicalListResponse__ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__TechnicalListResponse__*)p = *(struct __ns1__TechnicalListResponse__*)q;
		break;
	case SOAP_TYPE_ns___ns1__QuoteListByDateResponse__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__QuoteListByDateResponse__ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__QuoteListByDateResponse__*)p = *(struct __ns1__QuoteListByDateResponse__*)q;
		break;
	case SOAP_TYPE_ns___ns1__QuoteListByDate2Response__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__QuoteListByDate2Response__ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__QuoteListByDate2Response__*)p = *(struct __ns1__QuoteListByDate2Response__*)q;
		break;
	case SOAP_TYPE_ns___ns1__SymbolHistoryResponse__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SymbolHistoryResponse__ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SymbolHistoryResponse__*)p = *(struct __ns1__SymbolHistoryResponse__*)q;
		break;
	case SOAP_TYPE_ns___ns1__Top10GainsResponse__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__Top10GainsResponse__ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__Top10GainsResponse__*)p = *(struct __ns1__Top10GainsResponse__*)q;
		break;
	case SOAP_TYPE_ns___ns1__Top10LossesResponse__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__Top10LossesResponse__ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__Top10LossesResponse__*)p = *(struct __ns1__Top10LossesResponse__*)q;
		break;
	case SOAP_TYPE_ns___ns1__SymbolChartResponse__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SymbolChartResponse__ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SymbolChartResponse__*)p = *(struct __ns1__SymbolChartResponse__*)q;
		break;
	case SOAP_TYPE_ns___ns1__ExchangeMonthsResponse__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ExchangeMonthsResponse__ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ExchangeMonthsResponse__*)p = *(struct __ns1__ExchangeMonthsResponse__*)q;
		break;
	case SOAP_TYPE_ns___ns1__SplitListByExchangeResponse__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SplitListByExchangeResponse__ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SplitListByExchangeResponse__*)p = *(struct __ns1__SplitListByExchangeResponse__*)q;
		break;
	case SOAP_TYPE_ns___ns1__SplitListBySymbolResponse__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SplitListBySymbolResponse__ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SplitListBySymbolResponse__*)p = *(struct __ns1__SplitListBySymbolResponse__*)q;
		break;
	case SOAP_TYPE_ns___ns1__CountryListResponse__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__CountryListResponse__ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__CountryListResponse__*)p = *(struct __ns1__CountryListResponse__*)q;
		break;
	case SOAP_TYPE_ns___ns1__SymbolHistoryPeriodResponse__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SymbolHistoryPeriodResponse__ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SymbolHistoryPeriodResponse__*)p = *(struct __ns1__SymbolHistoryPeriodResponse__*)q;
		break;
	case SOAP_TYPE_ns___ns1__SymbolHistoryPeriodByDateRangeResponse__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SymbolHistoryPeriodByDateRangeResponse__ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SymbolHistoryPeriodByDateRangeResponse__*)p = *(struct __ns1__SymbolHistoryPeriodByDateRangeResponse__*)q;
		break;
	case SOAP_TYPE_ns___ns1__QuoteListByDatePeriodResponse__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__QuoteListByDatePeriodResponse__ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__QuoteListByDatePeriodResponse__*)p = *(struct __ns1__QuoteListByDatePeriodResponse__*)q;
		break;
	case SOAP_TYPE_ns___ns1__QuoteListByDatePeriod2Response__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__QuoteListByDatePeriod2Response__ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__QuoteListByDatePeriod2Response__*)p = *(struct __ns1__QuoteListByDatePeriod2Response__*)q;
		break;
	case SOAP_TYPE_ns___ns1__SymbolChangesByExchangeResponse__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SymbolChangesByExchangeResponse__ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SymbolChangesByExchangeResponse__*)p = *(struct __ns1__SymbolChangesByExchangeResponse__*)q;
		break;
	case SOAP_TYPE_ns___ns1__DataClientLatestVersionResponse__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__DataClientLatestVersionResponse__ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__DataClientLatestVersionResponse__*)p = *(struct __ns1__DataClientLatestVersionResponse__*)q;
		break;
	case SOAP_TYPE_ns___ns1__DataFormatsResponse__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__DataFormatsResponse__ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__DataFormatsResponse__*)p = *(struct __ns1__DataFormatsResponse__*)q;
		break;
	case SOAP_TYPE_ns___ns1__UpdateDataFormatResponse__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__UpdateDataFormatResponse__ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__UpdateDataFormatResponse__*)p = *(struct __ns1__UpdateDataFormatResponse__*)q;
		break;
	case SOAP_TYPE_ns___ns1__ValidateAccessResponse__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ValidateAccessResponse__ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ValidateAccessResponse__*)p = *(struct __ns1__ValidateAccessResponse__*)q;
		break;
	case SOAP_TYPE_ns___ns1__Login___:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__Login___ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__Login___*)p = *(struct __ns1__Login___*)q;
		break;
	case SOAP_TYPE_ns___ns1__Login2___:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__Login2___ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__Login2___*)p = *(struct __ns1__Login2___*)q;
		break;
	case SOAP_TYPE_ns___ns1__Membership___:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__Membership___ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__Membership___*)p = *(struct __ns1__Membership___*)q;
		break;
	case SOAP_TYPE_ns___ns1__ExchangeList___:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ExchangeList___ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ExchangeList___*)p = *(struct __ns1__ExchangeList___*)q;
		break;
	case SOAP_TYPE_ns___ns1__ExchangeGet___:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ExchangeGet___ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ExchangeGet___*)p = *(struct __ns1__ExchangeGet___*)q;
		break;
	case SOAP_TYPE_ns___ns1__SymbolList___:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SymbolList___ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SymbolList___*)p = *(struct __ns1__SymbolList___*)q;
		break;
	case SOAP_TYPE_ns___ns1__SymbolList2___:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SymbolList2___ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SymbolList2___*)p = *(struct __ns1__SymbolList2___*)q;
		break;
	case SOAP_TYPE_ns___ns1__QuoteGet___:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__QuoteGet___ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__QuoteGet___*)p = *(struct __ns1__QuoteGet___*)q;
		break;
	case SOAP_TYPE_ns___ns1__QuoteList2___:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__QuoteList2___ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__QuoteList2___*)p = *(struct __ns1__QuoteList2___*)q;
		break;
	case SOAP_TYPE_ns___ns1__SymbolGet___:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SymbolGet___ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SymbolGet___*)p = *(struct __ns1__SymbolGet___*)q;
		break;
	case SOAP_TYPE_ns___ns1__QuoteList___:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__QuoteList___ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__QuoteList___*)p = *(struct __ns1__QuoteList___*)q;
		break;
	case SOAP_TYPE_ns___ns1__NewsList___:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__NewsList___ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__NewsList___*)p = *(struct __ns1__NewsList___*)q;
		break;
	case SOAP_TYPE_ns___ns1__NewsListBySymbol___:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__NewsListBySymbol___ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__NewsListBySymbol___*)p = *(struct __ns1__NewsListBySymbol___*)q;
		break;
	case SOAP_TYPE_ns___ns1__FundamentalList___:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__FundamentalList___ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__FundamentalList___*)p = *(struct __ns1__FundamentalList___*)q;
		break;
	case SOAP_TYPE_ns___ns1__TechnicalList___:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__TechnicalList___ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__TechnicalList___*)p = *(struct __ns1__TechnicalList___*)q;
		break;
	case SOAP_TYPE_ns___ns1__QuoteListByDate___:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__QuoteListByDate___ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__QuoteListByDate___*)p = *(struct __ns1__QuoteListByDate___*)q;
		break;
	case SOAP_TYPE_ns___ns1__QuoteListByDate2___:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__QuoteListByDate2___ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__QuoteListByDate2___*)p = *(struct __ns1__QuoteListByDate2___*)q;
		break;
	case SOAP_TYPE_ns___ns1__SymbolHistory___:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SymbolHistory___ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SymbolHistory___*)p = *(struct __ns1__SymbolHistory___*)q;
		break;
	case SOAP_TYPE_ns___ns1__Top10Gains___:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__Top10Gains___ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__Top10Gains___*)p = *(struct __ns1__Top10Gains___*)q;
		break;
	case SOAP_TYPE_ns___ns1__Top10Losses___:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__Top10Losses___ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__Top10Losses___*)p = *(struct __ns1__Top10Losses___*)q;
		break;
	case SOAP_TYPE_ns___ns1__SymbolChart___:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SymbolChart___ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SymbolChart___*)p = *(struct __ns1__SymbolChart___*)q;
		break;
	case SOAP_TYPE_ns___ns1__ExchangeMonths___:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ExchangeMonths___ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ExchangeMonths___*)p = *(struct __ns1__ExchangeMonths___*)q;
		break;
	case SOAP_TYPE_ns___ns1__SplitListByExchange___:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SplitListByExchange___ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SplitListByExchange___*)p = *(struct __ns1__SplitListByExchange___*)q;
		break;
	case SOAP_TYPE_ns___ns1__SplitListBySymbol___:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SplitListBySymbol___ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SplitListBySymbol___*)p = *(struct __ns1__SplitListBySymbol___*)q;
		break;
	case SOAP_TYPE_ns___ns1__CountryList___:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__CountryList___ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__CountryList___*)p = *(struct __ns1__CountryList___*)q;
		break;
	case SOAP_TYPE_ns___ns1__SymbolHistoryPeriod___:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SymbolHistoryPeriod___ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SymbolHistoryPeriod___*)p = *(struct __ns1__SymbolHistoryPeriod___*)q;
		break;
	case SOAP_TYPE_ns___ns1__SymbolHistoryPeriodByDateRange___:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SymbolHistoryPeriodByDateRange___ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SymbolHistoryPeriodByDateRange___*)p = *(struct __ns1__SymbolHistoryPeriodByDateRange___*)q;
		break;
	case SOAP_TYPE_ns___ns1__QuoteListByDatePeriod___:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__QuoteListByDatePeriod___ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__QuoteListByDatePeriod___*)p = *(struct __ns1__QuoteListByDatePeriod___*)q;
		break;
	case SOAP_TYPE_ns___ns1__QuoteListByDatePeriod2___:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__QuoteListByDatePeriod2___ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__QuoteListByDatePeriod2___*)p = *(struct __ns1__QuoteListByDatePeriod2___*)q;
		break;
	case SOAP_TYPE_ns___ns1__SymbolChangesByExchange___:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SymbolChangesByExchange___ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SymbolChangesByExchange___*)p = *(struct __ns1__SymbolChangesByExchange___*)q;
		break;
	case SOAP_TYPE_ns___ns1__DataClientLatestVersion___:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__DataClientLatestVersion___ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__DataClientLatestVersion___*)p = *(struct __ns1__DataClientLatestVersion___*)q;
		break;
	case SOAP_TYPE_ns___ns1__DataFormats___:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__DataFormats___ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__DataFormats___*)p = *(struct __ns1__DataFormats___*)q;
		break;
	case SOAP_TYPE_ns___ns1__UpdateDataFormat___:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__UpdateDataFormat___ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__UpdateDataFormat___*)p = *(struct __ns1__UpdateDataFormat___*)q;
		break;
	case SOAP_TYPE_ns___ns1__ValidateAccess___:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ValidateAccess___ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ValidateAccess___*)p = *(struct __ns1__ValidateAccess___*)q;
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_ns_SOAP_ENV__Header:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Header type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_ns_SOAP_ENV__Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Code type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_ns_SOAP_ENV__Detail:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Detail type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_ns_SOAP_ENV__Reason:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Reason type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_ns_SOAP_ENV__Fault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Fault type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
		break;
#endif
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type = %d in %d\n", t, tt));
	}
}
#ifdef WIN32
#pragma warning(pop)
#endif
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_ns_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	a = soap_inbyte(soap, tag, a, type, SOAP_TYPE_ns_byte);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	if (soap_out_byte(soap, tag?tag:"byte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_ns_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_ns_int);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_int(soap, tag?tag:"int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_LONG64(struct soap *soap, LONG64 *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_LONG64
	*a = SOAP_DEFAULT_LONG64;
#else
	*a = (LONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_ns_LONG64);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{
	a = soap_inLONG64(soap, tag, a, type, SOAP_TYPE_ns_LONG64);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	if (soap_out_LONG64(soap, tag?tag:"long", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_LONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_double(struct soap *soap, double *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_double
	*a = SOAP_DEFAULT_double;
#else
	*a = (double)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_ns_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{
	a = soap_indouble(soap, tag, a, type, SOAP_TYPE_ns_double);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	if (soap_out_double(soap, tag?tag:"double", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dateTime(struct soap *soap, time_t *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_dateTime
	*a = SOAP_DEFAULT_dateTime;
#else
	*a = (time_t)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dateTime(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_ns_dateTime);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_dateTime(struct soap *soap, const char *tag, time_t *a, const char *type)
{
	a = soap_indateTime(soap, tag, a, type, SOAP_TYPE_ns_dateTime);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dateTime(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	if (soap_out_dateTime(soap, tag?tag:"dateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_dateTime(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_dateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (LONG64)false, "false" },
	{ (LONG64)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_bool, n != 0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns_bool, sizeof(bool), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns_bool, SOAP_TYPE_ns_bool, sizeof(bool), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	if (soap_out_bool(soap, tag?tag:"boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns_std__string, sizeof(std::string), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns_std__string, sizeof(std::string), soap->type, soap->arrayType, ns_instantiate, ns_fbase), 0, SOAP_TYPE_ns_std__string, SOAP_TYPE_ns_std__string, sizeof(std::string), 0, ns_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::string *p;
	size_t k = sizeof(std::string);
	if (n < 0)
	{	p = SOAP_NEW(std::string);
	}
	else
	{	p = SOAP_NEW_ARRAY(std::string, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::string location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns_std__string, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_std__string(soap, tag?tag:"string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ValidateAccessResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__ValidateAccessResponse::ValidateAccessResult = NULL;
	/* transient soap skipped */
}

void _ns1__ValidateAccessResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RESPONSE(soap, &this->_ns1__ValidateAccessResponse::ValidateAccessResult);
#endif
}

int _ns1__ValidateAccessResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ValidateAccessResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ValidateAccessResponse(struct soap *soap, const char *tag, int id, const _ns1__ValidateAccessResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__ValidateAccessResponse), type))
		return soap->error;
	if (a->ValidateAccessResult)
		soap_element_result(soap, "ns1:ValidateAccessResult");
	if (soap_out_PointerTons1__RESPONSE(soap, "ns1:ValidateAccessResult", -1, &a->_ns1__ValidateAccessResponse::ValidateAccessResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ValidateAccessResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ValidateAccessResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ValidateAccessResponse * SOAP_FMAC4 soap_in__ns1__ValidateAccessResponse(struct soap *soap, const char *tag, _ns1__ValidateAccessResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ValidateAccessResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__ValidateAccessResponse, sizeof(_ns1__ValidateAccessResponse), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ValidateAccessResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ValidateAccessResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RESPONSE(soap, "ns1:ValidateAccessResult", &a->_ns1__ValidateAccessResponse::ValidateAccessResult, "ns1:RESPONSE"))
				{	soap_flag_ValidateAccessResult1--;
					continue;
				}
			soap_check_result(soap, "ns1:ValidateAccessResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__ValidateAccessResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__ValidateAccessResponse, SOAP_TYPE_ns__ns1__ValidateAccessResponse, sizeof(_ns1__ValidateAccessResponse), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ValidateAccessResponse * SOAP_FMAC2 soap_instantiate__ns1__ValidateAccessResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ValidateAccessResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ValidateAccessResponse *p;
	size_t k = sizeof(_ns1__ValidateAccessResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__ValidateAccessResponse);
		if (p)
			((_ns1__ValidateAccessResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__ValidateAccessResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__ValidateAccessResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ValidateAccessResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__ValidateAccessResponse, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__ValidateAccessResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:ValidateAccessResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ValidateAccessResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ValidateAccessResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ValidateAccessResponse * SOAP_FMAC4 soap_get__ns1__ValidateAccessResponse(struct soap *soap, _ns1__ValidateAccessResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ValidateAccessResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ValidateAccess::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__ValidateAccess::Token = NULL;
	this->_ns1__ValidateAccess::Exchange = NULL;
	this->_ns1__ValidateAccess::QuoteDate = NULL;
	this->_ns1__ValidateAccess::Period = NULL;
	/* transient soap skipped */
}

void _ns1__ValidateAccess::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__ValidateAccess::Token);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__ValidateAccess::Exchange);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__ValidateAccess::QuoteDate);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__ValidateAccess::Period);
#endif
}

int _ns1__ValidateAccess::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ValidateAccess(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ValidateAccess(struct soap *soap, const char *tag, int id, const _ns1__ValidateAccess *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__ValidateAccess), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Token", -1, &a->_ns1__ValidateAccess::Token, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Exchange", -1, &a->_ns1__ValidateAccess::Exchange, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:QuoteDate", -1, &a->_ns1__ValidateAccess::QuoteDate, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Period", -1, &a->_ns1__ValidateAccess::Period, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ValidateAccess::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ValidateAccess(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ValidateAccess * SOAP_FMAC4 soap_in__ns1__ValidateAccess(struct soap *soap, const char *tag, _ns1__ValidateAccess *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ValidateAccess *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__ValidateAccess, sizeof(_ns1__ValidateAccess), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	size_t soap_flag_Exchange1 = 1;
	size_t soap_flag_QuoteDate1 = 1;
	size_t soap_flag_Period1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Token", &a->_ns1__ValidateAccess::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap_flag_Exchange1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Exchange", &a->_ns1__ValidateAccess::Exchange, "xsd:string"))
				{	soap_flag_Exchange1--;
					continue;
				}
			if (soap_flag_QuoteDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:QuoteDate", &a->_ns1__ValidateAccess::QuoteDate, "xsd:string"))
				{	soap_flag_QuoteDate1--;
					continue;
				}
			if (soap_flag_Period1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Period", &a->_ns1__ValidateAccess::Period, "xsd:string"))
				{	soap_flag_Period1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__ValidateAccess *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__ValidateAccess, SOAP_TYPE_ns__ns1__ValidateAccess, sizeof(_ns1__ValidateAccess), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ValidateAccess * SOAP_FMAC2 soap_instantiate__ns1__ValidateAccess(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ValidateAccess(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ValidateAccess *p;
	size_t k = sizeof(_ns1__ValidateAccess);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__ValidateAccess);
		if (p)
			((_ns1__ValidateAccess*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__ValidateAccess, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__ValidateAccess*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ValidateAccess location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__ValidateAccess, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__ValidateAccess::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:ValidateAccess", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ValidateAccess::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ValidateAccess(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ValidateAccess * SOAP_FMAC4 soap_get__ns1__ValidateAccess(struct soap *soap, _ns1__ValidateAccess *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ValidateAccess(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__UpdateDataFormatResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__UpdateDataFormatResponse::UpdateDataFormatResult = NULL;
	/* transient soap skipped */
}

void _ns1__UpdateDataFormatResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RESPONSE(soap, &this->_ns1__UpdateDataFormatResponse::UpdateDataFormatResult);
#endif
}

int _ns1__UpdateDataFormatResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UpdateDataFormatResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UpdateDataFormatResponse(struct soap *soap, const char *tag, int id, const _ns1__UpdateDataFormatResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__UpdateDataFormatResponse), type))
		return soap->error;
	if (a->UpdateDataFormatResult)
		soap_element_result(soap, "ns1:UpdateDataFormatResult");
	if (soap_out_PointerTons1__RESPONSE(soap, "ns1:UpdateDataFormatResult", -1, &a->_ns1__UpdateDataFormatResponse::UpdateDataFormatResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__UpdateDataFormatResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UpdateDataFormatResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UpdateDataFormatResponse * SOAP_FMAC4 soap_in__ns1__UpdateDataFormatResponse(struct soap *soap, const char *tag, _ns1__UpdateDataFormatResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UpdateDataFormatResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__UpdateDataFormatResponse, sizeof(_ns1__UpdateDataFormatResponse), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_UpdateDataFormatResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UpdateDataFormatResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RESPONSE(soap, "ns1:UpdateDataFormatResult", &a->_ns1__UpdateDataFormatResponse::UpdateDataFormatResult, "ns1:RESPONSE"))
				{	soap_flag_UpdateDataFormatResult1--;
					continue;
				}
			soap_check_result(soap, "ns1:UpdateDataFormatResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__UpdateDataFormatResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__UpdateDataFormatResponse, SOAP_TYPE_ns__ns1__UpdateDataFormatResponse, sizeof(_ns1__UpdateDataFormatResponse), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__UpdateDataFormatResponse * SOAP_FMAC2 soap_instantiate__ns1__UpdateDataFormatResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UpdateDataFormatResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__UpdateDataFormatResponse *p;
	size_t k = sizeof(_ns1__UpdateDataFormatResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__UpdateDataFormatResponse);
		if (p)
			((_ns1__UpdateDataFormatResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__UpdateDataFormatResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__UpdateDataFormatResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__UpdateDataFormatResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__UpdateDataFormatResponse, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__UpdateDataFormatResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:UpdateDataFormatResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UpdateDataFormatResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UpdateDataFormatResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UpdateDataFormatResponse * SOAP_FMAC4 soap_get__ns1__UpdateDataFormatResponse(struct soap *soap, _ns1__UpdateDataFormatResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UpdateDataFormatResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__UpdateDataFormat::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__UpdateDataFormat::Token = NULL;
	this->_ns1__UpdateDataFormat::DataFormat = NULL;
	soap_default_bool(soap, &this->_ns1__UpdateDataFormat::IncludeHeader);
	soap_default_bool(soap, &this->_ns1__UpdateDataFormat::IncludeSuffix);
	/* transient soap skipped */
}

void _ns1__UpdateDataFormat::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__UpdateDataFormat::Token);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__UpdateDataFormat::DataFormat);
#endif
}

int _ns1__UpdateDataFormat::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UpdateDataFormat(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UpdateDataFormat(struct soap *soap, const char *tag, int id, const _ns1__UpdateDataFormat *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__UpdateDataFormat), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Token", -1, &a->_ns1__UpdateDataFormat::Token, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:DataFormat", -1, &a->_ns1__UpdateDataFormat::DataFormat, ""))
		return soap->error;
	if (soap_out_bool(soap, "ns1:IncludeHeader", -1, &a->_ns1__UpdateDataFormat::IncludeHeader, ""))
		return soap->error;
	if (soap_out_bool(soap, "ns1:IncludeSuffix", -1, &a->_ns1__UpdateDataFormat::IncludeSuffix, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__UpdateDataFormat::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UpdateDataFormat(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UpdateDataFormat * SOAP_FMAC4 soap_in__ns1__UpdateDataFormat(struct soap *soap, const char *tag, _ns1__UpdateDataFormat *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UpdateDataFormat *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__UpdateDataFormat, sizeof(_ns1__UpdateDataFormat), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	size_t soap_flag_DataFormat1 = 1;
	size_t soap_flag_IncludeHeader1 = 1;
	size_t soap_flag_IncludeSuffix1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Token", &a->_ns1__UpdateDataFormat::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap_flag_DataFormat1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:DataFormat", &a->_ns1__UpdateDataFormat::DataFormat, "xsd:string"))
				{	soap_flag_DataFormat1--;
					continue;
				}
			if (soap_flag_IncludeHeader1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns1:IncludeHeader", &a->_ns1__UpdateDataFormat::IncludeHeader, "xsd:boolean"))
				{	soap_flag_IncludeHeader1--;
					continue;
				}
			if (soap_flag_IncludeSuffix1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns1:IncludeSuffix", &a->_ns1__UpdateDataFormat::IncludeSuffix, "xsd:boolean"))
				{	soap_flag_IncludeSuffix1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_IncludeHeader1 > 0 || soap_flag_IncludeSuffix1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__UpdateDataFormat *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__UpdateDataFormat, SOAP_TYPE_ns__ns1__UpdateDataFormat, sizeof(_ns1__UpdateDataFormat), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__UpdateDataFormat * SOAP_FMAC2 soap_instantiate__ns1__UpdateDataFormat(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UpdateDataFormat(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__UpdateDataFormat *p;
	size_t k = sizeof(_ns1__UpdateDataFormat);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__UpdateDataFormat);
		if (p)
			((_ns1__UpdateDataFormat*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__UpdateDataFormat, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__UpdateDataFormat*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__UpdateDataFormat location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__UpdateDataFormat, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__UpdateDataFormat::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:UpdateDataFormat", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UpdateDataFormat::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UpdateDataFormat(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UpdateDataFormat * SOAP_FMAC4 soap_get__ns1__UpdateDataFormat(struct soap *soap, _ns1__UpdateDataFormat *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UpdateDataFormat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__DataFormatsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__DataFormatsResponse::DataFormatsResult = NULL;
	/* transient soap skipped */
}

void _ns1__DataFormatsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RESPONSE(soap, &this->_ns1__DataFormatsResponse::DataFormatsResult);
#endif
}

int _ns1__DataFormatsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__DataFormatsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__DataFormatsResponse(struct soap *soap, const char *tag, int id, const _ns1__DataFormatsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__DataFormatsResponse), type))
		return soap->error;
	if (a->DataFormatsResult)
		soap_element_result(soap, "ns1:DataFormatsResult");
	if (soap_out_PointerTons1__RESPONSE(soap, "ns1:DataFormatsResult", -1, &a->_ns1__DataFormatsResponse::DataFormatsResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__DataFormatsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__DataFormatsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__DataFormatsResponse * SOAP_FMAC4 soap_in__ns1__DataFormatsResponse(struct soap *soap, const char *tag, _ns1__DataFormatsResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__DataFormatsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__DataFormatsResponse, sizeof(_ns1__DataFormatsResponse), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_DataFormatsResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DataFormatsResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RESPONSE(soap, "ns1:DataFormatsResult", &a->_ns1__DataFormatsResponse::DataFormatsResult, "ns1:RESPONSE"))
				{	soap_flag_DataFormatsResult1--;
					continue;
				}
			soap_check_result(soap, "ns1:DataFormatsResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__DataFormatsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__DataFormatsResponse, SOAP_TYPE_ns__ns1__DataFormatsResponse, sizeof(_ns1__DataFormatsResponse), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__DataFormatsResponse * SOAP_FMAC2 soap_instantiate__ns1__DataFormatsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__DataFormatsResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__DataFormatsResponse *p;
	size_t k = sizeof(_ns1__DataFormatsResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__DataFormatsResponse);
		if (p)
			((_ns1__DataFormatsResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__DataFormatsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__DataFormatsResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__DataFormatsResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__DataFormatsResponse, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__DataFormatsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:DataFormatsResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__DataFormatsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__DataFormatsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__DataFormatsResponse * SOAP_FMAC4 soap_get__ns1__DataFormatsResponse(struct soap *soap, _ns1__DataFormatsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__DataFormatsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__DataFormats::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__DataFormats::Token = NULL;
	/* transient soap skipped */
}

void _ns1__DataFormats::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__DataFormats::Token);
#endif
}

int _ns1__DataFormats::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__DataFormats(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__DataFormats(struct soap *soap, const char *tag, int id, const _ns1__DataFormats *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__DataFormats), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Token", -1, &a->_ns1__DataFormats::Token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__DataFormats::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__DataFormats(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__DataFormats * SOAP_FMAC4 soap_in__ns1__DataFormats(struct soap *soap, const char *tag, _ns1__DataFormats *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__DataFormats *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__DataFormats, sizeof(_ns1__DataFormats), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Token", &a->_ns1__DataFormats::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__DataFormats *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__DataFormats, SOAP_TYPE_ns__ns1__DataFormats, sizeof(_ns1__DataFormats), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__DataFormats * SOAP_FMAC2 soap_instantiate__ns1__DataFormats(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__DataFormats(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__DataFormats *p;
	size_t k = sizeof(_ns1__DataFormats);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__DataFormats);
		if (p)
			((_ns1__DataFormats*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__DataFormats, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__DataFormats*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__DataFormats location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__DataFormats, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__DataFormats::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:DataFormats", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__DataFormats::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__DataFormats(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__DataFormats * SOAP_FMAC4 soap_get__ns1__DataFormats(struct soap *soap, _ns1__DataFormats *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__DataFormats(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__DataClientLatestVersionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__DataClientLatestVersionResponse::DataClientLatestVersionResult = NULL;
	/* transient soap skipped */
}

void _ns1__DataClientLatestVersionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RESPONSE(soap, &this->_ns1__DataClientLatestVersionResponse::DataClientLatestVersionResult);
#endif
}

int _ns1__DataClientLatestVersionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__DataClientLatestVersionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__DataClientLatestVersionResponse(struct soap *soap, const char *tag, int id, const _ns1__DataClientLatestVersionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__DataClientLatestVersionResponse), type))
		return soap->error;
	if (a->DataClientLatestVersionResult)
		soap_element_result(soap, "ns1:DataClientLatestVersionResult");
	if (soap_out_PointerTons1__RESPONSE(soap, "ns1:DataClientLatestVersionResult", -1, &a->_ns1__DataClientLatestVersionResponse::DataClientLatestVersionResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__DataClientLatestVersionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__DataClientLatestVersionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__DataClientLatestVersionResponse * SOAP_FMAC4 soap_in__ns1__DataClientLatestVersionResponse(struct soap *soap, const char *tag, _ns1__DataClientLatestVersionResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__DataClientLatestVersionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__DataClientLatestVersionResponse, sizeof(_ns1__DataClientLatestVersionResponse), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_DataClientLatestVersionResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DataClientLatestVersionResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RESPONSE(soap, "ns1:DataClientLatestVersionResult", &a->_ns1__DataClientLatestVersionResponse::DataClientLatestVersionResult, "ns1:RESPONSE"))
				{	soap_flag_DataClientLatestVersionResult1--;
					continue;
				}
			soap_check_result(soap, "ns1:DataClientLatestVersionResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__DataClientLatestVersionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__DataClientLatestVersionResponse, SOAP_TYPE_ns__ns1__DataClientLatestVersionResponse, sizeof(_ns1__DataClientLatestVersionResponse), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__DataClientLatestVersionResponse * SOAP_FMAC2 soap_instantiate__ns1__DataClientLatestVersionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__DataClientLatestVersionResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__DataClientLatestVersionResponse *p;
	size_t k = sizeof(_ns1__DataClientLatestVersionResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__DataClientLatestVersionResponse);
		if (p)
			((_ns1__DataClientLatestVersionResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__DataClientLatestVersionResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__DataClientLatestVersionResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__DataClientLatestVersionResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__DataClientLatestVersionResponse, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__DataClientLatestVersionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:DataClientLatestVersionResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__DataClientLatestVersionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__DataClientLatestVersionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__DataClientLatestVersionResponse * SOAP_FMAC4 soap_get__ns1__DataClientLatestVersionResponse(struct soap *soap, _ns1__DataClientLatestVersionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__DataClientLatestVersionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__DataClientLatestVersion::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__DataClientLatestVersion::Token = NULL;
	/* transient soap skipped */
}

void _ns1__DataClientLatestVersion::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__DataClientLatestVersion::Token);
#endif
}

int _ns1__DataClientLatestVersion::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__DataClientLatestVersion(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__DataClientLatestVersion(struct soap *soap, const char *tag, int id, const _ns1__DataClientLatestVersion *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__DataClientLatestVersion), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Token", -1, &a->_ns1__DataClientLatestVersion::Token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__DataClientLatestVersion::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__DataClientLatestVersion(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__DataClientLatestVersion * SOAP_FMAC4 soap_in__ns1__DataClientLatestVersion(struct soap *soap, const char *tag, _ns1__DataClientLatestVersion *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__DataClientLatestVersion *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__DataClientLatestVersion, sizeof(_ns1__DataClientLatestVersion), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Token", &a->_ns1__DataClientLatestVersion::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__DataClientLatestVersion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__DataClientLatestVersion, SOAP_TYPE_ns__ns1__DataClientLatestVersion, sizeof(_ns1__DataClientLatestVersion), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__DataClientLatestVersion * SOAP_FMAC2 soap_instantiate__ns1__DataClientLatestVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__DataClientLatestVersion(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__DataClientLatestVersion *p;
	size_t k = sizeof(_ns1__DataClientLatestVersion);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__DataClientLatestVersion);
		if (p)
			((_ns1__DataClientLatestVersion*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__DataClientLatestVersion, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__DataClientLatestVersion*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__DataClientLatestVersion location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__DataClientLatestVersion, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__DataClientLatestVersion::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:DataClientLatestVersion", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__DataClientLatestVersion::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__DataClientLatestVersion(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__DataClientLatestVersion * SOAP_FMAC4 soap_get__ns1__DataClientLatestVersion(struct soap *soap, _ns1__DataClientLatestVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__DataClientLatestVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SymbolChangesByExchangeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SymbolChangesByExchangeResponse::SymbolChangesByExchangeResult = NULL;
	/* transient soap skipped */
}

void _ns1__SymbolChangesByExchangeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RESPONSE(soap, &this->_ns1__SymbolChangesByExchangeResponse::SymbolChangesByExchangeResult);
#endif
}

int _ns1__SymbolChangesByExchangeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SymbolChangesByExchangeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SymbolChangesByExchangeResponse(struct soap *soap, const char *tag, int id, const _ns1__SymbolChangesByExchangeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__SymbolChangesByExchangeResponse), type))
		return soap->error;
	if (a->SymbolChangesByExchangeResult)
		soap_element_result(soap, "ns1:SymbolChangesByExchangeResult");
	if (soap_out_PointerTons1__RESPONSE(soap, "ns1:SymbolChangesByExchangeResult", -1, &a->_ns1__SymbolChangesByExchangeResponse::SymbolChangesByExchangeResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SymbolChangesByExchangeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SymbolChangesByExchangeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SymbolChangesByExchangeResponse * SOAP_FMAC4 soap_in__ns1__SymbolChangesByExchangeResponse(struct soap *soap, const char *tag, _ns1__SymbolChangesByExchangeResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SymbolChangesByExchangeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__SymbolChangesByExchangeResponse, sizeof(_ns1__SymbolChangesByExchangeResponse), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SymbolChangesByExchangeResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SymbolChangesByExchangeResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RESPONSE(soap, "ns1:SymbolChangesByExchangeResult", &a->_ns1__SymbolChangesByExchangeResponse::SymbolChangesByExchangeResult, "ns1:RESPONSE"))
				{	soap_flag_SymbolChangesByExchangeResult1--;
					continue;
				}
			soap_check_result(soap, "ns1:SymbolChangesByExchangeResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SymbolChangesByExchangeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__SymbolChangesByExchangeResponse, SOAP_TYPE_ns__ns1__SymbolChangesByExchangeResponse, sizeof(_ns1__SymbolChangesByExchangeResponse), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SymbolChangesByExchangeResponse * SOAP_FMAC2 soap_instantiate__ns1__SymbolChangesByExchangeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SymbolChangesByExchangeResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SymbolChangesByExchangeResponse *p;
	size_t k = sizeof(_ns1__SymbolChangesByExchangeResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SymbolChangesByExchangeResponse);
		if (p)
			((_ns1__SymbolChangesByExchangeResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SymbolChangesByExchangeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SymbolChangesByExchangeResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SymbolChangesByExchangeResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__SymbolChangesByExchangeResponse, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SymbolChangesByExchangeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:SymbolChangesByExchangeResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SymbolChangesByExchangeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SymbolChangesByExchangeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SymbolChangesByExchangeResponse * SOAP_FMAC4 soap_get__ns1__SymbolChangesByExchangeResponse(struct soap *soap, _ns1__SymbolChangesByExchangeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SymbolChangesByExchangeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SymbolChangesByExchange::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SymbolChangesByExchange::Token = NULL;
	this->_ns1__SymbolChangesByExchange::Exchange = NULL;
	/* transient soap skipped */
}

void _ns1__SymbolChangesByExchange::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SymbolChangesByExchange::Token);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SymbolChangesByExchange::Exchange);
#endif
}

int _ns1__SymbolChangesByExchange::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SymbolChangesByExchange(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SymbolChangesByExchange(struct soap *soap, const char *tag, int id, const _ns1__SymbolChangesByExchange *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__SymbolChangesByExchange), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Token", -1, &a->_ns1__SymbolChangesByExchange::Token, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Exchange", -1, &a->_ns1__SymbolChangesByExchange::Exchange, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SymbolChangesByExchange::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SymbolChangesByExchange(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SymbolChangesByExchange * SOAP_FMAC4 soap_in__ns1__SymbolChangesByExchange(struct soap *soap, const char *tag, _ns1__SymbolChangesByExchange *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SymbolChangesByExchange *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__SymbolChangesByExchange, sizeof(_ns1__SymbolChangesByExchange), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	size_t soap_flag_Exchange1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Token", &a->_ns1__SymbolChangesByExchange::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap_flag_Exchange1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Exchange", &a->_ns1__SymbolChangesByExchange::Exchange, "xsd:string"))
				{	soap_flag_Exchange1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SymbolChangesByExchange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__SymbolChangesByExchange, SOAP_TYPE_ns__ns1__SymbolChangesByExchange, sizeof(_ns1__SymbolChangesByExchange), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SymbolChangesByExchange * SOAP_FMAC2 soap_instantiate__ns1__SymbolChangesByExchange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SymbolChangesByExchange(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SymbolChangesByExchange *p;
	size_t k = sizeof(_ns1__SymbolChangesByExchange);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SymbolChangesByExchange);
		if (p)
			((_ns1__SymbolChangesByExchange*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SymbolChangesByExchange, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SymbolChangesByExchange*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SymbolChangesByExchange location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__SymbolChangesByExchange, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SymbolChangesByExchange::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:SymbolChangesByExchange", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SymbolChangesByExchange::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SymbolChangesByExchange(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SymbolChangesByExchange * SOAP_FMAC4 soap_get__ns1__SymbolChangesByExchange(struct soap *soap, _ns1__SymbolChangesByExchange *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SymbolChangesByExchange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__QuoteListByDatePeriod2Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__QuoteListByDatePeriod2Response::QuoteListByDatePeriod2Result = NULL;
	/* transient soap skipped */
}

void _ns1__QuoteListByDatePeriod2Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RESPONSE(soap, &this->_ns1__QuoteListByDatePeriod2Response::QuoteListByDatePeriod2Result);
#endif
}

int _ns1__QuoteListByDatePeriod2Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__QuoteListByDatePeriod2Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__QuoteListByDatePeriod2Response(struct soap *soap, const char *tag, int id, const _ns1__QuoteListByDatePeriod2Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__QuoteListByDatePeriod2Response), type))
		return soap->error;
	if (a->QuoteListByDatePeriod2Result)
		soap_element_result(soap, "ns1:QuoteListByDatePeriod2Result");
	if (soap_out_PointerTons1__RESPONSE(soap, "ns1:QuoteListByDatePeriod2Result", -1, &a->_ns1__QuoteListByDatePeriod2Response::QuoteListByDatePeriod2Result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__QuoteListByDatePeriod2Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__QuoteListByDatePeriod2Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__QuoteListByDatePeriod2Response * SOAP_FMAC4 soap_in__ns1__QuoteListByDatePeriod2Response(struct soap *soap, const char *tag, _ns1__QuoteListByDatePeriod2Response *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__QuoteListByDatePeriod2Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__QuoteListByDatePeriod2Response, sizeof(_ns1__QuoteListByDatePeriod2Response), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_QuoteListByDatePeriod2Result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_QuoteListByDatePeriod2Result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RESPONSE(soap, "ns1:QuoteListByDatePeriod2Result", &a->_ns1__QuoteListByDatePeriod2Response::QuoteListByDatePeriod2Result, "ns1:RESPONSE"))
				{	soap_flag_QuoteListByDatePeriod2Result1--;
					continue;
				}
			soap_check_result(soap, "ns1:QuoteListByDatePeriod2Result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__QuoteListByDatePeriod2Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__QuoteListByDatePeriod2Response, SOAP_TYPE_ns__ns1__QuoteListByDatePeriod2Response, sizeof(_ns1__QuoteListByDatePeriod2Response), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__QuoteListByDatePeriod2Response * SOAP_FMAC2 soap_instantiate__ns1__QuoteListByDatePeriod2Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__QuoteListByDatePeriod2Response(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__QuoteListByDatePeriod2Response *p;
	size_t k = sizeof(_ns1__QuoteListByDatePeriod2Response);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__QuoteListByDatePeriod2Response);
		if (p)
			((_ns1__QuoteListByDatePeriod2Response*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__QuoteListByDatePeriod2Response, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__QuoteListByDatePeriod2Response*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__QuoteListByDatePeriod2Response location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__QuoteListByDatePeriod2Response, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__QuoteListByDatePeriod2Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:QuoteListByDatePeriod2Response", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__QuoteListByDatePeriod2Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__QuoteListByDatePeriod2Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__QuoteListByDatePeriod2Response * SOAP_FMAC4 soap_get__ns1__QuoteListByDatePeriod2Response(struct soap *soap, _ns1__QuoteListByDatePeriod2Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__QuoteListByDatePeriod2Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__QuoteListByDatePeriod2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__QuoteListByDatePeriod2::Token = NULL;
	this->_ns1__QuoteListByDatePeriod2::Exchange = NULL;
	this->_ns1__QuoteListByDatePeriod2::QuoteDate = NULL;
	this->_ns1__QuoteListByDatePeriod2::Period = NULL;
	/* transient soap skipped */
}

void _ns1__QuoteListByDatePeriod2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__QuoteListByDatePeriod2::Token);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__QuoteListByDatePeriod2::Exchange);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__QuoteListByDatePeriod2::QuoteDate);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__QuoteListByDatePeriod2::Period);
#endif
}

int _ns1__QuoteListByDatePeriod2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__QuoteListByDatePeriod2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__QuoteListByDatePeriod2(struct soap *soap, const char *tag, int id, const _ns1__QuoteListByDatePeriod2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__QuoteListByDatePeriod2), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Token", -1, &a->_ns1__QuoteListByDatePeriod2::Token, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Exchange", -1, &a->_ns1__QuoteListByDatePeriod2::Exchange, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:QuoteDate", -1, &a->_ns1__QuoteListByDatePeriod2::QuoteDate, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Period", -1, &a->_ns1__QuoteListByDatePeriod2::Period, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__QuoteListByDatePeriod2::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__QuoteListByDatePeriod2(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__QuoteListByDatePeriod2 * SOAP_FMAC4 soap_in__ns1__QuoteListByDatePeriod2(struct soap *soap, const char *tag, _ns1__QuoteListByDatePeriod2 *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__QuoteListByDatePeriod2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__QuoteListByDatePeriod2, sizeof(_ns1__QuoteListByDatePeriod2), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	size_t soap_flag_Exchange1 = 1;
	size_t soap_flag_QuoteDate1 = 1;
	size_t soap_flag_Period1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Token", &a->_ns1__QuoteListByDatePeriod2::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap_flag_Exchange1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Exchange", &a->_ns1__QuoteListByDatePeriod2::Exchange, "xsd:string"))
				{	soap_flag_Exchange1--;
					continue;
				}
			if (soap_flag_QuoteDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:QuoteDate", &a->_ns1__QuoteListByDatePeriod2::QuoteDate, "xsd:string"))
				{	soap_flag_QuoteDate1--;
					continue;
				}
			if (soap_flag_Period1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Period", &a->_ns1__QuoteListByDatePeriod2::Period, "xsd:string"))
				{	soap_flag_Period1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__QuoteListByDatePeriod2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__QuoteListByDatePeriod2, SOAP_TYPE_ns__ns1__QuoteListByDatePeriod2, sizeof(_ns1__QuoteListByDatePeriod2), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__QuoteListByDatePeriod2 * SOAP_FMAC2 soap_instantiate__ns1__QuoteListByDatePeriod2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__QuoteListByDatePeriod2(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__QuoteListByDatePeriod2 *p;
	size_t k = sizeof(_ns1__QuoteListByDatePeriod2);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__QuoteListByDatePeriod2);
		if (p)
			((_ns1__QuoteListByDatePeriod2*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__QuoteListByDatePeriod2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__QuoteListByDatePeriod2*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__QuoteListByDatePeriod2 location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__QuoteListByDatePeriod2, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__QuoteListByDatePeriod2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:QuoteListByDatePeriod2", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__QuoteListByDatePeriod2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__QuoteListByDatePeriod2(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__QuoteListByDatePeriod2 * SOAP_FMAC4 soap_get__ns1__QuoteListByDatePeriod2(struct soap *soap, _ns1__QuoteListByDatePeriod2 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__QuoteListByDatePeriod2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__QuoteListByDatePeriodResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__QuoteListByDatePeriodResponse::QuoteListByDatePeriodResult = NULL;
	/* transient soap skipped */
}

void _ns1__QuoteListByDatePeriodResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RESPONSE(soap, &this->_ns1__QuoteListByDatePeriodResponse::QuoteListByDatePeriodResult);
#endif
}

int _ns1__QuoteListByDatePeriodResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__QuoteListByDatePeriodResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__QuoteListByDatePeriodResponse(struct soap *soap, const char *tag, int id, const _ns1__QuoteListByDatePeriodResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__QuoteListByDatePeriodResponse), type))
		return soap->error;
	if (a->QuoteListByDatePeriodResult)
		soap_element_result(soap, "ns1:QuoteListByDatePeriodResult");
	if (soap_out_PointerTons1__RESPONSE(soap, "ns1:QuoteListByDatePeriodResult", -1, &a->_ns1__QuoteListByDatePeriodResponse::QuoteListByDatePeriodResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__QuoteListByDatePeriodResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__QuoteListByDatePeriodResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__QuoteListByDatePeriodResponse * SOAP_FMAC4 soap_in__ns1__QuoteListByDatePeriodResponse(struct soap *soap, const char *tag, _ns1__QuoteListByDatePeriodResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__QuoteListByDatePeriodResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__QuoteListByDatePeriodResponse, sizeof(_ns1__QuoteListByDatePeriodResponse), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_QuoteListByDatePeriodResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_QuoteListByDatePeriodResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RESPONSE(soap, "ns1:QuoteListByDatePeriodResult", &a->_ns1__QuoteListByDatePeriodResponse::QuoteListByDatePeriodResult, "ns1:RESPONSE"))
				{	soap_flag_QuoteListByDatePeriodResult1--;
					continue;
				}
			soap_check_result(soap, "ns1:QuoteListByDatePeriodResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__QuoteListByDatePeriodResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__QuoteListByDatePeriodResponse, SOAP_TYPE_ns__ns1__QuoteListByDatePeriodResponse, sizeof(_ns1__QuoteListByDatePeriodResponse), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__QuoteListByDatePeriodResponse * SOAP_FMAC2 soap_instantiate__ns1__QuoteListByDatePeriodResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__QuoteListByDatePeriodResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__QuoteListByDatePeriodResponse *p;
	size_t k = sizeof(_ns1__QuoteListByDatePeriodResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__QuoteListByDatePeriodResponse);
		if (p)
			((_ns1__QuoteListByDatePeriodResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__QuoteListByDatePeriodResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__QuoteListByDatePeriodResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__QuoteListByDatePeriodResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__QuoteListByDatePeriodResponse, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__QuoteListByDatePeriodResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:QuoteListByDatePeriodResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__QuoteListByDatePeriodResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__QuoteListByDatePeriodResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__QuoteListByDatePeriodResponse * SOAP_FMAC4 soap_get__ns1__QuoteListByDatePeriodResponse(struct soap *soap, _ns1__QuoteListByDatePeriodResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__QuoteListByDatePeriodResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__QuoteListByDatePeriod::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__QuoteListByDatePeriod::Token = NULL;
	this->_ns1__QuoteListByDatePeriod::Exchange = NULL;
	this->_ns1__QuoteListByDatePeriod::QuoteDate = NULL;
	this->_ns1__QuoteListByDatePeriod::Period = NULL;
	/* transient soap skipped */
}

void _ns1__QuoteListByDatePeriod::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__QuoteListByDatePeriod::Token);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__QuoteListByDatePeriod::Exchange);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__QuoteListByDatePeriod::QuoteDate);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__QuoteListByDatePeriod::Period);
#endif
}

int _ns1__QuoteListByDatePeriod::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__QuoteListByDatePeriod(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__QuoteListByDatePeriod(struct soap *soap, const char *tag, int id, const _ns1__QuoteListByDatePeriod *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__QuoteListByDatePeriod), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Token", -1, &a->_ns1__QuoteListByDatePeriod::Token, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Exchange", -1, &a->_ns1__QuoteListByDatePeriod::Exchange, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:QuoteDate", -1, &a->_ns1__QuoteListByDatePeriod::QuoteDate, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Period", -1, &a->_ns1__QuoteListByDatePeriod::Period, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__QuoteListByDatePeriod::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__QuoteListByDatePeriod(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__QuoteListByDatePeriod * SOAP_FMAC4 soap_in__ns1__QuoteListByDatePeriod(struct soap *soap, const char *tag, _ns1__QuoteListByDatePeriod *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__QuoteListByDatePeriod *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__QuoteListByDatePeriod, sizeof(_ns1__QuoteListByDatePeriod), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	size_t soap_flag_Exchange1 = 1;
	size_t soap_flag_QuoteDate1 = 1;
	size_t soap_flag_Period1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Token", &a->_ns1__QuoteListByDatePeriod::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap_flag_Exchange1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Exchange", &a->_ns1__QuoteListByDatePeriod::Exchange, "xsd:string"))
				{	soap_flag_Exchange1--;
					continue;
				}
			if (soap_flag_QuoteDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:QuoteDate", &a->_ns1__QuoteListByDatePeriod::QuoteDate, "xsd:string"))
				{	soap_flag_QuoteDate1--;
					continue;
				}
			if (soap_flag_Period1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Period", &a->_ns1__QuoteListByDatePeriod::Period, "xsd:string"))
				{	soap_flag_Period1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__QuoteListByDatePeriod *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__QuoteListByDatePeriod, SOAP_TYPE_ns__ns1__QuoteListByDatePeriod, sizeof(_ns1__QuoteListByDatePeriod), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__QuoteListByDatePeriod * SOAP_FMAC2 soap_instantiate__ns1__QuoteListByDatePeriod(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__QuoteListByDatePeriod(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__QuoteListByDatePeriod *p;
	size_t k = sizeof(_ns1__QuoteListByDatePeriod);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__QuoteListByDatePeriod);
		if (p)
			((_ns1__QuoteListByDatePeriod*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__QuoteListByDatePeriod, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__QuoteListByDatePeriod*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__QuoteListByDatePeriod location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__QuoteListByDatePeriod, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__QuoteListByDatePeriod::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:QuoteListByDatePeriod", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__QuoteListByDatePeriod::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__QuoteListByDatePeriod(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__QuoteListByDatePeriod * SOAP_FMAC4 soap_get__ns1__QuoteListByDatePeriod(struct soap *soap, _ns1__QuoteListByDatePeriod *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__QuoteListByDatePeriod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SymbolHistoryPeriodByDateRangeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SymbolHistoryPeriodByDateRangeResponse::SymbolHistoryPeriodByDateRangeResult = NULL;
	/* transient soap skipped */
}

void _ns1__SymbolHistoryPeriodByDateRangeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RESPONSE(soap, &this->_ns1__SymbolHistoryPeriodByDateRangeResponse::SymbolHistoryPeriodByDateRangeResult);
#endif
}

int _ns1__SymbolHistoryPeriodByDateRangeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SymbolHistoryPeriodByDateRangeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SymbolHistoryPeriodByDateRangeResponse(struct soap *soap, const char *tag, int id, const _ns1__SymbolHistoryPeriodByDateRangeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__SymbolHistoryPeriodByDateRangeResponse), type))
		return soap->error;
	if (a->SymbolHistoryPeriodByDateRangeResult)
		soap_element_result(soap, "ns1:SymbolHistoryPeriodByDateRangeResult");
	if (soap_out_PointerTons1__RESPONSE(soap, "ns1:SymbolHistoryPeriodByDateRangeResult", -1, &a->_ns1__SymbolHistoryPeriodByDateRangeResponse::SymbolHistoryPeriodByDateRangeResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SymbolHistoryPeriodByDateRangeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SymbolHistoryPeriodByDateRangeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SymbolHistoryPeriodByDateRangeResponse * SOAP_FMAC4 soap_in__ns1__SymbolHistoryPeriodByDateRangeResponse(struct soap *soap, const char *tag, _ns1__SymbolHistoryPeriodByDateRangeResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SymbolHistoryPeriodByDateRangeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__SymbolHistoryPeriodByDateRangeResponse, sizeof(_ns1__SymbolHistoryPeriodByDateRangeResponse), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SymbolHistoryPeriodByDateRangeResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SymbolHistoryPeriodByDateRangeResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RESPONSE(soap, "ns1:SymbolHistoryPeriodByDateRangeResult", &a->_ns1__SymbolHistoryPeriodByDateRangeResponse::SymbolHistoryPeriodByDateRangeResult, "ns1:RESPONSE"))
				{	soap_flag_SymbolHistoryPeriodByDateRangeResult1--;
					continue;
				}
			soap_check_result(soap, "ns1:SymbolHistoryPeriodByDateRangeResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SymbolHistoryPeriodByDateRangeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__SymbolHistoryPeriodByDateRangeResponse, SOAP_TYPE_ns__ns1__SymbolHistoryPeriodByDateRangeResponse, sizeof(_ns1__SymbolHistoryPeriodByDateRangeResponse), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SymbolHistoryPeriodByDateRangeResponse * SOAP_FMAC2 soap_instantiate__ns1__SymbolHistoryPeriodByDateRangeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SymbolHistoryPeriodByDateRangeResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SymbolHistoryPeriodByDateRangeResponse *p;
	size_t k = sizeof(_ns1__SymbolHistoryPeriodByDateRangeResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SymbolHistoryPeriodByDateRangeResponse);
		if (p)
			((_ns1__SymbolHistoryPeriodByDateRangeResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SymbolHistoryPeriodByDateRangeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SymbolHistoryPeriodByDateRangeResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SymbolHistoryPeriodByDateRangeResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__SymbolHistoryPeriodByDateRangeResponse, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SymbolHistoryPeriodByDateRangeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:SymbolHistoryPeriodByDateRangeResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SymbolHistoryPeriodByDateRangeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SymbolHistoryPeriodByDateRangeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SymbolHistoryPeriodByDateRangeResponse * SOAP_FMAC4 soap_get__ns1__SymbolHistoryPeriodByDateRangeResponse(struct soap *soap, _ns1__SymbolHistoryPeriodByDateRangeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SymbolHistoryPeriodByDateRangeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SymbolHistoryPeriodByDateRange::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SymbolHistoryPeriodByDateRange::Token = NULL;
	this->_ns1__SymbolHistoryPeriodByDateRange::Exchange = NULL;
	this->_ns1__SymbolHistoryPeriodByDateRange::Symbol = NULL;
	this->_ns1__SymbolHistoryPeriodByDateRange::StartDate = NULL;
	this->_ns1__SymbolHistoryPeriodByDateRange::EndDate = NULL;
	this->_ns1__SymbolHistoryPeriodByDateRange::Period = NULL;
	/* transient soap skipped */
}

void _ns1__SymbolHistoryPeriodByDateRange::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SymbolHistoryPeriodByDateRange::Token);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SymbolHistoryPeriodByDateRange::Exchange);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SymbolHistoryPeriodByDateRange::Symbol);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SymbolHistoryPeriodByDateRange::StartDate);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SymbolHistoryPeriodByDateRange::EndDate);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SymbolHistoryPeriodByDateRange::Period);
#endif
}

int _ns1__SymbolHistoryPeriodByDateRange::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SymbolHistoryPeriodByDateRange(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SymbolHistoryPeriodByDateRange(struct soap *soap, const char *tag, int id, const _ns1__SymbolHistoryPeriodByDateRange *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__SymbolHistoryPeriodByDateRange), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Token", -1, &a->_ns1__SymbolHistoryPeriodByDateRange::Token, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Exchange", -1, &a->_ns1__SymbolHistoryPeriodByDateRange::Exchange, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Symbol", -1, &a->_ns1__SymbolHistoryPeriodByDateRange::Symbol, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:StartDate", -1, &a->_ns1__SymbolHistoryPeriodByDateRange::StartDate, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:EndDate", -1, &a->_ns1__SymbolHistoryPeriodByDateRange::EndDate, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Period", -1, &a->_ns1__SymbolHistoryPeriodByDateRange::Period, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SymbolHistoryPeriodByDateRange::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SymbolHistoryPeriodByDateRange(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SymbolHistoryPeriodByDateRange * SOAP_FMAC4 soap_in__ns1__SymbolHistoryPeriodByDateRange(struct soap *soap, const char *tag, _ns1__SymbolHistoryPeriodByDateRange *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SymbolHistoryPeriodByDateRange *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__SymbolHistoryPeriodByDateRange, sizeof(_ns1__SymbolHistoryPeriodByDateRange), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	size_t soap_flag_Exchange1 = 1;
	size_t soap_flag_Symbol1 = 1;
	size_t soap_flag_StartDate1 = 1;
	size_t soap_flag_EndDate1 = 1;
	size_t soap_flag_Period1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Token", &a->_ns1__SymbolHistoryPeriodByDateRange::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap_flag_Exchange1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Exchange", &a->_ns1__SymbolHistoryPeriodByDateRange::Exchange, "xsd:string"))
				{	soap_flag_Exchange1--;
					continue;
				}
			if (soap_flag_Symbol1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Symbol", &a->_ns1__SymbolHistoryPeriodByDateRange::Symbol, "xsd:string"))
				{	soap_flag_Symbol1--;
					continue;
				}
			if (soap_flag_StartDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:StartDate", &a->_ns1__SymbolHistoryPeriodByDateRange::StartDate, "xsd:string"))
				{	soap_flag_StartDate1--;
					continue;
				}
			if (soap_flag_EndDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:EndDate", &a->_ns1__SymbolHistoryPeriodByDateRange::EndDate, "xsd:string"))
				{	soap_flag_EndDate1--;
					continue;
				}
			if (soap_flag_Period1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Period", &a->_ns1__SymbolHistoryPeriodByDateRange::Period, "xsd:string"))
				{	soap_flag_Period1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SymbolHistoryPeriodByDateRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__SymbolHistoryPeriodByDateRange, SOAP_TYPE_ns__ns1__SymbolHistoryPeriodByDateRange, sizeof(_ns1__SymbolHistoryPeriodByDateRange), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SymbolHistoryPeriodByDateRange * SOAP_FMAC2 soap_instantiate__ns1__SymbolHistoryPeriodByDateRange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SymbolHistoryPeriodByDateRange(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SymbolHistoryPeriodByDateRange *p;
	size_t k = sizeof(_ns1__SymbolHistoryPeriodByDateRange);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SymbolHistoryPeriodByDateRange);
		if (p)
			((_ns1__SymbolHistoryPeriodByDateRange*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SymbolHistoryPeriodByDateRange, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SymbolHistoryPeriodByDateRange*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SymbolHistoryPeriodByDateRange location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__SymbolHistoryPeriodByDateRange, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SymbolHistoryPeriodByDateRange::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:SymbolHistoryPeriodByDateRange", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SymbolHistoryPeriodByDateRange::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SymbolHistoryPeriodByDateRange(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SymbolHistoryPeriodByDateRange * SOAP_FMAC4 soap_get__ns1__SymbolHistoryPeriodByDateRange(struct soap *soap, _ns1__SymbolHistoryPeriodByDateRange *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SymbolHistoryPeriodByDateRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SymbolHistoryPeriodResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SymbolHistoryPeriodResponse::SymbolHistoryPeriodResult = NULL;
	/* transient soap skipped */
}

void _ns1__SymbolHistoryPeriodResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RESPONSE(soap, &this->_ns1__SymbolHistoryPeriodResponse::SymbolHistoryPeriodResult);
#endif
}

int _ns1__SymbolHistoryPeriodResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SymbolHistoryPeriodResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SymbolHistoryPeriodResponse(struct soap *soap, const char *tag, int id, const _ns1__SymbolHistoryPeriodResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__SymbolHistoryPeriodResponse), type))
		return soap->error;
	if (a->SymbolHistoryPeriodResult)
		soap_element_result(soap, "ns1:SymbolHistoryPeriodResult");
	if (soap_out_PointerTons1__RESPONSE(soap, "ns1:SymbolHistoryPeriodResult", -1, &a->_ns1__SymbolHistoryPeriodResponse::SymbolHistoryPeriodResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SymbolHistoryPeriodResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SymbolHistoryPeriodResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SymbolHistoryPeriodResponse * SOAP_FMAC4 soap_in__ns1__SymbolHistoryPeriodResponse(struct soap *soap, const char *tag, _ns1__SymbolHistoryPeriodResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SymbolHistoryPeriodResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__SymbolHistoryPeriodResponse, sizeof(_ns1__SymbolHistoryPeriodResponse), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SymbolHistoryPeriodResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SymbolHistoryPeriodResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RESPONSE(soap, "ns1:SymbolHistoryPeriodResult", &a->_ns1__SymbolHistoryPeriodResponse::SymbolHistoryPeriodResult, "ns1:RESPONSE"))
				{	soap_flag_SymbolHistoryPeriodResult1--;
					continue;
				}
			soap_check_result(soap, "ns1:SymbolHistoryPeriodResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SymbolHistoryPeriodResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__SymbolHistoryPeriodResponse, SOAP_TYPE_ns__ns1__SymbolHistoryPeriodResponse, sizeof(_ns1__SymbolHistoryPeriodResponse), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SymbolHistoryPeriodResponse * SOAP_FMAC2 soap_instantiate__ns1__SymbolHistoryPeriodResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SymbolHistoryPeriodResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SymbolHistoryPeriodResponse *p;
	size_t k = sizeof(_ns1__SymbolHistoryPeriodResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SymbolHistoryPeriodResponse);
		if (p)
			((_ns1__SymbolHistoryPeriodResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SymbolHistoryPeriodResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SymbolHistoryPeriodResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SymbolHistoryPeriodResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__SymbolHistoryPeriodResponse, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SymbolHistoryPeriodResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:SymbolHistoryPeriodResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SymbolHistoryPeriodResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SymbolHistoryPeriodResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SymbolHistoryPeriodResponse * SOAP_FMAC4 soap_get__ns1__SymbolHistoryPeriodResponse(struct soap *soap, _ns1__SymbolHistoryPeriodResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SymbolHistoryPeriodResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SymbolHistoryPeriod::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SymbolHistoryPeriod::Token = NULL;
	this->_ns1__SymbolHistoryPeriod::Exchange = NULL;
	this->_ns1__SymbolHistoryPeriod::Symbol = NULL;
	this->_ns1__SymbolHistoryPeriod::Date = NULL;
	this->_ns1__SymbolHistoryPeriod::Period = NULL;
	/* transient soap skipped */
}

void _ns1__SymbolHistoryPeriod::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SymbolHistoryPeriod::Token);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SymbolHistoryPeriod::Exchange);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SymbolHistoryPeriod::Symbol);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SymbolHistoryPeriod::Date);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SymbolHistoryPeriod::Period);
#endif
}

int _ns1__SymbolHistoryPeriod::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SymbolHistoryPeriod(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SymbolHistoryPeriod(struct soap *soap, const char *tag, int id, const _ns1__SymbolHistoryPeriod *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__SymbolHistoryPeriod), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Token", -1, &a->_ns1__SymbolHistoryPeriod::Token, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Exchange", -1, &a->_ns1__SymbolHistoryPeriod::Exchange, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Symbol", -1, &a->_ns1__SymbolHistoryPeriod::Symbol, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Date", -1, &a->_ns1__SymbolHistoryPeriod::Date, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Period", -1, &a->_ns1__SymbolHistoryPeriod::Period, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SymbolHistoryPeriod::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SymbolHistoryPeriod(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SymbolHistoryPeriod * SOAP_FMAC4 soap_in__ns1__SymbolHistoryPeriod(struct soap *soap, const char *tag, _ns1__SymbolHistoryPeriod *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SymbolHistoryPeriod *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__SymbolHistoryPeriod, sizeof(_ns1__SymbolHistoryPeriod), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	size_t soap_flag_Exchange1 = 1;
	size_t soap_flag_Symbol1 = 1;
	size_t soap_flag_Date1 = 1;
	size_t soap_flag_Period1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Token", &a->_ns1__SymbolHistoryPeriod::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap_flag_Exchange1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Exchange", &a->_ns1__SymbolHistoryPeriod::Exchange, "xsd:string"))
				{	soap_flag_Exchange1--;
					continue;
				}
			if (soap_flag_Symbol1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Symbol", &a->_ns1__SymbolHistoryPeriod::Symbol, "xsd:string"))
				{	soap_flag_Symbol1--;
					continue;
				}
			if (soap_flag_Date1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Date", &a->_ns1__SymbolHistoryPeriod::Date, "xsd:string"))
				{	soap_flag_Date1--;
					continue;
				}
			if (soap_flag_Period1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Period", &a->_ns1__SymbolHistoryPeriod::Period, "xsd:string"))
				{	soap_flag_Period1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SymbolHistoryPeriod *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__SymbolHistoryPeriod, SOAP_TYPE_ns__ns1__SymbolHistoryPeriod, sizeof(_ns1__SymbolHistoryPeriod), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SymbolHistoryPeriod * SOAP_FMAC2 soap_instantiate__ns1__SymbolHistoryPeriod(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SymbolHistoryPeriod(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SymbolHistoryPeriod *p;
	size_t k = sizeof(_ns1__SymbolHistoryPeriod);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SymbolHistoryPeriod);
		if (p)
			((_ns1__SymbolHistoryPeriod*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SymbolHistoryPeriod, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SymbolHistoryPeriod*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SymbolHistoryPeriod location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__SymbolHistoryPeriod, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SymbolHistoryPeriod::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:SymbolHistoryPeriod", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SymbolHistoryPeriod::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SymbolHistoryPeriod(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SymbolHistoryPeriod * SOAP_FMAC4 soap_get__ns1__SymbolHistoryPeriod(struct soap *soap, _ns1__SymbolHistoryPeriod *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SymbolHistoryPeriod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__CountryListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__CountryListResponse::CountryListResult = NULL;
	/* transient soap skipped */
}

void _ns1__CountryListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RESPONSE(soap, &this->_ns1__CountryListResponse::CountryListResult);
#endif
}

int _ns1__CountryListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CountryListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CountryListResponse(struct soap *soap, const char *tag, int id, const _ns1__CountryListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__CountryListResponse), type))
		return soap->error;
	if (a->CountryListResult)
		soap_element_result(soap, "ns1:CountryListResult");
	if (soap_out_PointerTons1__RESPONSE(soap, "ns1:CountryListResult", -1, &a->_ns1__CountryListResponse::CountryListResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__CountryListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CountryListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CountryListResponse * SOAP_FMAC4 soap_in__ns1__CountryListResponse(struct soap *soap, const char *tag, _ns1__CountryListResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CountryListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__CountryListResponse, sizeof(_ns1__CountryListResponse), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CountryListResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CountryListResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RESPONSE(soap, "ns1:CountryListResult", &a->_ns1__CountryListResponse::CountryListResult, "ns1:RESPONSE"))
				{	soap_flag_CountryListResult1--;
					continue;
				}
			soap_check_result(soap, "ns1:CountryListResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__CountryListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__CountryListResponse, SOAP_TYPE_ns__ns1__CountryListResponse, sizeof(_ns1__CountryListResponse), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__CountryListResponse * SOAP_FMAC2 soap_instantiate__ns1__CountryListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CountryListResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__CountryListResponse *p;
	size_t k = sizeof(_ns1__CountryListResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__CountryListResponse);
		if (p)
			((_ns1__CountryListResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__CountryListResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__CountryListResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__CountryListResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__CountryListResponse, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__CountryListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:CountryListResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CountryListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CountryListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CountryListResponse * SOAP_FMAC4 soap_get__ns1__CountryListResponse(struct soap *soap, _ns1__CountryListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CountryListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__CountryList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__CountryList::Token = NULL;
	/* transient soap skipped */
}

void _ns1__CountryList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__CountryList::Token);
#endif
}

int _ns1__CountryList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CountryList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CountryList(struct soap *soap, const char *tag, int id, const _ns1__CountryList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__CountryList), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Token", -1, &a->_ns1__CountryList::Token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__CountryList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CountryList(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CountryList * SOAP_FMAC4 soap_in__ns1__CountryList(struct soap *soap, const char *tag, _ns1__CountryList *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CountryList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__CountryList, sizeof(_ns1__CountryList), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Token", &a->_ns1__CountryList::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__CountryList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__CountryList, SOAP_TYPE_ns__ns1__CountryList, sizeof(_ns1__CountryList), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__CountryList * SOAP_FMAC2 soap_instantiate__ns1__CountryList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CountryList(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__CountryList *p;
	size_t k = sizeof(_ns1__CountryList);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__CountryList);
		if (p)
			((_ns1__CountryList*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__CountryList, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__CountryList*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__CountryList location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__CountryList, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__CountryList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:CountryList", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CountryList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CountryList(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CountryList * SOAP_FMAC4 soap_get__ns1__CountryList(struct soap *soap, _ns1__CountryList *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CountryList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SplitListBySymbolResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SplitListBySymbolResponse::SplitListBySymbolResult = NULL;
	/* transient soap skipped */
}

void _ns1__SplitListBySymbolResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RESPONSE(soap, &this->_ns1__SplitListBySymbolResponse::SplitListBySymbolResult);
#endif
}

int _ns1__SplitListBySymbolResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SplitListBySymbolResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SplitListBySymbolResponse(struct soap *soap, const char *tag, int id, const _ns1__SplitListBySymbolResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__SplitListBySymbolResponse), type))
		return soap->error;
	if (a->SplitListBySymbolResult)
		soap_element_result(soap, "ns1:SplitListBySymbolResult");
	if (soap_out_PointerTons1__RESPONSE(soap, "ns1:SplitListBySymbolResult", -1, &a->_ns1__SplitListBySymbolResponse::SplitListBySymbolResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SplitListBySymbolResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SplitListBySymbolResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SplitListBySymbolResponse * SOAP_FMAC4 soap_in__ns1__SplitListBySymbolResponse(struct soap *soap, const char *tag, _ns1__SplitListBySymbolResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SplitListBySymbolResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__SplitListBySymbolResponse, sizeof(_ns1__SplitListBySymbolResponse), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SplitListBySymbolResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SplitListBySymbolResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RESPONSE(soap, "ns1:SplitListBySymbolResult", &a->_ns1__SplitListBySymbolResponse::SplitListBySymbolResult, "ns1:RESPONSE"))
				{	soap_flag_SplitListBySymbolResult1--;
					continue;
				}
			soap_check_result(soap, "ns1:SplitListBySymbolResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SplitListBySymbolResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__SplitListBySymbolResponse, SOAP_TYPE_ns__ns1__SplitListBySymbolResponse, sizeof(_ns1__SplitListBySymbolResponse), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SplitListBySymbolResponse * SOAP_FMAC2 soap_instantiate__ns1__SplitListBySymbolResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SplitListBySymbolResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SplitListBySymbolResponse *p;
	size_t k = sizeof(_ns1__SplitListBySymbolResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SplitListBySymbolResponse);
		if (p)
			((_ns1__SplitListBySymbolResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SplitListBySymbolResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SplitListBySymbolResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SplitListBySymbolResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__SplitListBySymbolResponse, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SplitListBySymbolResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:SplitListBySymbolResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SplitListBySymbolResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SplitListBySymbolResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SplitListBySymbolResponse * SOAP_FMAC4 soap_get__ns1__SplitListBySymbolResponse(struct soap *soap, _ns1__SplitListBySymbolResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SplitListBySymbolResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SplitListBySymbol::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SplitListBySymbol::Token = NULL;
	this->_ns1__SplitListBySymbol::Exchange = NULL;
	this->_ns1__SplitListBySymbol::Symbol = NULL;
	/* transient soap skipped */
}

void _ns1__SplitListBySymbol::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SplitListBySymbol::Token);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SplitListBySymbol::Exchange);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SplitListBySymbol::Symbol);
#endif
}

int _ns1__SplitListBySymbol::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SplitListBySymbol(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SplitListBySymbol(struct soap *soap, const char *tag, int id, const _ns1__SplitListBySymbol *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__SplitListBySymbol), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Token", -1, &a->_ns1__SplitListBySymbol::Token, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Exchange", -1, &a->_ns1__SplitListBySymbol::Exchange, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Symbol", -1, &a->_ns1__SplitListBySymbol::Symbol, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SplitListBySymbol::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SplitListBySymbol(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SplitListBySymbol * SOAP_FMAC4 soap_in__ns1__SplitListBySymbol(struct soap *soap, const char *tag, _ns1__SplitListBySymbol *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SplitListBySymbol *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__SplitListBySymbol, sizeof(_ns1__SplitListBySymbol), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	size_t soap_flag_Exchange1 = 1;
	size_t soap_flag_Symbol1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Token", &a->_ns1__SplitListBySymbol::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap_flag_Exchange1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Exchange", &a->_ns1__SplitListBySymbol::Exchange, "xsd:string"))
				{	soap_flag_Exchange1--;
					continue;
				}
			if (soap_flag_Symbol1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Symbol", &a->_ns1__SplitListBySymbol::Symbol, "xsd:string"))
				{	soap_flag_Symbol1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SplitListBySymbol *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__SplitListBySymbol, SOAP_TYPE_ns__ns1__SplitListBySymbol, sizeof(_ns1__SplitListBySymbol), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SplitListBySymbol * SOAP_FMAC2 soap_instantiate__ns1__SplitListBySymbol(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SplitListBySymbol(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SplitListBySymbol *p;
	size_t k = sizeof(_ns1__SplitListBySymbol);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SplitListBySymbol);
		if (p)
			((_ns1__SplitListBySymbol*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SplitListBySymbol, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SplitListBySymbol*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SplitListBySymbol location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__SplitListBySymbol, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SplitListBySymbol::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:SplitListBySymbol", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SplitListBySymbol::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SplitListBySymbol(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SplitListBySymbol * SOAP_FMAC4 soap_get__ns1__SplitListBySymbol(struct soap *soap, _ns1__SplitListBySymbol *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SplitListBySymbol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SplitListByExchangeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SplitListByExchangeResponse::SplitListByExchangeResult = NULL;
	/* transient soap skipped */
}

void _ns1__SplitListByExchangeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RESPONSE(soap, &this->_ns1__SplitListByExchangeResponse::SplitListByExchangeResult);
#endif
}

int _ns1__SplitListByExchangeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SplitListByExchangeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SplitListByExchangeResponse(struct soap *soap, const char *tag, int id, const _ns1__SplitListByExchangeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__SplitListByExchangeResponse), type))
		return soap->error;
	if (a->SplitListByExchangeResult)
		soap_element_result(soap, "ns1:SplitListByExchangeResult");
	if (soap_out_PointerTons1__RESPONSE(soap, "ns1:SplitListByExchangeResult", -1, &a->_ns1__SplitListByExchangeResponse::SplitListByExchangeResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SplitListByExchangeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SplitListByExchangeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SplitListByExchangeResponse * SOAP_FMAC4 soap_in__ns1__SplitListByExchangeResponse(struct soap *soap, const char *tag, _ns1__SplitListByExchangeResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SplitListByExchangeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__SplitListByExchangeResponse, sizeof(_ns1__SplitListByExchangeResponse), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SplitListByExchangeResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SplitListByExchangeResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RESPONSE(soap, "ns1:SplitListByExchangeResult", &a->_ns1__SplitListByExchangeResponse::SplitListByExchangeResult, "ns1:RESPONSE"))
				{	soap_flag_SplitListByExchangeResult1--;
					continue;
				}
			soap_check_result(soap, "ns1:SplitListByExchangeResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SplitListByExchangeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__SplitListByExchangeResponse, SOAP_TYPE_ns__ns1__SplitListByExchangeResponse, sizeof(_ns1__SplitListByExchangeResponse), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SplitListByExchangeResponse * SOAP_FMAC2 soap_instantiate__ns1__SplitListByExchangeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SplitListByExchangeResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SplitListByExchangeResponse *p;
	size_t k = sizeof(_ns1__SplitListByExchangeResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SplitListByExchangeResponse);
		if (p)
			((_ns1__SplitListByExchangeResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SplitListByExchangeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SplitListByExchangeResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SplitListByExchangeResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__SplitListByExchangeResponse, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SplitListByExchangeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:SplitListByExchangeResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SplitListByExchangeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SplitListByExchangeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SplitListByExchangeResponse * SOAP_FMAC4 soap_get__ns1__SplitListByExchangeResponse(struct soap *soap, _ns1__SplitListByExchangeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SplitListByExchangeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SplitListByExchange::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SplitListByExchange::Token = NULL;
	this->_ns1__SplitListByExchange::Exchange = NULL;
	/* transient soap skipped */
}

void _ns1__SplitListByExchange::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SplitListByExchange::Token);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SplitListByExchange::Exchange);
#endif
}

int _ns1__SplitListByExchange::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SplitListByExchange(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SplitListByExchange(struct soap *soap, const char *tag, int id, const _ns1__SplitListByExchange *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__SplitListByExchange), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Token", -1, &a->_ns1__SplitListByExchange::Token, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Exchange", -1, &a->_ns1__SplitListByExchange::Exchange, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SplitListByExchange::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SplitListByExchange(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SplitListByExchange * SOAP_FMAC4 soap_in__ns1__SplitListByExchange(struct soap *soap, const char *tag, _ns1__SplitListByExchange *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SplitListByExchange *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__SplitListByExchange, sizeof(_ns1__SplitListByExchange), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	size_t soap_flag_Exchange1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Token", &a->_ns1__SplitListByExchange::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap_flag_Exchange1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Exchange", &a->_ns1__SplitListByExchange::Exchange, "xsd:string"))
				{	soap_flag_Exchange1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SplitListByExchange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__SplitListByExchange, SOAP_TYPE_ns__ns1__SplitListByExchange, sizeof(_ns1__SplitListByExchange), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SplitListByExchange * SOAP_FMAC2 soap_instantiate__ns1__SplitListByExchange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SplitListByExchange(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SplitListByExchange *p;
	size_t k = sizeof(_ns1__SplitListByExchange);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SplitListByExchange);
		if (p)
			((_ns1__SplitListByExchange*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SplitListByExchange, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SplitListByExchange*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SplitListByExchange location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__SplitListByExchange, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SplitListByExchange::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:SplitListByExchange", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SplitListByExchange::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SplitListByExchange(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SplitListByExchange * SOAP_FMAC4 soap_get__ns1__SplitListByExchange(struct soap *soap, _ns1__SplitListByExchange *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SplitListByExchange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ExchangeMonthsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__ExchangeMonthsResponse::ExchangeMonthsResult = NULL;
	/* transient soap skipped */
}

void _ns1__ExchangeMonthsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RESPONSE(soap, &this->_ns1__ExchangeMonthsResponse::ExchangeMonthsResult);
#endif
}

int _ns1__ExchangeMonthsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ExchangeMonthsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ExchangeMonthsResponse(struct soap *soap, const char *tag, int id, const _ns1__ExchangeMonthsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__ExchangeMonthsResponse), type))
		return soap->error;
	if (a->ExchangeMonthsResult)
		soap_element_result(soap, "ns1:ExchangeMonthsResult");
	if (soap_out_PointerTons1__RESPONSE(soap, "ns1:ExchangeMonthsResult", -1, &a->_ns1__ExchangeMonthsResponse::ExchangeMonthsResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ExchangeMonthsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ExchangeMonthsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ExchangeMonthsResponse * SOAP_FMAC4 soap_in__ns1__ExchangeMonthsResponse(struct soap *soap, const char *tag, _ns1__ExchangeMonthsResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ExchangeMonthsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__ExchangeMonthsResponse, sizeof(_ns1__ExchangeMonthsResponse), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ExchangeMonthsResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ExchangeMonthsResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RESPONSE(soap, "ns1:ExchangeMonthsResult", &a->_ns1__ExchangeMonthsResponse::ExchangeMonthsResult, "ns1:RESPONSE"))
				{	soap_flag_ExchangeMonthsResult1--;
					continue;
				}
			soap_check_result(soap, "ns1:ExchangeMonthsResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__ExchangeMonthsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__ExchangeMonthsResponse, SOAP_TYPE_ns__ns1__ExchangeMonthsResponse, sizeof(_ns1__ExchangeMonthsResponse), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ExchangeMonthsResponse * SOAP_FMAC2 soap_instantiate__ns1__ExchangeMonthsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ExchangeMonthsResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ExchangeMonthsResponse *p;
	size_t k = sizeof(_ns1__ExchangeMonthsResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__ExchangeMonthsResponse);
		if (p)
			((_ns1__ExchangeMonthsResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__ExchangeMonthsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__ExchangeMonthsResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ExchangeMonthsResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__ExchangeMonthsResponse, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__ExchangeMonthsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:ExchangeMonthsResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ExchangeMonthsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ExchangeMonthsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ExchangeMonthsResponse * SOAP_FMAC4 soap_get__ns1__ExchangeMonthsResponse(struct soap *soap, _ns1__ExchangeMonthsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ExchangeMonthsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ExchangeMonths::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__ExchangeMonths::Token = NULL;
	this->_ns1__ExchangeMonths::Exchange = NULL;
	/* transient soap skipped */
}

void _ns1__ExchangeMonths::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__ExchangeMonths::Token);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__ExchangeMonths::Exchange);
#endif
}

int _ns1__ExchangeMonths::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ExchangeMonths(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ExchangeMonths(struct soap *soap, const char *tag, int id, const _ns1__ExchangeMonths *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__ExchangeMonths), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Token", -1, &a->_ns1__ExchangeMonths::Token, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Exchange", -1, &a->_ns1__ExchangeMonths::Exchange, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ExchangeMonths::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ExchangeMonths(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ExchangeMonths * SOAP_FMAC4 soap_in__ns1__ExchangeMonths(struct soap *soap, const char *tag, _ns1__ExchangeMonths *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ExchangeMonths *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__ExchangeMonths, sizeof(_ns1__ExchangeMonths), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	size_t soap_flag_Exchange1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Token", &a->_ns1__ExchangeMonths::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap_flag_Exchange1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Exchange", &a->_ns1__ExchangeMonths::Exchange, "xsd:string"))
				{	soap_flag_Exchange1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__ExchangeMonths *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__ExchangeMonths, SOAP_TYPE_ns__ns1__ExchangeMonths, sizeof(_ns1__ExchangeMonths), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ExchangeMonths * SOAP_FMAC2 soap_instantiate__ns1__ExchangeMonths(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ExchangeMonths(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ExchangeMonths *p;
	size_t k = sizeof(_ns1__ExchangeMonths);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__ExchangeMonths);
		if (p)
			((_ns1__ExchangeMonths*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__ExchangeMonths, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__ExchangeMonths*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ExchangeMonths location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__ExchangeMonths, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__ExchangeMonths::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:ExchangeMonths", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ExchangeMonths::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ExchangeMonths(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ExchangeMonths * SOAP_FMAC4 soap_get__ns1__ExchangeMonths(struct soap *soap, _ns1__ExchangeMonths *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ExchangeMonths(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SymbolChartResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SymbolChartResponse::SymbolChartResult = NULL;
	/* transient soap skipped */
}

void _ns1__SymbolChartResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RESPONSE(soap, &this->_ns1__SymbolChartResponse::SymbolChartResult);
#endif
}

int _ns1__SymbolChartResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SymbolChartResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SymbolChartResponse(struct soap *soap, const char *tag, int id, const _ns1__SymbolChartResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__SymbolChartResponse), type))
		return soap->error;
	if (a->SymbolChartResult)
		soap_element_result(soap, "ns1:SymbolChartResult");
	if (soap_out_PointerTons1__RESPONSE(soap, "ns1:SymbolChartResult", -1, &a->_ns1__SymbolChartResponse::SymbolChartResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SymbolChartResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SymbolChartResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SymbolChartResponse * SOAP_FMAC4 soap_in__ns1__SymbolChartResponse(struct soap *soap, const char *tag, _ns1__SymbolChartResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SymbolChartResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__SymbolChartResponse, sizeof(_ns1__SymbolChartResponse), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SymbolChartResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SymbolChartResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RESPONSE(soap, "ns1:SymbolChartResult", &a->_ns1__SymbolChartResponse::SymbolChartResult, "ns1:RESPONSE"))
				{	soap_flag_SymbolChartResult1--;
					continue;
				}
			soap_check_result(soap, "ns1:SymbolChartResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SymbolChartResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__SymbolChartResponse, SOAP_TYPE_ns__ns1__SymbolChartResponse, sizeof(_ns1__SymbolChartResponse), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SymbolChartResponse * SOAP_FMAC2 soap_instantiate__ns1__SymbolChartResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SymbolChartResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SymbolChartResponse *p;
	size_t k = sizeof(_ns1__SymbolChartResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SymbolChartResponse);
		if (p)
			((_ns1__SymbolChartResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SymbolChartResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SymbolChartResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SymbolChartResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__SymbolChartResponse, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SymbolChartResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:SymbolChartResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SymbolChartResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SymbolChartResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SymbolChartResponse * SOAP_FMAC4 soap_get__ns1__SymbolChartResponse(struct soap *soap, _ns1__SymbolChartResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SymbolChartResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SymbolChart::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SymbolChart::Token = NULL;
	this->_ns1__SymbolChart::Exchange = NULL;
	this->_ns1__SymbolChart::Symbol = NULL;
	/* transient soap skipped */
}

void _ns1__SymbolChart::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SymbolChart::Token);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SymbolChart::Exchange);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SymbolChart::Symbol);
#endif
}

int _ns1__SymbolChart::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SymbolChart(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SymbolChart(struct soap *soap, const char *tag, int id, const _ns1__SymbolChart *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__SymbolChart), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Token", -1, &a->_ns1__SymbolChart::Token, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Exchange", -1, &a->_ns1__SymbolChart::Exchange, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Symbol", -1, &a->_ns1__SymbolChart::Symbol, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SymbolChart::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SymbolChart(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SymbolChart * SOAP_FMAC4 soap_in__ns1__SymbolChart(struct soap *soap, const char *tag, _ns1__SymbolChart *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SymbolChart *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__SymbolChart, sizeof(_ns1__SymbolChart), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	size_t soap_flag_Exchange1 = 1;
	size_t soap_flag_Symbol1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Token", &a->_ns1__SymbolChart::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap_flag_Exchange1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Exchange", &a->_ns1__SymbolChart::Exchange, "xsd:string"))
				{	soap_flag_Exchange1--;
					continue;
				}
			if (soap_flag_Symbol1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Symbol", &a->_ns1__SymbolChart::Symbol, "xsd:string"))
				{	soap_flag_Symbol1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SymbolChart *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__SymbolChart, SOAP_TYPE_ns__ns1__SymbolChart, sizeof(_ns1__SymbolChart), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SymbolChart * SOAP_FMAC2 soap_instantiate__ns1__SymbolChart(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SymbolChart(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SymbolChart *p;
	size_t k = sizeof(_ns1__SymbolChart);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SymbolChart);
		if (p)
			((_ns1__SymbolChart*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SymbolChart, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SymbolChart*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SymbolChart location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__SymbolChart, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SymbolChart::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:SymbolChart", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SymbolChart::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SymbolChart(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SymbolChart * SOAP_FMAC4 soap_get__ns1__SymbolChart(struct soap *soap, _ns1__SymbolChart *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SymbolChart(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__Top10LossesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__Top10LossesResponse::Top10LossesResult = NULL;
	/* transient soap skipped */
}

void _ns1__Top10LossesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RESPONSE(soap, &this->_ns1__Top10LossesResponse::Top10LossesResult);
#endif
}

int _ns1__Top10LossesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__Top10LossesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__Top10LossesResponse(struct soap *soap, const char *tag, int id, const _ns1__Top10LossesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__Top10LossesResponse), type))
		return soap->error;
	if (a->Top10LossesResult)
		soap_element_result(soap, "ns1:Top10LossesResult");
	if (soap_out_PointerTons1__RESPONSE(soap, "ns1:Top10LossesResult", -1, &a->_ns1__Top10LossesResponse::Top10LossesResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__Top10LossesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__Top10LossesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__Top10LossesResponse * SOAP_FMAC4 soap_in__ns1__Top10LossesResponse(struct soap *soap, const char *tag, _ns1__Top10LossesResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__Top10LossesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__Top10LossesResponse, sizeof(_ns1__Top10LossesResponse), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Top10LossesResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Top10LossesResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RESPONSE(soap, "ns1:Top10LossesResult", &a->_ns1__Top10LossesResponse::Top10LossesResult, "ns1:RESPONSE"))
				{	soap_flag_Top10LossesResult1--;
					continue;
				}
			soap_check_result(soap, "ns1:Top10LossesResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__Top10LossesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__Top10LossesResponse, SOAP_TYPE_ns__ns1__Top10LossesResponse, sizeof(_ns1__Top10LossesResponse), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__Top10LossesResponse * SOAP_FMAC2 soap_instantiate__ns1__Top10LossesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__Top10LossesResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__Top10LossesResponse *p;
	size_t k = sizeof(_ns1__Top10LossesResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__Top10LossesResponse);
		if (p)
			((_ns1__Top10LossesResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__Top10LossesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__Top10LossesResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__Top10LossesResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__Top10LossesResponse, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__Top10LossesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:Top10LossesResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__Top10LossesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__Top10LossesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__Top10LossesResponse * SOAP_FMAC4 soap_get__ns1__Top10LossesResponse(struct soap *soap, _ns1__Top10LossesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__Top10LossesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__Top10Losses::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__Top10Losses::Token = NULL;
	this->_ns1__Top10Losses::Exchange = NULL;
	/* transient soap skipped */
}

void _ns1__Top10Losses::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__Top10Losses::Token);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__Top10Losses::Exchange);
#endif
}

int _ns1__Top10Losses::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__Top10Losses(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__Top10Losses(struct soap *soap, const char *tag, int id, const _ns1__Top10Losses *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__Top10Losses), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Token", -1, &a->_ns1__Top10Losses::Token, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Exchange", -1, &a->_ns1__Top10Losses::Exchange, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__Top10Losses::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__Top10Losses(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__Top10Losses * SOAP_FMAC4 soap_in__ns1__Top10Losses(struct soap *soap, const char *tag, _ns1__Top10Losses *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__Top10Losses *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__Top10Losses, sizeof(_ns1__Top10Losses), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	size_t soap_flag_Exchange1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Token", &a->_ns1__Top10Losses::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap_flag_Exchange1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Exchange", &a->_ns1__Top10Losses::Exchange, "xsd:string"))
				{	soap_flag_Exchange1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__Top10Losses *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__Top10Losses, SOAP_TYPE_ns__ns1__Top10Losses, sizeof(_ns1__Top10Losses), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__Top10Losses * SOAP_FMAC2 soap_instantiate__ns1__Top10Losses(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__Top10Losses(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__Top10Losses *p;
	size_t k = sizeof(_ns1__Top10Losses);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__Top10Losses);
		if (p)
			((_ns1__Top10Losses*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__Top10Losses, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__Top10Losses*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__Top10Losses location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__Top10Losses, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__Top10Losses::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:Top10Losses", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__Top10Losses::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__Top10Losses(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__Top10Losses * SOAP_FMAC4 soap_get__ns1__Top10Losses(struct soap *soap, _ns1__Top10Losses *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__Top10Losses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__Top10GainsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__Top10GainsResponse::Top10GainsResult = NULL;
	/* transient soap skipped */
}

void _ns1__Top10GainsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RESPONSE(soap, &this->_ns1__Top10GainsResponse::Top10GainsResult);
#endif
}

int _ns1__Top10GainsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__Top10GainsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__Top10GainsResponse(struct soap *soap, const char *tag, int id, const _ns1__Top10GainsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__Top10GainsResponse), type))
		return soap->error;
	if (a->Top10GainsResult)
		soap_element_result(soap, "ns1:Top10GainsResult");
	if (soap_out_PointerTons1__RESPONSE(soap, "ns1:Top10GainsResult", -1, &a->_ns1__Top10GainsResponse::Top10GainsResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__Top10GainsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__Top10GainsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__Top10GainsResponse * SOAP_FMAC4 soap_in__ns1__Top10GainsResponse(struct soap *soap, const char *tag, _ns1__Top10GainsResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__Top10GainsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__Top10GainsResponse, sizeof(_ns1__Top10GainsResponse), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Top10GainsResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Top10GainsResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RESPONSE(soap, "ns1:Top10GainsResult", &a->_ns1__Top10GainsResponse::Top10GainsResult, "ns1:RESPONSE"))
				{	soap_flag_Top10GainsResult1--;
					continue;
				}
			soap_check_result(soap, "ns1:Top10GainsResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__Top10GainsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__Top10GainsResponse, SOAP_TYPE_ns__ns1__Top10GainsResponse, sizeof(_ns1__Top10GainsResponse), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__Top10GainsResponse * SOAP_FMAC2 soap_instantiate__ns1__Top10GainsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__Top10GainsResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__Top10GainsResponse *p;
	size_t k = sizeof(_ns1__Top10GainsResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__Top10GainsResponse);
		if (p)
			((_ns1__Top10GainsResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__Top10GainsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__Top10GainsResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__Top10GainsResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__Top10GainsResponse, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__Top10GainsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:Top10GainsResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__Top10GainsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__Top10GainsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__Top10GainsResponse * SOAP_FMAC4 soap_get__ns1__Top10GainsResponse(struct soap *soap, _ns1__Top10GainsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__Top10GainsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__Top10Gains::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__Top10Gains::Token = NULL;
	this->_ns1__Top10Gains::Exchange = NULL;
	/* transient soap skipped */
}

void _ns1__Top10Gains::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__Top10Gains::Token);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__Top10Gains::Exchange);
#endif
}

int _ns1__Top10Gains::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__Top10Gains(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__Top10Gains(struct soap *soap, const char *tag, int id, const _ns1__Top10Gains *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__Top10Gains), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Token", -1, &a->_ns1__Top10Gains::Token, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Exchange", -1, &a->_ns1__Top10Gains::Exchange, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__Top10Gains::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__Top10Gains(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__Top10Gains * SOAP_FMAC4 soap_in__ns1__Top10Gains(struct soap *soap, const char *tag, _ns1__Top10Gains *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__Top10Gains *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__Top10Gains, sizeof(_ns1__Top10Gains), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	size_t soap_flag_Exchange1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Token", &a->_ns1__Top10Gains::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap_flag_Exchange1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Exchange", &a->_ns1__Top10Gains::Exchange, "xsd:string"))
				{	soap_flag_Exchange1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__Top10Gains *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__Top10Gains, SOAP_TYPE_ns__ns1__Top10Gains, sizeof(_ns1__Top10Gains), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__Top10Gains * SOAP_FMAC2 soap_instantiate__ns1__Top10Gains(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__Top10Gains(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__Top10Gains *p;
	size_t k = sizeof(_ns1__Top10Gains);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__Top10Gains);
		if (p)
			((_ns1__Top10Gains*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__Top10Gains, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__Top10Gains*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__Top10Gains location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__Top10Gains, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__Top10Gains::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:Top10Gains", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__Top10Gains::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__Top10Gains(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__Top10Gains * SOAP_FMAC4 soap_get__ns1__Top10Gains(struct soap *soap, _ns1__Top10Gains *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__Top10Gains(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SymbolHistoryResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SymbolHistoryResponse::SymbolHistoryResult = NULL;
	/* transient soap skipped */
}

void _ns1__SymbolHistoryResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RESPONSE(soap, &this->_ns1__SymbolHistoryResponse::SymbolHistoryResult);
#endif
}

int _ns1__SymbolHistoryResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SymbolHistoryResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SymbolHistoryResponse(struct soap *soap, const char *tag, int id, const _ns1__SymbolHistoryResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__SymbolHistoryResponse), type))
		return soap->error;
	if (a->SymbolHistoryResult)
		soap_element_result(soap, "ns1:SymbolHistoryResult");
	if (soap_out_PointerTons1__RESPONSE(soap, "ns1:SymbolHistoryResult", -1, &a->_ns1__SymbolHistoryResponse::SymbolHistoryResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SymbolHistoryResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SymbolHistoryResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SymbolHistoryResponse * SOAP_FMAC4 soap_in__ns1__SymbolHistoryResponse(struct soap *soap, const char *tag, _ns1__SymbolHistoryResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SymbolHistoryResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__SymbolHistoryResponse, sizeof(_ns1__SymbolHistoryResponse), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SymbolHistoryResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SymbolHistoryResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RESPONSE(soap, "ns1:SymbolHistoryResult", &a->_ns1__SymbolHistoryResponse::SymbolHistoryResult, "ns1:RESPONSE"))
				{	soap_flag_SymbolHistoryResult1--;
					continue;
				}
			soap_check_result(soap, "ns1:SymbolHistoryResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SymbolHistoryResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__SymbolHistoryResponse, SOAP_TYPE_ns__ns1__SymbolHistoryResponse, sizeof(_ns1__SymbolHistoryResponse), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SymbolHistoryResponse * SOAP_FMAC2 soap_instantiate__ns1__SymbolHistoryResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SymbolHistoryResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SymbolHistoryResponse *p;
	size_t k = sizeof(_ns1__SymbolHistoryResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SymbolHistoryResponse);
		if (p)
			((_ns1__SymbolHistoryResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SymbolHistoryResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SymbolHistoryResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SymbolHistoryResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__SymbolHistoryResponse, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SymbolHistoryResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:SymbolHistoryResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SymbolHistoryResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SymbolHistoryResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SymbolHistoryResponse * SOAP_FMAC4 soap_get__ns1__SymbolHistoryResponse(struct soap *soap, _ns1__SymbolHistoryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SymbolHistoryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SymbolHistory::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SymbolHistory::Token = NULL;
	this->_ns1__SymbolHistory::Exchange = NULL;
	this->_ns1__SymbolHistory::Symbol = NULL;
	this->_ns1__SymbolHistory::StartDate = NULL;
	/* transient soap skipped */
}

void _ns1__SymbolHistory::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SymbolHistory::Token);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SymbolHistory::Exchange);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SymbolHistory::Symbol);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SymbolHistory::StartDate);
#endif
}

int _ns1__SymbolHistory::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SymbolHistory(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SymbolHistory(struct soap *soap, const char *tag, int id, const _ns1__SymbolHistory *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__SymbolHistory), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Token", -1, &a->_ns1__SymbolHistory::Token, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Exchange", -1, &a->_ns1__SymbolHistory::Exchange, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Symbol", -1, &a->_ns1__SymbolHistory::Symbol, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:StartDate", -1, &a->_ns1__SymbolHistory::StartDate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SymbolHistory::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SymbolHistory(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SymbolHistory * SOAP_FMAC4 soap_in__ns1__SymbolHistory(struct soap *soap, const char *tag, _ns1__SymbolHistory *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SymbolHistory *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__SymbolHistory, sizeof(_ns1__SymbolHistory), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	size_t soap_flag_Exchange1 = 1;
	size_t soap_flag_Symbol1 = 1;
	size_t soap_flag_StartDate1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Token", &a->_ns1__SymbolHistory::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap_flag_Exchange1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Exchange", &a->_ns1__SymbolHistory::Exchange, "xsd:string"))
				{	soap_flag_Exchange1--;
					continue;
				}
			if (soap_flag_Symbol1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Symbol", &a->_ns1__SymbolHistory::Symbol, "xsd:string"))
				{	soap_flag_Symbol1--;
					continue;
				}
			if (soap_flag_StartDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:StartDate", &a->_ns1__SymbolHistory::StartDate, "xsd:string"))
				{	soap_flag_StartDate1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SymbolHistory *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__SymbolHistory, SOAP_TYPE_ns__ns1__SymbolHistory, sizeof(_ns1__SymbolHistory), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SymbolHistory * SOAP_FMAC2 soap_instantiate__ns1__SymbolHistory(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SymbolHistory(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SymbolHistory *p;
	size_t k = sizeof(_ns1__SymbolHistory);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SymbolHistory);
		if (p)
			((_ns1__SymbolHistory*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SymbolHistory, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SymbolHistory*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SymbolHistory location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__SymbolHistory, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SymbolHistory::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:SymbolHistory", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SymbolHistory::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SymbolHistory(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SymbolHistory * SOAP_FMAC4 soap_get__ns1__SymbolHistory(struct soap *soap, _ns1__SymbolHistory *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SymbolHistory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__QuoteListByDate2Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__QuoteListByDate2Response::QuoteListByDate2Result = NULL;
	/* transient soap skipped */
}

void _ns1__QuoteListByDate2Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RESPONSE(soap, &this->_ns1__QuoteListByDate2Response::QuoteListByDate2Result);
#endif
}

int _ns1__QuoteListByDate2Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__QuoteListByDate2Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__QuoteListByDate2Response(struct soap *soap, const char *tag, int id, const _ns1__QuoteListByDate2Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__QuoteListByDate2Response), type))
		return soap->error;
	if (a->QuoteListByDate2Result)
		soap_element_result(soap, "ns1:QuoteListByDate2Result");
	if (soap_out_PointerTons1__RESPONSE(soap, "ns1:QuoteListByDate2Result", -1, &a->_ns1__QuoteListByDate2Response::QuoteListByDate2Result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__QuoteListByDate2Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__QuoteListByDate2Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__QuoteListByDate2Response * SOAP_FMAC4 soap_in__ns1__QuoteListByDate2Response(struct soap *soap, const char *tag, _ns1__QuoteListByDate2Response *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__QuoteListByDate2Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__QuoteListByDate2Response, sizeof(_ns1__QuoteListByDate2Response), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_QuoteListByDate2Result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_QuoteListByDate2Result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RESPONSE(soap, "ns1:QuoteListByDate2Result", &a->_ns1__QuoteListByDate2Response::QuoteListByDate2Result, "ns1:RESPONSE"))
				{	soap_flag_QuoteListByDate2Result1--;
					continue;
				}
			soap_check_result(soap, "ns1:QuoteListByDate2Result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__QuoteListByDate2Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__QuoteListByDate2Response, SOAP_TYPE_ns__ns1__QuoteListByDate2Response, sizeof(_ns1__QuoteListByDate2Response), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__QuoteListByDate2Response * SOAP_FMAC2 soap_instantiate__ns1__QuoteListByDate2Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__QuoteListByDate2Response(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__QuoteListByDate2Response *p;
	size_t k = sizeof(_ns1__QuoteListByDate2Response);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__QuoteListByDate2Response);
		if (p)
			((_ns1__QuoteListByDate2Response*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__QuoteListByDate2Response, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__QuoteListByDate2Response*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__QuoteListByDate2Response location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__QuoteListByDate2Response, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__QuoteListByDate2Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:QuoteListByDate2Response", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__QuoteListByDate2Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__QuoteListByDate2Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__QuoteListByDate2Response * SOAP_FMAC4 soap_get__ns1__QuoteListByDate2Response(struct soap *soap, _ns1__QuoteListByDate2Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__QuoteListByDate2Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__QuoteListByDate2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__QuoteListByDate2::Token = NULL;
	this->_ns1__QuoteListByDate2::Exchange = NULL;
	this->_ns1__QuoteListByDate2::QuoteDate = NULL;
	/* transient soap skipped */
}

void _ns1__QuoteListByDate2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__QuoteListByDate2::Token);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__QuoteListByDate2::Exchange);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__QuoteListByDate2::QuoteDate);
#endif
}

int _ns1__QuoteListByDate2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__QuoteListByDate2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__QuoteListByDate2(struct soap *soap, const char *tag, int id, const _ns1__QuoteListByDate2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__QuoteListByDate2), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Token", -1, &a->_ns1__QuoteListByDate2::Token, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Exchange", -1, &a->_ns1__QuoteListByDate2::Exchange, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:QuoteDate", -1, &a->_ns1__QuoteListByDate2::QuoteDate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__QuoteListByDate2::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__QuoteListByDate2(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__QuoteListByDate2 * SOAP_FMAC4 soap_in__ns1__QuoteListByDate2(struct soap *soap, const char *tag, _ns1__QuoteListByDate2 *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__QuoteListByDate2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__QuoteListByDate2, sizeof(_ns1__QuoteListByDate2), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	size_t soap_flag_Exchange1 = 1;
	size_t soap_flag_QuoteDate1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Token", &a->_ns1__QuoteListByDate2::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap_flag_Exchange1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Exchange", &a->_ns1__QuoteListByDate2::Exchange, "xsd:string"))
				{	soap_flag_Exchange1--;
					continue;
				}
			if (soap_flag_QuoteDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:QuoteDate", &a->_ns1__QuoteListByDate2::QuoteDate, "xsd:string"))
				{	soap_flag_QuoteDate1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__QuoteListByDate2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__QuoteListByDate2, SOAP_TYPE_ns__ns1__QuoteListByDate2, sizeof(_ns1__QuoteListByDate2), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__QuoteListByDate2 * SOAP_FMAC2 soap_instantiate__ns1__QuoteListByDate2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__QuoteListByDate2(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__QuoteListByDate2 *p;
	size_t k = sizeof(_ns1__QuoteListByDate2);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__QuoteListByDate2);
		if (p)
			((_ns1__QuoteListByDate2*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__QuoteListByDate2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__QuoteListByDate2*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__QuoteListByDate2 location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__QuoteListByDate2, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__QuoteListByDate2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:QuoteListByDate2", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__QuoteListByDate2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__QuoteListByDate2(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__QuoteListByDate2 * SOAP_FMAC4 soap_get__ns1__QuoteListByDate2(struct soap *soap, _ns1__QuoteListByDate2 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__QuoteListByDate2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__QuoteListByDateResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__QuoteListByDateResponse::QuoteListByDateResult = NULL;
	/* transient soap skipped */
}

void _ns1__QuoteListByDateResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RESPONSE(soap, &this->_ns1__QuoteListByDateResponse::QuoteListByDateResult);
#endif
}

int _ns1__QuoteListByDateResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__QuoteListByDateResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__QuoteListByDateResponse(struct soap *soap, const char *tag, int id, const _ns1__QuoteListByDateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__QuoteListByDateResponse), type))
		return soap->error;
	if (a->QuoteListByDateResult)
		soap_element_result(soap, "ns1:QuoteListByDateResult");
	if (soap_out_PointerTons1__RESPONSE(soap, "ns1:QuoteListByDateResult", -1, &a->_ns1__QuoteListByDateResponse::QuoteListByDateResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__QuoteListByDateResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__QuoteListByDateResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__QuoteListByDateResponse * SOAP_FMAC4 soap_in__ns1__QuoteListByDateResponse(struct soap *soap, const char *tag, _ns1__QuoteListByDateResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__QuoteListByDateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__QuoteListByDateResponse, sizeof(_ns1__QuoteListByDateResponse), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_QuoteListByDateResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_QuoteListByDateResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RESPONSE(soap, "ns1:QuoteListByDateResult", &a->_ns1__QuoteListByDateResponse::QuoteListByDateResult, "ns1:RESPONSE"))
				{	soap_flag_QuoteListByDateResult1--;
					continue;
				}
			soap_check_result(soap, "ns1:QuoteListByDateResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__QuoteListByDateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__QuoteListByDateResponse, SOAP_TYPE_ns__ns1__QuoteListByDateResponse, sizeof(_ns1__QuoteListByDateResponse), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__QuoteListByDateResponse * SOAP_FMAC2 soap_instantiate__ns1__QuoteListByDateResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__QuoteListByDateResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__QuoteListByDateResponse *p;
	size_t k = sizeof(_ns1__QuoteListByDateResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__QuoteListByDateResponse);
		if (p)
			((_ns1__QuoteListByDateResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__QuoteListByDateResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__QuoteListByDateResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__QuoteListByDateResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__QuoteListByDateResponse, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__QuoteListByDateResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:QuoteListByDateResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__QuoteListByDateResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__QuoteListByDateResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__QuoteListByDateResponse * SOAP_FMAC4 soap_get__ns1__QuoteListByDateResponse(struct soap *soap, _ns1__QuoteListByDateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__QuoteListByDateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__QuoteListByDate::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__QuoteListByDate::Token = NULL;
	this->_ns1__QuoteListByDate::Exchange = NULL;
	this->_ns1__QuoteListByDate::QuoteDate = NULL;
	/* transient soap skipped */
}

void _ns1__QuoteListByDate::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__QuoteListByDate::Token);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__QuoteListByDate::Exchange);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__QuoteListByDate::QuoteDate);
#endif
}

int _ns1__QuoteListByDate::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__QuoteListByDate(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__QuoteListByDate(struct soap *soap, const char *tag, int id, const _ns1__QuoteListByDate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__QuoteListByDate), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Token", -1, &a->_ns1__QuoteListByDate::Token, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Exchange", -1, &a->_ns1__QuoteListByDate::Exchange, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:QuoteDate", -1, &a->_ns1__QuoteListByDate::QuoteDate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__QuoteListByDate::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__QuoteListByDate(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__QuoteListByDate * SOAP_FMAC4 soap_in__ns1__QuoteListByDate(struct soap *soap, const char *tag, _ns1__QuoteListByDate *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__QuoteListByDate *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__QuoteListByDate, sizeof(_ns1__QuoteListByDate), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	size_t soap_flag_Exchange1 = 1;
	size_t soap_flag_QuoteDate1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Token", &a->_ns1__QuoteListByDate::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap_flag_Exchange1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Exchange", &a->_ns1__QuoteListByDate::Exchange, "xsd:string"))
				{	soap_flag_Exchange1--;
					continue;
				}
			if (soap_flag_QuoteDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:QuoteDate", &a->_ns1__QuoteListByDate::QuoteDate, "xsd:string"))
				{	soap_flag_QuoteDate1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__QuoteListByDate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__QuoteListByDate, SOAP_TYPE_ns__ns1__QuoteListByDate, sizeof(_ns1__QuoteListByDate), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__QuoteListByDate * SOAP_FMAC2 soap_instantiate__ns1__QuoteListByDate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__QuoteListByDate(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__QuoteListByDate *p;
	size_t k = sizeof(_ns1__QuoteListByDate);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__QuoteListByDate);
		if (p)
			((_ns1__QuoteListByDate*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__QuoteListByDate, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__QuoteListByDate*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__QuoteListByDate location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__QuoteListByDate, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__QuoteListByDate::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:QuoteListByDate", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__QuoteListByDate::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__QuoteListByDate(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__QuoteListByDate * SOAP_FMAC4 soap_get__ns1__QuoteListByDate(struct soap *soap, _ns1__QuoteListByDate *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__QuoteListByDate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__TechnicalListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__TechnicalListResponse::TechnicalListResult = NULL;
	/* transient soap skipped */
}

void _ns1__TechnicalListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RESPONSE(soap, &this->_ns1__TechnicalListResponse::TechnicalListResult);
#endif
}

int _ns1__TechnicalListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__TechnicalListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__TechnicalListResponse(struct soap *soap, const char *tag, int id, const _ns1__TechnicalListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__TechnicalListResponse), type))
		return soap->error;
	if (a->TechnicalListResult)
		soap_element_result(soap, "ns1:TechnicalListResult");
	if (soap_out_PointerTons1__RESPONSE(soap, "ns1:TechnicalListResult", -1, &a->_ns1__TechnicalListResponse::TechnicalListResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__TechnicalListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__TechnicalListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__TechnicalListResponse * SOAP_FMAC4 soap_in__ns1__TechnicalListResponse(struct soap *soap, const char *tag, _ns1__TechnicalListResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__TechnicalListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__TechnicalListResponse, sizeof(_ns1__TechnicalListResponse), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_TechnicalListResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TechnicalListResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RESPONSE(soap, "ns1:TechnicalListResult", &a->_ns1__TechnicalListResponse::TechnicalListResult, "ns1:RESPONSE"))
				{	soap_flag_TechnicalListResult1--;
					continue;
				}
			soap_check_result(soap, "ns1:TechnicalListResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__TechnicalListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__TechnicalListResponse, SOAP_TYPE_ns__ns1__TechnicalListResponse, sizeof(_ns1__TechnicalListResponse), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__TechnicalListResponse * SOAP_FMAC2 soap_instantiate__ns1__TechnicalListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__TechnicalListResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__TechnicalListResponse *p;
	size_t k = sizeof(_ns1__TechnicalListResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__TechnicalListResponse);
		if (p)
			((_ns1__TechnicalListResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__TechnicalListResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__TechnicalListResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__TechnicalListResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__TechnicalListResponse, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__TechnicalListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:TechnicalListResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__TechnicalListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__TechnicalListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__TechnicalListResponse * SOAP_FMAC4 soap_get__ns1__TechnicalListResponse(struct soap *soap, _ns1__TechnicalListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__TechnicalListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__TechnicalList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__TechnicalList::Token = NULL;
	this->_ns1__TechnicalList::Exchange = NULL;
	/* transient soap skipped */
}

void _ns1__TechnicalList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__TechnicalList::Token);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__TechnicalList::Exchange);
#endif
}

int _ns1__TechnicalList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__TechnicalList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__TechnicalList(struct soap *soap, const char *tag, int id, const _ns1__TechnicalList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__TechnicalList), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Token", -1, &a->_ns1__TechnicalList::Token, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Exchange", -1, &a->_ns1__TechnicalList::Exchange, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__TechnicalList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__TechnicalList(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__TechnicalList * SOAP_FMAC4 soap_in__ns1__TechnicalList(struct soap *soap, const char *tag, _ns1__TechnicalList *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__TechnicalList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__TechnicalList, sizeof(_ns1__TechnicalList), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	size_t soap_flag_Exchange1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Token", &a->_ns1__TechnicalList::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap_flag_Exchange1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Exchange", &a->_ns1__TechnicalList::Exchange, "xsd:string"))
				{	soap_flag_Exchange1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__TechnicalList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__TechnicalList, SOAP_TYPE_ns__ns1__TechnicalList, sizeof(_ns1__TechnicalList), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__TechnicalList * SOAP_FMAC2 soap_instantiate__ns1__TechnicalList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__TechnicalList(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__TechnicalList *p;
	size_t k = sizeof(_ns1__TechnicalList);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__TechnicalList);
		if (p)
			((_ns1__TechnicalList*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__TechnicalList, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__TechnicalList*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__TechnicalList location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__TechnicalList, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__TechnicalList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:TechnicalList", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__TechnicalList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__TechnicalList(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__TechnicalList * SOAP_FMAC4 soap_get__ns1__TechnicalList(struct soap *soap, _ns1__TechnicalList *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__TechnicalList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__FundamentalListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__FundamentalListResponse::FundamentalListResult = NULL;
	/* transient soap skipped */
}

void _ns1__FundamentalListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RESPONSE(soap, &this->_ns1__FundamentalListResponse::FundamentalListResult);
#endif
}

int _ns1__FundamentalListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__FundamentalListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__FundamentalListResponse(struct soap *soap, const char *tag, int id, const _ns1__FundamentalListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__FundamentalListResponse), type))
		return soap->error;
	if (a->FundamentalListResult)
		soap_element_result(soap, "ns1:FundamentalListResult");
	if (soap_out_PointerTons1__RESPONSE(soap, "ns1:FundamentalListResult", -1, &a->_ns1__FundamentalListResponse::FundamentalListResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__FundamentalListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__FundamentalListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__FundamentalListResponse * SOAP_FMAC4 soap_in__ns1__FundamentalListResponse(struct soap *soap, const char *tag, _ns1__FundamentalListResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__FundamentalListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__FundamentalListResponse, sizeof(_ns1__FundamentalListResponse), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FundamentalListResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FundamentalListResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RESPONSE(soap, "ns1:FundamentalListResult", &a->_ns1__FundamentalListResponse::FundamentalListResult, "ns1:RESPONSE"))
				{	soap_flag_FundamentalListResult1--;
					continue;
				}
			soap_check_result(soap, "ns1:FundamentalListResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__FundamentalListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__FundamentalListResponse, SOAP_TYPE_ns__ns1__FundamentalListResponse, sizeof(_ns1__FundamentalListResponse), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__FundamentalListResponse * SOAP_FMAC2 soap_instantiate__ns1__FundamentalListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__FundamentalListResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__FundamentalListResponse *p;
	size_t k = sizeof(_ns1__FundamentalListResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__FundamentalListResponse);
		if (p)
			((_ns1__FundamentalListResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__FundamentalListResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__FundamentalListResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__FundamentalListResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__FundamentalListResponse, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__FundamentalListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:FundamentalListResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__FundamentalListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__FundamentalListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__FundamentalListResponse * SOAP_FMAC4 soap_get__ns1__FundamentalListResponse(struct soap *soap, _ns1__FundamentalListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__FundamentalListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__FundamentalList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__FundamentalList::Token = NULL;
	this->_ns1__FundamentalList::Exchange = NULL;
	/* transient soap skipped */
}

void _ns1__FundamentalList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__FundamentalList::Token);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__FundamentalList::Exchange);
#endif
}

int _ns1__FundamentalList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__FundamentalList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__FundamentalList(struct soap *soap, const char *tag, int id, const _ns1__FundamentalList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__FundamentalList), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Token", -1, &a->_ns1__FundamentalList::Token, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Exchange", -1, &a->_ns1__FundamentalList::Exchange, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__FundamentalList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__FundamentalList(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__FundamentalList * SOAP_FMAC4 soap_in__ns1__FundamentalList(struct soap *soap, const char *tag, _ns1__FundamentalList *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__FundamentalList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__FundamentalList, sizeof(_ns1__FundamentalList), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	size_t soap_flag_Exchange1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Token", &a->_ns1__FundamentalList::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap_flag_Exchange1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Exchange", &a->_ns1__FundamentalList::Exchange, "xsd:string"))
				{	soap_flag_Exchange1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__FundamentalList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__FundamentalList, SOAP_TYPE_ns__ns1__FundamentalList, sizeof(_ns1__FundamentalList), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__FundamentalList * SOAP_FMAC2 soap_instantiate__ns1__FundamentalList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__FundamentalList(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__FundamentalList *p;
	size_t k = sizeof(_ns1__FundamentalList);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__FundamentalList);
		if (p)
			((_ns1__FundamentalList*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__FundamentalList, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__FundamentalList*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__FundamentalList location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__FundamentalList, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__FundamentalList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:FundamentalList", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__FundamentalList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__FundamentalList(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__FundamentalList * SOAP_FMAC4 soap_get__ns1__FundamentalList(struct soap *soap, _ns1__FundamentalList *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__FundamentalList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__NewsListBySymbolResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__NewsListBySymbolResponse::NewsListBySymbolResult = NULL;
	/* transient soap skipped */
}

void _ns1__NewsListBySymbolResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RESPONSE(soap, &this->_ns1__NewsListBySymbolResponse::NewsListBySymbolResult);
#endif
}

int _ns1__NewsListBySymbolResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__NewsListBySymbolResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__NewsListBySymbolResponse(struct soap *soap, const char *tag, int id, const _ns1__NewsListBySymbolResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__NewsListBySymbolResponse), type))
		return soap->error;
	if (a->NewsListBySymbolResult)
		soap_element_result(soap, "ns1:NewsListBySymbolResult");
	if (soap_out_PointerTons1__RESPONSE(soap, "ns1:NewsListBySymbolResult", -1, &a->_ns1__NewsListBySymbolResponse::NewsListBySymbolResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__NewsListBySymbolResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__NewsListBySymbolResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__NewsListBySymbolResponse * SOAP_FMAC4 soap_in__ns1__NewsListBySymbolResponse(struct soap *soap, const char *tag, _ns1__NewsListBySymbolResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__NewsListBySymbolResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__NewsListBySymbolResponse, sizeof(_ns1__NewsListBySymbolResponse), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_NewsListBySymbolResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_NewsListBySymbolResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RESPONSE(soap, "ns1:NewsListBySymbolResult", &a->_ns1__NewsListBySymbolResponse::NewsListBySymbolResult, "ns1:RESPONSE"))
				{	soap_flag_NewsListBySymbolResult1--;
					continue;
				}
			soap_check_result(soap, "ns1:NewsListBySymbolResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__NewsListBySymbolResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__NewsListBySymbolResponse, SOAP_TYPE_ns__ns1__NewsListBySymbolResponse, sizeof(_ns1__NewsListBySymbolResponse), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__NewsListBySymbolResponse * SOAP_FMAC2 soap_instantiate__ns1__NewsListBySymbolResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__NewsListBySymbolResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__NewsListBySymbolResponse *p;
	size_t k = sizeof(_ns1__NewsListBySymbolResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__NewsListBySymbolResponse);
		if (p)
			((_ns1__NewsListBySymbolResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__NewsListBySymbolResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__NewsListBySymbolResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__NewsListBySymbolResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__NewsListBySymbolResponse, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__NewsListBySymbolResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:NewsListBySymbolResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__NewsListBySymbolResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__NewsListBySymbolResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__NewsListBySymbolResponse * SOAP_FMAC4 soap_get__ns1__NewsListBySymbolResponse(struct soap *soap, _ns1__NewsListBySymbolResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__NewsListBySymbolResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__NewsListBySymbol::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__NewsListBySymbol::token = NULL;
	this->_ns1__NewsListBySymbol::Exchange = NULL;
	this->_ns1__NewsListBySymbol::symbol = NULL;
	/* transient soap skipped */
}

void _ns1__NewsListBySymbol::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__NewsListBySymbol::token);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__NewsListBySymbol::Exchange);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__NewsListBySymbol::symbol);
#endif
}

int _ns1__NewsListBySymbol::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__NewsListBySymbol(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__NewsListBySymbol(struct soap *soap, const char *tag, int id, const _ns1__NewsListBySymbol *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__NewsListBySymbol), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:token", -1, &a->_ns1__NewsListBySymbol::token, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Exchange", -1, &a->_ns1__NewsListBySymbol::Exchange, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:symbol", -1, &a->_ns1__NewsListBySymbol::symbol, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__NewsListBySymbol::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__NewsListBySymbol(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__NewsListBySymbol * SOAP_FMAC4 soap_in__ns1__NewsListBySymbol(struct soap *soap, const char *tag, _ns1__NewsListBySymbol *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__NewsListBySymbol *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__NewsListBySymbol, sizeof(_ns1__NewsListBySymbol), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_token1 = 1;
	size_t soap_flag_Exchange1 = 1;
	size_t soap_flag_symbol1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:token", &a->_ns1__NewsListBySymbol::token, "xsd:string"))
				{	soap_flag_token1--;
					continue;
				}
			if (soap_flag_Exchange1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Exchange", &a->_ns1__NewsListBySymbol::Exchange, "xsd:string"))
				{	soap_flag_Exchange1--;
					continue;
				}
			if (soap_flag_symbol1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:symbol", &a->_ns1__NewsListBySymbol::symbol, "xsd:string"))
				{	soap_flag_symbol1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__NewsListBySymbol *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__NewsListBySymbol, SOAP_TYPE_ns__ns1__NewsListBySymbol, sizeof(_ns1__NewsListBySymbol), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__NewsListBySymbol * SOAP_FMAC2 soap_instantiate__ns1__NewsListBySymbol(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__NewsListBySymbol(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__NewsListBySymbol *p;
	size_t k = sizeof(_ns1__NewsListBySymbol);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__NewsListBySymbol);
		if (p)
			((_ns1__NewsListBySymbol*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__NewsListBySymbol, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__NewsListBySymbol*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__NewsListBySymbol location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__NewsListBySymbol, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__NewsListBySymbol::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:NewsListBySymbol", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__NewsListBySymbol::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__NewsListBySymbol(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__NewsListBySymbol * SOAP_FMAC4 soap_get__ns1__NewsListBySymbol(struct soap *soap, _ns1__NewsListBySymbol *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__NewsListBySymbol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__NewsListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__NewsListResponse::NewsListResult = NULL;
	/* transient soap skipped */
}

void _ns1__NewsListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RESPONSE(soap, &this->_ns1__NewsListResponse::NewsListResult);
#endif
}

int _ns1__NewsListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__NewsListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__NewsListResponse(struct soap *soap, const char *tag, int id, const _ns1__NewsListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__NewsListResponse), type))
		return soap->error;
	if (a->NewsListResult)
		soap_element_result(soap, "ns1:NewsListResult");
	if (soap_out_PointerTons1__RESPONSE(soap, "ns1:NewsListResult", -1, &a->_ns1__NewsListResponse::NewsListResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__NewsListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__NewsListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__NewsListResponse * SOAP_FMAC4 soap_in__ns1__NewsListResponse(struct soap *soap, const char *tag, _ns1__NewsListResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__NewsListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__NewsListResponse, sizeof(_ns1__NewsListResponse), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_NewsListResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_NewsListResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RESPONSE(soap, "ns1:NewsListResult", &a->_ns1__NewsListResponse::NewsListResult, "ns1:RESPONSE"))
				{	soap_flag_NewsListResult1--;
					continue;
				}
			soap_check_result(soap, "ns1:NewsListResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__NewsListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__NewsListResponse, SOAP_TYPE_ns__ns1__NewsListResponse, sizeof(_ns1__NewsListResponse), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__NewsListResponse * SOAP_FMAC2 soap_instantiate__ns1__NewsListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__NewsListResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__NewsListResponse *p;
	size_t k = sizeof(_ns1__NewsListResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__NewsListResponse);
		if (p)
			((_ns1__NewsListResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__NewsListResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__NewsListResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__NewsListResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__NewsListResponse, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__NewsListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:NewsListResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__NewsListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__NewsListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__NewsListResponse * SOAP_FMAC4 soap_get__ns1__NewsListResponse(struct soap *soap, _ns1__NewsListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__NewsListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__NewsList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__NewsList::Token = NULL;
	this->_ns1__NewsList::Exchange = NULL;
	/* transient soap skipped */
}

void _ns1__NewsList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__NewsList::Token);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__NewsList::Exchange);
#endif
}

int _ns1__NewsList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__NewsList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__NewsList(struct soap *soap, const char *tag, int id, const _ns1__NewsList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__NewsList), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Token", -1, &a->_ns1__NewsList::Token, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Exchange", -1, &a->_ns1__NewsList::Exchange, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__NewsList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__NewsList(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__NewsList * SOAP_FMAC4 soap_in__ns1__NewsList(struct soap *soap, const char *tag, _ns1__NewsList *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__NewsList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__NewsList, sizeof(_ns1__NewsList), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	size_t soap_flag_Exchange1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Token", &a->_ns1__NewsList::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap_flag_Exchange1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Exchange", &a->_ns1__NewsList::Exchange, "xsd:string"))
				{	soap_flag_Exchange1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__NewsList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__NewsList, SOAP_TYPE_ns__ns1__NewsList, sizeof(_ns1__NewsList), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__NewsList * SOAP_FMAC2 soap_instantiate__ns1__NewsList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__NewsList(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__NewsList *p;
	size_t k = sizeof(_ns1__NewsList);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__NewsList);
		if (p)
			((_ns1__NewsList*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__NewsList, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__NewsList*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__NewsList location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__NewsList, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__NewsList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:NewsList", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__NewsList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__NewsList(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__NewsList * SOAP_FMAC4 soap_get__ns1__NewsList(struct soap *soap, _ns1__NewsList *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__NewsList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__QuoteListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__QuoteListResponse::QuoteListResult = NULL;
	/* transient soap skipped */
}

void _ns1__QuoteListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RESPONSE(soap, &this->_ns1__QuoteListResponse::QuoteListResult);
#endif
}

int _ns1__QuoteListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__QuoteListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__QuoteListResponse(struct soap *soap, const char *tag, int id, const _ns1__QuoteListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__QuoteListResponse), type))
		return soap->error;
	if (a->QuoteListResult)
		soap_element_result(soap, "ns1:QuoteListResult");
	if (soap_out_PointerTons1__RESPONSE(soap, "ns1:QuoteListResult", -1, &a->_ns1__QuoteListResponse::QuoteListResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__QuoteListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__QuoteListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__QuoteListResponse * SOAP_FMAC4 soap_in__ns1__QuoteListResponse(struct soap *soap, const char *tag, _ns1__QuoteListResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__QuoteListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__QuoteListResponse, sizeof(_ns1__QuoteListResponse), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_QuoteListResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_QuoteListResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RESPONSE(soap, "ns1:QuoteListResult", &a->_ns1__QuoteListResponse::QuoteListResult, "ns1:RESPONSE"))
				{	soap_flag_QuoteListResult1--;
					continue;
				}
			soap_check_result(soap, "ns1:QuoteListResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__QuoteListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__QuoteListResponse, SOAP_TYPE_ns__ns1__QuoteListResponse, sizeof(_ns1__QuoteListResponse), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__QuoteListResponse * SOAP_FMAC2 soap_instantiate__ns1__QuoteListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__QuoteListResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__QuoteListResponse *p;
	size_t k = sizeof(_ns1__QuoteListResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__QuoteListResponse);
		if (p)
			((_ns1__QuoteListResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__QuoteListResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__QuoteListResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__QuoteListResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__QuoteListResponse, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__QuoteListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:QuoteListResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__QuoteListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__QuoteListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__QuoteListResponse * SOAP_FMAC4 soap_get__ns1__QuoteListResponse(struct soap *soap, _ns1__QuoteListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__QuoteListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__QuoteList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__QuoteList::Token = NULL;
	this->_ns1__QuoteList::Exchange = NULL;
	/* transient soap skipped */
}

void _ns1__QuoteList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__QuoteList::Token);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__QuoteList::Exchange);
#endif
}

int _ns1__QuoteList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__QuoteList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__QuoteList(struct soap *soap, const char *tag, int id, const _ns1__QuoteList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__QuoteList), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Token", -1, &a->_ns1__QuoteList::Token, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Exchange", -1, &a->_ns1__QuoteList::Exchange, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__QuoteList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__QuoteList(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__QuoteList * SOAP_FMAC4 soap_in__ns1__QuoteList(struct soap *soap, const char *tag, _ns1__QuoteList *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__QuoteList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__QuoteList, sizeof(_ns1__QuoteList), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	size_t soap_flag_Exchange1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Token", &a->_ns1__QuoteList::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap_flag_Exchange1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Exchange", &a->_ns1__QuoteList::Exchange, "xsd:string"))
				{	soap_flag_Exchange1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__QuoteList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__QuoteList, SOAP_TYPE_ns__ns1__QuoteList, sizeof(_ns1__QuoteList), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__QuoteList * SOAP_FMAC2 soap_instantiate__ns1__QuoteList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__QuoteList(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__QuoteList *p;
	size_t k = sizeof(_ns1__QuoteList);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__QuoteList);
		if (p)
			((_ns1__QuoteList*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__QuoteList, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__QuoteList*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__QuoteList location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__QuoteList, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__QuoteList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:QuoteList", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__QuoteList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__QuoteList(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__QuoteList * SOAP_FMAC4 soap_get__ns1__QuoteList(struct soap *soap, _ns1__QuoteList *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__QuoteList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SymbolGetResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SymbolGetResponse::SymbolGetResult = NULL;
	/* transient soap skipped */
}

void _ns1__SymbolGetResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RESPONSE(soap, &this->_ns1__SymbolGetResponse::SymbolGetResult);
#endif
}

int _ns1__SymbolGetResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SymbolGetResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SymbolGetResponse(struct soap *soap, const char *tag, int id, const _ns1__SymbolGetResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__SymbolGetResponse), type))
		return soap->error;
	if (a->SymbolGetResult)
		soap_element_result(soap, "ns1:SymbolGetResult");
	if (soap_out_PointerTons1__RESPONSE(soap, "ns1:SymbolGetResult", -1, &a->_ns1__SymbolGetResponse::SymbolGetResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SymbolGetResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SymbolGetResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SymbolGetResponse * SOAP_FMAC4 soap_in__ns1__SymbolGetResponse(struct soap *soap, const char *tag, _ns1__SymbolGetResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SymbolGetResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__SymbolGetResponse, sizeof(_ns1__SymbolGetResponse), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SymbolGetResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SymbolGetResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RESPONSE(soap, "ns1:SymbolGetResult", &a->_ns1__SymbolGetResponse::SymbolGetResult, "ns1:RESPONSE"))
				{	soap_flag_SymbolGetResult1--;
					continue;
				}
			soap_check_result(soap, "ns1:SymbolGetResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SymbolGetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__SymbolGetResponse, SOAP_TYPE_ns__ns1__SymbolGetResponse, sizeof(_ns1__SymbolGetResponse), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SymbolGetResponse * SOAP_FMAC2 soap_instantiate__ns1__SymbolGetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SymbolGetResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SymbolGetResponse *p;
	size_t k = sizeof(_ns1__SymbolGetResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SymbolGetResponse);
		if (p)
			((_ns1__SymbolGetResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SymbolGetResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SymbolGetResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SymbolGetResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__SymbolGetResponse, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SymbolGetResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:SymbolGetResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SymbolGetResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SymbolGetResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SymbolGetResponse * SOAP_FMAC4 soap_get__ns1__SymbolGetResponse(struct soap *soap, _ns1__SymbolGetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SymbolGetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SymbolGet::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SymbolGet::Token = NULL;
	this->_ns1__SymbolGet::Exchange = NULL;
	this->_ns1__SymbolGet::Symbol = NULL;
	/* transient soap skipped */
}

void _ns1__SymbolGet::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SymbolGet::Token);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SymbolGet::Exchange);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SymbolGet::Symbol);
#endif
}

int _ns1__SymbolGet::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SymbolGet(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SymbolGet(struct soap *soap, const char *tag, int id, const _ns1__SymbolGet *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__SymbolGet), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Token", -1, &a->_ns1__SymbolGet::Token, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Exchange", -1, &a->_ns1__SymbolGet::Exchange, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Symbol", -1, &a->_ns1__SymbolGet::Symbol, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SymbolGet::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SymbolGet(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SymbolGet * SOAP_FMAC4 soap_in__ns1__SymbolGet(struct soap *soap, const char *tag, _ns1__SymbolGet *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SymbolGet *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__SymbolGet, sizeof(_ns1__SymbolGet), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	size_t soap_flag_Exchange1 = 1;
	size_t soap_flag_Symbol1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Token", &a->_ns1__SymbolGet::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap_flag_Exchange1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Exchange", &a->_ns1__SymbolGet::Exchange, "xsd:string"))
				{	soap_flag_Exchange1--;
					continue;
				}
			if (soap_flag_Symbol1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Symbol", &a->_ns1__SymbolGet::Symbol, "xsd:string"))
				{	soap_flag_Symbol1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SymbolGet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__SymbolGet, SOAP_TYPE_ns__ns1__SymbolGet, sizeof(_ns1__SymbolGet), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SymbolGet * SOAP_FMAC2 soap_instantiate__ns1__SymbolGet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SymbolGet(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SymbolGet *p;
	size_t k = sizeof(_ns1__SymbolGet);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SymbolGet);
		if (p)
			((_ns1__SymbolGet*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SymbolGet, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SymbolGet*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SymbolGet location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__SymbolGet, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SymbolGet::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:SymbolGet", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SymbolGet::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SymbolGet(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SymbolGet * SOAP_FMAC4 soap_get__ns1__SymbolGet(struct soap *soap, _ns1__SymbolGet *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SymbolGet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__QuoteList2Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__QuoteList2Response::QuoteList2Result = NULL;
	/* transient soap skipped */
}

void _ns1__QuoteList2Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RESPONSE(soap, &this->_ns1__QuoteList2Response::QuoteList2Result);
#endif
}

int _ns1__QuoteList2Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__QuoteList2Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__QuoteList2Response(struct soap *soap, const char *tag, int id, const _ns1__QuoteList2Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__QuoteList2Response), type))
		return soap->error;
	if (a->QuoteList2Result)
		soap_element_result(soap, "ns1:QuoteList2Result");
	if (soap_out_PointerTons1__RESPONSE(soap, "ns1:QuoteList2Result", -1, &a->_ns1__QuoteList2Response::QuoteList2Result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__QuoteList2Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__QuoteList2Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__QuoteList2Response * SOAP_FMAC4 soap_in__ns1__QuoteList2Response(struct soap *soap, const char *tag, _ns1__QuoteList2Response *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__QuoteList2Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__QuoteList2Response, sizeof(_ns1__QuoteList2Response), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_QuoteList2Result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_QuoteList2Result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RESPONSE(soap, "ns1:QuoteList2Result", &a->_ns1__QuoteList2Response::QuoteList2Result, "ns1:RESPONSE"))
				{	soap_flag_QuoteList2Result1--;
					continue;
				}
			soap_check_result(soap, "ns1:QuoteList2Result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__QuoteList2Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__QuoteList2Response, SOAP_TYPE_ns__ns1__QuoteList2Response, sizeof(_ns1__QuoteList2Response), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__QuoteList2Response * SOAP_FMAC2 soap_instantiate__ns1__QuoteList2Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__QuoteList2Response(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__QuoteList2Response *p;
	size_t k = sizeof(_ns1__QuoteList2Response);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__QuoteList2Response);
		if (p)
			((_ns1__QuoteList2Response*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__QuoteList2Response, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__QuoteList2Response*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__QuoteList2Response location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__QuoteList2Response, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__QuoteList2Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:QuoteList2Response", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__QuoteList2Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__QuoteList2Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__QuoteList2Response * SOAP_FMAC4 soap_get__ns1__QuoteList2Response(struct soap *soap, _ns1__QuoteList2Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__QuoteList2Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__QuoteList2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__QuoteList2::Token = NULL;
	this->_ns1__QuoteList2::Exchange = NULL;
	this->_ns1__QuoteList2::Symbols = NULL;
	/* transient soap skipped */
}

void _ns1__QuoteList2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__QuoteList2::Token);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__QuoteList2::Exchange);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__QuoteList2::Symbols);
#endif
}

int _ns1__QuoteList2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__QuoteList2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__QuoteList2(struct soap *soap, const char *tag, int id, const _ns1__QuoteList2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__QuoteList2), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Token", -1, &a->_ns1__QuoteList2::Token, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Exchange", -1, &a->_ns1__QuoteList2::Exchange, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Symbols", -1, &a->_ns1__QuoteList2::Symbols, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__QuoteList2::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__QuoteList2(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__QuoteList2 * SOAP_FMAC4 soap_in__ns1__QuoteList2(struct soap *soap, const char *tag, _ns1__QuoteList2 *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__QuoteList2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__QuoteList2, sizeof(_ns1__QuoteList2), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	size_t soap_flag_Exchange1 = 1;
	size_t soap_flag_Symbols1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Token", &a->_ns1__QuoteList2::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap_flag_Exchange1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Exchange", &a->_ns1__QuoteList2::Exchange, "xsd:string"))
				{	soap_flag_Exchange1--;
					continue;
				}
			if (soap_flag_Symbols1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Symbols", &a->_ns1__QuoteList2::Symbols, "xsd:string"))
				{	soap_flag_Symbols1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__QuoteList2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__QuoteList2, SOAP_TYPE_ns__ns1__QuoteList2, sizeof(_ns1__QuoteList2), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__QuoteList2 * SOAP_FMAC2 soap_instantiate__ns1__QuoteList2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__QuoteList2(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__QuoteList2 *p;
	size_t k = sizeof(_ns1__QuoteList2);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__QuoteList2);
		if (p)
			((_ns1__QuoteList2*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__QuoteList2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__QuoteList2*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__QuoteList2 location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__QuoteList2, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__QuoteList2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:QuoteList2", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__QuoteList2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__QuoteList2(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__QuoteList2 * SOAP_FMAC4 soap_get__ns1__QuoteList2(struct soap *soap, _ns1__QuoteList2 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__QuoteList2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__QuoteGetResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__QuoteGetResponse::QuoteGetResult = NULL;
	/* transient soap skipped */
}

void _ns1__QuoteGetResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RESPONSE(soap, &this->_ns1__QuoteGetResponse::QuoteGetResult);
#endif
}

int _ns1__QuoteGetResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__QuoteGetResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__QuoteGetResponse(struct soap *soap, const char *tag, int id, const _ns1__QuoteGetResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__QuoteGetResponse), type))
		return soap->error;
	if (a->QuoteGetResult)
		soap_element_result(soap, "ns1:QuoteGetResult");
	if (soap_out_PointerTons1__RESPONSE(soap, "ns1:QuoteGetResult", -1, &a->_ns1__QuoteGetResponse::QuoteGetResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__QuoteGetResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__QuoteGetResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__QuoteGetResponse * SOAP_FMAC4 soap_in__ns1__QuoteGetResponse(struct soap *soap, const char *tag, _ns1__QuoteGetResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__QuoteGetResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__QuoteGetResponse, sizeof(_ns1__QuoteGetResponse), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_QuoteGetResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_QuoteGetResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RESPONSE(soap, "ns1:QuoteGetResult", &a->_ns1__QuoteGetResponse::QuoteGetResult, "ns1:RESPONSE"))
				{	soap_flag_QuoteGetResult1--;
					continue;
				}
			soap_check_result(soap, "ns1:QuoteGetResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__QuoteGetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__QuoteGetResponse, SOAP_TYPE_ns__ns1__QuoteGetResponse, sizeof(_ns1__QuoteGetResponse), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__QuoteGetResponse * SOAP_FMAC2 soap_instantiate__ns1__QuoteGetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__QuoteGetResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__QuoteGetResponse *p;
	size_t k = sizeof(_ns1__QuoteGetResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__QuoteGetResponse);
		if (p)
			((_ns1__QuoteGetResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__QuoteGetResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__QuoteGetResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__QuoteGetResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__QuoteGetResponse, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__QuoteGetResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:QuoteGetResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__QuoteGetResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__QuoteGetResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__QuoteGetResponse * SOAP_FMAC4 soap_get__ns1__QuoteGetResponse(struct soap *soap, _ns1__QuoteGetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__QuoteGetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__QuoteGet::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__QuoteGet::Token = NULL;
	this->_ns1__QuoteGet::Exchange = NULL;
	this->_ns1__QuoteGet::Symbol = NULL;
	/* transient soap skipped */
}

void _ns1__QuoteGet::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__QuoteGet::Token);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__QuoteGet::Exchange);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__QuoteGet::Symbol);
#endif
}

int _ns1__QuoteGet::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__QuoteGet(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__QuoteGet(struct soap *soap, const char *tag, int id, const _ns1__QuoteGet *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__QuoteGet), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Token", -1, &a->_ns1__QuoteGet::Token, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Exchange", -1, &a->_ns1__QuoteGet::Exchange, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Symbol", -1, &a->_ns1__QuoteGet::Symbol, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__QuoteGet::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__QuoteGet(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__QuoteGet * SOAP_FMAC4 soap_in__ns1__QuoteGet(struct soap *soap, const char *tag, _ns1__QuoteGet *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__QuoteGet *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__QuoteGet, sizeof(_ns1__QuoteGet), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	size_t soap_flag_Exchange1 = 1;
	size_t soap_flag_Symbol1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Token", &a->_ns1__QuoteGet::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap_flag_Exchange1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Exchange", &a->_ns1__QuoteGet::Exchange, "xsd:string"))
				{	soap_flag_Exchange1--;
					continue;
				}
			if (soap_flag_Symbol1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Symbol", &a->_ns1__QuoteGet::Symbol, "xsd:string"))
				{	soap_flag_Symbol1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__QuoteGet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__QuoteGet, SOAP_TYPE_ns__ns1__QuoteGet, sizeof(_ns1__QuoteGet), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__QuoteGet * SOAP_FMAC2 soap_instantiate__ns1__QuoteGet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__QuoteGet(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__QuoteGet *p;
	size_t k = sizeof(_ns1__QuoteGet);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__QuoteGet);
		if (p)
			((_ns1__QuoteGet*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__QuoteGet, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__QuoteGet*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__QuoteGet location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__QuoteGet, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__QuoteGet::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:QuoteGet", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__QuoteGet::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__QuoteGet(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__QuoteGet * SOAP_FMAC4 soap_get__ns1__QuoteGet(struct soap *soap, _ns1__QuoteGet *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__QuoteGet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SymbolList2Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SymbolList2Response::SymbolList2Result = NULL;
	/* transient soap skipped */
}

void _ns1__SymbolList2Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RESPONSE(soap, &this->_ns1__SymbolList2Response::SymbolList2Result);
#endif
}

int _ns1__SymbolList2Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SymbolList2Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SymbolList2Response(struct soap *soap, const char *tag, int id, const _ns1__SymbolList2Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__SymbolList2Response), type))
		return soap->error;
	if (a->SymbolList2Result)
		soap_element_result(soap, "ns1:SymbolList2Result");
	if (soap_out_PointerTons1__RESPONSE(soap, "ns1:SymbolList2Result", -1, &a->_ns1__SymbolList2Response::SymbolList2Result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SymbolList2Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SymbolList2Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SymbolList2Response * SOAP_FMAC4 soap_in__ns1__SymbolList2Response(struct soap *soap, const char *tag, _ns1__SymbolList2Response *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SymbolList2Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__SymbolList2Response, sizeof(_ns1__SymbolList2Response), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SymbolList2Result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SymbolList2Result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RESPONSE(soap, "ns1:SymbolList2Result", &a->_ns1__SymbolList2Response::SymbolList2Result, "ns1:RESPONSE"))
				{	soap_flag_SymbolList2Result1--;
					continue;
				}
			soap_check_result(soap, "ns1:SymbolList2Result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SymbolList2Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__SymbolList2Response, SOAP_TYPE_ns__ns1__SymbolList2Response, sizeof(_ns1__SymbolList2Response), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SymbolList2Response * SOAP_FMAC2 soap_instantiate__ns1__SymbolList2Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SymbolList2Response(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SymbolList2Response *p;
	size_t k = sizeof(_ns1__SymbolList2Response);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SymbolList2Response);
		if (p)
			((_ns1__SymbolList2Response*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SymbolList2Response, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SymbolList2Response*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SymbolList2Response location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__SymbolList2Response, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SymbolList2Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:SymbolList2Response", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SymbolList2Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SymbolList2Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SymbolList2Response * SOAP_FMAC4 soap_get__ns1__SymbolList2Response(struct soap *soap, _ns1__SymbolList2Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SymbolList2Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SymbolList2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SymbolList2::Token = NULL;
	this->_ns1__SymbolList2::Exchange = NULL;
	/* transient soap skipped */
}

void _ns1__SymbolList2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SymbolList2::Token);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SymbolList2::Exchange);
#endif
}

int _ns1__SymbolList2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SymbolList2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SymbolList2(struct soap *soap, const char *tag, int id, const _ns1__SymbolList2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__SymbolList2), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Token", -1, &a->_ns1__SymbolList2::Token, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Exchange", -1, &a->_ns1__SymbolList2::Exchange, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SymbolList2::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SymbolList2(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SymbolList2 * SOAP_FMAC4 soap_in__ns1__SymbolList2(struct soap *soap, const char *tag, _ns1__SymbolList2 *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SymbolList2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__SymbolList2, sizeof(_ns1__SymbolList2), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	size_t soap_flag_Exchange1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Token", &a->_ns1__SymbolList2::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap_flag_Exchange1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Exchange", &a->_ns1__SymbolList2::Exchange, "xsd:string"))
				{	soap_flag_Exchange1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SymbolList2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__SymbolList2, SOAP_TYPE_ns__ns1__SymbolList2, sizeof(_ns1__SymbolList2), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SymbolList2 * SOAP_FMAC2 soap_instantiate__ns1__SymbolList2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SymbolList2(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SymbolList2 *p;
	size_t k = sizeof(_ns1__SymbolList2);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SymbolList2);
		if (p)
			((_ns1__SymbolList2*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SymbolList2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SymbolList2*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SymbolList2 location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__SymbolList2, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SymbolList2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:SymbolList2", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SymbolList2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SymbolList2(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SymbolList2 * SOAP_FMAC4 soap_get__ns1__SymbolList2(struct soap *soap, _ns1__SymbolList2 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SymbolList2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SymbolListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SymbolListResponse::SymbolListResult = NULL;
	/* transient soap skipped */
}

void _ns1__SymbolListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RESPONSE(soap, &this->_ns1__SymbolListResponse::SymbolListResult);
#endif
}

int _ns1__SymbolListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SymbolListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SymbolListResponse(struct soap *soap, const char *tag, int id, const _ns1__SymbolListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__SymbolListResponse), type))
		return soap->error;
	if (a->SymbolListResult)
		soap_element_result(soap, "ns1:SymbolListResult");
	if (soap_out_PointerTons1__RESPONSE(soap, "ns1:SymbolListResult", -1, &a->_ns1__SymbolListResponse::SymbolListResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SymbolListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SymbolListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SymbolListResponse * SOAP_FMAC4 soap_in__ns1__SymbolListResponse(struct soap *soap, const char *tag, _ns1__SymbolListResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SymbolListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__SymbolListResponse, sizeof(_ns1__SymbolListResponse), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SymbolListResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SymbolListResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RESPONSE(soap, "ns1:SymbolListResult", &a->_ns1__SymbolListResponse::SymbolListResult, "ns1:RESPONSE"))
				{	soap_flag_SymbolListResult1--;
					continue;
				}
			soap_check_result(soap, "ns1:SymbolListResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SymbolListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__SymbolListResponse, SOAP_TYPE_ns__ns1__SymbolListResponse, sizeof(_ns1__SymbolListResponse), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SymbolListResponse * SOAP_FMAC2 soap_instantiate__ns1__SymbolListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SymbolListResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SymbolListResponse *p;
	size_t k = sizeof(_ns1__SymbolListResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SymbolListResponse);
		if (p)
			((_ns1__SymbolListResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SymbolListResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SymbolListResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SymbolListResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__SymbolListResponse, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SymbolListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:SymbolListResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SymbolListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SymbolListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SymbolListResponse * SOAP_FMAC4 soap_get__ns1__SymbolListResponse(struct soap *soap, _ns1__SymbolListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SymbolListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SymbolList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SymbolList::Token = NULL;
	this->_ns1__SymbolList::Exchange = NULL;
	/* transient soap skipped */
}

void _ns1__SymbolList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SymbolList::Token);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SymbolList::Exchange);
#endif
}

int _ns1__SymbolList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SymbolList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SymbolList(struct soap *soap, const char *tag, int id, const _ns1__SymbolList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__SymbolList), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Token", -1, &a->_ns1__SymbolList::Token, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Exchange", -1, &a->_ns1__SymbolList::Exchange, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SymbolList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SymbolList(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SymbolList * SOAP_FMAC4 soap_in__ns1__SymbolList(struct soap *soap, const char *tag, _ns1__SymbolList *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SymbolList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__SymbolList, sizeof(_ns1__SymbolList), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	size_t soap_flag_Exchange1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Token", &a->_ns1__SymbolList::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap_flag_Exchange1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Exchange", &a->_ns1__SymbolList::Exchange, "xsd:string"))
				{	soap_flag_Exchange1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SymbolList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__SymbolList, SOAP_TYPE_ns__ns1__SymbolList, sizeof(_ns1__SymbolList), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SymbolList * SOAP_FMAC2 soap_instantiate__ns1__SymbolList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SymbolList(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SymbolList *p;
	size_t k = sizeof(_ns1__SymbolList);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SymbolList);
		if (p)
			((_ns1__SymbolList*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SymbolList, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SymbolList*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SymbolList location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__SymbolList, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SymbolList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:SymbolList", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SymbolList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SymbolList(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SymbolList * SOAP_FMAC4 soap_get__ns1__SymbolList(struct soap *soap, _ns1__SymbolList *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SymbolList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ExchangeGetResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__ExchangeGetResponse::ExchangeGetResult = NULL;
	/* transient soap skipped */
}

void _ns1__ExchangeGetResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RESPONSE(soap, &this->_ns1__ExchangeGetResponse::ExchangeGetResult);
#endif
}

int _ns1__ExchangeGetResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ExchangeGetResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ExchangeGetResponse(struct soap *soap, const char *tag, int id, const _ns1__ExchangeGetResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__ExchangeGetResponse), type))
		return soap->error;
	if (a->ExchangeGetResult)
		soap_element_result(soap, "ns1:ExchangeGetResult");
	if (soap_out_PointerTons1__RESPONSE(soap, "ns1:ExchangeGetResult", -1, &a->_ns1__ExchangeGetResponse::ExchangeGetResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ExchangeGetResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ExchangeGetResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ExchangeGetResponse * SOAP_FMAC4 soap_in__ns1__ExchangeGetResponse(struct soap *soap, const char *tag, _ns1__ExchangeGetResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ExchangeGetResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__ExchangeGetResponse, sizeof(_ns1__ExchangeGetResponse), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ExchangeGetResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ExchangeGetResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RESPONSE(soap, "ns1:ExchangeGetResult", &a->_ns1__ExchangeGetResponse::ExchangeGetResult, "ns1:RESPONSE"))
				{	soap_flag_ExchangeGetResult1--;
					continue;
				}
			soap_check_result(soap, "ns1:ExchangeGetResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__ExchangeGetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__ExchangeGetResponse, SOAP_TYPE_ns__ns1__ExchangeGetResponse, sizeof(_ns1__ExchangeGetResponse), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ExchangeGetResponse * SOAP_FMAC2 soap_instantiate__ns1__ExchangeGetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ExchangeGetResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ExchangeGetResponse *p;
	size_t k = sizeof(_ns1__ExchangeGetResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__ExchangeGetResponse);
		if (p)
			((_ns1__ExchangeGetResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__ExchangeGetResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__ExchangeGetResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ExchangeGetResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__ExchangeGetResponse, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__ExchangeGetResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:ExchangeGetResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ExchangeGetResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ExchangeGetResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ExchangeGetResponse * SOAP_FMAC4 soap_get__ns1__ExchangeGetResponse(struct soap *soap, _ns1__ExchangeGetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ExchangeGetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ExchangeGet::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__ExchangeGet::Token = NULL;
	this->_ns1__ExchangeGet::Exchange = NULL;
	/* transient soap skipped */
}

void _ns1__ExchangeGet::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__ExchangeGet::Token);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__ExchangeGet::Exchange);
#endif
}

int _ns1__ExchangeGet::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ExchangeGet(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ExchangeGet(struct soap *soap, const char *tag, int id, const _ns1__ExchangeGet *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__ExchangeGet), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Token", -1, &a->_ns1__ExchangeGet::Token, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Exchange", -1, &a->_ns1__ExchangeGet::Exchange, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ExchangeGet::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ExchangeGet(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ExchangeGet * SOAP_FMAC4 soap_in__ns1__ExchangeGet(struct soap *soap, const char *tag, _ns1__ExchangeGet *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ExchangeGet *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__ExchangeGet, sizeof(_ns1__ExchangeGet), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	size_t soap_flag_Exchange1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Token", &a->_ns1__ExchangeGet::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap_flag_Exchange1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Exchange", &a->_ns1__ExchangeGet::Exchange, "xsd:string"))
				{	soap_flag_Exchange1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__ExchangeGet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__ExchangeGet, SOAP_TYPE_ns__ns1__ExchangeGet, sizeof(_ns1__ExchangeGet), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ExchangeGet * SOAP_FMAC2 soap_instantiate__ns1__ExchangeGet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ExchangeGet(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ExchangeGet *p;
	size_t k = sizeof(_ns1__ExchangeGet);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__ExchangeGet);
		if (p)
			((_ns1__ExchangeGet*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__ExchangeGet, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__ExchangeGet*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ExchangeGet location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__ExchangeGet, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__ExchangeGet::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:ExchangeGet", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ExchangeGet::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ExchangeGet(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ExchangeGet * SOAP_FMAC4 soap_get__ns1__ExchangeGet(struct soap *soap, _ns1__ExchangeGet *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ExchangeGet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ExchangeListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__ExchangeListResponse::ExchangeListResult = NULL;
	/* transient soap skipped */
}

void _ns1__ExchangeListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RESPONSE(soap, &this->_ns1__ExchangeListResponse::ExchangeListResult);
#endif
}

int _ns1__ExchangeListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ExchangeListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ExchangeListResponse(struct soap *soap, const char *tag, int id, const _ns1__ExchangeListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__ExchangeListResponse), type))
		return soap->error;
	if (a->ExchangeListResult)
		soap_element_result(soap, "ns1:ExchangeListResult");
	if (soap_out_PointerTons1__RESPONSE(soap, "ns1:ExchangeListResult", -1, &a->_ns1__ExchangeListResponse::ExchangeListResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ExchangeListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ExchangeListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ExchangeListResponse * SOAP_FMAC4 soap_in__ns1__ExchangeListResponse(struct soap *soap, const char *tag, _ns1__ExchangeListResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ExchangeListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__ExchangeListResponse, sizeof(_ns1__ExchangeListResponse), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ExchangeListResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ExchangeListResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RESPONSE(soap, "ns1:ExchangeListResult", &a->_ns1__ExchangeListResponse::ExchangeListResult, "ns1:RESPONSE"))
				{	soap_flag_ExchangeListResult1--;
					continue;
				}
			soap_check_result(soap, "ns1:ExchangeListResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__ExchangeListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__ExchangeListResponse, SOAP_TYPE_ns__ns1__ExchangeListResponse, sizeof(_ns1__ExchangeListResponse), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ExchangeListResponse * SOAP_FMAC2 soap_instantiate__ns1__ExchangeListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ExchangeListResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ExchangeListResponse *p;
	size_t k = sizeof(_ns1__ExchangeListResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__ExchangeListResponse);
		if (p)
			((_ns1__ExchangeListResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__ExchangeListResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__ExchangeListResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ExchangeListResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__ExchangeListResponse, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__ExchangeListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:ExchangeListResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ExchangeListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ExchangeListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ExchangeListResponse * SOAP_FMAC4 soap_get__ns1__ExchangeListResponse(struct soap *soap, _ns1__ExchangeListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ExchangeListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ExchangeList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__ExchangeList::Token = NULL;
	/* transient soap skipped */
}

void _ns1__ExchangeList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__ExchangeList::Token);
#endif
}

int _ns1__ExchangeList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ExchangeList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ExchangeList(struct soap *soap, const char *tag, int id, const _ns1__ExchangeList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__ExchangeList), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Token", -1, &a->_ns1__ExchangeList::Token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ExchangeList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ExchangeList(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ExchangeList * SOAP_FMAC4 soap_in__ns1__ExchangeList(struct soap *soap, const char *tag, _ns1__ExchangeList *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ExchangeList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__ExchangeList, sizeof(_ns1__ExchangeList), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Token", &a->_ns1__ExchangeList::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__ExchangeList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__ExchangeList, SOAP_TYPE_ns__ns1__ExchangeList, sizeof(_ns1__ExchangeList), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ExchangeList * SOAP_FMAC2 soap_instantiate__ns1__ExchangeList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ExchangeList(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ExchangeList *p;
	size_t k = sizeof(_ns1__ExchangeList);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__ExchangeList);
		if (p)
			((_ns1__ExchangeList*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__ExchangeList, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__ExchangeList*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ExchangeList location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__ExchangeList, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__ExchangeList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:ExchangeList", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ExchangeList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ExchangeList(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ExchangeList * SOAP_FMAC4 soap_get__ns1__ExchangeList(struct soap *soap, _ns1__ExchangeList *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ExchangeList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__MembershipResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__MembershipResponse::MembershipResult = NULL;
	/* transient soap skipped */
}

void _ns1__MembershipResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RESPONSE(soap, &this->_ns1__MembershipResponse::MembershipResult);
#endif
}

int _ns1__MembershipResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__MembershipResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__MembershipResponse(struct soap *soap, const char *tag, int id, const _ns1__MembershipResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__MembershipResponse), type))
		return soap->error;
	if (a->MembershipResult)
		soap_element_result(soap, "ns1:MembershipResult");
	if (soap_out_PointerTons1__RESPONSE(soap, "ns1:MembershipResult", -1, &a->_ns1__MembershipResponse::MembershipResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__MembershipResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__MembershipResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__MembershipResponse * SOAP_FMAC4 soap_in__ns1__MembershipResponse(struct soap *soap, const char *tag, _ns1__MembershipResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__MembershipResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__MembershipResponse, sizeof(_ns1__MembershipResponse), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_MembershipResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MembershipResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RESPONSE(soap, "ns1:MembershipResult", &a->_ns1__MembershipResponse::MembershipResult, "ns1:RESPONSE"))
				{	soap_flag_MembershipResult1--;
					continue;
				}
			soap_check_result(soap, "ns1:MembershipResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__MembershipResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__MembershipResponse, SOAP_TYPE_ns__ns1__MembershipResponse, sizeof(_ns1__MembershipResponse), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__MembershipResponse * SOAP_FMAC2 soap_instantiate__ns1__MembershipResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__MembershipResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__MembershipResponse *p;
	size_t k = sizeof(_ns1__MembershipResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__MembershipResponse);
		if (p)
			((_ns1__MembershipResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__MembershipResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__MembershipResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__MembershipResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__MembershipResponse, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__MembershipResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:MembershipResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__MembershipResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__MembershipResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__MembershipResponse * SOAP_FMAC4 soap_get__ns1__MembershipResponse(struct soap *soap, _ns1__MembershipResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__MembershipResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__Membership::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__Membership::Token = NULL;
	/* transient soap skipped */
}

void _ns1__Membership::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__Membership::Token);
#endif
}

int _ns1__Membership::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__Membership(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__Membership(struct soap *soap, const char *tag, int id, const _ns1__Membership *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__Membership), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Token", -1, &a->_ns1__Membership::Token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__Membership::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__Membership(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__Membership * SOAP_FMAC4 soap_in__ns1__Membership(struct soap *soap, const char *tag, _ns1__Membership *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__Membership *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__Membership, sizeof(_ns1__Membership), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Token", &a->_ns1__Membership::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__Membership *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__Membership, SOAP_TYPE_ns__ns1__Membership, sizeof(_ns1__Membership), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__Membership * SOAP_FMAC2 soap_instantiate__ns1__Membership(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__Membership(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__Membership *p;
	size_t k = sizeof(_ns1__Membership);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__Membership);
		if (p)
			((_ns1__Membership*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__Membership, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__Membership*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__Membership location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__Membership, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__Membership::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:Membership", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__Membership::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__Membership(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__Membership * SOAP_FMAC4 soap_get__ns1__Membership(struct soap *soap, _ns1__Membership *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__Membership(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__Login2Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__Login2Response::Login2Result = NULL;
	/* transient soap skipped */
}

void _ns1__Login2Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__LOGINRESPONSE(soap, &this->_ns1__Login2Response::Login2Result);
#endif
}

int _ns1__Login2Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__Login2Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__Login2Response(struct soap *soap, const char *tag, int id, const _ns1__Login2Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__Login2Response), type))
		return soap->error;
	if (a->Login2Result)
		soap_element_result(soap, "ns1:Login2Result");
	if (soap_out_PointerTons1__LOGINRESPONSE(soap, "ns1:Login2Result", -1, &a->_ns1__Login2Response::Login2Result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__Login2Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__Login2Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__Login2Response * SOAP_FMAC4 soap_in__ns1__Login2Response(struct soap *soap, const char *tag, _ns1__Login2Response *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__Login2Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__Login2Response, sizeof(_ns1__Login2Response), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Login2Result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Login2Result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__LOGINRESPONSE(soap, "ns1:Login2Result", &a->_ns1__Login2Response::Login2Result, "ns1:LOGINRESPONSE"))
				{	soap_flag_Login2Result1--;
					continue;
				}
			soap_check_result(soap, "ns1:Login2Result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__Login2Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__Login2Response, SOAP_TYPE_ns__ns1__Login2Response, sizeof(_ns1__Login2Response), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__Login2Response * SOAP_FMAC2 soap_instantiate__ns1__Login2Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__Login2Response(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__Login2Response *p;
	size_t k = sizeof(_ns1__Login2Response);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__Login2Response);
		if (p)
			((_ns1__Login2Response*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__Login2Response, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__Login2Response*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__Login2Response location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__Login2Response, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__Login2Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:Login2Response", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__Login2Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__Login2Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__Login2Response * SOAP_FMAC4 soap_get__ns1__Login2Response(struct soap *soap, _ns1__Login2Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__Login2Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__Login2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__Login2::Username = NULL;
	this->_ns1__Login2::Password = NULL;
	this->_ns1__Login2::Version = NULL;
	/* transient soap skipped */
}

void _ns1__Login2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__Login2::Username);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__Login2::Password);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__Login2::Version);
#endif
}

int _ns1__Login2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__Login2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__Login2(struct soap *soap, const char *tag, int id, const _ns1__Login2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__Login2), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Username", -1, &a->_ns1__Login2::Username, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Password", -1, &a->_ns1__Login2::Password, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Version", -1, &a->_ns1__Login2::Version, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__Login2::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__Login2(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__Login2 * SOAP_FMAC4 soap_in__ns1__Login2(struct soap *soap, const char *tag, _ns1__Login2 *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__Login2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__Login2, sizeof(_ns1__Login2), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Username1 = 1;
	size_t soap_flag_Password1 = 1;
	size_t soap_flag_Version1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Username1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Username", &a->_ns1__Login2::Username, "xsd:string"))
				{	soap_flag_Username1--;
					continue;
				}
			if (soap_flag_Password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Password", &a->_ns1__Login2::Password, "xsd:string"))
				{	soap_flag_Password1--;
					continue;
				}
			if (soap_flag_Version1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Version", &a->_ns1__Login2::Version, "xsd:string"))
				{	soap_flag_Version1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__Login2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__Login2, SOAP_TYPE_ns__ns1__Login2, sizeof(_ns1__Login2), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__Login2 * SOAP_FMAC2 soap_instantiate__ns1__Login2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__Login2(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__Login2 *p;
	size_t k = sizeof(_ns1__Login2);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__Login2);
		if (p)
			((_ns1__Login2*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__Login2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__Login2*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__Login2 location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__Login2, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__Login2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:Login2", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__Login2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__Login2(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__Login2 * SOAP_FMAC4 soap_get__ns1__Login2(struct soap *soap, _ns1__Login2 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__Login2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__LoginResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__LoginResponse::LoginResult = NULL;
	/* transient soap skipped */
}

void _ns1__LoginResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__LOGINRESPONSE(soap, &this->_ns1__LoginResponse::LoginResult);
#endif
}

int _ns1__LoginResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__LoginResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__LoginResponse(struct soap *soap, const char *tag, int id, const _ns1__LoginResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__LoginResponse), type))
		return soap->error;
	if (a->LoginResult)
		soap_element_result(soap, "ns1:LoginResult");
	if (soap_out_PointerTons1__LOGINRESPONSE(soap, "ns1:LoginResult", -1, &a->_ns1__LoginResponse::LoginResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__LoginResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__LoginResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__LoginResponse * SOAP_FMAC4 soap_in__ns1__LoginResponse(struct soap *soap, const char *tag, _ns1__LoginResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__LoginResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__LoginResponse, sizeof(_ns1__LoginResponse), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_LoginResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LoginResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__LOGINRESPONSE(soap, "ns1:LoginResult", &a->_ns1__LoginResponse::LoginResult, "ns1:LOGINRESPONSE"))
				{	soap_flag_LoginResult1--;
					continue;
				}
			soap_check_result(soap, "ns1:LoginResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__LoginResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__LoginResponse, SOAP_TYPE_ns__ns1__LoginResponse, sizeof(_ns1__LoginResponse), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__LoginResponse * SOAP_FMAC2 soap_instantiate__ns1__LoginResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__LoginResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__LoginResponse *p;
	size_t k = sizeof(_ns1__LoginResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__LoginResponse);
		if (p)
			((_ns1__LoginResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__LoginResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__LoginResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__LoginResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__LoginResponse, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__LoginResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:LoginResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__LoginResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__LoginResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__LoginResponse * SOAP_FMAC4 soap_get__ns1__LoginResponse(struct soap *soap, _ns1__LoginResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__LoginResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__Login::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__Login::Username = NULL;
	this->_ns1__Login::Password = NULL;
	/* transient soap skipped */
}

void _ns1__Login::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__Login::Username);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__Login::Password);
#endif
}

int _ns1__Login::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__Login(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__Login(struct soap *soap, const char *tag, int id, const _ns1__Login *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ns1__Login), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Username", -1, &a->_ns1__Login::Username, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Password", -1, &a->_ns1__Login::Password, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__Login::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__Login(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__Login * SOAP_FMAC4 soap_in__ns1__Login(struct soap *soap, const char *tag, _ns1__Login *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__Login *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ns1__Login, sizeof(_ns1__Login), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Username1 = 1;
	size_t soap_flag_Password1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Username1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Username", &a->_ns1__Login::Username, "xsd:string"))
				{	soap_flag_Username1--;
					continue;
				}
			if (soap_flag_Password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Password", &a->_ns1__Login::Password, "xsd:string"))
				{	soap_flag_Password1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__Login *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ns1__Login, SOAP_TYPE_ns__ns1__Login, sizeof(_ns1__Login), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__Login * SOAP_FMAC2 soap_instantiate__ns1__Login(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__Login(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__Login *p;
	size_t k = sizeof(_ns1__Login);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__Login);
		if (p)
			((_ns1__Login*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__Login, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__Login*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__Login location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ns1__Login, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__Login::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:Login", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__Login::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__Login(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__Login * SOAP_FMAC4 soap_get__ns1__Login(struct soap *soap, _ns1__Login *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__Login(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__DATAFORMAT_USCORECOLUMN::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__DATAFORMAT_USCORECOLUMN::SortOrder);
	this->ns1__DATAFORMAT_USCORECOLUMN::Code = NULL;
	this->ns1__DATAFORMAT_USCORECOLUMN::DataFormat = NULL;
	this->ns1__DATAFORMAT_USCORECOLUMN::ColumnCode = NULL;
	this->ns1__DATAFORMAT_USCORECOLUMN::ColumnName = NULL;
	soap_default_int(soap, &this->ns1__DATAFORMAT_USCORECOLUMN::ColumnTypeId);
	this->ns1__DATAFORMAT_USCORECOLUMN::ColumnType = NULL;
	this->ns1__DATAFORMAT_USCORECOLUMN::Header = NULL;
	/* transient soap skipped */
}

void ns1__DATAFORMAT_USCORECOLUMN::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns1__DATAFORMAT_USCORECOLUMN::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__DATAFORMAT_USCORECOLUMN(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DATAFORMAT_USCORECOLUMN(struct soap *soap, const char *tag, int id, const ns1__DATAFORMAT_USCORECOLUMN *a, const char *type)
{
	soap_set_attr(soap, "SortOrder", soap_int2s(soap, ((ns1__DATAFORMAT_USCORECOLUMN*)a)->SortOrder), 1);
	if (((ns1__DATAFORMAT_USCORECOLUMN*)a)->Code)
		soap_set_attr(soap, "Code", ((ns1__DATAFORMAT_USCORECOLUMN*)a)->Code->c_str(), 1);
	if (((ns1__DATAFORMAT_USCORECOLUMN*)a)->DataFormat)
		soap_set_attr(soap, "DataFormat", ((ns1__DATAFORMAT_USCORECOLUMN*)a)->DataFormat->c_str(), 1);
	if (((ns1__DATAFORMAT_USCORECOLUMN*)a)->ColumnCode)
		soap_set_attr(soap, "ColumnCode", ((ns1__DATAFORMAT_USCORECOLUMN*)a)->ColumnCode->c_str(), 1);
	if (((ns1__DATAFORMAT_USCORECOLUMN*)a)->ColumnName)
		soap_set_attr(soap, "ColumnName", ((ns1__DATAFORMAT_USCORECOLUMN*)a)->ColumnName->c_str(), 1);
	soap_set_attr(soap, "ColumnTypeId", soap_int2s(soap, ((ns1__DATAFORMAT_USCORECOLUMN*)a)->ColumnTypeId), 1);
	if (((ns1__DATAFORMAT_USCORECOLUMN*)a)->ColumnType)
		soap_set_attr(soap, "ColumnType", ((ns1__DATAFORMAT_USCORECOLUMN*)a)->ColumnType->c_str(), 1);
	if (((ns1__DATAFORMAT_USCORECOLUMN*)a)->Header)
		soap_set_attr(soap, "Header", ((ns1__DATAFORMAT_USCORECOLUMN*)a)->Header->c_str(), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns_ns1__DATAFORMAT_USCORECOLUMN), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__DATAFORMAT_USCORECOLUMN::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__DATAFORMAT_USCORECOLUMN(soap, tag, this, type);
}

SOAP_FMAC3 ns1__DATAFORMAT_USCORECOLUMN * SOAP_FMAC4 soap_in_ns1__DATAFORMAT_USCORECOLUMN(struct soap *soap, const char *tag, ns1__DATAFORMAT_USCORECOLUMN *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__DATAFORMAT_USCORECOLUMN *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns_ns1__DATAFORMAT_USCORECOLUMN, sizeof(ns1__DATAFORMAT_USCORECOLUMN), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2int(soap, soap_attr_value(soap, "SortOrder", 1), &((ns1__DATAFORMAT_USCORECOLUMN*)a)->SortOrder))
		return NULL;
	{	const char *t = soap_attr_value(soap, "Code", 0);
		if (t)
		{
			if (!(((ns1__DATAFORMAT_USCORECOLUMN*)a)->Code = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__DATAFORMAT_USCORECOLUMN*)a)->Code, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "DataFormat", 0);
		if (t)
		{
			if (!(((ns1__DATAFORMAT_USCORECOLUMN*)a)->DataFormat = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__DATAFORMAT_USCORECOLUMN*)a)->DataFormat, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "ColumnCode", 0);
		if (t)
		{
			if (!(((ns1__DATAFORMAT_USCORECOLUMN*)a)->ColumnCode = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__DATAFORMAT_USCORECOLUMN*)a)->ColumnCode, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "ColumnName", 0);
		if (t)
		{
			if (!(((ns1__DATAFORMAT_USCORECOLUMN*)a)->ColumnName = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__DATAFORMAT_USCORECOLUMN*)a)->ColumnName, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2int(soap, soap_attr_value(soap, "ColumnTypeId", 1), &((ns1__DATAFORMAT_USCORECOLUMN*)a)->ColumnTypeId))
		return NULL;
	{	const char *t = soap_attr_value(soap, "ColumnType", 0);
		if (t)
		{
			if (!(((ns1__DATAFORMAT_USCORECOLUMN*)a)->ColumnType = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__DATAFORMAT_USCORECOLUMN*)a)->ColumnType, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Header", 0);
		if (t)
		{
			if (!(((ns1__DATAFORMAT_USCORECOLUMN*)a)->Header = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__DATAFORMAT_USCORECOLUMN*)a)->Header, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__DATAFORMAT_USCORECOLUMN *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns_ns1__DATAFORMAT_USCORECOLUMN, SOAP_TYPE_ns_ns1__DATAFORMAT_USCORECOLUMN, sizeof(ns1__DATAFORMAT_USCORECOLUMN), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__DATAFORMAT_USCORECOLUMN * SOAP_FMAC2 soap_instantiate_ns1__DATAFORMAT_USCORECOLUMN(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DATAFORMAT_USCORECOLUMN(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__DATAFORMAT_USCORECOLUMN *p;
	size_t k = sizeof(ns1__DATAFORMAT_USCORECOLUMN);
	if (n < 0)
	{	p = SOAP_NEW(ns1__DATAFORMAT_USCORECOLUMN);
		if (p)
			((ns1__DATAFORMAT_USCORECOLUMN*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__DATAFORMAT_USCORECOLUMN, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__DATAFORMAT_USCORECOLUMN*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__DATAFORMAT_USCORECOLUMN location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns_ns1__DATAFORMAT_USCORECOLUMN, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__DATAFORMAT_USCORECOLUMN::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:DATAFORMAT_COLUMN", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__DATAFORMAT_USCORECOLUMN::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__DATAFORMAT_USCORECOLUMN(soap, this, tag, type);
}

SOAP_FMAC3 ns1__DATAFORMAT_USCORECOLUMN * SOAP_FMAC4 soap_get_ns1__DATAFORMAT_USCORECOLUMN(struct soap *soap, ns1__DATAFORMAT_USCORECOLUMN *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DATAFORMAT_USCORECOLUMN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ArrayOfDATAFORMAT_USCORECOLUMN::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__DATAFORMAT_USCORECOLUMN(soap, &this->ns1__ArrayOfDATAFORMAT_USCORECOLUMN::DATAFORMAT_USCORECOLUMN);
	/* transient soap skipped */
}

void ns1__ArrayOfDATAFORMAT_USCORECOLUMN::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__DATAFORMAT_USCORECOLUMN(soap, &this->ns1__ArrayOfDATAFORMAT_USCORECOLUMN::DATAFORMAT_USCORECOLUMN);
#endif
}

int ns1__ArrayOfDATAFORMAT_USCORECOLUMN::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfDATAFORMAT_USCORECOLUMN(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfDATAFORMAT_USCORECOLUMN(struct soap *soap, const char *tag, int id, const ns1__ArrayOfDATAFORMAT_USCORECOLUMN *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns_ns1__ArrayOfDATAFORMAT_USCORECOLUMN), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__DATAFORMAT_USCORECOLUMN(soap, "ns1:DATAFORMAT_COLUMN", -1, &a->ns1__ArrayOfDATAFORMAT_USCORECOLUMN::DATAFORMAT_USCORECOLUMN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfDATAFORMAT_USCORECOLUMN::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfDATAFORMAT_USCORECOLUMN(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfDATAFORMAT_USCORECOLUMN * SOAP_FMAC4 soap_in_ns1__ArrayOfDATAFORMAT_USCORECOLUMN(struct soap *soap, const char *tag, ns1__ArrayOfDATAFORMAT_USCORECOLUMN *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfDATAFORMAT_USCORECOLUMN *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns_ns1__ArrayOfDATAFORMAT_USCORECOLUMN, sizeof(ns1__ArrayOfDATAFORMAT_USCORECOLUMN), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__DATAFORMAT_USCORECOLUMN(soap, "ns1:DATAFORMAT_COLUMN", &a->ns1__ArrayOfDATAFORMAT_USCORECOLUMN::DATAFORMAT_USCORECOLUMN, "ns1:DATAFORMAT_COLUMN"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfDATAFORMAT_USCORECOLUMN *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns_ns1__ArrayOfDATAFORMAT_USCORECOLUMN, SOAP_TYPE_ns_ns1__ArrayOfDATAFORMAT_USCORECOLUMN, sizeof(ns1__ArrayOfDATAFORMAT_USCORECOLUMN), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ArrayOfDATAFORMAT_USCORECOLUMN * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfDATAFORMAT_USCORECOLUMN(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfDATAFORMAT_USCORECOLUMN(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ArrayOfDATAFORMAT_USCORECOLUMN *p;
	size_t k = sizeof(ns1__ArrayOfDATAFORMAT_USCORECOLUMN);
	if (n < 0)
	{	p = SOAP_NEW(ns1__ArrayOfDATAFORMAT_USCORECOLUMN);
		if (p)
			((ns1__ArrayOfDATAFORMAT_USCORECOLUMN*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__ArrayOfDATAFORMAT_USCORECOLUMN, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__ArrayOfDATAFORMAT_USCORECOLUMN*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ArrayOfDATAFORMAT_USCORECOLUMN location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns_ns1__ArrayOfDATAFORMAT_USCORECOLUMN, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__ArrayOfDATAFORMAT_USCORECOLUMN::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfDATAFORMAT_COLUMN", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfDATAFORMAT_USCORECOLUMN::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfDATAFORMAT_USCORECOLUMN(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfDATAFORMAT_USCORECOLUMN * SOAP_FMAC4 soap_get_ns1__ArrayOfDATAFORMAT_USCORECOLUMN(struct soap *soap, ns1__ArrayOfDATAFORMAT_USCORECOLUMN *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfDATAFORMAT_USCORECOLUMN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__DATAFORMAT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__DATAFORMAT::COLUMNS = NULL;
	this->ns1__DATAFORMAT::Code = NULL;
	this->ns1__DATAFORMAT::Name = NULL;
	this->ns1__DATAFORMAT::Header = NULL;
	this->ns1__DATAFORMAT::DateFormat = NULL;
	this->ns1__DATAFORMAT::Extension = NULL;
	soap_default_bool(soap, &this->ns1__DATAFORMAT::IncludeSuffix);
	soap_default_bool(soap, &this->ns1__DATAFORMAT::TabColumnSeperator);
	this->ns1__DATAFORMAT::ColumnSeperator = NULL;
	this->ns1__DATAFORMAT::TextQualifier = NULL;
	this->ns1__DATAFORMAT::FilenamePrefix = NULL;
	soap_default_bool(soap, &this->ns1__DATAFORMAT::FilenameExchangeCode);
	soap_default_bool(soap, &this->ns1__DATAFORMAT::FilenameDate);
	soap_default_bool(soap, &this->ns1__DATAFORMAT::IncludeHeaderRow);
	this->ns1__DATAFORMAT::HourFormat = NULL;
	this->ns1__DATAFORMAT::DateTimeSeperator = NULL;
	this->ns1__DATAFORMAT::ExchangeFilenameFormatDate = NULL;
	this->ns1__DATAFORMAT::ExchangeFilenameFormatDateRange = NULL;
	this->ns1__DATAFORMAT::SymbolFilenameFormatDate = NULL;
	this->ns1__DATAFORMAT::SymbolFilenameFormatDateRange = NULL;
	/* transient soap skipped */
}

void ns1__DATAFORMAT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ArrayOfDATAFORMAT_USCORECOLUMN(soap, &this->ns1__DATAFORMAT::COLUMNS);
#endif
}

int ns1__DATAFORMAT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__DATAFORMAT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DATAFORMAT(struct soap *soap, const char *tag, int id, const ns1__DATAFORMAT *a, const char *type)
{
	if (((ns1__DATAFORMAT*)a)->Code)
		soap_set_attr(soap, "Code", ((ns1__DATAFORMAT*)a)->Code->c_str(), 1);
	if (((ns1__DATAFORMAT*)a)->Name)
		soap_set_attr(soap, "Name", ((ns1__DATAFORMAT*)a)->Name->c_str(), 1);
	if (((ns1__DATAFORMAT*)a)->Header)
		soap_set_attr(soap, "Header", ((ns1__DATAFORMAT*)a)->Header->c_str(), 1);
	if (((ns1__DATAFORMAT*)a)->DateFormat)
		soap_set_attr(soap, "DateFormat", ((ns1__DATAFORMAT*)a)->DateFormat->c_str(), 1);
	if (((ns1__DATAFORMAT*)a)->Extension)
		soap_set_attr(soap, "Extension", ((ns1__DATAFORMAT*)a)->Extension->c_str(), 1);
	soap_set_attr(soap, "IncludeSuffix", soap_bool2s(soap, ((ns1__DATAFORMAT*)a)->IncludeSuffix), 1);
	soap_set_attr(soap, "TabColumnSeperator", soap_bool2s(soap, ((ns1__DATAFORMAT*)a)->TabColumnSeperator), 1);
	if (((ns1__DATAFORMAT*)a)->ColumnSeperator)
		soap_set_attr(soap, "ColumnSeperator", ((ns1__DATAFORMAT*)a)->ColumnSeperator->c_str(), 1);
	if (((ns1__DATAFORMAT*)a)->TextQualifier)
		soap_set_attr(soap, "TextQualifier", ((ns1__DATAFORMAT*)a)->TextQualifier->c_str(), 1);
	if (((ns1__DATAFORMAT*)a)->FilenamePrefix)
		soap_set_attr(soap, "FilenamePrefix", ((ns1__DATAFORMAT*)a)->FilenamePrefix->c_str(), 1);
	soap_set_attr(soap, "FilenameExchangeCode", soap_bool2s(soap, ((ns1__DATAFORMAT*)a)->FilenameExchangeCode), 1);
	soap_set_attr(soap, "FilenameDate", soap_bool2s(soap, ((ns1__DATAFORMAT*)a)->FilenameDate), 1);
	soap_set_attr(soap, "IncludeHeaderRow", soap_bool2s(soap, ((ns1__DATAFORMAT*)a)->IncludeHeaderRow), 1);
	if (((ns1__DATAFORMAT*)a)->HourFormat)
		soap_set_attr(soap, "HourFormat", ((ns1__DATAFORMAT*)a)->HourFormat->c_str(), 1);
	if (((ns1__DATAFORMAT*)a)->DateTimeSeperator)
		soap_set_attr(soap, "DateTimeSeperator", ((ns1__DATAFORMAT*)a)->DateTimeSeperator->c_str(), 1);
	if (((ns1__DATAFORMAT*)a)->ExchangeFilenameFormatDate)
		soap_set_attr(soap, "ExchangeFilenameFormatDate", ((ns1__DATAFORMAT*)a)->ExchangeFilenameFormatDate->c_str(), 1);
	if (((ns1__DATAFORMAT*)a)->ExchangeFilenameFormatDateRange)
		soap_set_attr(soap, "ExchangeFilenameFormatDateRange", ((ns1__DATAFORMAT*)a)->ExchangeFilenameFormatDateRange->c_str(), 1);
	if (((ns1__DATAFORMAT*)a)->SymbolFilenameFormatDate)
		soap_set_attr(soap, "SymbolFilenameFormatDate", ((ns1__DATAFORMAT*)a)->SymbolFilenameFormatDate->c_str(), 1);
	if (((ns1__DATAFORMAT*)a)->SymbolFilenameFormatDateRange)
		soap_set_attr(soap, "SymbolFilenameFormatDateRange", ((ns1__DATAFORMAT*)a)->SymbolFilenameFormatDateRange->c_str(), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns_ns1__DATAFORMAT), type))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfDATAFORMAT_USCORECOLUMN(soap, "ns1:COLUMNS", -1, &a->ns1__DATAFORMAT::COLUMNS, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__DATAFORMAT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__DATAFORMAT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__DATAFORMAT * SOAP_FMAC4 soap_in_ns1__DATAFORMAT(struct soap *soap, const char *tag, ns1__DATAFORMAT *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__DATAFORMAT *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns_ns1__DATAFORMAT, sizeof(ns1__DATAFORMAT), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	{	const char *t = soap_attr_value(soap, "Code", 0);
		if (t)
		{
			if (!(((ns1__DATAFORMAT*)a)->Code = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__DATAFORMAT*)a)->Code, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Name", 0);
		if (t)
		{
			if (!(((ns1__DATAFORMAT*)a)->Name = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__DATAFORMAT*)a)->Name, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Header", 0);
		if (t)
		{
			if (!(((ns1__DATAFORMAT*)a)->Header = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__DATAFORMAT*)a)->Header, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "DateFormat", 0);
		if (t)
		{
			if (!(((ns1__DATAFORMAT*)a)->DateFormat = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__DATAFORMAT*)a)->DateFormat, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Extension", 0);
		if (t)
		{
			if (!(((ns1__DATAFORMAT*)a)->Extension = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__DATAFORMAT*)a)->Extension, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2bool(soap, soap_attr_value(soap, "IncludeSuffix", 1), &((ns1__DATAFORMAT*)a)->IncludeSuffix))
		return NULL;
	if (soap_s2bool(soap, soap_attr_value(soap, "TabColumnSeperator", 1), &((ns1__DATAFORMAT*)a)->TabColumnSeperator))
		return NULL;
	{	const char *t = soap_attr_value(soap, "ColumnSeperator", 0);
		if (t)
		{
			if (!(((ns1__DATAFORMAT*)a)->ColumnSeperator = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__DATAFORMAT*)a)->ColumnSeperator, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "TextQualifier", 0);
		if (t)
		{
			if (!(((ns1__DATAFORMAT*)a)->TextQualifier = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__DATAFORMAT*)a)->TextQualifier, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "FilenamePrefix", 0);
		if (t)
		{
			if (!(((ns1__DATAFORMAT*)a)->FilenamePrefix = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__DATAFORMAT*)a)->FilenamePrefix, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2bool(soap, soap_attr_value(soap, "FilenameExchangeCode", 1), &((ns1__DATAFORMAT*)a)->FilenameExchangeCode))
		return NULL;
	if (soap_s2bool(soap, soap_attr_value(soap, "FilenameDate", 1), &((ns1__DATAFORMAT*)a)->FilenameDate))
		return NULL;
	if (soap_s2bool(soap, soap_attr_value(soap, "IncludeHeaderRow", 1), &((ns1__DATAFORMAT*)a)->IncludeHeaderRow))
		return NULL;
	{	const char *t = soap_attr_value(soap, "HourFormat", 0);
		if (t)
		{
			if (!(((ns1__DATAFORMAT*)a)->HourFormat = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__DATAFORMAT*)a)->HourFormat, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "DateTimeSeperator", 0);
		if (t)
		{
			if (!(((ns1__DATAFORMAT*)a)->DateTimeSeperator = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__DATAFORMAT*)a)->DateTimeSeperator, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "ExchangeFilenameFormatDate", 0);
		if (t)
		{
			if (!(((ns1__DATAFORMAT*)a)->ExchangeFilenameFormatDate = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__DATAFORMAT*)a)->ExchangeFilenameFormatDate, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "ExchangeFilenameFormatDateRange", 0);
		if (t)
		{
			if (!(((ns1__DATAFORMAT*)a)->ExchangeFilenameFormatDateRange = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__DATAFORMAT*)a)->ExchangeFilenameFormatDateRange, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "SymbolFilenameFormatDate", 0);
		if (t)
		{
			if (!(((ns1__DATAFORMAT*)a)->SymbolFilenameFormatDate = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__DATAFORMAT*)a)->SymbolFilenameFormatDate, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "SymbolFilenameFormatDateRange", 0);
		if (t)
		{
			if (!(((ns1__DATAFORMAT*)a)->SymbolFilenameFormatDateRange = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__DATAFORMAT*)a)->SymbolFilenameFormatDateRange, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_COLUMNS1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_COLUMNS1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfDATAFORMAT_USCORECOLUMN(soap, "ns1:COLUMNS", &a->ns1__DATAFORMAT::COLUMNS, "ns1:ArrayOfDATAFORMAT_COLUMN"))
				{	soap_flag_COLUMNS1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__DATAFORMAT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns_ns1__DATAFORMAT, SOAP_TYPE_ns_ns1__DATAFORMAT, sizeof(ns1__DATAFORMAT), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__DATAFORMAT * SOAP_FMAC2 soap_instantiate_ns1__DATAFORMAT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DATAFORMAT(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__DATAFORMAT *p;
	size_t k = sizeof(ns1__DATAFORMAT);
	if (n < 0)
	{	p = SOAP_NEW(ns1__DATAFORMAT);
		if (p)
			((ns1__DATAFORMAT*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__DATAFORMAT, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__DATAFORMAT*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__DATAFORMAT location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns_ns1__DATAFORMAT, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__DATAFORMAT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:DATAFORMAT", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__DATAFORMAT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__DATAFORMAT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__DATAFORMAT * SOAP_FMAC4 soap_get_ns1__DATAFORMAT(struct soap *soap, ns1__DATAFORMAT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DATAFORMAT(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ArrayOfDATAFORMAT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__DATAFORMAT(soap, &this->ns1__ArrayOfDATAFORMAT::DATAFORMAT);
	/* transient soap skipped */
}

void ns1__ArrayOfDATAFORMAT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__DATAFORMAT(soap, &this->ns1__ArrayOfDATAFORMAT::DATAFORMAT);
#endif
}

int ns1__ArrayOfDATAFORMAT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfDATAFORMAT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfDATAFORMAT(struct soap *soap, const char *tag, int id, const ns1__ArrayOfDATAFORMAT *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns_ns1__ArrayOfDATAFORMAT), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__DATAFORMAT(soap, "ns1:DATAFORMAT", -1, &a->ns1__ArrayOfDATAFORMAT::DATAFORMAT, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfDATAFORMAT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfDATAFORMAT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfDATAFORMAT * SOAP_FMAC4 soap_in_ns1__ArrayOfDATAFORMAT(struct soap *soap, const char *tag, ns1__ArrayOfDATAFORMAT *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfDATAFORMAT *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns_ns1__ArrayOfDATAFORMAT, sizeof(ns1__ArrayOfDATAFORMAT), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__DATAFORMAT(soap, "ns1:DATAFORMAT", &a->ns1__ArrayOfDATAFORMAT::DATAFORMAT, "ns1:DATAFORMAT"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfDATAFORMAT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns_ns1__ArrayOfDATAFORMAT, SOAP_TYPE_ns_ns1__ArrayOfDATAFORMAT, sizeof(ns1__ArrayOfDATAFORMAT), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ArrayOfDATAFORMAT * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfDATAFORMAT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfDATAFORMAT(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ArrayOfDATAFORMAT *p;
	size_t k = sizeof(ns1__ArrayOfDATAFORMAT);
	if (n < 0)
	{	p = SOAP_NEW(ns1__ArrayOfDATAFORMAT);
		if (p)
			((ns1__ArrayOfDATAFORMAT*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__ArrayOfDATAFORMAT, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__ArrayOfDATAFORMAT*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ArrayOfDATAFORMAT location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns_ns1__ArrayOfDATAFORMAT, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__ArrayOfDATAFORMAT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfDATAFORMAT", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfDATAFORMAT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfDATAFORMAT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfDATAFORMAT * SOAP_FMAC4 soap_get_ns1__ArrayOfDATAFORMAT(struct soap *soap, ns1__ArrayOfDATAFORMAT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfDATAFORMAT(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__NEWS::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__NEWS::Exchange = NULL;
	this->ns1__NEWS::Symbol = NULL;
	soap_default_LONG64(soap, &this->ns1__NEWS::Id);
	this->ns1__NEWS::SourceKey = NULL;
	soap_default_dateTime(soap, &this->ns1__NEWS::DateTime);
	this->ns1__NEWS::Headline = NULL;
	this->ns1__NEWS::Introduction = NULL;
	this->ns1__NEWS::Story = NULL;
	this->ns1__NEWS::Caption = NULL;
	soap_default_int(soap, &this->ns1__NEWS::Views);
	/* transient soap skipped */
}

void ns1__NEWS::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns1__NEWS::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__NEWS(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__NEWS(struct soap *soap, const char *tag, int id, const ns1__NEWS *a, const char *type)
{
	if (((ns1__NEWS*)a)->Exchange)
		soap_set_attr(soap, "Exchange", ((ns1__NEWS*)a)->Exchange->c_str(), 1);
	if (((ns1__NEWS*)a)->Symbol)
		soap_set_attr(soap, "Symbol", ((ns1__NEWS*)a)->Symbol->c_str(), 1);
	soap_set_attr(soap, "Id", soap_LONG642s(soap, ((ns1__NEWS*)a)->Id), 1);
	if (((ns1__NEWS*)a)->SourceKey)
		soap_set_attr(soap, "SourceKey", ((ns1__NEWS*)a)->SourceKey->c_str(), 1);
	soap_set_attr(soap, "DateTime", soap_dateTime2s(soap, ((ns1__NEWS*)a)->DateTime), 1);
	if (((ns1__NEWS*)a)->Headline)
		soap_set_attr(soap, "Headline", ((ns1__NEWS*)a)->Headline->c_str(), 1);
	if (((ns1__NEWS*)a)->Introduction)
		soap_set_attr(soap, "Introduction", ((ns1__NEWS*)a)->Introduction->c_str(), 1);
	if (((ns1__NEWS*)a)->Story)
		soap_set_attr(soap, "Story", ((ns1__NEWS*)a)->Story->c_str(), 1);
	if (((ns1__NEWS*)a)->Caption)
		soap_set_attr(soap, "Caption", ((ns1__NEWS*)a)->Caption->c_str(), 1);
	soap_set_attr(soap, "Views", soap_int2s(soap, ((ns1__NEWS*)a)->Views), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns_ns1__NEWS), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__NEWS::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__NEWS(soap, tag, this, type);
}

SOAP_FMAC3 ns1__NEWS * SOAP_FMAC4 soap_in_ns1__NEWS(struct soap *soap, const char *tag, ns1__NEWS *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__NEWS *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns_ns1__NEWS, sizeof(ns1__NEWS), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	{	const char *t = soap_attr_value(soap, "Exchange", 0);
		if (t)
		{
			if (!(((ns1__NEWS*)a)->Exchange = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__NEWS*)a)->Exchange, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Symbol", 0);
		if (t)
		{
			if (!(((ns1__NEWS*)a)->Symbol = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__NEWS*)a)->Symbol, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2LONG64(soap, soap_attr_value(soap, "Id", 1), &((ns1__NEWS*)a)->Id))
		return NULL;
	{	const char *t = soap_attr_value(soap, "SourceKey", 0);
		if (t)
		{
			if (!(((ns1__NEWS*)a)->SourceKey = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__NEWS*)a)->SourceKey, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2dateTime(soap, soap_attr_value(soap, "DateTime", 1), &((ns1__NEWS*)a)->DateTime))
		return NULL;
	{	const char *t = soap_attr_value(soap, "Headline", 0);
		if (t)
		{
			if (!(((ns1__NEWS*)a)->Headline = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__NEWS*)a)->Headline, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Introduction", 0);
		if (t)
		{
			if (!(((ns1__NEWS*)a)->Introduction = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__NEWS*)a)->Introduction, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Story", 0);
		if (t)
		{
			if (!(((ns1__NEWS*)a)->Story = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__NEWS*)a)->Story, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Caption", 0);
		if (t)
		{
			if (!(((ns1__NEWS*)a)->Caption = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__NEWS*)a)->Caption, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2int(soap, soap_attr_value(soap, "Views", 1), &((ns1__NEWS*)a)->Views))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__NEWS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns_ns1__NEWS, SOAP_TYPE_ns_ns1__NEWS, sizeof(ns1__NEWS), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__NEWS * SOAP_FMAC2 soap_instantiate_ns1__NEWS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__NEWS(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__NEWS *p;
	size_t k = sizeof(ns1__NEWS);
	if (n < 0)
	{	p = SOAP_NEW(ns1__NEWS);
		if (p)
			((ns1__NEWS*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__NEWS, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__NEWS*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__NEWS location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns_ns1__NEWS, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__NEWS::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:NEWS", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__NEWS::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__NEWS(soap, this, tag, type);
}

SOAP_FMAC3 ns1__NEWS * SOAP_FMAC4 soap_get_ns1__NEWS(struct soap *soap, ns1__NEWS *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__NEWS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ArrayOfNEWS::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__NEWS(soap, &this->ns1__ArrayOfNEWS::NEWS);
	/* transient soap skipped */
}

void ns1__ArrayOfNEWS::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__NEWS(soap, &this->ns1__ArrayOfNEWS::NEWS);
#endif
}

int ns1__ArrayOfNEWS::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfNEWS(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfNEWS(struct soap *soap, const char *tag, int id, const ns1__ArrayOfNEWS *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns_ns1__ArrayOfNEWS), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__NEWS(soap, "ns1:NEWS", -1, &a->ns1__ArrayOfNEWS::NEWS, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfNEWS::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfNEWS(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfNEWS * SOAP_FMAC4 soap_in_ns1__ArrayOfNEWS(struct soap *soap, const char *tag, ns1__ArrayOfNEWS *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfNEWS *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns_ns1__ArrayOfNEWS, sizeof(ns1__ArrayOfNEWS), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__NEWS(soap, "ns1:NEWS", &a->ns1__ArrayOfNEWS::NEWS, "ns1:NEWS"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfNEWS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns_ns1__ArrayOfNEWS, SOAP_TYPE_ns_ns1__ArrayOfNEWS, sizeof(ns1__ArrayOfNEWS), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ArrayOfNEWS * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfNEWS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfNEWS(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ArrayOfNEWS *p;
	size_t k = sizeof(ns1__ArrayOfNEWS);
	if (n < 0)
	{	p = SOAP_NEW(ns1__ArrayOfNEWS);
		if (p)
			((ns1__ArrayOfNEWS*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__ArrayOfNEWS, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__ArrayOfNEWS*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ArrayOfNEWS location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns_ns1__ArrayOfNEWS, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__ArrayOfNEWS::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfNEWS", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfNEWS::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfNEWS(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfNEWS * SOAP_FMAC4 soap_get_ns1__ArrayOfNEWS(struct soap *soap, ns1__ArrayOfNEWS *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfNEWS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__SYMBOLCHANGE::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_dateTime(soap, &this->ns1__SYMBOLCHANGE::DateTime);
	this->ns1__SYMBOLCHANGE::OldSymbol = NULL;
	this->ns1__SYMBOLCHANGE::NewSymbol = NULL;
	this->ns1__SYMBOLCHANGE::ExchangeCode = NULL;
	this->ns1__SYMBOLCHANGE::NewExchangeCode = NULL;
	/* transient soap skipped */
}

void ns1__SYMBOLCHANGE::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns1__SYMBOLCHANGE::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SYMBOLCHANGE(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SYMBOLCHANGE(struct soap *soap, const char *tag, int id, const ns1__SYMBOLCHANGE *a, const char *type)
{
	soap_set_attr(soap, "DateTime", soap_dateTime2s(soap, ((ns1__SYMBOLCHANGE*)a)->DateTime), 1);
	if (((ns1__SYMBOLCHANGE*)a)->OldSymbol)
		soap_set_attr(soap, "OldSymbol", ((ns1__SYMBOLCHANGE*)a)->OldSymbol->c_str(), 1);
	if (((ns1__SYMBOLCHANGE*)a)->NewSymbol)
		soap_set_attr(soap, "NewSymbol", ((ns1__SYMBOLCHANGE*)a)->NewSymbol->c_str(), 1);
	if (((ns1__SYMBOLCHANGE*)a)->ExchangeCode)
		soap_set_attr(soap, "ExchangeCode", ((ns1__SYMBOLCHANGE*)a)->ExchangeCode->c_str(), 1);
	if (((ns1__SYMBOLCHANGE*)a)->NewExchangeCode)
		soap_set_attr(soap, "NewExchangeCode", ((ns1__SYMBOLCHANGE*)a)->NewExchangeCode->c_str(), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns_ns1__SYMBOLCHANGE), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__SYMBOLCHANGE::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__SYMBOLCHANGE(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SYMBOLCHANGE * SOAP_FMAC4 soap_in_ns1__SYMBOLCHANGE(struct soap *soap, const char *tag, ns1__SYMBOLCHANGE *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SYMBOLCHANGE *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns_ns1__SYMBOLCHANGE, sizeof(ns1__SYMBOLCHANGE), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2dateTime(soap, soap_attr_value(soap, "DateTime", 1), &((ns1__SYMBOLCHANGE*)a)->DateTime))
		return NULL;
	{	const char *t = soap_attr_value(soap, "OldSymbol", 0);
		if (t)
		{
			if (!(((ns1__SYMBOLCHANGE*)a)->OldSymbol = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__SYMBOLCHANGE*)a)->OldSymbol, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "NewSymbol", 0);
		if (t)
		{
			if (!(((ns1__SYMBOLCHANGE*)a)->NewSymbol = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__SYMBOLCHANGE*)a)->NewSymbol, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "ExchangeCode", 0);
		if (t)
		{
			if (!(((ns1__SYMBOLCHANGE*)a)->ExchangeCode = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__SYMBOLCHANGE*)a)->ExchangeCode, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "NewExchangeCode", 0);
		if (t)
		{
			if (!(((ns1__SYMBOLCHANGE*)a)->NewExchangeCode = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__SYMBOLCHANGE*)a)->NewExchangeCode, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__SYMBOLCHANGE *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns_ns1__SYMBOLCHANGE, SOAP_TYPE_ns_ns1__SYMBOLCHANGE, sizeof(ns1__SYMBOLCHANGE), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__SYMBOLCHANGE * SOAP_FMAC2 soap_instantiate_ns1__SYMBOLCHANGE(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SYMBOLCHANGE(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__SYMBOLCHANGE *p;
	size_t k = sizeof(ns1__SYMBOLCHANGE);
	if (n < 0)
	{	p = SOAP_NEW(ns1__SYMBOLCHANGE);
		if (p)
			((ns1__SYMBOLCHANGE*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__SYMBOLCHANGE, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__SYMBOLCHANGE*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__SYMBOLCHANGE location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns_ns1__SYMBOLCHANGE, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__SYMBOLCHANGE::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:SYMBOLCHANGE", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SYMBOLCHANGE::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SYMBOLCHANGE(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SYMBOLCHANGE * SOAP_FMAC4 soap_get_ns1__SYMBOLCHANGE(struct soap *soap, ns1__SYMBOLCHANGE *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SYMBOLCHANGE(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ArrayOfSYMBOLCHANGE::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__SYMBOLCHANGE(soap, &this->ns1__ArrayOfSYMBOLCHANGE::SYMBOLCHANGE);
	/* transient soap skipped */
}

void ns1__ArrayOfSYMBOLCHANGE::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__SYMBOLCHANGE(soap, &this->ns1__ArrayOfSYMBOLCHANGE::SYMBOLCHANGE);
#endif
}

int ns1__ArrayOfSYMBOLCHANGE::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfSYMBOLCHANGE(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfSYMBOLCHANGE(struct soap *soap, const char *tag, int id, const ns1__ArrayOfSYMBOLCHANGE *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns_ns1__ArrayOfSYMBOLCHANGE), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__SYMBOLCHANGE(soap, "ns1:SYMBOLCHANGE", -1, &a->ns1__ArrayOfSYMBOLCHANGE::SYMBOLCHANGE, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfSYMBOLCHANGE::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfSYMBOLCHANGE(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfSYMBOLCHANGE * SOAP_FMAC4 soap_in_ns1__ArrayOfSYMBOLCHANGE(struct soap *soap, const char *tag, ns1__ArrayOfSYMBOLCHANGE *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfSYMBOLCHANGE *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns_ns1__ArrayOfSYMBOLCHANGE, sizeof(ns1__ArrayOfSYMBOLCHANGE), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__SYMBOLCHANGE(soap, "ns1:SYMBOLCHANGE", &a->ns1__ArrayOfSYMBOLCHANGE::SYMBOLCHANGE, "ns1:SYMBOLCHANGE"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfSYMBOLCHANGE *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns_ns1__ArrayOfSYMBOLCHANGE, SOAP_TYPE_ns_ns1__ArrayOfSYMBOLCHANGE, sizeof(ns1__ArrayOfSYMBOLCHANGE), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ArrayOfSYMBOLCHANGE * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfSYMBOLCHANGE(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfSYMBOLCHANGE(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ArrayOfSYMBOLCHANGE *p;
	size_t k = sizeof(ns1__ArrayOfSYMBOLCHANGE);
	if (n < 0)
	{	p = SOAP_NEW(ns1__ArrayOfSYMBOLCHANGE);
		if (p)
			((ns1__ArrayOfSYMBOLCHANGE*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__ArrayOfSYMBOLCHANGE, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__ArrayOfSYMBOLCHANGE*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ArrayOfSYMBOLCHANGE location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns_ns1__ArrayOfSYMBOLCHANGE, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__ArrayOfSYMBOLCHANGE::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfSYMBOLCHANGE", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfSYMBOLCHANGE::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfSYMBOLCHANGE(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfSYMBOLCHANGE * SOAP_FMAC4 soap_get_ns1__ArrayOfSYMBOLCHANGE(struct soap *soap, ns1__ArrayOfSYMBOLCHANGE *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfSYMBOLCHANGE(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__TECHNICAL::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__TECHNICAL::Symbol = NULL;
	this->ns1__TECHNICAL::Name = NULL;
	this->ns1__TECHNICAL::Description = NULL;
	soap_default_dateTime(soap, &this->ns1__TECHNICAL::DateTime);
	soap_default_double(soap, &this->ns1__TECHNICAL::Previous);
	soap_default_double(soap, &this->ns1__TECHNICAL::Change);
	soap_default_int(soap, &this->ns1__TECHNICAL::MA1);
	soap_default_int(soap, &this->ns1__TECHNICAL::MA2);
	soap_default_int(soap, &this->ns1__TECHNICAL::MA5);
	soap_default_int(soap, &this->ns1__TECHNICAL::MA20);
	soap_default_int(soap, &this->ns1__TECHNICAL::MA50);
	soap_default_int(soap, &this->ns1__TECHNICAL::MA100);
	soap_default_int(soap, &this->ns1__TECHNICAL::MA200);
	soap_default_double(soap, &this->ns1__TECHNICAL::MAPercent);
	soap_default_double(soap, &this->ns1__TECHNICAL::MAReturn);
	soap_default_LONG64(soap, &this->ns1__TECHNICAL::VolumeChange);
	soap_default_double(soap, &this->ns1__TECHNICAL::ThreeMonthChange);
	soap_default_double(soap, &this->ns1__TECHNICAL::SixMonthChange);
	soap_default_double(soap, &this->ns1__TECHNICAL::WeekHigh);
	soap_default_double(soap, &this->ns1__TECHNICAL::WeekLow);
	soap_default_double(soap, &this->ns1__TECHNICAL::WeekChange);
	soap_default_double(soap, &this->ns1__TECHNICAL::AvgWeekChange);
	soap_default_double(soap, &this->ns1__TECHNICAL::AvgWeekVolume);
	soap_default_double(soap, &this->ns1__TECHNICAL::WeekVolume);
	soap_default_double(soap, &this->ns1__TECHNICAL::MonthHigh);
	soap_default_double(soap, &this->ns1__TECHNICAL::MonthLow);
	soap_default_double(soap, &this->ns1__TECHNICAL::MonthChange);
	soap_default_double(soap, &this->ns1__TECHNICAL::AvgMonthChange);
	soap_default_double(soap, &this->ns1__TECHNICAL::AvgMonthVolume);
	soap_default_double(soap, &this->ns1__TECHNICAL::MonthVolume);
	soap_default_double(soap, &this->ns1__TECHNICAL::YearHigh);
	soap_default_double(soap, &this->ns1__TECHNICAL::YearLow);
	soap_default_double(soap, &this->ns1__TECHNICAL::YearChange);
	soap_default_double(soap, &this->ns1__TECHNICAL::AvgYearChange);
	soap_default_double(soap, &this->ns1__TECHNICAL::AvgYearVolume);
	soap_default_double(soap, &this->ns1__TECHNICAL::YTDChange);
	soap_default_double(soap, &this->ns1__TECHNICAL::RSI14);
	soap_default_double(soap, &this->ns1__TECHNICAL::STO9);
	soap_default_double(soap, &this->ns1__TECHNICAL::WPR14);
	soap_default_double(soap, &this->ns1__TECHNICAL::MTM14);
	soap_default_double(soap, &this->ns1__TECHNICAL::ROC14);
	soap_default_LONG64(soap, &this->ns1__TECHNICAL::PTC);
	soap_default_double(soap, &this->ns1__TECHNICAL::SAR);
	soap_default_double(soap, &this->ns1__TECHNICAL::Volatility);
	soap_default_double(soap, &this->ns1__TECHNICAL::Liquidity);
	/* transient soap skipped */
}

void ns1__TECHNICAL::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns1__TECHNICAL::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__TECHNICAL(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TECHNICAL(struct soap *soap, const char *tag, int id, const ns1__TECHNICAL *a, const char *type)
{
	if (((ns1__TECHNICAL*)a)->Symbol)
		soap_set_attr(soap, "Symbol", ((ns1__TECHNICAL*)a)->Symbol->c_str(), 1);
	if (((ns1__TECHNICAL*)a)->Name)
		soap_set_attr(soap, "Name", ((ns1__TECHNICAL*)a)->Name->c_str(), 1);
	if (((ns1__TECHNICAL*)a)->Description)
		soap_set_attr(soap, "Description", ((ns1__TECHNICAL*)a)->Description->c_str(), 1);
	soap_set_attr(soap, "DateTime", soap_dateTime2s(soap, ((ns1__TECHNICAL*)a)->DateTime), 1);
	soap_set_attr(soap, "Previous", soap_double2s(soap, ((ns1__TECHNICAL*)a)->Previous), 1);
	soap_set_attr(soap, "Change", soap_double2s(soap, ((ns1__TECHNICAL*)a)->Change), 1);
	soap_set_attr(soap, "MA1", soap_int2s(soap, ((ns1__TECHNICAL*)a)->MA1), 1);
	soap_set_attr(soap, "MA2", soap_int2s(soap, ((ns1__TECHNICAL*)a)->MA2), 1);
	soap_set_attr(soap, "MA5", soap_int2s(soap, ((ns1__TECHNICAL*)a)->MA5), 1);
	soap_set_attr(soap, "MA20", soap_int2s(soap, ((ns1__TECHNICAL*)a)->MA20), 1);
	soap_set_attr(soap, "MA50", soap_int2s(soap, ((ns1__TECHNICAL*)a)->MA50), 1);
	soap_set_attr(soap, "MA100", soap_int2s(soap, ((ns1__TECHNICAL*)a)->MA100), 1);
	soap_set_attr(soap, "MA200", soap_int2s(soap, ((ns1__TECHNICAL*)a)->MA200), 1);
	soap_set_attr(soap, "MAPercent", soap_double2s(soap, ((ns1__TECHNICAL*)a)->MAPercent), 1);
	soap_set_attr(soap, "MAReturn", soap_double2s(soap, ((ns1__TECHNICAL*)a)->MAReturn), 1);
	soap_set_attr(soap, "VolumeChange", soap_LONG642s(soap, ((ns1__TECHNICAL*)a)->VolumeChange), 1);
	soap_set_attr(soap, "ThreeMonthChange", soap_double2s(soap, ((ns1__TECHNICAL*)a)->ThreeMonthChange), 1);
	soap_set_attr(soap, "SixMonthChange", soap_double2s(soap, ((ns1__TECHNICAL*)a)->SixMonthChange), 1);
	soap_set_attr(soap, "WeekHigh", soap_double2s(soap, ((ns1__TECHNICAL*)a)->WeekHigh), 1);
	soap_set_attr(soap, "WeekLow", soap_double2s(soap, ((ns1__TECHNICAL*)a)->WeekLow), 1);
	soap_set_attr(soap, "WeekChange", soap_double2s(soap, ((ns1__TECHNICAL*)a)->WeekChange), 1);
	soap_set_attr(soap, "AvgWeekChange", soap_double2s(soap, ((ns1__TECHNICAL*)a)->AvgWeekChange), 1);
	soap_set_attr(soap, "AvgWeekVolume", soap_double2s(soap, ((ns1__TECHNICAL*)a)->AvgWeekVolume), 1);
	soap_set_attr(soap, "WeekVolume", soap_double2s(soap, ((ns1__TECHNICAL*)a)->WeekVolume), 1);
	soap_set_attr(soap, "MonthHigh", soap_double2s(soap, ((ns1__TECHNICAL*)a)->MonthHigh), 1);
	soap_set_attr(soap, "MonthLow", soap_double2s(soap, ((ns1__TECHNICAL*)a)->MonthLow), 1);
	soap_set_attr(soap, "MonthChange", soap_double2s(soap, ((ns1__TECHNICAL*)a)->MonthChange), 1);
	soap_set_attr(soap, "AvgMonthChange", soap_double2s(soap, ((ns1__TECHNICAL*)a)->AvgMonthChange), 1);
	soap_set_attr(soap, "AvgMonthVolume", soap_double2s(soap, ((ns1__TECHNICAL*)a)->AvgMonthVolume), 1);
	soap_set_attr(soap, "MonthVolume", soap_double2s(soap, ((ns1__TECHNICAL*)a)->MonthVolume), 1);
	soap_set_attr(soap, "YearHigh", soap_double2s(soap, ((ns1__TECHNICAL*)a)->YearHigh), 1);
	soap_set_attr(soap, "YearLow", soap_double2s(soap, ((ns1__TECHNICAL*)a)->YearLow), 1);
	soap_set_attr(soap, "YearChange", soap_double2s(soap, ((ns1__TECHNICAL*)a)->YearChange), 1);
	soap_set_attr(soap, "AvgYearChange", soap_double2s(soap, ((ns1__TECHNICAL*)a)->AvgYearChange), 1);
	soap_set_attr(soap, "AvgYearVolume", soap_double2s(soap, ((ns1__TECHNICAL*)a)->AvgYearVolume), 1);
	soap_set_attr(soap, "YTDChange", soap_double2s(soap, ((ns1__TECHNICAL*)a)->YTDChange), 1);
	soap_set_attr(soap, "RSI14", soap_double2s(soap, ((ns1__TECHNICAL*)a)->RSI14), 1);
	soap_set_attr(soap, "STO9", soap_double2s(soap, ((ns1__TECHNICAL*)a)->STO9), 1);
	soap_set_attr(soap, "WPR14", soap_double2s(soap, ((ns1__TECHNICAL*)a)->WPR14), 1);
	soap_set_attr(soap, "MTM14", soap_double2s(soap, ((ns1__TECHNICAL*)a)->MTM14), 1);
	soap_set_attr(soap, "ROC14", soap_double2s(soap, ((ns1__TECHNICAL*)a)->ROC14), 1);
	soap_set_attr(soap, "PTC", soap_LONG642s(soap, ((ns1__TECHNICAL*)a)->PTC), 1);
	soap_set_attr(soap, "SAR", soap_double2s(soap, ((ns1__TECHNICAL*)a)->SAR), 1);
	soap_set_attr(soap, "Volatility", soap_double2s(soap, ((ns1__TECHNICAL*)a)->Volatility), 1);
	soap_set_attr(soap, "Liquidity", soap_double2s(soap, ((ns1__TECHNICAL*)a)->Liquidity), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns_ns1__TECHNICAL), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__TECHNICAL::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__TECHNICAL(soap, tag, this, type);
}

SOAP_FMAC3 ns1__TECHNICAL * SOAP_FMAC4 soap_in_ns1__TECHNICAL(struct soap *soap, const char *tag, ns1__TECHNICAL *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__TECHNICAL *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns_ns1__TECHNICAL, sizeof(ns1__TECHNICAL), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	{	const char *t = soap_attr_value(soap, "Symbol", 0);
		if (t)
		{
			if (!(((ns1__TECHNICAL*)a)->Symbol = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__TECHNICAL*)a)->Symbol, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Name", 0);
		if (t)
		{
			if (!(((ns1__TECHNICAL*)a)->Name = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__TECHNICAL*)a)->Name, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Description", 0);
		if (t)
		{
			if (!(((ns1__TECHNICAL*)a)->Description = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__TECHNICAL*)a)->Description, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2dateTime(soap, soap_attr_value(soap, "DateTime", 1), &((ns1__TECHNICAL*)a)->DateTime))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "Previous", 1), &((ns1__TECHNICAL*)a)->Previous))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "Change", 1), &((ns1__TECHNICAL*)a)->Change))
		return NULL;
	if (soap_s2int(soap, soap_attr_value(soap, "MA1", 1), &((ns1__TECHNICAL*)a)->MA1))
		return NULL;
	if (soap_s2int(soap, soap_attr_value(soap, "MA2", 1), &((ns1__TECHNICAL*)a)->MA2))
		return NULL;
	if (soap_s2int(soap, soap_attr_value(soap, "MA5", 1), &((ns1__TECHNICAL*)a)->MA5))
		return NULL;
	if (soap_s2int(soap, soap_attr_value(soap, "MA20", 1), &((ns1__TECHNICAL*)a)->MA20))
		return NULL;
	if (soap_s2int(soap, soap_attr_value(soap, "MA50", 1), &((ns1__TECHNICAL*)a)->MA50))
		return NULL;
	if (soap_s2int(soap, soap_attr_value(soap, "MA100", 1), &((ns1__TECHNICAL*)a)->MA100))
		return NULL;
	if (soap_s2int(soap, soap_attr_value(soap, "MA200", 1), &((ns1__TECHNICAL*)a)->MA200))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "MAPercent", 1), &((ns1__TECHNICAL*)a)->MAPercent))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "MAReturn", 1), &((ns1__TECHNICAL*)a)->MAReturn))
		return NULL;
	if (soap_s2LONG64(soap, soap_attr_value(soap, "VolumeChange", 1), &((ns1__TECHNICAL*)a)->VolumeChange))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "ThreeMonthChange", 1), &((ns1__TECHNICAL*)a)->ThreeMonthChange))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "SixMonthChange", 1), &((ns1__TECHNICAL*)a)->SixMonthChange))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "WeekHigh", 1), &((ns1__TECHNICAL*)a)->WeekHigh))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "WeekLow", 1), &((ns1__TECHNICAL*)a)->WeekLow))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "WeekChange", 1), &((ns1__TECHNICAL*)a)->WeekChange))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "AvgWeekChange", 1), &((ns1__TECHNICAL*)a)->AvgWeekChange))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "AvgWeekVolume", 1), &((ns1__TECHNICAL*)a)->AvgWeekVolume))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "WeekVolume", 1), &((ns1__TECHNICAL*)a)->WeekVolume))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "MonthHigh", 1), &((ns1__TECHNICAL*)a)->MonthHigh))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "MonthLow", 1), &((ns1__TECHNICAL*)a)->MonthLow))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "MonthChange", 1), &((ns1__TECHNICAL*)a)->MonthChange))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "AvgMonthChange", 1), &((ns1__TECHNICAL*)a)->AvgMonthChange))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "AvgMonthVolume", 1), &((ns1__TECHNICAL*)a)->AvgMonthVolume))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "MonthVolume", 1), &((ns1__TECHNICAL*)a)->MonthVolume))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "YearHigh", 1), &((ns1__TECHNICAL*)a)->YearHigh))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "YearLow", 1), &((ns1__TECHNICAL*)a)->YearLow))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "YearChange", 1), &((ns1__TECHNICAL*)a)->YearChange))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "AvgYearChange", 1), &((ns1__TECHNICAL*)a)->AvgYearChange))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "AvgYearVolume", 1), &((ns1__TECHNICAL*)a)->AvgYearVolume))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "YTDChange", 1), &((ns1__TECHNICAL*)a)->YTDChange))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "RSI14", 1), &((ns1__TECHNICAL*)a)->RSI14))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "STO9", 1), &((ns1__TECHNICAL*)a)->STO9))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "WPR14", 1), &((ns1__TECHNICAL*)a)->WPR14))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "MTM14", 1), &((ns1__TECHNICAL*)a)->MTM14))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "ROC14", 1), &((ns1__TECHNICAL*)a)->ROC14))
		return NULL;
	if (soap_s2LONG64(soap, soap_attr_value(soap, "PTC", 1), &((ns1__TECHNICAL*)a)->PTC))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "SAR", 1), &((ns1__TECHNICAL*)a)->SAR))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "Volatility", 1), &((ns1__TECHNICAL*)a)->Volatility))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "Liquidity", 1), &((ns1__TECHNICAL*)a)->Liquidity))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__TECHNICAL *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns_ns1__TECHNICAL, SOAP_TYPE_ns_ns1__TECHNICAL, sizeof(ns1__TECHNICAL), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__TECHNICAL * SOAP_FMAC2 soap_instantiate_ns1__TECHNICAL(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__TECHNICAL(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__TECHNICAL *p;
	size_t k = sizeof(ns1__TECHNICAL);
	if (n < 0)
	{	p = SOAP_NEW(ns1__TECHNICAL);
		if (p)
			((ns1__TECHNICAL*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__TECHNICAL, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__TECHNICAL*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__TECHNICAL location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns_ns1__TECHNICAL, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__TECHNICAL::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:TECHNICAL", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__TECHNICAL::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__TECHNICAL(soap, this, tag, type);
}

SOAP_FMAC3 ns1__TECHNICAL * SOAP_FMAC4 soap_get_ns1__TECHNICAL(struct soap *soap, ns1__TECHNICAL *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TECHNICAL(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ArrayOfTECHNICAL::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__TECHNICAL(soap, &this->ns1__ArrayOfTECHNICAL::TECHNICAL);
	/* transient soap skipped */
}

void ns1__ArrayOfTECHNICAL::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__TECHNICAL(soap, &this->ns1__ArrayOfTECHNICAL::TECHNICAL);
#endif
}

int ns1__ArrayOfTECHNICAL::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfTECHNICAL(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfTECHNICAL(struct soap *soap, const char *tag, int id, const ns1__ArrayOfTECHNICAL *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns_ns1__ArrayOfTECHNICAL), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__TECHNICAL(soap, "ns1:TECHNICAL", -1, &a->ns1__ArrayOfTECHNICAL::TECHNICAL, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfTECHNICAL::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfTECHNICAL(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfTECHNICAL * SOAP_FMAC4 soap_in_ns1__ArrayOfTECHNICAL(struct soap *soap, const char *tag, ns1__ArrayOfTECHNICAL *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfTECHNICAL *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns_ns1__ArrayOfTECHNICAL, sizeof(ns1__ArrayOfTECHNICAL), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__TECHNICAL(soap, "ns1:TECHNICAL", &a->ns1__ArrayOfTECHNICAL::TECHNICAL, "ns1:TECHNICAL"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfTECHNICAL *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns_ns1__ArrayOfTECHNICAL, SOAP_TYPE_ns_ns1__ArrayOfTECHNICAL, sizeof(ns1__ArrayOfTECHNICAL), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ArrayOfTECHNICAL * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfTECHNICAL(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfTECHNICAL(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ArrayOfTECHNICAL *p;
	size_t k = sizeof(ns1__ArrayOfTECHNICAL);
	if (n < 0)
	{	p = SOAP_NEW(ns1__ArrayOfTECHNICAL);
		if (p)
			((ns1__ArrayOfTECHNICAL*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__ArrayOfTECHNICAL, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__ArrayOfTECHNICAL*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ArrayOfTECHNICAL location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns_ns1__ArrayOfTECHNICAL, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__ArrayOfTECHNICAL::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfTECHNICAL", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfTECHNICAL::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfTECHNICAL(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfTECHNICAL * SOAP_FMAC4 soap_get_ns1__ArrayOfTECHNICAL(struct soap *soap, ns1__ArrayOfTECHNICAL *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfTECHNICAL(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__FUNDAMENTAL::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__FUNDAMENTAL::Symbol = NULL;
	this->ns1__FUNDAMENTAL::Name = NULL;
	this->ns1__FUNDAMENTAL::Description = NULL;
	soap_default_dateTime(soap, &this->ns1__FUNDAMENTAL::DateTime);
	this->ns1__FUNDAMENTAL::Industry = NULL;
	this->ns1__FUNDAMENTAL::Sector = NULL;
	soap_default_LONG64(soap, &this->ns1__FUNDAMENTAL::Shares);
	soap_default_LONG64(soap, &this->ns1__FUNDAMENTAL::MarketCap);
	soap_default_double(soap, &this->ns1__FUNDAMENTAL::PE);
	soap_default_double(soap, &this->ns1__FUNDAMENTAL::EPS);
	soap_default_double(soap, &this->ns1__FUNDAMENTAL::NTA);
	soap_default_double(soap, &this->ns1__FUNDAMENTAL::DivYield);
	soap_default_double(soap, &this->ns1__FUNDAMENTAL::Dividend);
	soap_default_dateTime(soap, &this->ns1__FUNDAMENTAL::DividendDate);
	soap_default_double(soap, &this->ns1__FUNDAMENTAL::DPS);
	soap_default_double(soap, &this->ns1__FUNDAMENTAL::ImputationCredits);
	soap_default_double(soap, &this->ns1__FUNDAMENTAL::EBITDA);
	soap_default_double(soap, &this->ns1__FUNDAMENTAL::PEG);
	soap_default_double(soap, &this->ns1__FUNDAMENTAL::PtS);
	soap_default_double(soap, &this->ns1__FUNDAMENTAL::PtB);
	soap_default_double(soap, &this->ns1__FUNDAMENTAL::Yield);
	/* transient soap skipped */
}

void ns1__FUNDAMENTAL::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns1__FUNDAMENTAL::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__FUNDAMENTAL(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__FUNDAMENTAL(struct soap *soap, const char *tag, int id, const ns1__FUNDAMENTAL *a, const char *type)
{
	if (((ns1__FUNDAMENTAL*)a)->Symbol)
		soap_set_attr(soap, "Symbol", ((ns1__FUNDAMENTAL*)a)->Symbol->c_str(), 1);
	if (((ns1__FUNDAMENTAL*)a)->Name)
		soap_set_attr(soap, "Name", ((ns1__FUNDAMENTAL*)a)->Name->c_str(), 1);
	if (((ns1__FUNDAMENTAL*)a)->Description)
		soap_set_attr(soap, "Description", ((ns1__FUNDAMENTAL*)a)->Description->c_str(), 1);
	soap_set_attr(soap, "DateTime", soap_dateTime2s(soap, ((ns1__FUNDAMENTAL*)a)->DateTime), 1);
	if (((ns1__FUNDAMENTAL*)a)->Industry)
		soap_set_attr(soap, "Industry", ((ns1__FUNDAMENTAL*)a)->Industry->c_str(), 1);
	if (((ns1__FUNDAMENTAL*)a)->Sector)
		soap_set_attr(soap, "Sector", ((ns1__FUNDAMENTAL*)a)->Sector->c_str(), 1);
	soap_set_attr(soap, "Shares", soap_LONG642s(soap, ((ns1__FUNDAMENTAL*)a)->Shares), 1);
	soap_set_attr(soap, "MarketCap", soap_LONG642s(soap, ((ns1__FUNDAMENTAL*)a)->MarketCap), 1);
	soap_set_attr(soap, "PE", soap_double2s(soap, ((ns1__FUNDAMENTAL*)a)->PE), 1);
	soap_set_attr(soap, "EPS", soap_double2s(soap, ((ns1__FUNDAMENTAL*)a)->EPS), 1);
	soap_set_attr(soap, "NTA", soap_double2s(soap, ((ns1__FUNDAMENTAL*)a)->NTA), 1);
	soap_set_attr(soap, "DivYield", soap_double2s(soap, ((ns1__FUNDAMENTAL*)a)->DivYield), 1);
	soap_set_attr(soap, "Dividend", soap_double2s(soap, ((ns1__FUNDAMENTAL*)a)->Dividend), 1);
	soap_set_attr(soap, "DividendDate", soap_dateTime2s(soap, ((ns1__FUNDAMENTAL*)a)->DividendDate), 1);
	soap_set_attr(soap, "DPS", soap_double2s(soap, ((ns1__FUNDAMENTAL*)a)->DPS), 1);
	soap_set_attr(soap, "ImputationCredits", soap_double2s(soap, ((ns1__FUNDAMENTAL*)a)->ImputationCredits), 1);
	soap_set_attr(soap, "EBITDA", soap_double2s(soap, ((ns1__FUNDAMENTAL*)a)->EBITDA), 1);
	soap_set_attr(soap, "PEG", soap_double2s(soap, ((ns1__FUNDAMENTAL*)a)->PEG), 1);
	soap_set_attr(soap, "PtS", soap_double2s(soap, ((ns1__FUNDAMENTAL*)a)->PtS), 1);
	soap_set_attr(soap, "PtB", soap_double2s(soap, ((ns1__FUNDAMENTAL*)a)->PtB), 1);
	soap_set_attr(soap, "Yield", soap_double2s(soap, ((ns1__FUNDAMENTAL*)a)->Yield), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns_ns1__FUNDAMENTAL), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__FUNDAMENTAL::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__FUNDAMENTAL(soap, tag, this, type);
}

SOAP_FMAC3 ns1__FUNDAMENTAL * SOAP_FMAC4 soap_in_ns1__FUNDAMENTAL(struct soap *soap, const char *tag, ns1__FUNDAMENTAL *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__FUNDAMENTAL *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns_ns1__FUNDAMENTAL, sizeof(ns1__FUNDAMENTAL), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	{	const char *t = soap_attr_value(soap, "Symbol", 0);
		if (t)
		{
			if (!(((ns1__FUNDAMENTAL*)a)->Symbol = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__FUNDAMENTAL*)a)->Symbol, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Name", 0);
		if (t)
		{
			if (!(((ns1__FUNDAMENTAL*)a)->Name = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__FUNDAMENTAL*)a)->Name, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Description", 0);
		if (t)
		{
			if (!(((ns1__FUNDAMENTAL*)a)->Description = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__FUNDAMENTAL*)a)->Description, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2dateTime(soap, soap_attr_value(soap, "DateTime", 1), &((ns1__FUNDAMENTAL*)a)->DateTime))
		return NULL;
	{	const char *t = soap_attr_value(soap, "Industry", 0);
		if (t)
		{
			if (!(((ns1__FUNDAMENTAL*)a)->Industry = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__FUNDAMENTAL*)a)->Industry, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Sector", 0);
		if (t)
		{
			if (!(((ns1__FUNDAMENTAL*)a)->Sector = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__FUNDAMENTAL*)a)->Sector, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2LONG64(soap, soap_attr_value(soap, "Shares", 1), &((ns1__FUNDAMENTAL*)a)->Shares))
		return NULL;
	if (soap_s2LONG64(soap, soap_attr_value(soap, "MarketCap", 1), &((ns1__FUNDAMENTAL*)a)->MarketCap))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "PE", 1), &((ns1__FUNDAMENTAL*)a)->PE))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "EPS", 1), &((ns1__FUNDAMENTAL*)a)->EPS))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "NTA", 1), &((ns1__FUNDAMENTAL*)a)->NTA))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "DivYield", 1), &((ns1__FUNDAMENTAL*)a)->DivYield))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "Dividend", 1), &((ns1__FUNDAMENTAL*)a)->Dividend))
		return NULL;
	if (soap_s2dateTime(soap, soap_attr_value(soap, "DividendDate", 1), &((ns1__FUNDAMENTAL*)a)->DividendDate))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "DPS", 1), &((ns1__FUNDAMENTAL*)a)->DPS))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "ImputationCredits", 1), &((ns1__FUNDAMENTAL*)a)->ImputationCredits))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "EBITDA", 1), &((ns1__FUNDAMENTAL*)a)->EBITDA))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "PEG", 1), &((ns1__FUNDAMENTAL*)a)->PEG))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "PtS", 1), &((ns1__FUNDAMENTAL*)a)->PtS))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "PtB", 1), &((ns1__FUNDAMENTAL*)a)->PtB))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "Yield", 1), &((ns1__FUNDAMENTAL*)a)->Yield))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__FUNDAMENTAL *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns_ns1__FUNDAMENTAL, SOAP_TYPE_ns_ns1__FUNDAMENTAL, sizeof(ns1__FUNDAMENTAL), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__FUNDAMENTAL * SOAP_FMAC2 soap_instantiate_ns1__FUNDAMENTAL(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__FUNDAMENTAL(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__FUNDAMENTAL *p;
	size_t k = sizeof(ns1__FUNDAMENTAL);
	if (n < 0)
	{	p = SOAP_NEW(ns1__FUNDAMENTAL);
		if (p)
			((ns1__FUNDAMENTAL*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__FUNDAMENTAL, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__FUNDAMENTAL*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__FUNDAMENTAL location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns_ns1__FUNDAMENTAL, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__FUNDAMENTAL::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:FUNDAMENTAL", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__FUNDAMENTAL::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__FUNDAMENTAL(soap, this, tag, type);
}

SOAP_FMAC3 ns1__FUNDAMENTAL * SOAP_FMAC4 soap_get_ns1__FUNDAMENTAL(struct soap *soap, ns1__FUNDAMENTAL *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__FUNDAMENTAL(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ArrayOfFUNDAMENTAL::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__FUNDAMENTAL(soap, &this->ns1__ArrayOfFUNDAMENTAL::FUNDAMENTAL);
	/* transient soap skipped */
}

void ns1__ArrayOfFUNDAMENTAL::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__FUNDAMENTAL(soap, &this->ns1__ArrayOfFUNDAMENTAL::FUNDAMENTAL);
#endif
}

int ns1__ArrayOfFUNDAMENTAL::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfFUNDAMENTAL(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfFUNDAMENTAL(struct soap *soap, const char *tag, int id, const ns1__ArrayOfFUNDAMENTAL *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns_ns1__ArrayOfFUNDAMENTAL), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__FUNDAMENTAL(soap, "ns1:FUNDAMENTAL", -1, &a->ns1__ArrayOfFUNDAMENTAL::FUNDAMENTAL, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfFUNDAMENTAL::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfFUNDAMENTAL(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfFUNDAMENTAL * SOAP_FMAC4 soap_in_ns1__ArrayOfFUNDAMENTAL(struct soap *soap, const char *tag, ns1__ArrayOfFUNDAMENTAL *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfFUNDAMENTAL *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns_ns1__ArrayOfFUNDAMENTAL, sizeof(ns1__ArrayOfFUNDAMENTAL), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__FUNDAMENTAL(soap, "ns1:FUNDAMENTAL", &a->ns1__ArrayOfFUNDAMENTAL::FUNDAMENTAL, "ns1:FUNDAMENTAL"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfFUNDAMENTAL *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns_ns1__ArrayOfFUNDAMENTAL, SOAP_TYPE_ns_ns1__ArrayOfFUNDAMENTAL, sizeof(ns1__ArrayOfFUNDAMENTAL), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ArrayOfFUNDAMENTAL * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfFUNDAMENTAL(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfFUNDAMENTAL(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ArrayOfFUNDAMENTAL *p;
	size_t k = sizeof(ns1__ArrayOfFUNDAMENTAL);
	if (n < 0)
	{	p = SOAP_NEW(ns1__ArrayOfFUNDAMENTAL);
		if (p)
			((ns1__ArrayOfFUNDAMENTAL*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__ArrayOfFUNDAMENTAL, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__ArrayOfFUNDAMENTAL*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ArrayOfFUNDAMENTAL location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns_ns1__ArrayOfFUNDAMENTAL, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__ArrayOfFUNDAMENTAL::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfFUNDAMENTAL", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfFUNDAMENTAL::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfFUNDAMENTAL(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfFUNDAMENTAL * SOAP_FMAC4 soap_get_ns1__ArrayOfFUNDAMENTAL(struct soap *soap, ns1__ArrayOfFUNDAMENTAL *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfFUNDAMENTAL(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__CountryBase::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__CountryBase::Code = NULL;
	this->ns1__CountryBase::Name = NULL;
	/* transient soap skipped */
}

void ns1__CountryBase::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns1__CountryBase::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CountryBase(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CountryBase(struct soap *soap, const char *tag, int id, const ns1__CountryBase *a, const char *type)
{
	if (((ns1__CountryBase*)a)->Code)
		soap_set_attr(soap, "Code", ((ns1__CountryBase*)a)->Code->c_str(), 1);
	if (((ns1__CountryBase*)a)->Name)
		soap_set_attr(soap, "Name", ((ns1__CountryBase*)a)->Name->c_str(), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns_ns1__CountryBase), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CountryBase::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CountryBase(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CountryBase * SOAP_FMAC4 soap_in_ns1__CountryBase(struct soap *soap, const char *tag, ns1__CountryBase *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CountryBase *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns_ns1__CountryBase, sizeof(ns1__CountryBase), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	{	const char *t = soap_attr_value(soap, "Code", 0);
		if (t)
		{
			if (!(((ns1__CountryBase*)a)->Code = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__CountryBase*)a)->Code, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Name", 0);
		if (t)
		{
			if (!(((ns1__CountryBase*)a)->Name = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__CountryBase*)a)->Name, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CountryBase *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns_ns1__CountryBase, SOAP_TYPE_ns_ns1__CountryBase, sizeof(ns1__CountryBase), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__CountryBase * SOAP_FMAC2 soap_instantiate_ns1__CountryBase(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CountryBase(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__CountryBase *p;
	size_t k = sizeof(ns1__CountryBase);
	if (n < 0)
	{	p = SOAP_NEW(ns1__CountryBase);
		if (p)
			((ns1__CountryBase*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__CountryBase, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__CountryBase*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__CountryBase location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns_ns1__CountryBase, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__CountryBase::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:CountryBase", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CountryBase::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CountryBase(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CountryBase * SOAP_FMAC4 soap_get_ns1__CountryBase(struct soap *soap, ns1__CountryBase *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CountryBase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ArrayOfCountryBase::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__CountryBase(soap, &this->ns1__ArrayOfCountryBase::CountryBase);
	/* transient soap skipped */
}

void ns1__ArrayOfCountryBase::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__CountryBase(soap, &this->ns1__ArrayOfCountryBase::CountryBase);
#endif
}

int ns1__ArrayOfCountryBase::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfCountryBase(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfCountryBase(struct soap *soap, const char *tag, int id, const ns1__ArrayOfCountryBase *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns_ns1__ArrayOfCountryBase), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__CountryBase(soap, "ns1:CountryBase", -1, &a->ns1__ArrayOfCountryBase::CountryBase, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfCountryBase::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfCountryBase(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfCountryBase * SOAP_FMAC4 soap_in_ns1__ArrayOfCountryBase(struct soap *soap, const char *tag, ns1__ArrayOfCountryBase *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfCountryBase *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns_ns1__ArrayOfCountryBase, sizeof(ns1__ArrayOfCountryBase), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__CountryBase(soap, "ns1:CountryBase", &a->ns1__ArrayOfCountryBase::CountryBase, "ns1:CountryBase"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfCountryBase *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns_ns1__ArrayOfCountryBase, SOAP_TYPE_ns_ns1__ArrayOfCountryBase, sizeof(ns1__ArrayOfCountryBase), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ArrayOfCountryBase * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfCountryBase(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfCountryBase(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ArrayOfCountryBase *p;
	size_t k = sizeof(ns1__ArrayOfCountryBase);
	if (n < 0)
	{	p = SOAP_NEW(ns1__ArrayOfCountryBase);
		if (p)
			((ns1__ArrayOfCountryBase*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__ArrayOfCountryBase, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__ArrayOfCountryBase*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ArrayOfCountryBase location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns_ns1__ArrayOfCountryBase, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__ArrayOfCountryBase::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfCountryBase", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfCountryBase::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfCountryBase(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfCountryBase * SOAP_FMAC4 soap_get_ns1__ArrayOfCountryBase(struct soap *soap, ns1__ArrayOfCountryBase *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfCountryBase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__SPLIT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__SPLIT::Exchange = NULL;
	this->ns1__SPLIT::Symbol = NULL;
	soap_default_dateTime(soap, &this->ns1__SPLIT::DateTime);
	this->ns1__SPLIT::Ratio = NULL;
	/* transient soap skipped */
}

void ns1__SPLIT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns1__SPLIT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SPLIT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SPLIT(struct soap *soap, const char *tag, int id, const ns1__SPLIT *a, const char *type)
{
	if (((ns1__SPLIT*)a)->Exchange)
		soap_set_attr(soap, "Exchange", ((ns1__SPLIT*)a)->Exchange->c_str(), 1);
	if (((ns1__SPLIT*)a)->Symbol)
		soap_set_attr(soap, "Symbol", ((ns1__SPLIT*)a)->Symbol->c_str(), 1);
	soap_set_attr(soap, "DateTime", soap_dateTime2s(soap, ((ns1__SPLIT*)a)->DateTime), 1);
	if (((ns1__SPLIT*)a)->Ratio)
		soap_set_attr(soap, "Ratio", ((ns1__SPLIT*)a)->Ratio->c_str(), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns_ns1__SPLIT), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__SPLIT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__SPLIT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SPLIT * SOAP_FMAC4 soap_in_ns1__SPLIT(struct soap *soap, const char *tag, ns1__SPLIT *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SPLIT *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns_ns1__SPLIT, sizeof(ns1__SPLIT), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	{	const char *t = soap_attr_value(soap, "Exchange", 0);
		if (t)
		{
			if (!(((ns1__SPLIT*)a)->Exchange = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__SPLIT*)a)->Exchange, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Symbol", 0);
		if (t)
		{
			if (!(((ns1__SPLIT*)a)->Symbol = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__SPLIT*)a)->Symbol, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2dateTime(soap, soap_attr_value(soap, "DateTime", 1), &((ns1__SPLIT*)a)->DateTime))
		return NULL;
	{	const char *t = soap_attr_value(soap, "Ratio", 0);
		if (t)
		{
			if (!(((ns1__SPLIT*)a)->Ratio = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__SPLIT*)a)->Ratio, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__SPLIT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns_ns1__SPLIT, SOAP_TYPE_ns_ns1__SPLIT, sizeof(ns1__SPLIT), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__SPLIT * SOAP_FMAC2 soap_instantiate_ns1__SPLIT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SPLIT(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__SPLIT *p;
	size_t k = sizeof(ns1__SPLIT);
	if (n < 0)
	{	p = SOAP_NEW(ns1__SPLIT);
		if (p)
			((ns1__SPLIT*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__SPLIT, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__SPLIT*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__SPLIT location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns_ns1__SPLIT, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__SPLIT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:SPLIT", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SPLIT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SPLIT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SPLIT * SOAP_FMAC4 soap_get_ns1__SPLIT(struct soap *soap, ns1__SPLIT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SPLIT(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ArrayOfSPLIT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__SPLIT(soap, &this->ns1__ArrayOfSPLIT::SPLIT);
	/* transient soap skipped */
}

void ns1__ArrayOfSPLIT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__SPLIT(soap, &this->ns1__ArrayOfSPLIT::SPLIT);
#endif
}

int ns1__ArrayOfSPLIT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfSPLIT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfSPLIT(struct soap *soap, const char *tag, int id, const ns1__ArrayOfSPLIT *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns_ns1__ArrayOfSPLIT), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__SPLIT(soap, "ns1:SPLIT", -1, &a->ns1__ArrayOfSPLIT::SPLIT, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfSPLIT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfSPLIT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfSPLIT * SOAP_FMAC4 soap_in_ns1__ArrayOfSPLIT(struct soap *soap, const char *tag, ns1__ArrayOfSPLIT *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfSPLIT *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns_ns1__ArrayOfSPLIT, sizeof(ns1__ArrayOfSPLIT), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__SPLIT(soap, "ns1:SPLIT", &a->ns1__ArrayOfSPLIT::SPLIT, "ns1:SPLIT"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfSPLIT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns_ns1__ArrayOfSPLIT, SOAP_TYPE_ns_ns1__ArrayOfSPLIT, sizeof(ns1__ArrayOfSPLIT), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ArrayOfSPLIT * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfSPLIT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfSPLIT(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ArrayOfSPLIT *p;
	size_t k = sizeof(ns1__ArrayOfSPLIT);
	if (n < 0)
	{	p = SOAP_NEW(ns1__ArrayOfSPLIT);
		if (p)
			((ns1__ArrayOfSPLIT*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__ArrayOfSPLIT, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__ArrayOfSPLIT*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ArrayOfSPLIT location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns_ns1__ArrayOfSPLIT, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__ArrayOfSPLIT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfSPLIT", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfSPLIT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfSPLIT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfSPLIT * SOAP_FMAC4 soap_get_ns1__ArrayOfSPLIT(struct soap *soap, ns1__ArrayOfSPLIT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfSPLIT(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__QUOTE2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__QUOTE2::s = NULL;
	soap_default_dateTime(soap, &this->ns1__QUOTE2::d);
	soap_default_double(soap, &this->ns1__QUOTE2::o);
	soap_default_double(soap, &this->ns1__QUOTE2::h);
	soap_default_double(soap, &this->ns1__QUOTE2::l);
	soap_default_double(soap, &this->ns1__QUOTE2::c);
	soap_default_LONG64(soap, &this->ns1__QUOTE2::v);
	soap_default_LONG64(soap, &this->ns1__QUOTE2::i);
	soap_default_double(soap, &this->ns1__QUOTE2::b);
	soap_default_double(soap, &this->ns1__QUOTE2::a);
	/* transient soap skipped */
}

void ns1__QUOTE2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns1__QUOTE2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__QUOTE2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__QUOTE2(struct soap *soap, const char *tag, int id, const ns1__QUOTE2 *a, const char *type)
{
	if (((ns1__QUOTE2*)a)->s)
		soap_set_attr(soap, "s", ((ns1__QUOTE2*)a)->s->c_str(), 1);
	soap_set_attr(soap, "d", soap_dateTime2s(soap, ((ns1__QUOTE2*)a)->d), 1);
	soap_set_attr(soap, "o", soap_double2s(soap, ((ns1__QUOTE2*)a)->o), 1);
	soap_set_attr(soap, "h", soap_double2s(soap, ((ns1__QUOTE2*)a)->h), 1);
	soap_set_attr(soap, "l", soap_double2s(soap, ((ns1__QUOTE2*)a)->l), 1);
	soap_set_attr(soap, "c", soap_double2s(soap, ((ns1__QUOTE2*)a)->c), 1);
	soap_set_attr(soap, "v", soap_LONG642s(soap, ((ns1__QUOTE2*)a)->v), 1);
	soap_set_attr(soap, "i", soap_LONG642s(soap, ((ns1__QUOTE2*)a)->i), 1);
	soap_set_attr(soap, "b", soap_double2s(soap, ((ns1__QUOTE2*)a)->b), 1);
	soap_set_attr(soap, "a", soap_double2s(soap, ((ns1__QUOTE2*)a)->a), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns_ns1__QUOTE2), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__QUOTE2::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__QUOTE2(soap, tag, this, type);
}

SOAP_FMAC3 ns1__QUOTE2 * SOAP_FMAC4 soap_in_ns1__QUOTE2(struct soap *soap, const char *tag, ns1__QUOTE2 *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__QUOTE2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns_ns1__QUOTE2, sizeof(ns1__QUOTE2), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	{	const char *t = soap_attr_value(soap, "s", 0);
		if (t)
		{
			if (!(((ns1__QUOTE2*)a)->s = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__QUOTE2*)a)->s, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2dateTime(soap, soap_attr_value(soap, "d", 1), &((ns1__QUOTE2*)a)->d))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "o", 1), &((ns1__QUOTE2*)a)->o))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "h", 1), &((ns1__QUOTE2*)a)->h))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "l", 1), &((ns1__QUOTE2*)a)->l))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "c", 1), &((ns1__QUOTE2*)a)->c))
		return NULL;
	if (soap_s2LONG64(soap, soap_attr_value(soap, "v", 1), &((ns1__QUOTE2*)a)->v))
		return NULL;
	if (soap_s2LONG64(soap, soap_attr_value(soap, "i", 1), &((ns1__QUOTE2*)a)->i))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "b", 1), &((ns1__QUOTE2*)a)->b))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "a", 1), &((ns1__QUOTE2*)a)->a))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__QUOTE2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns_ns1__QUOTE2, SOAP_TYPE_ns_ns1__QUOTE2, sizeof(ns1__QUOTE2), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__QUOTE2 * SOAP_FMAC2 soap_instantiate_ns1__QUOTE2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__QUOTE2(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__QUOTE2 *p;
	size_t k = sizeof(ns1__QUOTE2);
	if (n < 0)
	{	p = SOAP_NEW(ns1__QUOTE2);
		if (p)
			((ns1__QUOTE2*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__QUOTE2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__QUOTE2*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__QUOTE2 location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns_ns1__QUOTE2, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__QUOTE2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:QUOTE2", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__QUOTE2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__QUOTE2(soap, this, tag, type);
}

SOAP_FMAC3 ns1__QUOTE2 * SOAP_FMAC4 soap_get_ns1__QUOTE2(struct soap *soap, ns1__QUOTE2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__QUOTE2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ArrayOfQUOTE2::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__QUOTE2(soap, &this->ns1__ArrayOfQUOTE2::QUOTE2);
	/* transient soap skipped */
}

void ns1__ArrayOfQUOTE2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__QUOTE2(soap, &this->ns1__ArrayOfQUOTE2::QUOTE2);
#endif
}

int ns1__ArrayOfQUOTE2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfQUOTE2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfQUOTE2(struct soap *soap, const char *tag, int id, const ns1__ArrayOfQUOTE2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns_ns1__ArrayOfQUOTE2), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__QUOTE2(soap, "ns1:QUOTE2", -1, &a->ns1__ArrayOfQUOTE2::QUOTE2, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfQUOTE2::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfQUOTE2(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfQUOTE2 * SOAP_FMAC4 soap_in_ns1__ArrayOfQUOTE2(struct soap *soap, const char *tag, ns1__ArrayOfQUOTE2 *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfQUOTE2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns_ns1__ArrayOfQUOTE2, sizeof(ns1__ArrayOfQUOTE2), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__QUOTE2(soap, "ns1:QUOTE2", &a->ns1__ArrayOfQUOTE2::QUOTE2, "ns1:QUOTE2"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfQUOTE2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns_ns1__ArrayOfQUOTE2, SOAP_TYPE_ns_ns1__ArrayOfQUOTE2, sizeof(ns1__ArrayOfQUOTE2), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ArrayOfQUOTE2 * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfQUOTE2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfQUOTE2(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ArrayOfQUOTE2 *p;
	size_t k = sizeof(ns1__ArrayOfQUOTE2);
	if (n < 0)
	{	p = SOAP_NEW(ns1__ArrayOfQUOTE2);
		if (p)
			((ns1__ArrayOfQUOTE2*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__ArrayOfQUOTE2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__ArrayOfQUOTE2*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ArrayOfQUOTE2 location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns_ns1__ArrayOfQUOTE2, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__ArrayOfQUOTE2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfQUOTE2", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfQUOTE2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfQUOTE2(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfQUOTE2 * SOAP_FMAC4 soap_get_ns1__ArrayOfQUOTE2(struct soap *soap, ns1__ArrayOfQUOTE2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfQUOTE2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ArrayOfQUOTE::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__QUOTE(soap, &this->ns1__ArrayOfQUOTE::QUOTE);
	/* transient soap skipped */
}

void ns1__ArrayOfQUOTE::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__QUOTE(soap, &this->ns1__ArrayOfQUOTE::QUOTE);
#endif
}

int ns1__ArrayOfQUOTE::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfQUOTE(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfQUOTE(struct soap *soap, const char *tag, int id, const ns1__ArrayOfQUOTE *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns_ns1__ArrayOfQUOTE), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__QUOTE(soap, "ns1:QUOTE", -1, &a->ns1__ArrayOfQUOTE::QUOTE, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfQUOTE::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfQUOTE(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfQUOTE * SOAP_FMAC4 soap_in_ns1__ArrayOfQUOTE(struct soap *soap, const char *tag, ns1__ArrayOfQUOTE *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfQUOTE *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns_ns1__ArrayOfQUOTE, sizeof(ns1__ArrayOfQUOTE), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__QUOTE(soap, "ns1:QUOTE", &a->ns1__ArrayOfQUOTE::QUOTE, "ns1:QUOTE"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfQUOTE *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns_ns1__ArrayOfQUOTE, SOAP_TYPE_ns_ns1__ArrayOfQUOTE, sizeof(ns1__ArrayOfQUOTE), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ArrayOfQUOTE * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfQUOTE(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfQUOTE(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ArrayOfQUOTE *p;
	size_t k = sizeof(ns1__ArrayOfQUOTE);
	if (n < 0)
	{	p = SOAP_NEW(ns1__ArrayOfQUOTE);
		if (p)
			((ns1__ArrayOfQUOTE*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__ArrayOfQUOTE, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__ArrayOfQUOTE*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ArrayOfQUOTE location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns_ns1__ArrayOfQUOTE, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__ArrayOfQUOTE::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfQUOTE", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfQUOTE::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfQUOTE(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfQUOTE * SOAP_FMAC4 soap_get_ns1__ArrayOfQUOTE(struct soap *soap, ns1__ArrayOfQUOTE *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfQUOTE(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__QUOTE::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__QUOTE::Symbol = NULL;
	this->ns1__QUOTE::Description = NULL;
	this->ns1__QUOTE::Name = NULL;
	soap_default_dateTime(soap, &this->ns1__QUOTE::DateTime);
	soap_default_double(soap, &this->ns1__QUOTE::Open);
	soap_default_double(soap, &this->ns1__QUOTE::High);
	soap_default_double(soap, &this->ns1__QUOTE::Low);
	soap_default_double(soap, &this->ns1__QUOTE::Close);
	soap_default_LONG64(soap, &this->ns1__QUOTE::Volume);
	soap_default_LONG64(soap, &this->ns1__QUOTE::OpenInterest);
	soap_default_double(soap, &this->ns1__QUOTE::Previous);
	soap_default_double(soap, &this->ns1__QUOTE::Change);
	soap_default_double(soap, &this->ns1__QUOTE::Bid);
	soap_default_double(soap, &this->ns1__QUOTE::Ask);
	soap_default_double(soap, &this->ns1__QUOTE::PreviousClose);
	soap_default_double(soap, &this->ns1__QUOTE::NextOpen);
	soap_default_dateTime(soap, &this->ns1__QUOTE::Modified);
	/* transient soap skipped */
}

void ns1__QUOTE::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns1__QUOTE::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__QUOTE(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__QUOTE(struct soap *soap, const char *tag, int id, const ns1__QUOTE *a, const char *type)
{
	if (((ns1__QUOTE*)a)->Symbol)
		soap_set_attr(soap, "Symbol", ((ns1__QUOTE*)a)->Symbol->c_str(), 1);
	if (((ns1__QUOTE*)a)->Description)
		soap_set_attr(soap, "Description", ((ns1__QUOTE*)a)->Description->c_str(), 1);
	if (((ns1__QUOTE*)a)->Name)
		soap_set_attr(soap, "Name", ((ns1__QUOTE*)a)->Name->c_str(), 1);
	soap_set_attr(soap, "DateTime", soap_dateTime2s(soap, ((ns1__QUOTE*)a)->DateTime), 1);
	soap_set_attr(soap, "Open", soap_double2s(soap, ((ns1__QUOTE*)a)->Open), 1);
	soap_set_attr(soap, "High", soap_double2s(soap, ((ns1__QUOTE*)a)->High), 1);
	soap_set_attr(soap, "Low", soap_double2s(soap, ((ns1__QUOTE*)a)->Low), 1);
	soap_set_attr(soap, "Close", soap_double2s(soap, ((ns1__QUOTE*)a)->Close), 1);
	soap_set_attr(soap, "Volume", soap_LONG642s(soap, ((ns1__QUOTE*)a)->Volume), 1);
	soap_set_attr(soap, "OpenInterest", soap_LONG642s(soap, ((ns1__QUOTE*)a)->OpenInterest), 1);
	soap_set_attr(soap, "Previous", soap_double2s(soap, ((ns1__QUOTE*)a)->Previous), 1);
	soap_set_attr(soap, "Change", soap_double2s(soap, ((ns1__QUOTE*)a)->Change), 1);
	soap_set_attr(soap, "Bid", soap_double2s(soap, ((ns1__QUOTE*)a)->Bid), 1);
	soap_set_attr(soap, "Ask", soap_double2s(soap, ((ns1__QUOTE*)a)->Ask), 1);
	soap_set_attr(soap, "PreviousClose", soap_double2s(soap, ((ns1__QUOTE*)a)->PreviousClose), 1);
	soap_set_attr(soap, "NextOpen", soap_double2s(soap, ((ns1__QUOTE*)a)->NextOpen), 1);
	soap_set_attr(soap, "Modified", soap_dateTime2s(soap, ((ns1__QUOTE*)a)->Modified), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns_ns1__QUOTE), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__QUOTE::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__QUOTE(soap, tag, this, type);
}

SOAP_FMAC3 ns1__QUOTE * SOAP_FMAC4 soap_in_ns1__QUOTE(struct soap *soap, const char *tag, ns1__QUOTE *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__QUOTE *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns_ns1__QUOTE, sizeof(ns1__QUOTE), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	{	const char *t = soap_attr_value(soap, "Symbol", 0);
		if (t)
		{
			if (!(((ns1__QUOTE*)a)->Symbol = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__QUOTE*)a)->Symbol, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Description", 0);
		if (t)
		{
			if (!(((ns1__QUOTE*)a)->Description = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__QUOTE*)a)->Description, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Name", 0);
		if (t)
		{
			if (!(((ns1__QUOTE*)a)->Name = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__QUOTE*)a)->Name, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2dateTime(soap, soap_attr_value(soap, "DateTime", 1), &((ns1__QUOTE*)a)->DateTime))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "Open", 1), &((ns1__QUOTE*)a)->Open))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "High", 1), &((ns1__QUOTE*)a)->High))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "Low", 1), &((ns1__QUOTE*)a)->Low))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "Close", 1), &((ns1__QUOTE*)a)->Close))
		return NULL;
	if (soap_s2LONG64(soap, soap_attr_value(soap, "Volume", 1), &((ns1__QUOTE*)a)->Volume))
		return NULL;
	if (soap_s2LONG64(soap, soap_attr_value(soap, "OpenInterest", 1), &((ns1__QUOTE*)a)->OpenInterest))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "Previous", 1), &((ns1__QUOTE*)a)->Previous))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "Change", 1), &((ns1__QUOTE*)a)->Change))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "Bid", 1), &((ns1__QUOTE*)a)->Bid))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "Ask", 1), &((ns1__QUOTE*)a)->Ask))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "PreviousClose", 1), &((ns1__QUOTE*)a)->PreviousClose))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "NextOpen", 1), &((ns1__QUOTE*)a)->NextOpen))
		return NULL;
	if (soap_s2dateTime(soap, soap_attr_value(soap, "Modified", 1), &((ns1__QUOTE*)a)->Modified))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__QUOTE *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns_ns1__QUOTE, SOAP_TYPE_ns_ns1__QUOTE, sizeof(ns1__QUOTE), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__QUOTE * SOAP_FMAC2 soap_instantiate_ns1__QUOTE(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__QUOTE(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__QUOTE *p;
	size_t k = sizeof(ns1__QUOTE);
	if (n < 0)
	{	p = SOAP_NEW(ns1__QUOTE);
		if (p)
			((ns1__QUOTE*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__QUOTE, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__QUOTE*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__QUOTE location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns_ns1__QUOTE, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__QUOTE::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:QUOTE", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__QUOTE::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__QUOTE(soap, this, tag, type);
}

SOAP_FMAC3 ns1__QUOTE * SOAP_FMAC4 soap_get_ns1__QUOTE(struct soap *soap, ns1__QUOTE *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__QUOTE(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__SYMBOL2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__SYMBOL2::c = NULL;
	this->ns1__SYMBOL2::n = NULL;
	/* transient soap skipped */
}

void ns1__SYMBOL2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns1__SYMBOL2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SYMBOL2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SYMBOL2(struct soap *soap, const char *tag, int id, const ns1__SYMBOL2 *a, const char *type)
{
	if (((ns1__SYMBOL2*)a)->c)
		soap_set_attr(soap, "c", ((ns1__SYMBOL2*)a)->c->c_str(), 1);
	if (((ns1__SYMBOL2*)a)->n)
		soap_set_attr(soap, "n", ((ns1__SYMBOL2*)a)->n->c_str(), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns_ns1__SYMBOL2), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__SYMBOL2::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__SYMBOL2(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SYMBOL2 * SOAP_FMAC4 soap_in_ns1__SYMBOL2(struct soap *soap, const char *tag, ns1__SYMBOL2 *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SYMBOL2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns_ns1__SYMBOL2, sizeof(ns1__SYMBOL2), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	{	const char *t = soap_attr_value(soap, "c", 0);
		if (t)
		{
			if (!(((ns1__SYMBOL2*)a)->c = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__SYMBOL2*)a)->c, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "n", 0);
		if (t)
		{
			if (!(((ns1__SYMBOL2*)a)->n = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__SYMBOL2*)a)->n, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__SYMBOL2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns_ns1__SYMBOL2, SOAP_TYPE_ns_ns1__SYMBOL2, sizeof(ns1__SYMBOL2), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__SYMBOL2 * SOAP_FMAC2 soap_instantiate_ns1__SYMBOL2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SYMBOL2(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__SYMBOL2 *p;
	size_t k = sizeof(ns1__SYMBOL2);
	if (n < 0)
	{	p = SOAP_NEW(ns1__SYMBOL2);
		if (p)
			((ns1__SYMBOL2*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__SYMBOL2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__SYMBOL2*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__SYMBOL2 location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns_ns1__SYMBOL2, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__SYMBOL2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:SYMBOL2", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SYMBOL2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SYMBOL2(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SYMBOL2 * SOAP_FMAC4 soap_get_ns1__SYMBOL2(struct soap *soap, ns1__SYMBOL2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SYMBOL2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ArrayOfSYMBOL2::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__SYMBOL2(soap, &this->ns1__ArrayOfSYMBOL2::SYMBOL2);
	/* transient soap skipped */
}

void ns1__ArrayOfSYMBOL2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__SYMBOL2(soap, &this->ns1__ArrayOfSYMBOL2::SYMBOL2);
#endif
}

int ns1__ArrayOfSYMBOL2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfSYMBOL2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfSYMBOL2(struct soap *soap, const char *tag, int id, const ns1__ArrayOfSYMBOL2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns_ns1__ArrayOfSYMBOL2), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__SYMBOL2(soap, "ns1:SYMBOL2", -1, &a->ns1__ArrayOfSYMBOL2::SYMBOL2, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfSYMBOL2::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfSYMBOL2(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfSYMBOL2 * SOAP_FMAC4 soap_in_ns1__ArrayOfSYMBOL2(struct soap *soap, const char *tag, ns1__ArrayOfSYMBOL2 *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfSYMBOL2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns_ns1__ArrayOfSYMBOL2, sizeof(ns1__ArrayOfSYMBOL2), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__SYMBOL2(soap, "ns1:SYMBOL2", &a->ns1__ArrayOfSYMBOL2::SYMBOL2, "ns1:SYMBOL2"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfSYMBOL2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns_ns1__ArrayOfSYMBOL2, SOAP_TYPE_ns_ns1__ArrayOfSYMBOL2, sizeof(ns1__ArrayOfSYMBOL2), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ArrayOfSYMBOL2 * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfSYMBOL2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfSYMBOL2(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ArrayOfSYMBOL2 *p;
	size_t k = sizeof(ns1__ArrayOfSYMBOL2);
	if (n < 0)
	{	p = SOAP_NEW(ns1__ArrayOfSYMBOL2);
		if (p)
			((ns1__ArrayOfSYMBOL2*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__ArrayOfSYMBOL2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__ArrayOfSYMBOL2*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ArrayOfSYMBOL2 location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns_ns1__ArrayOfSYMBOL2, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__ArrayOfSYMBOL2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfSYMBOL2", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfSYMBOL2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfSYMBOL2(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfSYMBOL2 * SOAP_FMAC4 soap_get_ns1__ArrayOfSYMBOL2(struct soap *soap, ns1__ArrayOfSYMBOL2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfSYMBOL2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ArrayOfSYMBOL::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__SYMBOL(soap, &this->ns1__ArrayOfSYMBOL::SYMBOL);
	/* transient soap skipped */
}

void ns1__ArrayOfSYMBOL::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__SYMBOL(soap, &this->ns1__ArrayOfSYMBOL::SYMBOL);
#endif
}

int ns1__ArrayOfSYMBOL::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfSYMBOL(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfSYMBOL(struct soap *soap, const char *tag, int id, const ns1__ArrayOfSYMBOL *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns_ns1__ArrayOfSYMBOL), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__SYMBOL(soap, "ns1:SYMBOL", -1, &a->ns1__ArrayOfSYMBOL::SYMBOL, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfSYMBOL::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfSYMBOL(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfSYMBOL * SOAP_FMAC4 soap_in_ns1__ArrayOfSYMBOL(struct soap *soap, const char *tag, ns1__ArrayOfSYMBOL *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfSYMBOL *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns_ns1__ArrayOfSYMBOL, sizeof(ns1__ArrayOfSYMBOL), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__SYMBOL(soap, "ns1:SYMBOL", &a->ns1__ArrayOfSYMBOL::SYMBOL, "ns1:SYMBOL"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfSYMBOL *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns_ns1__ArrayOfSYMBOL, SOAP_TYPE_ns_ns1__ArrayOfSYMBOL, sizeof(ns1__ArrayOfSYMBOL), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ArrayOfSYMBOL * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfSYMBOL(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfSYMBOL(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ArrayOfSYMBOL *p;
	size_t k = sizeof(ns1__ArrayOfSYMBOL);
	if (n < 0)
	{	p = SOAP_NEW(ns1__ArrayOfSYMBOL);
		if (p)
			((ns1__ArrayOfSYMBOL*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__ArrayOfSYMBOL, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__ArrayOfSYMBOL*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ArrayOfSYMBOL location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns_ns1__ArrayOfSYMBOL, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__ArrayOfSYMBOL::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfSYMBOL", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfSYMBOL::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfSYMBOL(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfSYMBOL * SOAP_FMAC4 soap_get_ns1__ArrayOfSYMBOL(struct soap *soap, ns1__ArrayOfSYMBOL *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfSYMBOL(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__SYMBOL::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__SYMBOL::Code = NULL;
	this->ns1__SYMBOL::Name = NULL;
	this->ns1__SYMBOL::LongName = NULL;
	soap_default_dateTime(soap, &this->ns1__SYMBOL::DateTime);
	/* transient soap skipped */
}

void ns1__SYMBOL::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns1__SYMBOL::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SYMBOL(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SYMBOL(struct soap *soap, const char *tag, int id, const ns1__SYMBOL *a, const char *type)
{
	if (((ns1__SYMBOL*)a)->Code)
		soap_set_attr(soap, "Code", ((ns1__SYMBOL*)a)->Code->c_str(), 1);
	if (((ns1__SYMBOL*)a)->Name)
		soap_set_attr(soap, "Name", ((ns1__SYMBOL*)a)->Name->c_str(), 1);
	if (((ns1__SYMBOL*)a)->LongName)
		soap_set_attr(soap, "LongName", ((ns1__SYMBOL*)a)->LongName->c_str(), 1);
	soap_set_attr(soap, "DateTime", soap_dateTime2s(soap, ((ns1__SYMBOL*)a)->DateTime), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns_ns1__SYMBOL), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__SYMBOL::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__SYMBOL(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SYMBOL * SOAP_FMAC4 soap_in_ns1__SYMBOL(struct soap *soap, const char *tag, ns1__SYMBOL *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SYMBOL *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns_ns1__SYMBOL, sizeof(ns1__SYMBOL), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	{	const char *t = soap_attr_value(soap, "Code", 0);
		if (t)
		{
			if (!(((ns1__SYMBOL*)a)->Code = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__SYMBOL*)a)->Code, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Name", 0);
		if (t)
		{
			if (!(((ns1__SYMBOL*)a)->Name = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__SYMBOL*)a)->Name, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "LongName", 0);
		if (t)
		{
			if (!(((ns1__SYMBOL*)a)->LongName = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__SYMBOL*)a)->LongName, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2dateTime(soap, soap_attr_value(soap, "DateTime", 1), &((ns1__SYMBOL*)a)->DateTime))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__SYMBOL *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns_ns1__SYMBOL, SOAP_TYPE_ns_ns1__SYMBOL, sizeof(ns1__SYMBOL), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__SYMBOL * SOAP_FMAC2 soap_instantiate_ns1__SYMBOL(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SYMBOL(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__SYMBOL *p;
	size_t k = sizeof(ns1__SYMBOL);
	if (n < 0)
	{	p = SOAP_NEW(ns1__SYMBOL);
		if (p)
			((ns1__SYMBOL*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__SYMBOL, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__SYMBOL*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__SYMBOL location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns_ns1__SYMBOL, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__SYMBOL::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:SYMBOL", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SYMBOL::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SYMBOL(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SYMBOL * SOAP_FMAC4 soap_get_ns1__SYMBOL(struct soap *soap, ns1__SYMBOL *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SYMBOL(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ArrayOfEXCHANGE::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__EXCHANGE(soap, &this->ns1__ArrayOfEXCHANGE::EXCHANGE);
	/* transient soap skipped */
}

void ns1__ArrayOfEXCHANGE::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__EXCHANGE(soap, &this->ns1__ArrayOfEXCHANGE::EXCHANGE);
#endif
}

int ns1__ArrayOfEXCHANGE::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfEXCHANGE(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfEXCHANGE(struct soap *soap, const char *tag, int id, const ns1__ArrayOfEXCHANGE *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns_ns1__ArrayOfEXCHANGE), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__EXCHANGE(soap, "ns1:EXCHANGE", -1, &a->ns1__ArrayOfEXCHANGE::EXCHANGE, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfEXCHANGE::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfEXCHANGE(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfEXCHANGE * SOAP_FMAC4 soap_in_ns1__ArrayOfEXCHANGE(struct soap *soap, const char *tag, ns1__ArrayOfEXCHANGE *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfEXCHANGE *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns_ns1__ArrayOfEXCHANGE, sizeof(ns1__ArrayOfEXCHANGE), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__EXCHANGE(soap, "ns1:EXCHANGE", &a->ns1__ArrayOfEXCHANGE::EXCHANGE, "ns1:EXCHANGE"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfEXCHANGE *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns_ns1__ArrayOfEXCHANGE, SOAP_TYPE_ns_ns1__ArrayOfEXCHANGE, sizeof(ns1__ArrayOfEXCHANGE), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ArrayOfEXCHANGE * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfEXCHANGE(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfEXCHANGE(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ArrayOfEXCHANGE *p;
	size_t k = sizeof(ns1__ArrayOfEXCHANGE);
	if (n < 0)
	{	p = SOAP_NEW(ns1__ArrayOfEXCHANGE);
		if (p)
			((ns1__ArrayOfEXCHANGE*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__ArrayOfEXCHANGE, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__ArrayOfEXCHANGE*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ArrayOfEXCHANGE location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns_ns1__ArrayOfEXCHANGE, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__ArrayOfEXCHANGE::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfEXCHANGE", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfEXCHANGE::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfEXCHANGE(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfEXCHANGE * SOAP_FMAC4 soap_get_ns1__ArrayOfEXCHANGE(struct soap *soap, ns1__ArrayOfEXCHANGE *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfEXCHANGE(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__EXCHANGE::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__EXCHANGE::Code = NULL;
	this->ns1__EXCHANGE::Name = NULL;
	soap_default_dateTime(soap, &this->ns1__EXCHANGE::LastTradeDateTime);
	this->ns1__EXCHANGE::Country = NULL;
	this->ns1__EXCHANGE::Currency = NULL;
	soap_default_int(soap, &this->ns1__EXCHANGE::Advances);
	soap_default_int(soap, &this->ns1__EXCHANGE::Declines);
	this->ns1__EXCHANGE::Suffix = NULL;
	this->ns1__EXCHANGE::TimeZone = NULL;
	soap_default_bool(soap, &this->ns1__EXCHANGE::IsIntraday);
	soap_default_dateTime(soap, &this->ns1__EXCHANGE::IntradayStartDate);
	soap_default_bool(soap, &this->ns1__EXCHANGE::HasIntradayProduct);
	/* transient soap skipped */
}

void ns1__EXCHANGE::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns1__EXCHANGE::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__EXCHANGE(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__EXCHANGE(struct soap *soap, const char *tag, int id, const ns1__EXCHANGE *a, const char *type)
{
	if (((ns1__EXCHANGE*)a)->Code)
		soap_set_attr(soap, "Code", ((ns1__EXCHANGE*)a)->Code->c_str(), 1);
	if (((ns1__EXCHANGE*)a)->Name)
		soap_set_attr(soap, "Name", ((ns1__EXCHANGE*)a)->Name->c_str(), 1);
	soap_set_attr(soap, "LastTradeDateTime", soap_dateTime2s(soap, ((ns1__EXCHANGE*)a)->LastTradeDateTime), 1);
	if (((ns1__EXCHANGE*)a)->Country)
		soap_set_attr(soap, "Country", ((ns1__EXCHANGE*)a)->Country->c_str(), 1);
	if (((ns1__EXCHANGE*)a)->Currency)
		soap_set_attr(soap, "Currency", ((ns1__EXCHANGE*)a)->Currency->c_str(), 1);
	soap_set_attr(soap, "Advances", soap_int2s(soap, ((ns1__EXCHANGE*)a)->Advances), 1);
	soap_set_attr(soap, "Declines", soap_int2s(soap, ((ns1__EXCHANGE*)a)->Declines), 1);
	if (((ns1__EXCHANGE*)a)->Suffix)
		soap_set_attr(soap, "Suffix", ((ns1__EXCHANGE*)a)->Suffix->c_str(), 1);
	if (((ns1__EXCHANGE*)a)->TimeZone)
		soap_set_attr(soap, "TimeZone", ((ns1__EXCHANGE*)a)->TimeZone->c_str(), 1);
	soap_set_attr(soap, "IsIntraday", soap_bool2s(soap, ((ns1__EXCHANGE*)a)->IsIntraday), 1);
	soap_set_attr(soap, "IntradayStartDate", soap_dateTime2s(soap, ((ns1__EXCHANGE*)a)->IntradayStartDate), 1);
	soap_set_attr(soap, "HasIntradayProduct", soap_bool2s(soap, ((ns1__EXCHANGE*)a)->HasIntradayProduct), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns_ns1__EXCHANGE), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__EXCHANGE::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__EXCHANGE(soap, tag, this, type);
}

SOAP_FMAC3 ns1__EXCHANGE * SOAP_FMAC4 soap_in_ns1__EXCHANGE(struct soap *soap, const char *tag, ns1__EXCHANGE *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__EXCHANGE *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns_ns1__EXCHANGE, sizeof(ns1__EXCHANGE), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	{	const char *t = soap_attr_value(soap, "Code", 0);
		if (t)
		{
			if (!(((ns1__EXCHANGE*)a)->Code = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__EXCHANGE*)a)->Code, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Name", 0);
		if (t)
		{
			if (!(((ns1__EXCHANGE*)a)->Name = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__EXCHANGE*)a)->Name, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2dateTime(soap, soap_attr_value(soap, "LastTradeDateTime", 1), &((ns1__EXCHANGE*)a)->LastTradeDateTime))
		return NULL;
	{	const char *t = soap_attr_value(soap, "Country", 0);
		if (t)
		{
			if (!(((ns1__EXCHANGE*)a)->Country = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__EXCHANGE*)a)->Country, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Currency", 0);
		if (t)
		{
			if (!(((ns1__EXCHANGE*)a)->Currency = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__EXCHANGE*)a)->Currency, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2int(soap, soap_attr_value(soap, "Advances", 1), &((ns1__EXCHANGE*)a)->Advances))
		return NULL;
	if (soap_s2int(soap, soap_attr_value(soap, "Declines", 1), &((ns1__EXCHANGE*)a)->Declines))
		return NULL;
	{	const char *t = soap_attr_value(soap, "Suffix", 0);
		if (t)
		{
			if (!(((ns1__EXCHANGE*)a)->Suffix = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__EXCHANGE*)a)->Suffix, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "TimeZone", 0);
		if (t)
		{
			if (!(((ns1__EXCHANGE*)a)->TimeZone = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__EXCHANGE*)a)->TimeZone, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2bool(soap, soap_attr_value(soap, "IsIntraday", 1), &((ns1__EXCHANGE*)a)->IsIntraday))
		return NULL;
	if (soap_s2dateTime(soap, soap_attr_value(soap, "IntradayStartDate", 1), &((ns1__EXCHANGE*)a)->IntradayStartDate))
		return NULL;
	if (soap_s2bool(soap, soap_attr_value(soap, "HasIntradayProduct", 1), &((ns1__EXCHANGE*)a)->HasIntradayProduct))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__EXCHANGE *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns_ns1__EXCHANGE, SOAP_TYPE_ns_ns1__EXCHANGE, sizeof(ns1__EXCHANGE), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__EXCHANGE * SOAP_FMAC2 soap_instantiate_ns1__EXCHANGE(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__EXCHANGE(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__EXCHANGE *p;
	size_t k = sizeof(ns1__EXCHANGE);
	if (n < 0)
	{	p = SOAP_NEW(ns1__EXCHANGE);
		if (p)
			((ns1__EXCHANGE*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__EXCHANGE, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__EXCHANGE*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__EXCHANGE location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns_ns1__EXCHANGE, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__EXCHANGE::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:EXCHANGE", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__EXCHANGE::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__EXCHANGE(soap, this, tag, type);
}

SOAP_FMAC3 ns1__EXCHANGE * SOAP_FMAC4 soap_get_ns1__EXCHANGE(struct soap *soap, ns1__EXCHANGE *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__EXCHANGE(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__RESPONSE::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__RESPONSE::EXCHANGE = NULL;
	this->ns1__RESPONSE::EXCHANGES = NULL;
	this->ns1__RESPONSE::SYMBOL = NULL;
	this->ns1__RESPONSE::SYMBOLS = NULL;
	this->ns1__RESPONSE::SYMBOLS2 = NULL;
	this->ns1__RESPONSE::QUOTE = NULL;
	this->ns1__RESPONSE::QUOTES = NULL;
	this->ns1__RESPONSE::QUOTES2 = NULL;
	this->ns1__RESPONSE::SPLITS = NULL;
	this->ns1__RESPONSE::COUNTRIES = NULL;
	this->ns1__RESPONSE::FUNDAMENTALS = NULL;
	this->ns1__RESPONSE::TECHNICALS = NULL;
	this->ns1__RESPONSE::SYMBOLCHANGES = NULL;
	this->ns1__RESPONSE::NEWSLIST = NULL;
	this->ns1__RESPONSE::CHART = NULL;
	this->ns1__RESPONSE::MEMBERSHIP = NULL;
	this->ns1__RESPONSE::VERSION = NULL;
	this->ns1__RESPONSE::MONTHS = NULL;
	this->ns1__RESPONSE::DATAFORMATS = NULL;
	this->ns1__RESPONSE::Source = NULL;
	this->ns1__RESPONSE::Message = NULL;
	soap_default_dateTime(soap, &this->ns1__RESPONSE::Date);
	/* transient soap skipped */
}

void ns1__RESPONSE::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__EXCHANGE(soap, &this->ns1__RESPONSE::EXCHANGE);
	soap_serialize_PointerTons1__ArrayOfEXCHANGE(soap, &this->ns1__RESPONSE::EXCHANGES);
	soap_serialize_PointerTons1__SYMBOL(soap, &this->ns1__RESPONSE::SYMBOL);
	soap_serialize_PointerTons1__ArrayOfSYMBOL(soap, &this->ns1__RESPONSE::SYMBOLS);
	soap_serialize_PointerTons1__ArrayOfSYMBOL2(soap, &this->ns1__RESPONSE::SYMBOLS2);
	soap_serialize_PointerTons1__QUOTE(soap, &this->ns1__RESPONSE::QUOTE);
	soap_serialize_PointerTons1__ArrayOfQUOTE(soap, &this->ns1__RESPONSE::QUOTES);
	soap_serialize_PointerTons1__ArrayOfQUOTE2(soap, &this->ns1__RESPONSE::QUOTES2);
	soap_serialize_PointerTons1__ArrayOfSPLIT(soap, &this->ns1__RESPONSE::SPLITS);
	soap_serialize_PointerTons1__ArrayOfCountryBase(soap, &this->ns1__RESPONSE::COUNTRIES);
	soap_serialize_PointerTons1__ArrayOfFUNDAMENTAL(soap, &this->ns1__RESPONSE::FUNDAMENTALS);
	soap_serialize_PointerTons1__ArrayOfTECHNICAL(soap, &this->ns1__RESPONSE::TECHNICALS);
	soap_serialize_PointerTons1__ArrayOfSYMBOLCHANGE(soap, &this->ns1__RESPONSE::SYMBOLCHANGES);
	soap_serialize_PointerTons1__ArrayOfNEWS(soap, &this->ns1__RESPONSE::NEWSLIST);
	soap_serialize_PointerTostd__string(soap, &this->ns1__RESPONSE::CHART);
	soap_serialize_PointerTostd__string(soap, &this->ns1__RESPONSE::MEMBERSHIP);
	soap_serialize_PointerTostd__string(soap, &this->ns1__RESPONSE::VERSION);
	soap_serialize_PointerTostd__string(soap, &this->ns1__RESPONSE::MONTHS);
	soap_serialize_PointerTons1__ArrayOfDATAFORMAT(soap, &this->ns1__RESPONSE::DATAFORMATS);
#endif
}

int ns1__RESPONSE::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__RESPONSE(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RESPONSE(struct soap *soap, const char *tag, int id, const ns1__RESPONSE *a, const char *type)
{
	if (((ns1__RESPONSE*)a)->Source)
		soap_set_attr(soap, "Source", ((ns1__RESPONSE*)a)->Source->c_str(), 1);
	if (((ns1__RESPONSE*)a)->Message)
		soap_set_attr(soap, "Message", ((ns1__RESPONSE*)a)->Message->c_str(), 1);
	soap_set_attr(soap, "Date", soap_dateTime2s(soap, ((ns1__RESPONSE*)a)->Date), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns_ns1__RESPONSE), type))
		return soap->error;
	if (a->EXCHANGE)
		soap_element_result(soap, "ns1:EXCHANGE");
	if (soap_out_PointerTons1__EXCHANGE(soap, "ns1:EXCHANGE", -1, &a->ns1__RESPONSE::EXCHANGE, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfEXCHANGE(soap, "ns1:EXCHANGES", -1, &a->ns1__RESPONSE::EXCHANGES, ""))
		return soap->error;
	if (soap_out_PointerTons1__SYMBOL(soap, "ns1:SYMBOL", -1, &a->ns1__RESPONSE::SYMBOL, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfSYMBOL(soap, "ns1:SYMBOLS", -1, &a->ns1__RESPONSE::SYMBOLS, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfSYMBOL2(soap, "ns1:SYMBOLS2", -1, &a->ns1__RESPONSE::SYMBOLS2, ""))
		return soap->error;
	if (soap_out_PointerTons1__QUOTE(soap, "ns1:QUOTE", -1, &a->ns1__RESPONSE::QUOTE, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfQUOTE(soap, "ns1:QUOTES", -1, &a->ns1__RESPONSE::QUOTES, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfQUOTE2(soap, "ns1:QUOTES2", -1, &a->ns1__RESPONSE::QUOTES2, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfSPLIT(soap, "ns1:SPLITS", -1, &a->ns1__RESPONSE::SPLITS, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfCountryBase(soap, "ns1:COUNTRIES", -1, &a->ns1__RESPONSE::COUNTRIES, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfFUNDAMENTAL(soap, "ns1:FUNDAMENTALS", -1, &a->ns1__RESPONSE::FUNDAMENTALS, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfTECHNICAL(soap, "ns1:TECHNICALS", -1, &a->ns1__RESPONSE::TECHNICALS, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfSYMBOLCHANGE(soap, "ns1:SYMBOLCHANGES", -1, &a->ns1__RESPONSE::SYMBOLCHANGES, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfNEWS(soap, "ns1:NEWSLIST", -1, &a->ns1__RESPONSE::NEWSLIST, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:CHART", -1, &a->ns1__RESPONSE::CHART, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:MEMBERSHIP", -1, &a->ns1__RESPONSE::MEMBERSHIP, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:VERSION", -1, &a->ns1__RESPONSE::VERSION, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:MONTHS", -1, &a->ns1__RESPONSE::MONTHS, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfDATAFORMAT(soap, "ns1:DATAFORMATS", -1, &a->ns1__RESPONSE::DATAFORMATS, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__RESPONSE::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__RESPONSE(soap, tag, this, type);
}

SOAP_FMAC3 ns1__RESPONSE * SOAP_FMAC4 soap_in_ns1__RESPONSE(struct soap *soap, const char *tag, ns1__RESPONSE *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__RESPONSE *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns_ns1__RESPONSE, sizeof(ns1__RESPONSE), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	{	const char *t = soap_attr_value(soap, "Source", 0);
		if (t)
		{
			if (!(((ns1__RESPONSE*)a)->Source = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__RESPONSE*)a)->Source, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Message", 0);
		if (t)
		{
			if (!(((ns1__RESPONSE*)a)->Message = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__RESPONSE*)a)->Message, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2dateTime(soap, soap_attr_value(soap, "Date", 1), &((ns1__RESPONSE*)a)->Date))
		return NULL;
	size_t soap_flag_EXCHANGE1 = 1;
	size_t soap_flag_EXCHANGES1 = 1;
	size_t soap_flag_SYMBOL1 = 1;
	size_t soap_flag_SYMBOLS1 = 1;
	size_t soap_flag_SYMBOLS21 = 1;
	size_t soap_flag_QUOTE1 = 1;
	size_t soap_flag_QUOTES1 = 1;
	size_t soap_flag_QUOTES21 = 1;
	size_t soap_flag_SPLITS1 = 1;
	size_t soap_flag_COUNTRIES1 = 1;
	size_t soap_flag_FUNDAMENTALS1 = 1;
	size_t soap_flag_TECHNICALS1 = 1;
	size_t soap_flag_SYMBOLCHANGES1 = 1;
	size_t soap_flag_NEWSLIST1 = 1;
	size_t soap_flag_CHART1 = 1;
	size_t soap_flag_MEMBERSHIP1 = 1;
	size_t soap_flag_VERSION1 = 1;
	size_t soap_flag_MONTHS1 = 1;
	size_t soap_flag_DATAFORMATS1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EXCHANGE1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__EXCHANGE(soap, "ns1:EXCHANGE", &a->ns1__RESPONSE::EXCHANGE, "ns1:EXCHANGE"))
				{	soap_flag_EXCHANGE1--;
					continue;
				}
			if (soap_flag_EXCHANGES1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfEXCHANGE(soap, "ns1:EXCHANGES", &a->ns1__RESPONSE::EXCHANGES, "ns1:ArrayOfEXCHANGE"))
				{	soap_flag_EXCHANGES1--;
					continue;
				}
			if (soap_flag_SYMBOL1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SYMBOL(soap, "ns1:SYMBOL", &a->ns1__RESPONSE::SYMBOL, "ns1:SYMBOL"))
				{	soap_flag_SYMBOL1--;
					continue;
				}
			if (soap_flag_SYMBOLS1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfSYMBOL(soap, "ns1:SYMBOLS", &a->ns1__RESPONSE::SYMBOLS, "ns1:ArrayOfSYMBOL"))
				{	soap_flag_SYMBOLS1--;
					continue;
				}
			if (soap_flag_SYMBOLS21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfSYMBOL2(soap, "ns1:SYMBOLS2", &a->ns1__RESPONSE::SYMBOLS2, "ns1:ArrayOfSYMBOL2"))
				{	soap_flag_SYMBOLS21--;
					continue;
				}
			if (soap_flag_QUOTE1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__QUOTE(soap, "ns1:QUOTE", &a->ns1__RESPONSE::QUOTE, "ns1:QUOTE"))
				{	soap_flag_QUOTE1--;
					continue;
				}
			if (soap_flag_QUOTES1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfQUOTE(soap, "ns1:QUOTES", &a->ns1__RESPONSE::QUOTES, "ns1:ArrayOfQUOTE"))
				{	soap_flag_QUOTES1--;
					continue;
				}
			if (soap_flag_QUOTES21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfQUOTE2(soap, "ns1:QUOTES2", &a->ns1__RESPONSE::QUOTES2, "ns1:ArrayOfQUOTE2"))
				{	soap_flag_QUOTES21--;
					continue;
				}
			if (soap_flag_SPLITS1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfSPLIT(soap, "ns1:SPLITS", &a->ns1__RESPONSE::SPLITS, "ns1:ArrayOfSPLIT"))
				{	soap_flag_SPLITS1--;
					continue;
				}
			if (soap_flag_COUNTRIES1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfCountryBase(soap, "ns1:COUNTRIES", &a->ns1__RESPONSE::COUNTRIES, "ns1:ArrayOfCountryBase"))
				{	soap_flag_COUNTRIES1--;
					continue;
				}
			if (soap_flag_FUNDAMENTALS1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfFUNDAMENTAL(soap, "ns1:FUNDAMENTALS", &a->ns1__RESPONSE::FUNDAMENTALS, "ns1:ArrayOfFUNDAMENTAL"))
				{	soap_flag_FUNDAMENTALS1--;
					continue;
				}
			if (soap_flag_TECHNICALS1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfTECHNICAL(soap, "ns1:TECHNICALS", &a->ns1__RESPONSE::TECHNICALS, "ns1:ArrayOfTECHNICAL"))
				{	soap_flag_TECHNICALS1--;
					continue;
				}
			if (soap_flag_SYMBOLCHANGES1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfSYMBOLCHANGE(soap, "ns1:SYMBOLCHANGES", &a->ns1__RESPONSE::SYMBOLCHANGES, "ns1:ArrayOfSYMBOLCHANGE"))
				{	soap_flag_SYMBOLCHANGES1--;
					continue;
				}
			if (soap_flag_NEWSLIST1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfNEWS(soap, "ns1:NEWSLIST", &a->ns1__RESPONSE::NEWSLIST, "ns1:ArrayOfNEWS"))
				{	soap_flag_NEWSLIST1--;
					continue;
				}
			if (soap_flag_CHART1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:CHART", &a->ns1__RESPONSE::CHART, "xsd:string"))
				{	soap_flag_CHART1--;
					continue;
				}
			if (soap_flag_MEMBERSHIP1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:MEMBERSHIP", &a->ns1__RESPONSE::MEMBERSHIP, "xsd:string"))
				{	soap_flag_MEMBERSHIP1--;
					continue;
				}
			if (soap_flag_VERSION1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:VERSION", &a->ns1__RESPONSE::VERSION, "xsd:string"))
				{	soap_flag_VERSION1--;
					continue;
				}
			if (soap_flag_MONTHS1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:MONTHS", &a->ns1__RESPONSE::MONTHS, "xsd:string"))
				{	soap_flag_MONTHS1--;
					continue;
				}
			if (soap_flag_DATAFORMATS1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfDATAFORMAT(soap, "ns1:DATAFORMATS", &a->ns1__RESPONSE::DATAFORMATS, "ns1:ArrayOfDATAFORMAT"))
				{	soap_flag_DATAFORMATS1--;
					continue;
				}
			soap_check_result(soap, "ns1:EXCHANGE");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__RESPONSE *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns_ns1__RESPONSE, SOAP_TYPE_ns_ns1__RESPONSE, sizeof(ns1__RESPONSE), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__RESPONSE * SOAP_FMAC2 soap_instantiate_ns1__RESPONSE(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__RESPONSE(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__RESPONSE *p;
	size_t k = sizeof(ns1__RESPONSE);
	if (n < 0)
	{	p = SOAP_NEW(ns1__RESPONSE);
		if (p)
			((ns1__RESPONSE*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__RESPONSE, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__RESPONSE*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__RESPONSE location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns_ns1__RESPONSE, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__RESPONSE::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:RESPONSE", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__RESPONSE::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__RESPONSE(soap, this, tag, type);
}

SOAP_FMAC3 ns1__RESPONSE * SOAP_FMAC4 soap_get_ns1__RESPONSE(struct soap *soap, ns1__RESPONSE *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RESPONSE(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__LOGINRESPONSE::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__LOGINRESPONSE::Message = NULL;
	this->ns1__LOGINRESPONSE::Token = NULL;
	this->ns1__LOGINRESPONSE::DataFormat = NULL;
	soap_default_bool(soap, &this->ns1__LOGINRESPONSE::Header);
	soap_default_bool(soap, &this->ns1__LOGINRESPONSE::Suffix);
	/* transient soap skipped */
}

void ns1__LOGINRESPONSE::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns1__LOGINRESPONSE::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__LOGINRESPONSE(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__LOGINRESPONSE(struct soap *soap, const char *tag, int id, const ns1__LOGINRESPONSE *a, const char *type)
{
	if (((ns1__LOGINRESPONSE*)a)->Message)
		soap_set_attr(soap, "Message", ((ns1__LOGINRESPONSE*)a)->Message->c_str(), 1);
	if (((ns1__LOGINRESPONSE*)a)->Token)
		soap_set_attr(soap, "Token", ((ns1__LOGINRESPONSE*)a)->Token->c_str(), 1);
	if (((ns1__LOGINRESPONSE*)a)->DataFormat)
		soap_set_attr(soap, "DataFormat", ((ns1__LOGINRESPONSE*)a)->DataFormat->c_str(), 1);
	soap_set_attr(soap, "Header", soap_bool2s(soap, ((ns1__LOGINRESPONSE*)a)->Header), 1);
	soap_set_attr(soap, "Suffix", soap_bool2s(soap, ((ns1__LOGINRESPONSE*)a)->Suffix), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns_ns1__LOGINRESPONSE), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__LOGINRESPONSE::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__LOGINRESPONSE(soap, tag, this, type);
}

SOAP_FMAC3 ns1__LOGINRESPONSE * SOAP_FMAC4 soap_in_ns1__LOGINRESPONSE(struct soap *soap, const char *tag, ns1__LOGINRESPONSE *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__LOGINRESPONSE *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns_ns1__LOGINRESPONSE, sizeof(ns1__LOGINRESPONSE), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	{	const char *t = soap_attr_value(soap, "Message", 0);
		if (t)
		{
			if (!(((ns1__LOGINRESPONSE*)a)->Message = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__LOGINRESPONSE*)a)->Message, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Token", 0);
		if (t)
		{
			if (!(((ns1__LOGINRESPONSE*)a)->Token = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__LOGINRESPONSE*)a)->Token, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "DataFormat", 0);
		if (t)
		{
			if (!(((ns1__LOGINRESPONSE*)a)->DataFormat = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns1__LOGINRESPONSE*)a)->DataFormat, 0, -1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2bool(soap, soap_attr_value(soap, "Header", 1), &((ns1__LOGINRESPONSE*)a)->Header))
		return NULL;
	if (soap_s2bool(soap, soap_attr_value(soap, "Suffix", 1), &((ns1__LOGINRESPONSE*)a)->Suffix))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__LOGINRESPONSE *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns_ns1__LOGINRESPONSE, SOAP_TYPE_ns_ns1__LOGINRESPONSE, sizeof(ns1__LOGINRESPONSE), 0, ns_finsert, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__LOGINRESPONSE * SOAP_FMAC2 soap_instantiate_ns1__LOGINRESPONSE(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__LOGINRESPONSE(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__LOGINRESPONSE *p;
	size_t k = sizeof(ns1__LOGINRESPONSE);
	if (n < 0)
	{	p = SOAP_NEW(ns1__LOGINRESPONSE);
		if (p)
			((ns1__LOGINRESPONSE*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__LOGINRESPONSE, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__LOGINRESPONSE*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__LOGINRESPONSE location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns_ns1__LOGINRESPONSE, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__LOGINRESPONSE::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:LOGINRESPONSE", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__LOGINRESPONSE::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__LOGINRESPONSE(soap, this, tag, type);
}

SOAP_FMAC3 ns1__LOGINRESPONSE * SOAP_FMAC4 soap_get_ns1__LOGINRESPONSE(struct soap *soap, ns1__LOGINRESPONSE *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__LOGINRESPONSE(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_ENV__Fault::SOAP_ENV__Fault()
{
	soap_default_SOAP_ENV__Fault(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->faultcode);
	soap_serialize_string(soap, (char*const*)&a->faultstring);
	soap_serialize_string(soap, (char*const*)&a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Node);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, (char*const*)&a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, (char*const*)&a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, (char*const*)&a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, (char*const*)&a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", (char**)&a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", (char**)&a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", (char**)&a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", (char**)&a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", (char**)&a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns_SOAP_ENV__Fault, SOAP_TYPE_ns_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, ns_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Fault *p;
	size_t k = sizeof(struct SOAP_ENV__Fault);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Fault);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Fault, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Fault location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns_SOAP_ENV__Fault, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_ENV__Reason::SOAP_ENV__Reason()
{
	soap_default_SOAP_ENV__Reason(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, (char*const*)&a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", (char**)&a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns_SOAP_ENV__Reason, SOAP_TYPE_ns_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, ns_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Reason *p;
	size_t k = sizeof(struct SOAP_ENV__Reason);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Reason);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Reason, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Reason location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns_SOAP_ENV__Reason, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_ENV__Detail::SOAP_ENV__Detail()
{
	soap_default_SOAP_ENV__Detail(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns_SOAP_ENV__Detail, SOAP_TYPE_ns_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, ns_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Detail *p;
	size_t k = sizeof(struct SOAP_ENV__Detail);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Detail);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Detail, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Detail location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns_SOAP_ENV__Detail, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_ENV__Code::SOAP_ENV__Code()
{
	soap_default_SOAP_ENV__Code(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", (char**)&a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns_SOAP_ENV__Code, SOAP_TYPE_ns_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, ns_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Code *p;
	size_t k = sizeof(struct SOAP_ENV__Code);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Code);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Code, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Code location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns_SOAP_ENV__Code, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_ENV__Header::SOAP_ENV__Header()
{
	soap_default_SOAP_ENV__Header(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns_SOAP_ENV__Header, SOAP_TYPE_ns_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, ns_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Header *p;
	size_t k = sizeof(struct SOAP_ENV__Header);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Header);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Header, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Header location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns_SOAP_ENV__Header, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

__ns1__ValidateAccess___::__ns1__ValidateAccess___()
{
	soap_default___ns1__ValidateAccess___(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ValidateAccess___(struct soap *soap, struct __ns1__ValidateAccess___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->Token);
	soap_default_std__string(soap, &a->Exchange);
	soap_default_std__string(soap, &a->QuoteDate);
	soap_default_std__string(soap, &a->Period);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ValidateAccess___(struct soap *soap, const struct __ns1__ValidateAccess___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Token, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Token);
	soap_embedded(soap, &a->Exchange, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Exchange);
	soap_embedded(soap, &a->QuoteDate, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->QuoteDate);
	soap_embedded(soap, &a->Period, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Period);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ValidateAccess___(struct soap *soap, const char *tag, int id, const struct __ns1__ValidateAccess___ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_std__string(soap, "ns1:Token", -1, &a->Token, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Exchange", -1, &a->Exchange, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:QuoteDate", -1, &a->QuoteDate, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Period", -1, &a->Period, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ValidateAccess___ * SOAP_FMAC4 soap_in___ns1__ValidateAccess___(struct soap *soap, const char *tag, struct __ns1__ValidateAccess___ *a, const char *type)
{
	size_t soap_flag_Token = 1;
	size_t soap_flag_Exchange = 1;
	size_t soap_flag_QuoteDate = 1;
	size_t soap_flag_Period = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ValidateAccess___ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__ValidateAccess___, sizeof(struct __ns1__ValidateAccess___), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	soap_default___ns1__ValidateAccess___(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Token", &a->Token, "xsd:string"))
				{	soap_flag_Token--;
					continue;
				}
			if (soap_flag_Exchange && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Exchange", &a->Exchange, "xsd:string"))
				{	soap_flag_Exchange--;
					continue;
				}
			if (soap_flag_QuoteDate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:QuoteDate", &a->QuoteDate, "xsd:string"))
				{	soap_flag_QuoteDate--;
					continue;
				}
			if (soap_flag_Period && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Period", &a->Period, "xsd:string"))
				{	soap_flag_Period--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token > 0 || soap_flag_Exchange > 0 || soap_flag_QuoteDate > 0 || soap_flag_Period > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ValidateAccess___ * SOAP_FMAC2 soap_instantiate___ns1__ValidateAccess___(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ValidateAccess___(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ValidateAccess___ *p;
	size_t k = sizeof(struct __ns1__ValidateAccess___);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__ValidateAccess___);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__ValidateAccess___, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ValidateAccess___ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__ValidateAccess___, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ValidateAccess___(struct soap *soap, const struct __ns1__ValidateAccess___ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ValidateAccess___(soap, tag?tag:"-ns1:ValidateAccess", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ValidateAccess___ * SOAP_FMAC4 soap_get___ns1__ValidateAccess___(struct soap *soap, struct __ns1__ValidateAccess___ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ValidateAccess___(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__UpdateDataFormat___::__ns1__UpdateDataFormat___()
{
	soap_default___ns1__UpdateDataFormat___(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__UpdateDataFormat___(struct soap *soap, struct __ns1__UpdateDataFormat___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->Token);
	soap_default_std__string(soap, &a->DataFormat);
	soap_default_std__string(soap, &a->IncludeHeader);
	soap_default_std__string(soap, &a->IncludeSuffix);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__UpdateDataFormat___(struct soap *soap, const struct __ns1__UpdateDataFormat___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Token, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Token);
	soap_embedded(soap, &a->DataFormat, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->DataFormat);
	soap_embedded(soap, &a->IncludeHeader, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->IncludeHeader);
	soap_embedded(soap, &a->IncludeSuffix, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->IncludeSuffix);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__UpdateDataFormat___(struct soap *soap, const char *tag, int id, const struct __ns1__UpdateDataFormat___ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_std__string(soap, "ns1:Token", -1, &a->Token, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:DataFormat", -1, &a->DataFormat, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:IncludeHeader", -1, &a->IncludeHeader, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:IncludeSuffix", -1, &a->IncludeSuffix, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UpdateDataFormat___ * SOAP_FMAC4 soap_in___ns1__UpdateDataFormat___(struct soap *soap, const char *tag, struct __ns1__UpdateDataFormat___ *a, const char *type)
{
	size_t soap_flag_Token = 1;
	size_t soap_flag_DataFormat = 1;
	size_t soap_flag_IncludeHeader = 1;
	size_t soap_flag_IncludeSuffix = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__UpdateDataFormat___ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__UpdateDataFormat___, sizeof(struct __ns1__UpdateDataFormat___), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	soap_default___ns1__UpdateDataFormat___(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Token", &a->Token, "xsd:string"))
				{	soap_flag_Token--;
					continue;
				}
			if (soap_flag_DataFormat && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:DataFormat", &a->DataFormat, "xsd:string"))
				{	soap_flag_DataFormat--;
					continue;
				}
			if (soap_flag_IncludeHeader && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:IncludeHeader", &a->IncludeHeader, "xsd:string"))
				{	soap_flag_IncludeHeader--;
					continue;
				}
			if (soap_flag_IncludeSuffix && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:IncludeSuffix", &a->IncludeSuffix, "xsd:string"))
				{	soap_flag_IncludeSuffix--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token > 0 || soap_flag_DataFormat > 0 || soap_flag_IncludeHeader > 0 || soap_flag_IncludeSuffix > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__UpdateDataFormat___ * SOAP_FMAC2 soap_instantiate___ns1__UpdateDataFormat___(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__UpdateDataFormat___(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__UpdateDataFormat___ *p;
	size_t k = sizeof(struct __ns1__UpdateDataFormat___);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__UpdateDataFormat___);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__UpdateDataFormat___, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__UpdateDataFormat___ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__UpdateDataFormat___, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__UpdateDataFormat___(struct soap *soap, const struct __ns1__UpdateDataFormat___ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__UpdateDataFormat___(soap, tag?tag:"-ns1:UpdateDataFormat", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UpdateDataFormat___ * SOAP_FMAC4 soap_get___ns1__UpdateDataFormat___(struct soap *soap, struct __ns1__UpdateDataFormat___ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__UpdateDataFormat___(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__DataFormats___::__ns1__DataFormats___()
{
	soap_default___ns1__DataFormats___(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__DataFormats___(struct soap *soap, struct __ns1__DataFormats___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->Token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__DataFormats___(struct soap *soap, const struct __ns1__DataFormats___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Token, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Token);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__DataFormats___(struct soap *soap, const char *tag, int id, const struct __ns1__DataFormats___ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_std__string(soap, "ns1:Token", -1, &a->Token, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DataFormats___ * SOAP_FMAC4 soap_in___ns1__DataFormats___(struct soap *soap, const char *tag, struct __ns1__DataFormats___ *a, const char *type)
{
	size_t soap_flag_Token = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__DataFormats___ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__DataFormats___, sizeof(struct __ns1__DataFormats___), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	soap_default___ns1__DataFormats___(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Token", &a->Token, "xsd:string"))
				{	soap_flag_Token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__DataFormats___ * SOAP_FMAC2 soap_instantiate___ns1__DataFormats___(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__DataFormats___(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__DataFormats___ *p;
	size_t k = sizeof(struct __ns1__DataFormats___);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__DataFormats___);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__DataFormats___, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__DataFormats___ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__DataFormats___, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__DataFormats___(struct soap *soap, const struct __ns1__DataFormats___ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__DataFormats___(soap, tag?tag:"-ns1:DataFormats", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DataFormats___ * SOAP_FMAC4 soap_get___ns1__DataFormats___(struct soap *soap, struct __ns1__DataFormats___ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__DataFormats___(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__DataClientLatestVersion___::__ns1__DataClientLatestVersion___()
{
	soap_default___ns1__DataClientLatestVersion___(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__DataClientLatestVersion___(struct soap *soap, struct __ns1__DataClientLatestVersion___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->Token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__DataClientLatestVersion___(struct soap *soap, const struct __ns1__DataClientLatestVersion___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Token, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Token);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__DataClientLatestVersion___(struct soap *soap, const char *tag, int id, const struct __ns1__DataClientLatestVersion___ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_std__string(soap, "ns1:Token", -1, &a->Token, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DataClientLatestVersion___ * SOAP_FMAC4 soap_in___ns1__DataClientLatestVersion___(struct soap *soap, const char *tag, struct __ns1__DataClientLatestVersion___ *a, const char *type)
{
	size_t soap_flag_Token = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__DataClientLatestVersion___ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__DataClientLatestVersion___, sizeof(struct __ns1__DataClientLatestVersion___), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	soap_default___ns1__DataClientLatestVersion___(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Token", &a->Token, "xsd:string"))
				{	soap_flag_Token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__DataClientLatestVersion___ * SOAP_FMAC2 soap_instantiate___ns1__DataClientLatestVersion___(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__DataClientLatestVersion___(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__DataClientLatestVersion___ *p;
	size_t k = sizeof(struct __ns1__DataClientLatestVersion___);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__DataClientLatestVersion___);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__DataClientLatestVersion___, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__DataClientLatestVersion___ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__DataClientLatestVersion___, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__DataClientLatestVersion___(struct soap *soap, const struct __ns1__DataClientLatestVersion___ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__DataClientLatestVersion___(soap, tag?tag:"-ns1:DataClientLatestVersion", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DataClientLatestVersion___ * SOAP_FMAC4 soap_get___ns1__DataClientLatestVersion___(struct soap *soap, struct __ns1__DataClientLatestVersion___ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__DataClientLatestVersion___(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__SymbolChangesByExchange___::__ns1__SymbolChangesByExchange___()
{
	soap_default___ns1__SymbolChangesByExchange___(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SymbolChangesByExchange___(struct soap *soap, struct __ns1__SymbolChangesByExchange___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->Token);
	soap_default_std__string(soap, &a->Exchange);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SymbolChangesByExchange___(struct soap *soap, const struct __ns1__SymbolChangesByExchange___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Token, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Token);
	soap_embedded(soap, &a->Exchange, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Exchange);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SymbolChangesByExchange___(struct soap *soap, const char *tag, int id, const struct __ns1__SymbolChangesByExchange___ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_std__string(soap, "ns1:Token", -1, &a->Token, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Exchange", -1, &a->Exchange, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolChangesByExchange___ * SOAP_FMAC4 soap_in___ns1__SymbolChangesByExchange___(struct soap *soap, const char *tag, struct __ns1__SymbolChangesByExchange___ *a, const char *type)
{
	size_t soap_flag_Token = 1;
	size_t soap_flag_Exchange = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SymbolChangesByExchange___ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__SymbolChangesByExchange___, sizeof(struct __ns1__SymbolChangesByExchange___), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	soap_default___ns1__SymbolChangesByExchange___(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Token", &a->Token, "xsd:string"))
				{	soap_flag_Token--;
					continue;
				}
			if (soap_flag_Exchange && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Exchange", &a->Exchange, "xsd:string"))
				{	soap_flag_Exchange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token > 0 || soap_flag_Exchange > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SymbolChangesByExchange___ * SOAP_FMAC2 soap_instantiate___ns1__SymbolChangesByExchange___(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SymbolChangesByExchange___(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SymbolChangesByExchange___ *p;
	size_t k = sizeof(struct __ns1__SymbolChangesByExchange___);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SymbolChangesByExchange___);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SymbolChangesByExchange___, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SymbolChangesByExchange___ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__SymbolChangesByExchange___, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SymbolChangesByExchange___(struct soap *soap, const struct __ns1__SymbolChangesByExchange___ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SymbolChangesByExchange___(soap, tag?tag:"-ns1:SymbolChangesByExchange", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolChangesByExchange___ * SOAP_FMAC4 soap_get___ns1__SymbolChangesByExchange___(struct soap *soap, struct __ns1__SymbolChangesByExchange___ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SymbolChangesByExchange___(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__QuoteListByDatePeriod2___::__ns1__QuoteListByDatePeriod2___()
{
	soap_default___ns1__QuoteListByDatePeriod2___(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__QuoteListByDatePeriod2___(struct soap *soap, struct __ns1__QuoteListByDatePeriod2___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->Token);
	soap_default_std__string(soap, &a->Exchange);
	soap_default_std__string(soap, &a->QuoteDate);
	soap_default_std__string(soap, &a->Period);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__QuoteListByDatePeriod2___(struct soap *soap, const struct __ns1__QuoteListByDatePeriod2___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Token, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Token);
	soap_embedded(soap, &a->Exchange, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Exchange);
	soap_embedded(soap, &a->QuoteDate, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->QuoteDate);
	soap_embedded(soap, &a->Period, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Period);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__QuoteListByDatePeriod2___(struct soap *soap, const char *tag, int id, const struct __ns1__QuoteListByDatePeriod2___ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_std__string(soap, "ns1:Token", -1, &a->Token, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Exchange", -1, &a->Exchange, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:QuoteDate", -1, &a->QuoteDate, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Period", -1, &a->Period, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QuoteListByDatePeriod2___ * SOAP_FMAC4 soap_in___ns1__QuoteListByDatePeriod2___(struct soap *soap, const char *tag, struct __ns1__QuoteListByDatePeriod2___ *a, const char *type)
{
	size_t soap_flag_Token = 1;
	size_t soap_flag_Exchange = 1;
	size_t soap_flag_QuoteDate = 1;
	size_t soap_flag_Period = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__QuoteListByDatePeriod2___ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__QuoteListByDatePeriod2___, sizeof(struct __ns1__QuoteListByDatePeriod2___), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	soap_default___ns1__QuoteListByDatePeriod2___(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Token", &a->Token, "xsd:string"))
				{	soap_flag_Token--;
					continue;
				}
			if (soap_flag_Exchange && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Exchange", &a->Exchange, "xsd:string"))
				{	soap_flag_Exchange--;
					continue;
				}
			if (soap_flag_QuoteDate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:QuoteDate", &a->QuoteDate, "xsd:string"))
				{	soap_flag_QuoteDate--;
					continue;
				}
			if (soap_flag_Period && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Period", &a->Period, "xsd:string"))
				{	soap_flag_Period--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token > 0 || soap_flag_Exchange > 0 || soap_flag_QuoteDate > 0 || soap_flag_Period > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__QuoteListByDatePeriod2___ * SOAP_FMAC2 soap_instantiate___ns1__QuoteListByDatePeriod2___(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__QuoteListByDatePeriod2___(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__QuoteListByDatePeriod2___ *p;
	size_t k = sizeof(struct __ns1__QuoteListByDatePeriod2___);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__QuoteListByDatePeriod2___);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__QuoteListByDatePeriod2___, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__QuoteListByDatePeriod2___ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__QuoteListByDatePeriod2___, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__QuoteListByDatePeriod2___(struct soap *soap, const struct __ns1__QuoteListByDatePeriod2___ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__QuoteListByDatePeriod2___(soap, tag?tag:"-ns1:QuoteListByDatePeriod2", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QuoteListByDatePeriod2___ * SOAP_FMAC4 soap_get___ns1__QuoteListByDatePeriod2___(struct soap *soap, struct __ns1__QuoteListByDatePeriod2___ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__QuoteListByDatePeriod2___(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__QuoteListByDatePeriod___::__ns1__QuoteListByDatePeriod___()
{
	soap_default___ns1__QuoteListByDatePeriod___(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__QuoteListByDatePeriod___(struct soap *soap, struct __ns1__QuoteListByDatePeriod___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->Token);
	soap_default_std__string(soap, &a->Exchange);
	soap_default_std__string(soap, &a->QuoteDate);
	soap_default_std__string(soap, &a->Period);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__QuoteListByDatePeriod___(struct soap *soap, const struct __ns1__QuoteListByDatePeriod___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Token, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Token);
	soap_embedded(soap, &a->Exchange, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Exchange);
	soap_embedded(soap, &a->QuoteDate, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->QuoteDate);
	soap_embedded(soap, &a->Period, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Period);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__QuoteListByDatePeriod___(struct soap *soap, const char *tag, int id, const struct __ns1__QuoteListByDatePeriod___ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_std__string(soap, "ns1:Token", -1, &a->Token, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Exchange", -1, &a->Exchange, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:QuoteDate", -1, &a->QuoteDate, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Period", -1, &a->Period, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QuoteListByDatePeriod___ * SOAP_FMAC4 soap_in___ns1__QuoteListByDatePeriod___(struct soap *soap, const char *tag, struct __ns1__QuoteListByDatePeriod___ *a, const char *type)
{
	size_t soap_flag_Token = 1;
	size_t soap_flag_Exchange = 1;
	size_t soap_flag_QuoteDate = 1;
	size_t soap_flag_Period = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__QuoteListByDatePeriod___ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__QuoteListByDatePeriod___, sizeof(struct __ns1__QuoteListByDatePeriod___), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	soap_default___ns1__QuoteListByDatePeriod___(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Token", &a->Token, "xsd:string"))
				{	soap_flag_Token--;
					continue;
				}
			if (soap_flag_Exchange && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Exchange", &a->Exchange, "xsd:string"))
				{	soap_flag_Exchange--;
					continue;
				}
			if (soap_flag_QuoteDate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:QuoteDate", &a->QuoteDate, "xsd:string"))
				{	soap_flag_QuoteDate--;
					continue;
				}
			if (soap_flag_Period && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Period", &a->Period, "xsd:string"))
				{	soap_flag_Period--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token > 0 || soap_flag_Exchange > 0 || soap_flag_QuoteDate > 0 || soap_flag_Period > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__QuoteListByDatePeriod___ * SOAP_FMAC2 soap_instantiate___ns1__QuoteListByDatePeriod___(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__QuoteListByDatePeriod___(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__QuoteListByDatePeriod___ *p;
	size_t k = sizeof(struct __ns1__QuoteListByDatePeriod___);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__QuoteListByDatePeriod___);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__QuoteListByDatePeriod___, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__QuoteListByDatePeriod___ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__QuoteListByDatePeriod___, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__QuoteListByDatePeriod___(struct soap *soap, const struct __ns1__QuoteListByDatePeriod___ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__QuoteListByDatePeriod___(soap, tag?tag:"-ns1:QuoteListByDatePeriod", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QuoteListByDatePeriod___ * SOAP_FMAC4 soap_get___ns1__QuoteListByDatePeriod___(struct soap *soap, struct __ns1__QuoteListByDatePeriod___ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__QuoteListByDatePeriod___(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__SymbolHistoryPeriodByDateRange___::__ns1__SymbolHistoryPeriodByDateRange___()
{
	soap_default___ns1__SymbolHistoryPeriodByDateRange___(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SymbolHistoryPeriodByDateRange___(struct soap *soap, struct __ns1__SymbolHistoryPeriodByDateRange___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->Token);
	soap_default_std__string(soap, &a->Exchange);
	soap_default_std__string(soap, &a->Symbol);
	soap_default_std__string(soap, &a->StartDate);
	soap_default_std__string(soap, &a->EndDate);
	soap_default_std__string(soap, &a->Period);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SymbolHistoryPeriodByDateRange___(struct soap *soap, const struct __ns1__SymbolHistoryPeriodByDateRange___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Token, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Token);
	soap_embedded(soap, &a->Exchange, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Exchange);
	soap_embedded(soap, &a->Symbol, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Symbol);
	soap_embedded(soap, &a->StartDate, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->StartDate);
	soap_embedded(soap, &a->EndDate, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->EndDate);
	soap_embedded(soap, &a->Period, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Period);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SymbolHistoryPeriodByDateRange___(struct soap *soap, const char *tag, int id, const struct __ns1__SymbolHistoryPeriodByDateRange___ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_std__string(soap, "ns1:Token", -1, &a->Token, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Exchange", -1, &a->Exchange, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Symbol", -1, &a->Symbol, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:StartDate", -1, &a->StartDate, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:EndDate", -1, &a->EndDate, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Period", -1, &a->Period, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolHistoryPeriodByDateRange___ * SOAP_FMAC4 soap_in___ns1__SymbolHistoryPeriodByDateRange___(struct soap *soap, const char *tag, struct __ns1__SymbolHistoryPeriodByDateRange___ *a, const char *type)
{
	size_t soap_flag_Token = 1;
	size_t soap_flag_Exchange = 1;
	size_t soap_flag_Symbol = 1;
	size_t soap_flag_StartDate = 1;
	size_t soap_flag_EndDate = 1;
	size_t soap_flag_Period = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SymbolHistoryPeriodByDateRange___ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__SymbolHistoryPeriodByDateRange___, sizeof(struct __ns1__SymbolHistoryPeriodByDateRange___), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	soap_default___ns1__SymbolHistoryPeriodByDateRange___(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Token", &a->Token, "xsd:string"))
				{	soap_flag_Token--;
					continue;
				}
			if (soap_flag_Exchange && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Exchange", &a->Exchange, "xsd:string"))
				{	soap_flag_Exchange--;
					continue;
				}
			if (soap_flag_Symbol && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Symbol", &a->Symbol, "xsd:string"))
				{	soap_flag_Symbol--;
					continue;
				}
			if (soap_flag_StartDate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:StartDate", &a->StartDate, "xsd:string"))
				{	soap_flag_StartDate--;
					continue;
				}
			if (soap_flag_EndDate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:EndDate", &a->EndDate, "xsd:string"))
				{	soap_flag_EndDate--;
					continue;
				}
			if (soap_flag_Period && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Period", &a->Period, "xsd:string"))
				{	soap_flag_Period--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token > 0 || soap_flag_Exchange > 0 || soap_flag_Symbol > 0 || soap_flag_StartDate > 0 || soap_flag_EndDate > 0 || soap_flag_Period > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SymbolHistoryPeriodByDateRange___ * SOAP_FMAC2 soap_instantiate___ns1__SymbolHistoryPeriodByDateRange___(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SymbolHistoryPeriodByDateRange___(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SymbolHistoryPeriodByDateRange___ *p;
	size_t k = sizeof(struct __ns1__SymbolHistoryPeriodByDateRange___);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SymbolHistoryPeriodByDateRange___);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SymbolHistoryPeriodByDateRange___, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SymbolHistoryPeriodByDateRange___ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__SymbolHistoryPeriodByDateRange___, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SymbolHistoryPeriodByDateRange___(struct soap *soap, const struct __ns1__SymbolHistoryPeriodByDateRange___ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SymbolHistoryPeriodByDateRange___(soap, tag?tag:"-ns1:SymbolHistoryPeriodByDateRange", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolHistoryPeriodByDateRange___ * SOAP_FMAC4 soap_get___ns1__SymbolHistoryPeriodByDateRange___(struct soap *soap, struct __ns1__SymbolHistoryPeriodByDateRange___ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SymbolHistoryPeriodByDateRange___(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__SymbolHistoryPeriod___::__ns1__SymbolHistoryPeriod___()
{
	soap_default___ns1__SymbolHistoryPeriod___(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SymbolHistoryPeriod___(struct soap *soap, struct __ns1__SymbolHistoryPeriod___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->Token);
	soap_default_std__string(soap, &a->Exchange);
	soap_default_std__string(soap, &a->Symbol);
	soap_default_std__string(soap, &a->Date);
	soap_default_std__string(soap, &a->Period);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SymbolHistoryPeriod___(struct soap *soap, const struct __ns1__SymbolHistoryPeriod___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Token, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Token);
	soap_embedded(soap, &a->Exchange, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Exchange);
	soap_embedded(soap, &a->Symbol, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Symbol);
	soap_embedded(soap, &a->Date, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Date);
	soap_embedded(soap, &a->Period, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Period);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SymbolHistoryPeriod___(struct soap *soap, const char *tag, int id, const struct __ns1__SymbolHistoryPeriod___ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_std__string(soap, "ns1:Token", -1, &a->Token, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Exchange", -1, &a->Exchange, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Symbol", -1, &a->Symbol, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Date", -1, &a->Date, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Period", -1, &a->Period, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolHistoryPeriod___ * SOAP_FMAC4 soap_in___ns1__SymbolHistoryPeriod___(struct soap *soap, const char *tag, struct __ns1__SymbolHistoryPeriod___ *a, const char *type)
{
	size_t soap_flag_Token = 1;
	size_t soap_flag_Exchange = 1;
	size_t soap_flag_Symbol = 1;
	size_t soap_flag_Date = 1;
	size_t soap_flag_Period = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SymbolHistoryPeriod___ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__SymbolHistoryPeriod___, sizeof(struct __ns1__SymbolHistoryPeriod___), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	soap_default___ns1__SymbolHistoryPeriod___(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Token", &a->Token, "xsd:string"))
				{	soap_flag_Token--;
					continue;
				}
			if (soap_flag_Exchange && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Exchange", &a->Exchange, "xsd:string"))
				{	soap_flag_Exchange--;
					continue;
				}
			if (soap_flag_Symbol && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Symbol", &a->Symbol, "xsd:string"))
				{	soap_flag_Symbol--;
					continue;
				}
			if (soap_flag_Date && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Date", &a->Date, "xsd:string"))
				{	soap_flag_Date--;
					continue;
				}
			if (soap_flag_Period && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Period", &a->Period, "xsd:string"))
				{	soap_flag_Period--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token > 0 || soap_flag_Exchange > 0 || soap_flag_Symbol > 0 || soap_flag_Date > 0 || soap_flag_Period > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SymbolHistoryPeriod___ * SOAP_FMAC2 soap_instantiate___ns1__SymbolHistoryPeriod___(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SymbolHistoryPeriod___(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SymbolHistoryPeriod___ *p;
	size_t k = sizeof(struct __ns1__SymbolHistoryPeriod___);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SymbolHistoryPeriod___);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SymbolHistoryPeriod___, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SymbolHistoryPeriod___ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__SymbolHistoryPeriod___, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SymbolHistoryPeriod___(struct soap *soap, const struct __ns1__SymbolHistoryPeriod___ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SymbolHistoryPeriod___(soap, tag?tag:"-ns1:SymbolHistoryPeriod", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolHistoryPeriod___ * SOAP_FMAC4 soap_get___ns1__SymbolHistoryPeriod___(struct soap *soap, struct __ns1__SymbolHistoryPeriod___ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SymbolHistoryPeriod___(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__CountryList___::__ns1__CountryList___()
{
	soap_default___ns1__CountryList___(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__CountryList___(struct soap *soap, struct __ns1__CountryList___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->Token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__CountryList___(struct soap *soap, const struct __ns1__CountryList___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Token, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Token);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__CountryList___(struct soap *soap, const char *tag, int id, const struct __ns1__CountryList___ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_std__string(soap, "ns1:Token", -1, &a->Token, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CountryList___ * SOAP_FMAC4 soap_in___ns1__CountryList___(struct soap *soap, const char *tag, struct __ns1__CountryList___ *a, const char *type)
{
	size_t soap_flag_Token = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__CountryList___ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__CountryList___, sizeof(struct __ns1__CountryList___), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	soap_default___ns1__CountryList___(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Token", &a->Token, "xsd:string"))
				{	soap_flag_Token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__CountryList___ * SOAP_FMAC2 soap_instantiate___ns1__CountryList___(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__CountryList___(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__CountryList___ *p;
	size_t k = sizeof(struct __ns1__CountryList___);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__CountryList___);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__CountryList___, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__CountryList___ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__CountryList___, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__CountryList___(struct soap *soap, const struct __ns1__CountryList___ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__CountryList___(soap, tag?tag:"-ns1:CountryList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CountryList___ * SOAP_FMAC4 soap_get___ns1__CountryList___(struct soap *soap, struct __ns1__CountryList___ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__CountryList___(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__SplitListBySymbol___::__ns1__SplitListBySymbol___()
{
	soap_default___ns1__SplitListBySymbol___(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SplitListBySymbol___(struct soap *soap, struct __ns1__SplitListBySymbol___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->Token);
	soap_default_std__string(soap, &a->Exchange);
	soap_default_std__string(soap, &a->Symbol);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SplitListBySymbol___(struct soap *soap, const struct __ns1__SplitListBySymbol___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Token, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Token);
	soap_embedded(soap, &a->Exchange, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Exchange);
	soap_embedded(soap, &a->Symbol, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Symbol);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SplitListBySymbol___(struct soap *soap, const char *tag, int id, const struct __ns1__SplitListBySymbol___ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_std__string(soap, "ns1:Token", -1, &a->Token, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Exchange", -1, &a->Exchange, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Symbol", -1, &a->Symbol, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SplitListBySymbol___ * SOAP_FMAC4 soap_in___ns1__SplitListBySymbol___(struct soap *soap, const char *tag, struct __ns1__SplitListBySymbol___ *a, const char *type)
{
	size_t soap_flag_Token = 1;
	size_t soap_flag_Exchange = 1;
	size_t soap_flag_Symbol = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SplitListBySymbol___ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__SplitListBySymbol___, sizeof(struct __ns1__SplitListBySymbol___), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	soap_default___ns1__SplitListBySymbol___(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Token", &a->Token, "xsd:string"))
				{	soap_flag_Token--;
					continue;
				}
			if (soap_flag_Exchange && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Exchange", &a->Exchange, "xsd:string"))
				{	soap_flag_Exchange--;
					continue;
				}
			if (soap_flag_Symbol && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Symbol", &a->Symbol, "xsd:string"))
				{	soap_flag_Symbol--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token > 0 || soap_flag_Exchange > 0 || soap_flag_Symbol > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SplitListBySymbol___ * SOAP_FMAC2 soap_instantiate___ns1__SplitListBySymbol___(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SplitListBySymbol___(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SplitListBySymbol___ *p;
	size_t k = sizeof(struct __ns1__SplitListBySymbol___);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SplitListBySymbol___);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SplitListBySymbol___, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SplitListBySymbol___ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__SplitListBySymbol___, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SplitListBySymbol___(struct soap *soap, const struct __ns1__SplitListBySymbol___ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SplitListBySymbol___(soap, tag?tag:"-ns1:SplitListBySymbol", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SplitListBySymbol___ * SOAP_FMAC4 soap_get___ns1__SplitListBySymbol___(struct soap *soap, struct __ns1__SplitListBySymbol___ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SplitListBySymbol___(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__SplitListByExchange___::__ns1__SplitListByExchange___()
{
	soap_default___ns1__SplitListByExchange___(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SplitListByExchange___(struct soap *soap, struct __ns1__SplitListByExchange___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->Token);
	soap_default_std__string(soap, &a->Exchange);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SplitListByExchange___(struct soap *soap, const struct __ns1__SplitListByExchange___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Token, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Token);
	soap_embedded(soap, &a->Exchange, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Exchange);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SplitListByExchange___(struct soap *soap, const char *tag, int id, const struct __ns1__SplitListByExchange___ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_std__string(soap, "ns1:Token", -1, &a->Token, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Exchange", -1, &a->Exchange, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SplitListByExchange___ * SOAP_FMAC4 soap_in___ns1__SplitListByExchange___(struct soap *soap, const char *tag, struct __ns1__SplitListByExchange___ *a, const char *type)
{
	size_t soap_flag_Token = 1;
	size_t soap_flag_Exchange = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SplitListByExchange___ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__SplitListByExchange___, sizeof(struct __ns1__SplitListByExchange___), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	soap_default___ns1__SplitListByExchange___(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Token", &a->Token, "xsd:string"))
				{	soap_flag_Token--;
					continue;
				}
			if (soap_flag_Exchange && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Exchange", &a->Exchange, "xsd:string"))
				{	soap_flag_Exchange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token > 0 || soap_flag_Exchange > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SplitListByExchange___ * SOAP_FMAC2 soap_instantiate___ns1__SplitListByExchange___(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SplitListByExchange___(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SplitListByExchange___ *p;
	size_t k = sizeof(struct __ns1__SplitListByExchange___);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SplitListByExchange___);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SplitListByExchange___, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SplitListByExchange___ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__SplitListByExchange___, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SplitListByExchange___(struct soap *soap, const struct __ns1__SplitListByExchange___ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SplitListByExchange___(soap, tag?tag:"-ns1:SplitListByExchange", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SplitListByExchange___ * SOAP_FMAC4 soap_get___ns1__SplitListByExchange___(struct soap *soap, struct __ns1__SplitListByExchange___ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SplitListByExchange___(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__ExchangeMonths___::__ns1__ExchangeMonths___()
{
	soap_default___ns1__ExchangeMonths___(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ExchangeMonths___(struct soap *soap, struct __ns1__ExchangeMonths___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->Token);
	soap_default_std__string(soap, &a->Exchange);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ExchangeMonths___(struct soap *soap, const struct __ns1__ExchangeMonths___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Token, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Token);
	soap_embedded(soap, &a->Exchange, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Exchange);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ExchangeMonths___(struct soap *soap, const char *tag, int id, const struct __ns1__ExchangeMonths___ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_std__string(soap, "ns1:Token", -1, &a->Token, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Exchange", -1, &a->Exchange, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ExchangeMonths___ * SOAP_FMAC4 soap_in___ns1__ExchangeMonths___(struct soap *soap, const char *tag, struct __ns1__ExchangeMonths___ *a, const char *type)
{
	size_t soap_flag_Token = 1;
	size_t soap_flag_Exchange = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ExchangeMonths___ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__ExchangeMonths___, sizeof(struct __ns1__ExchangeMonths___), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	soap_default___ns1__ExchangeMonths___(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Token", &a->Token, "xsd:string"))
				{	soap_flag_Token--;
					continue;
				}
			if (soap_flag_Exchange && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Exchange", &a->Exchange, "xsd:string"))
				{	soap_flag_Exchange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token > 0 || soap_flag_Exchange > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ExchangeMonths___ * SOAP_FMAC2 soap_instantiate___ns1__ExchangeMonths___(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ExchangeMonths___(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ExchangeMonths___ *p;
	size_t k = sizeof(struct __ns1__ExchangeMonths___);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__ExchangeMonths___);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__ExchangeMonths___, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ExchangeMonths___ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__ExchangeMonths___, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ExchangeMonths___(struct soap *soap, const struct __ns1__ExchangeMonths___ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ExchangeMonths___(soap, tag?tag:"-ns1:ExchangeMonths", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ExchangeMonths___ * SOAP_FMAC4 soap_get___ns1__ExchangeMonths___(struct soap *soap, struct __ns1__ExchangeMonths___ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ExchangeMonths___(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__SymbolChart___::__ns1__SymbolChart___()
{
	soap_default___ns1__SymbolChart___(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SymbolChart___(struct soap *soap, struct __ns1__SymbolChart___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->Token);
	soap_default_std__string(soap, &a->Exchange);
	soap_default_std__string(soap, &a->Symbol);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SymbolChart___(struct soap *soap, const struct __ns1__SymbolChart___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Token, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Token);
	soap_embedded(soap, &a->Exchange, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Exchange);
	soap_embedded(soap, &a->Symbol, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Symbol);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SymbolChart___(struct soap *soap, const char *tag, int id, const struct __ns1__SymbolChart___ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_std__string(soap, "ns1:Token", -1, &a->Token, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Exchange", -1, &a->Exchange, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Symbol", -1, &a->Symbol, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolChart___ * SOAP_FMAC4 soap_in___ns1__SymbolChart___(struct soap *soap, const char *tag, struct __ns1__SymbolChart___ *a, const char *type)
{
	size_t soap_flag_Token = 1;
	size_t soap_flag_Exchange = 1;
	size_t soap_flag_Symbol = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SymbolChart___ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__SymbolChart___, sizeof(struct __ns1__SymbolChart___), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	soap_default___ns1__SymbolChart___(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Token", &a->Token, "xsd:string"))
				{	soap_flag_Token--;
					continue;
				}
			if (soap_flag_Exchange && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Exchange", &a->Exchange, "xsd:string"))
				{	soap_flag_Exchange--;
					continue;
				}
			if (soap_flag_Symbol && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Symbol", &a->Symbol, "xsd:string"))
				{	soap_flag_Symbol--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token > 0 || soap_flag_Exchange > 0 || soap_flag_Symbol > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SymbolChart___ * SOAP_FMAC2 soap_instantiate___ns1__SymbolChart___(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SymbolChart___(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SymbolChart___ *p;
	size_t k = sizeof(struct __ns1__SymbolChart___);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SymbolChart___);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SymbolChart___, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SymbolChart___ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__SymbolChart___, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SymbolChart___(struct soap *soap, const struct __ns1__SymbolChart___ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SymbolChart___(soap, tag?tag:"-ns1:SymbolChart", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolChart___ * SOAP_FMAC4 soap_get___ns1__SymbolChart___(struct soap *soap, struct __ns1__SymbolChart___ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SymbolChart___(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__Top10Losses___::__ns1__Top10Losses___()
{
	soap_default___ns1__Top10Losses___(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Top10Losses___(struct soap *soap, struct __ns1__Top10Losses___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->Token);
	soap_default_std__string(soap, &a->Exchange);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Top10Losses___(struct soap *soap, const struct __ns1__Top10Losses___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Token, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Token);
	soap_embedded(soap, &a->Exchange, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Exchange);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Top10Losses___(struct soap *soap, const char *tag, int id, const struct __ns1__Top10Losses___ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_std__string(soap, "ns1:Token", -1, &a->Token, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Exchange", -1, &a->Exchange, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Top10Losses___ * SOAP_FMAC4 soap_in___ns1__Top10Losses___(struct soap *soap, const char *tag, struct __ns1__Top10Losses___ *a, const char *type)
{
	size_t soap_flag_Token = 1;
	size_t soap_flag_Exchange = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__Top10Losses___ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__Top10Losses___, sizeof(struct __ns1__Top10Losses___), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	soap_default___ns1__Top10Losses___(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Token", &a->Token, "xsd:string"))
				{	soap_flag_Token--;
					continue;
				}
			if (soap_flag_Exchange && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Exchange", &a->Exchange, "xsd:string"))
				{	soap_flag_Exchange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token > 0 || soap_flag_Exchange > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__Top10Losses___ * SOAP_FMAC2 soap_instantiate___ns1__Top10Losses___(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Top10Losses___(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__Top10Losses___ *p;
	size_t k = sizeof(struct __ns1__Top10Losses___);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__Top10Losses___);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__Top10Losses___, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__Top10Losses___ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__Top10Losses___, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Top10Losses___(struct soap *soap, const struct __ns1__Top10Losses___ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__Top10Losses___(soap, tag?tag:"-ns1:Top10Losses", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Top10Losses___ * SOAP_FMAC4 soap_get___ns1__Top10Losses___(struct soap *soap, struct __ns1__Top10Losses___ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Top10Losses___(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__Top10Gains___::__ns1__Top10Gains___()
{
	soap_default___ns1__Top10Gains___(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Top10Gains___(struct soap *soap, struct __ns1__Top10Gains___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->Token);
	soap_default_std__string(soap, &a->Exchange);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Top10Gains___(struct soap *soap, const struct __ns1__Top10Gains___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Token, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Token);
	soap_embedded(soap, &a->Exchange, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Exchange);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Top10Gains___(struct soap *soap, const char *tag, int id, const struct __ns1__Top10Gains___ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_std__string(soap, "ns1:Token", -1, &a->Token, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Exchange", -1, &a->Exchange, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Top10Gains___ * SOAP_FMAC4 soap_in___ns1__Top10Gains___(struct soap *soap, const char *tag, struct __ns1__Top10Gains___ *a, const char *type)
{
	size_t soap_flag_Token = 1;
	size_t soap_flag_Exchange = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__Top10Gains___ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__Top10Gains___, sizeof(struct __ns1__Top10Gains___), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	soap_default___ns1__Top10Gains___(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Token", &a->Token, "xsd:string"))
				{	soap_flag_Token--;
					continue;
				}
			if (soap_flag_Exchange && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Exchange", &a->Exchange, "xsd:string"))
				{	soap_flag_Exchange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token > 0 || soap_flag_Exchange > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__Top10Gains___ * SOAP_FMAC2 soap_instantiate___ns1__Top10Gains___(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Top10Gains___(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__Top10Gains___ *p;
	size_t k = sizeof(struct __ns1__Top10Gains___);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__Top10Gains___);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__Top10Gains___, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__Top10Gains___ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__Top10Gains___, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Top10Gains___(struct soap *soap, const struct __ns1__Top10Gains___ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__Top10Gains___(soap, tag?tag:"-ns1:Top10Gains", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Top10Gains___ * SOAP_FMAC4 soap_get___ns1__Top10Gains___(struct soap *soap, struct __ns1__Top10Gains___ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Top10Gains___(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__SymbolHistory___::__ns1__SymbolHistory___()
{
	soap_default___ns1__SymbolHistory___(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SymbolHistory___(struct soap *soap, struct __ns1__SymbolHistory___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->Token);
	soap_default_std__string(soap, &a->Exchange);
	soap_default_std__string(soap, &a->Symbol);
	soap_default_std__string(soap, &a->StartDate);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SymbolHistory___(struct soap *soap, const struct __ns1__SymbolHistory___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Token, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Token);
	soap_embedded(soap, &a->Exchange, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Exchange);
	soap_embedded(soap, &a->Symbol, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Symbol);
	soap_embedded(soap, &a->StartDate, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->StartDate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SymbolHistory___(struct soap *soap, const char *tag, int id, const struct __ns1__SymbolHistory___ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_std__string(soap, "ns1:Token", -1, &a->Token, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Exchange", -1, &a->Exchange, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Symbol", -1, &a->Symbol, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:StartDate", -1, &a->StartDate, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolHistory___ * SOAP_FMAC4 soap_in___ns1__SymbolHistory___(struct soap *soap, const char *tag, struct __ns1__SymbolHistory___ *a, const char *type)
{
	size_t soap_flag_Token = 1;
	size_t soap_flag_Exchange = 1;
	size_t soap_flag_Symbol = 1;
	size_t soap_flag_StartDate = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SymbolHistory___ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__SymbolHistory___, sizeof(struct __ns1__SymbolHistory___), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	soap_default___ns1__SymbolHistory___(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Token", &a->Token, "xsd:string"))
				{	soap_flag_Token--;
					continue;
				}
			if (soap_flag_Exchange && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Exchange", &a->Exchange, "xsd:string"))
				{	soap_flag_Exchange--;
					continue;
				}
			if (soap_flag_Symbol && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Symbol", &a->Symbol, "xsd:string"))
				{	soap_flag_Symbol--;
					continue;
				}
			if (soap_flag_StartDate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:StartDate", &a->StartDate, "xsd:string"))
				{	soap_flag_StartDate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token > 0 || soap_flag_Exchange > 0 || soap_flag_Symbol > 0 || soap_flag_StartDate > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SymbolHistory___ * SOAP_FMAC2 soap_instantiate___ns1__SymbolHistory___(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SymbolHistory___(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SymbolHistory___ *p;
	size_t k = sizeof(struct __ns1__SymbolHistory___);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SymbolHistory___);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SymbolHistory___, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SymbolHistory___ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__SymbolHistory___, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SymbolHistory___(struct soap *soap, const struct __ns1__SymbolHistory___ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SymbolHistory___(soap, tag?tag:"-ns1:SymbolHistory", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolHistory___ * SOAP_FMAC4 soap_get___ns1__SymbolHistory___(struct soap *soap, struct __ns1__SymbolHistory___ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SymbolHistory___(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__QuoteListByDate2___::__ns1__QuoteListByDate2___()
{
	soap_default___ns1__QuoteListByDate2___(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__QuoteListByDate2___(struct soap *soap, struct __ns1__QuoteListByDate2___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->Token);
	soap_default_std__string(soap, &a->Exchange);
	soap_default_std__string(soap, &a->QuoteDate);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__QuoteListByDate2___(struct soap *soap, const struct __ns1__QuoteListByDate2___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Token, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Token);
	soap_embedded(soap, &a->Exchange, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Exchange);
	soap_embedded(soap, &a->QuoteDate, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->QuoteDate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__QuoteListByDate2___(struct soap *soap, const char *tag, int id, const struct __ns1__QuoteListByDate2___ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_std__string(soap, "ns1:Token", -1, &a->Token, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Exchange", -1, &a->Exchange, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:QuoteDate", -1, &a->QuoteDate, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QuoteListByDate2___ * SOAP_FMAC4 soap_in___ns1__QuoteListByDate2___(struct soap *soap, const char *tag, struct __ns1__QuoteListByDate2___ *a, const char *type)
{
	size_t soap_flag_Token = 1;
	size_t soap_flag_Exchange = 1;
	size_t soap_flag_QuoteDate = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__QuoteListByDate2___ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__QuoteListByDate2___, sizeof(struct __ns1__QuoteListByDate2___), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	soap_default___ns1__QuoteListByDate2___(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Token", &a->Token, "xsd:string"))
				{	soap_flag_Token--;
					continue;
				}
			if (soap_flag_Exchange && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Exchange", &a->Exchange, "xsd:string"))
				{	soap_flag_Exchange--;
					continue;
				}
			if (soap_flag_QuoteDate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:QuoteDate", &a->QuoteDate, "xsd:string"))
				{	soap_flag_QuoteDate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token > 0 || soap_flag_Exchange > 0 || soap_flag_QuoteDate > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__QuoteListByDate2___ * SOAP_FMAC2 soap_instantiate___ns1__QuoteListByDate2___(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__QuoteListByDate2___(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__QuoteListByDate2___ *p;
	size_t k = sizeof(struct __ns1__QuoteListByDate2___);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__QuoteListByDate2___);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__QuoteListByDate2___, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__QuoteListByDate2___ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__QuoteListByDate2___, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__QuoteListByDate2___(struct soap *soap, const struct __ns1__QuoteListByDate2___ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__QuoteListByDate2___(soap, tag?tag:"-ns1:QuoteListByDate2", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QuoteListByDate2___ * SOAP_FMAC4 soap_get___ns1__QuoteListByDate2___(struct soap *soap, struct __ns1__QuoteListByDate2___ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__QuoteListByDate2___(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__QuoteListByDate___::__ns1__QuoteListByDate___()
{
	soap_default___ns1__QuoteListByDate___(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__QuoteListByDate___(struct soap *soap, struct __ns1__QuoteListByDate___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->Token);
	soap_default_std__string(soap, &a->Exchange);
	soap_default_std__string(soap, &a->QuoteDate);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__QuoteListByDate___(struct soap *soap, const struct __ns1__QuoteListByDate___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Token, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Token);
	soap_embedded(soap, &a->Exchange, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Exchange);
	soap_embedded(soap, &a->QuoteDate, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->QuoteDate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__QuoteListByDate___(struct soap *soap, const char *tag, int id, const struct __ns1__QuoteListByDate___ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_std__string(soap, "ns1:Token", -1, &a->Token, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Exchange", -1, &a->Exchange, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:QuoteDate", -1, &a->QuoteDate, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QuoteListByDate___ * SOAP_FMAC4 soap_in___ns1__QuoteListByDate___(struct soap *soap, const char *tag, struct __ns1__QuoteListByDate___ *a, const char *type)
{
	size_t soap_flag_Token = 1;
	size_t soap_flag_Exchange = 1;
	size_t soap_flag_QuoteDate = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__QuoteListByDate___ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__QuoteListByDate___, sizeof(struct __ns1__QuoteListByDate___), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	soap_default___ns1__QuoteListByDate___(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Token", &a->Token, "xsd:string"))
				{	soap_flag_Token--;
					continue;
				}
			if (soap_flag_Exchange && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Exchange", &a->Exchange, "xsd:string"))
				{	soap_flag_Exchange--;
					continue;
				}
			if (soap_flag_QuoteDate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:QuoteDate", &a->QuoteDate, "xsd:string"))
				{	soap_flag_QuoteDate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token > 0 || soap_flag_Exchange > 0 || soap_flag_QuoteDate > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__QuoteListByDate___ * SOAP_FMAC2 soap_instantiate___ns1__QuoteListByDate___(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__QuoteListByDate___(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__QuoteListByDate___ *p;
	size_t k = sizeof(struct __ns1__QuoteListByDate___);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__QuoteListByDate___);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__QuoteListByDate___, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__QuoteListByDate___ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__QuoteListByDate___, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__QuoteListByDate___(struct soap *soap, const struct __ns1__QuoteListByDate___ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__QuoteListByDate___(soap, tag?tag:"-ns1:QuoteListByDate", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QuoteListByDate___ * SOAP_FMAC4 soap_get___ns1__QuoteListByDate___(struct soap *soap, struct __ns1__QuoteListByDate___ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__QuoteListByDate___(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__TechnicalList___::__ns1__TechnicalList___()
{
	soap_default___ns1__TechnicalList___(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__TechnicalList___(struct soap *soap, struct __ns1__TechnicalList___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->Token);
	soap_default_std__string(soap, &a->Exchange);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__TechnicalList___(struct soap *soap, const struct __ns1__TechnicalList___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Token, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Token);
	soap_embedded(soap, &a->Exchange, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Exchange);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__TechnicalList___(struct soap *soap, const char *tag, int id, const struct __ns1__TechnicalList___ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_std__string(soap, "ns1:Token", -1, &a->Token, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Exchange", -1, &a->Exchange, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__TechnicalList___ * SOAP_FMAC4 soap_in___ns1__TechnicalList___(struct soap *soap, const char *tag, struct __ns1__TechnicalList___ *a, const char *type)
{
	size_t soap_flag_Token = 1;
	size_t soap_flag_Exchange = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__TechnicalList___ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__TechnicalList___, sizeof(struct __ns1__TechnicalList___), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	soap_default___ns1__TechnicalList___(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Token", &a->Token, "xsd:string"))
				{	soap_flag_Token--;
					continue;
				}
			if (soap_flag_Exchange && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Exchange", &a->Exchange, "xsd:string"))
				{	soap_flag_Exchange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token > 0 || soap_flag_Exchange > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__TechnicalList___ * SOAP_FMAC2 soap_instantiate___ns1__TechnicalList___(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__TechnicalList___(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__TechnicalList___ *p;
	size_t k = sizeof(struct __ns1__TechnicalList___);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__TechnicalList___);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__TechnicalList___, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__TechnicalList___ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__TechnicalList___, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__TechnicalList___(struct soap *soap, const struct __ns1__TechnicalList___ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__TechnicalList___(soap, tag?tag:"-ns1:TechnicalList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__TechnicalList___ * SOAP_FMAC4 soap_get___ns1__TechnicalList___(struct soap *soap, struct __ns1__TechnicalList___ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__TechnicalList___(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__FundamentalList___::__ns1__FundamentalList___()
{
	soap_default___ns1__FundamentalList___(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__FundamentalList___(struct soap *soap, struct __ns1__FundamentalList___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->Token);
	soap_default_std__string(soap, &a->Exchange);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__FundamentalList___(struct soap *soap, const struct __ns1__FundamentalList___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Token, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Token);
	soap_embedded(soap, &a->Exchange, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Exchange);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__FundamentalList___(struct soap *soap, const char *tag, int id, const struct __ns1__FundamentalList___ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_std__string(soap, "ns1:Token", -1, &a->Token, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Exchange", -1, &a->Exchange, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__FundamentalList___ * SOAP_FMAC4 soap_in___ns1__FundamentalList___(struct soap *soap, const char *tag, struct __ns1__FundamentalList___ *a, const char *type)
{
	size_t soap_flag_Token = 1;
	size_t soap_flag_Exchange = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__FundamentalList___ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__FundamentalList___, sizeof(struct __ns1__FundamentalList___), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	soap_default___ns1__FundamentalList___(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Token", &a->Token, "xsd:string"))
				{	soap_flag_Token--;
					continue;
				}
			if (soap_flag_Exchange && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Exchange", &a->Exchange, "xsd:string"))
				{	soap_flag_Exchange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token > 0 || soap_flag_Exchange > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__FundamentalList___ * SOAP_FMAC2 soap_instantiate___ns1__FundamentalList___(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__FundamentalList___(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__FundamentalList___ *p;
	size_t k = sizeof(struct __ns1__FundamentalList___);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__FundamentalList___);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__FundamentalList___, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__FundamentalList___ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__FundamentalList___, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__FundamentalList___(struct soap *soap, const struct __ns1__FundamentalList___ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__FundamentalList___(soap, tag?tag:"-ns1:FundamentalList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__FundamentalList___ * SOAP_FMAC4 soap_get___ns1__FundamentalList___(struct soap *soap, struct __ns1__FundamentalList___ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__FundamentalList___(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__NewsListBySymbol___::__ns1__NewsListBySymbol___()
{
	soap_default___ns1__NewsListBySymbol___(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__NewsListBySymbol___(struct soap *soap, struct __ns1__NewsListBySymbol___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->token);
	soap_default_std__string(soap, &a->Exchange);
	soap_default_std__string(soap, &a->symbol);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__NewsListBySymbol___(struct soap *soap, const struct __ns1__NewsListBySymbol___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->token, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->token);
	soap_embedded(soap, &a->Exchange, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Exchange);
	soap_embedded(soap, &a->symbol, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->symbol);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__NewsListBySymbol___(struct soap *soap, const char *tag, int id, const struct __ns1__NewsListBySymbol___ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_std__string(soap, "ns1:token", -1, &a->token, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Exchange", -1, &a->Exchange, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:symbol", -1, &a->symbol, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__NewsListBySymbol___ * SOAP_FMAC4 soap_in___ns1__NewsListBySymbol___(struct soap *soap, const char *tag, struct __ns1__NewsListBySymbol___ *a, const char *type)
{
	size_t soap_flag_token = 1;
	size_t soap_flag_Exchange = 1;
	size_t soap_flag_symbol = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__NewsListBySymbol___ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__NewsListBySymbol___, sizeof(struct __ns1__NewsListBySymbol___), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	soap_default___ns1__NewsListBySymbol___(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:token", &a->token, "xsd:string"))
				{	soap_flag_token--;
					continue;
				}
			if (soap_flag_Exchange && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Exchange", &a->Exchange, "xsd:string"))
				{	soap_flag_Exchange--;
					continue;
				}
			if (soap_flag_symbol && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:symbol", &a->symbol, "xsd:string"))
				{	soap_flag_symbol--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_token > 0 || soap_flag_Exchange > 0 || soap_flag_symbol > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__NewsListBySymbol___ * SOAP_FMAC2 soap_instantiate___ns1__NewsListBySymbol___(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__NewsListBySymbol___(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__NewsListBySymbol___ *p;
	size_t k = sizeof(struct __ns1__NewsListBySymbol___);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__NewsListBySymbol___);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__NewsListBySymbol___, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__NewsListBySymbol___ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__NewsListBySymbol___, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__NewsListBySymbol___(struct soap *soap, const struct __ns1__NewsListBySymbol___ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__NewsListBySymbol___(soap, tag?tag:"-ns1:NewsListBySymbol", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__NewsListBySymbol___ * SOAP_FMAC4 soap_get___ns1__NewsListBySymbol___(struct soap *soap, struct __ns1__NewsListBySymbol___ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__NewsListBySymbol___(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__NewsList___::__ns1__NewsList___()
{
	soap_default___ns1__NewsList___(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__NewsList___(struct soap *soap, struct __ns1__NewsList___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->Token);
	soap_default_std__string(soap, &a->Exchange);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__NewsList___(struct soap *soap, const struct __ns1__NewsList___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Token, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Token);
	soap_embedded(soap, &a->Exchange, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Exchange);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__NewsList___(struct soap *soap, const char *tag, int id, const struct __ns1__NewsList___ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_std__string(soap, "ns1:Token", -1, &a->Token, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Exchange", -1, &a->Exchange, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__NewsList___ * SOAP_FMAC4 soap_in___ns1__NewsList___(struct soap *soap, const char *tag, struct __ns1__NewsList___ *a, const char *type)
{
	size_t soap_flag_Token = 1;
	size_t soap_flag_Exchange = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__NewsList___ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__NewsList___, sizeof(struct __ns1__NewsList___), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	soap_default___ns1__NewsList___(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Token", &a->Token, "xsd:string"))
				{	soap_flag_Token--;
					continue;
				}
			if (soap_flag_Exchange && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Exchange", &a->Exchange, "xsd:string"))
				{	soap_flag_Exchange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token > 0 || soap_flag_Exchange > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__NewsList___ * SOAP_FMAC2 soap_instantiate___ns1__NewsList___(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__NewsList___(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__NewsList___ *p;
	size_t k = sizeof(struct __ns1__NewsList___);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__NewsList___);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__NewsList___, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__NewsList___ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__NewsList___, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__NewsList___(struct soap *soap, const struct __ns1__NewsList___ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__NewsList___(soap, tag?tag:"-ns1:NewsList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__NewsList___ * SOAP_FMAC4 soap_get___ns1__NewsList___(struct soap *soap, struct __ns1__NewsList___ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__NewsList___(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__QuoteList___::__ns1__QuoteList___()
{
	soap_default___ns1__QuoteList___(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__QuoteList___(struct soap *soap, struct __ns1__QuoteList___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->Token);
	soap_default_std__string(soap, &a->Exchange);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__QuoteList___(struct soap *soap, const struct __ns1__QuoteList___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Token, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Token);
	soap_embedded(soap, &a->Exchange, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Exchange);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__QuoteList___(struct soap *soap, const char *tag, int id, const struct __ns1__QuoteList___ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_std__string(soap, "ns1:Token", -1, &a->Token, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Exchange", -1, &a->Exchange, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QuoteList___ * SOAP_FMAC4 soap_in___ns1__QuoteList___(struct soap *soap, const char *tag, struct __ns1__QuoteList___ *a, const char *type)
{
	size_t soap_flag_Token = 1;
	size_t soap_flag_Exchange = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__QuoteList___ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__QuoteList___, sizeof(struct __ns1__QuoteList___), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	soap_default___ns1__QuoteList___(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Token", &a->Token, "xsd:string"))
				{	soap_flag_Token--;
					continue;
				}
			if (soap_flag_Exchange && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Exchange", &a->Exchange, "xsd:string"))
				{	soap_flag_Exchange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token > 0 || soap_flag_Exchange > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__QuoteList___ * SOAP_FMAC2 soap_instantiate___ns1__QuoteList___(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__QuoteList___(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__QuoteList___ *p;
	size_t k = sizeof(struct __ns1__QuoteList___);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__QuoteList___);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__QuoteList___, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__QuoteList___ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__QuoteList___, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__QuoteList___(struct soap *soap, const struct __ns1__QuoteList___ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__QuoteList___(soap, tag?tag:"-ns1:QuoteList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QuoteList___ * SOAP_FMAC4 soap_get___ns1__QuoteList___(struct soap *soap, struct __ns1__QuoteList___ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__QuoteList___(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__SymbolGet___::__ns1__SymbolGet___()
{
	soap_default___ns1__SymbolGet___(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SymbolGet___(struct soap *soap, struct __ns1__SymbolGet___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->Token);
	soap_default_std__string(soap, &a->Exchange);
	soap_default_std__string(soap, &a->Symbol);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SymbolGet___(struct soap *soap, const struct __ns1__SymbolGet___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Token, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Token);
	soap_embedded(soap, &a->Exchange, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Exchange);
	soap_embedded(soap, &a->Symbol, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Symbol);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SymbolGet___(struct soap *soap, const char *tag, int id, const struct __ns1__SymbolGet___ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_std__string(soap, "ns1:Token", -1, &a->Token, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Exchange", -1, &a->Exchange, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Symbol", -1, &a->Symbol, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolGet___ * SOAP_FMAC4 soap_in___ns1__SymbolGet___(struct soap *soap, const char *tag, struct __ns1__SymbolGet___ *a, const char *type)
{
	size_t soap_flag_Token = 1;
	size_t soap_flag_Exchange = 1;
	size_t soap_flag_Symbol = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SymbolGet___ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__SymbolGet___, sizeof(struct __ns1__SymbolGet___), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	soap_default___ns1__SymbolGet___(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Token", &a->Token, "xsd:string"))
				{	soap_flag_Token--;
					continue;
				}
			if (soap_flag_Exchange && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Exchange", &a->Exchange, "xsd:string"))
				{	soap_flag_Exchange--;
					continue;
				}
			if (soap_flag_Symbol && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Symbol", &a->Symbol, "xsd:string"))
				{	soap_flag_Symbol--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token > 0 || soap_flag_Exchange > 0 || soap_flag_Symbol > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SymbolGet___ * SOAP_FMAC2 soap_instantiate___ns1__SymbolGet___(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SymbolGet___(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SymbolGet___ *p;
	size_t k = sizeof(struct __ns1__SymbolGet___);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SymbolGet___);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SymbolGet___, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SymbolGet___ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__SymbolGet___, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SymbolGet___(struct soap *soap, const struct __ns1__SymbolGet___ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SymbolGet___(soap, tag?tag:"-ns1:SymbolGet", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolGet___ * SOAP_FMAC4 soap_get___ns1__SymbolGet___(struct soap *soap, struct __ns1__SymbolGet___ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SymbolGet___(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__QuoteList2___::__ns1__QuoteList2___()
{
	soap_default___ns1__QuoteList2___(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__QuoteList2___(struct soap *soap, struct __ns1__QuoteList2___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->Token);
	soap_default_std__string(soap, &a->Exchange);
	soap_default_std__string(soap, &a->Symbols);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__QuoteList2___(struct soap *soap, const struct __ns1__QuoteList2___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Token, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Token);
	soap_embedded(soap, &a->Exchange, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Exchange);
	soap_embedded(soap, &a->Symbols, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Symbols);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__QuoteList2___(struct soap *soap, const char *tag, int id, const struct __ns1__QuoteList2___ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_std__string(soap, "ns1:Token", -1, &a->Token, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Exchange", -1, &a->Exchange, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Symbols", -1, &a->Symbols, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QuoteList2___ * SOAP_FMAC4 soap_in___ns1__QuoteList2___(struct soap *soap, const char *tag, struct __ns1__QuoteList2___ *a, const char *type)
{
	size_t soap_flag_Token = 1;
	size_t soap_flag_Exchange = 1;
	size_t soap_flag_Symbols = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__QuoteList2___ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__QuoteList2___, sizeof(struct __ns1__QuoteList2___), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	soap_default___ns1__QuoteList2___(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Token", &a->Token, "xsd:string"))
				{	soap_flag_Token--;
					continue;
				}
			if (soap_flag_Exchange && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Exchange", &a->Exchange, "xsd:string"))
				{	soap_flag_Exchange--;
					continue;
				}
			if (soap_flag_Symbols && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Symbols", &a->Symbols, "xsd:string"))
				{	soap_flag_Symbols--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token > 0 || soap_flag_Exchange > 0 || soap_flag_Symbols > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__QuoteList2___ * SOAP_FMAC2 soap_instantiate___ns1__QuoteList2___(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__QuoteList2___(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__QuoteList2___ *p;
	size_t k = sizeof(struct __ns1__QuoteList2___);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__QuoteList2___);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__QuoteList2___, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__QuoteList2___ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__QuoteList2___, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__QuoteList2___(struct soap *soap, const struct __ns1__QuoteList2___ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__QuoteList2___(soap, tag?tag:"-ns1:QuoteList2", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QuoteList2___ * SOAP_FMAC4 soap_get___ns1__QuoteList2___(struct soap *soap, struct __ns1__QuoteList2___ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__QuoteList2___(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__QuoteGet___::__ns1__QuoteGet___()
{
	soap_default___ns1__QuoteGet___(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__QuoteGet___(struct soap *soap, struct __ns1__QuoteGet___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->Token);
	soap_default_std__string(soap, &a->Exchange);
	soap_default_std__string(soap, &a->Symbol);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__QuoteGet___(struct soap *soap, const struct __ns1__QuoteGet___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Token, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Token);
	soap_embedded(soap, &a->Exchange, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Exchange);
	soap_embedded(soap, &a->Symbol, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Symbol);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__QuoteGet___(struct soap *soap, const char *tag, int id, const struct __ns1__QuoteGet___ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_std__string(soap, "ns1:Token", -1, &a->Token, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Exchange", -1, &a->Exchange, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Symbol", -1, &a->Symbol, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QuoteGet___ * SOAP_FMAC4 soap_in___ns1__QuoteGet___(struct soap *soap, const char *tag, struct __ns1__QuoteGet___ *a, const char *type)
{
	size_t soap_flag_Token = 1;
	size_t soap_flag_Exchange = 1;
	size_t soap_flag_Symbol = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__QuoteGet___ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__QuoteGet___, sizeof(struct __ns1__QuoteGet___), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	soap_default___ns1__QuoteGet___(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Token", &a->Token, "xsd:string"))
				{	soap_flag_Token--;
					continue;
				}
			if (soap_flag_Exchange && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Exchange", &a->Exchange, "xsd:string"))
				{	soap_flag_Exchange--;
					continue;
				}
			if (soap_flag_Symbol && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Symbol", &a->Symbol, "xsd:string"))
				{	soap_flag_Symbol--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token > 0 || soap_flag_Exchange > 0 || soap_flag_Symbol > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__QuoteGet___ * SOAP_FMAC2 soap_instantiate___ns1__QuoteGet___(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__QuoteGet___(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__QuoteGet___ *p;
	size_t k = sizeof(struct __ns1__QuoteGet___);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__QuoteGet___);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__QuoteGet___, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__QuoteGet___ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__QuoteGet___, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__QuoteGet___(struct soap *soap, const struct __ns1__QuoteGet___ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__QuoteGet___(soap, tag?tag:"-ns1:QuoteGet", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QuoteGet___ * SOAP_FMAC4 soap_get___ns1__QuoteGet___(struct soap *soap, struct __ns1__QuoteGet___ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__QuoteGet___(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__SymbolList2___::__ns1__SymbolList2___()
{
	soap_default___ns1__SymbolList2___(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SymbolList2___(struct soap *soap, struct __ns1__SymbolList2___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->Token);
	soap_default_std__string(soap, &a->Exchange);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SymbolList2___(struct soap *soap, const struct __ns1__SymbolList2___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Token, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Token);
	soap_embedded(soap, &a->Exchange, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Exchange);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SymbolList2___(struct soap *soap, const char *tag, int id, const struct __ns1__SymbolList2___ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_std__string(soap, "ns1:Token", -1, &a->Token, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Exchange", -1, &a->Exchange, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolList2___ * SOAP_FMAC4 soap_in___ns1__SymbolList2___(struct soap *soap, const char *tag, struct __ns1__SymbolList2___ *a, const char *type)
{
	size_t soap_flag_Token = 1;
	size_t soap_flag_Exchange = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SymbolList2___ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__SymbolList2___, sizeof(struct __ns1__SymbolList2___), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	soap_default___ns1__SymbolList2___(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Token", &a->Token, "xsd:string"))
				{	soap_flag_Token--;
					continue;
				}
			if (soap_flag_Exchange && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Exchange", &a->Exchange, "xsd:string"))
				{	soap_flag_Exchange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token > 0 || soap_flag_Exchange > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SymbolList2___ * SOAP_FMAC2 soap_instantiate___ns1__SymbolList2___(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SymbolList2___(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SymbolList2___ *p;
	size_t k = sizeof(struct __ns1__SymbolList2___);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SymbolList2___);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SymbolList2___, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SymbolList2___ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__SymbolList2___, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SymbolList2___(struct soap *soap, const struct __ns1__SymbolList2___ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SymbolList2___(soap, tag?tag:"-ns1:SymbolList2", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolList2___ * SOAP_FMAC4 soap_get___ns1__SymbolList2___(struct soap *soap, struct __ns1__SymbolList2___ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SymbolList2___(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__SymbolList___::__ns1__SymbolList___()
{
	soap_default___ns1__SymbolList___(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SymbolList___(struct soap *soap, struct __ns1__SymbolList___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->Token);
	soap_default_std__string(soap, &a->Exchange);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SymbolList___(struct soap *soap, const struct __ns1__SymbolList___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Token, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Token);
	soap_embedded(soap, &a->Exchange, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Exchange);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SymbolList___(struct soap *soap, const char *tag, int id, const struct __ns1__SymbolList___ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_std__string(soap, "ns1:Token", -1, &a->Token, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Exchange", -1, &a->Exchange, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolList___ * SOAP_FMAC4 soap_in___ns1__SymbolList___(struct soap *soap, const char *tag, struct __ns1__SymbolList___ *a, const char *type)
{
	size_t soap_flag_Token = 1;
	size_t soap_flag_Exchange = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SymbolList___ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__SymbolList___, sizeof(struct __ns1__SymbolList___), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	soap_default___ns1__SymbolList___(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Token", &a->Token, "xsd:string"))
				{	soap_flag_Token--;
					continue;
				}
			if (soap_flag_Exchange && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Exchange", &a->Exchange, "xsd:string"))
				{	soap_flag_Exchange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token > 0 || soap_flag_Exchange > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SymbolList___ * SOAP_FMAC2 soap_instantiate___ns1__SymbolList___(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SymbolList___(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SymbolList___ *p;
	size_t k = sizeof(struct __ns1__SymbolList___);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SymbolList___);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SymbolList___, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SymbolList___ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__SymbolList___, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SymbolList___(struct soap *soap, const struct __ns1__SymbolList___ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SymbolList___(soap, tag?tag:"-ns1:SymbolList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolList___ * SOAP_FMAC4 soap_get___ns1__SymbolList___(struct soap *soap, struct __ns1__SymbolList___ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SymbolList___(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__ExchangeGet___::__ns1__ExchangeGet___()
{
	soap_default___ns1__ExchangeGet___(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ExchangeGet___(struct soap *soap, struct __ns1__ExchangeGet___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->Token);
	soap_default_std__string(soap, &a->Exchange);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ExchangeGet___(struct soap *soap, const struct __ns1__ExchangeGet___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Token, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Token);
	soap_embedded(soap, &a->Exchange, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Exchange);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ExchangeGet___(struct soap *soap, const char *tag, int id, const struct __ns1__ExchangeGet___ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_std__string(soap, "ns1:Token", -1, &a->Token, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Exchange", -1, &a->Exchange, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ExchangeGet___ * SOAP_FMAC4 soap_in___ns1__ExchangeGet___(struct soap *soap, const char *tag, struct __ns1__ExchangeGet___ *a, const char *type)
{
	size_t soap_flag_Token = 1;
	size_t soap_flag_Exchange = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ExchangeGet___ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__ExchangeGet___, sizeof(struct __ns1__ExchangeGet___), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	soap_default___ns1__ExchangeGet___(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Token", &a->Token, "xsd:string"))
				{	soap_flag_Token--;
					continue;
				}
			if (soap_flag_Exchange && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Exchange", &a->Exchange, "xsd:string"))
				{	soap_flag_Exchange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token > 0 || soap_flag_Exchange > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ExchangeGet___ * SOAP_FMAC2 soap_instantiate___ns1__ExchangeGet___(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ExchangeGet___(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ExchangeGet___ *p;
	size_t k = sizeof(struct __ns1__ExchangeGet___);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__ExchangeGet___);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__ExchangeGet___, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ExchangeGet___ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__ExchangeGet___, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ExchangeGet___(struct soap *soap, const struct __ns1__ExchangeGet___ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ExchangeGet___(soap, tag?tag:"-ns1:ExchangeGet", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ExchangeGet___ * SOAP_FMAC4 soap_get___ns1__ExchangeGet___(struct soap *soap, struct __ns1__ExchangeGet___ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ExchangeGet___(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__ExchangeList___::__ns1__ExchangeList___()
{
	soap_default___ns1__ExchangeList___(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ExchangeList___(struct soap *soap, struct __ns1__ExchangeList___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->Token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ExchangeList___(struct soap *soap, const struct __ns1__ExchangeList___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Token, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Token);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ExchangeList___(struct soap *soap, const char *tag, int id, const struct __ns1__ExchangeList___ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_std__string(soap, "ns1:Token", -1, &a->Token, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ExchangeList___ * SOAP_FMAC4 soap_in___ns1__ExchangeList___(struct soap *soap, const char *tag, struct __ns1__ExchangeList___ *a, const char *type)
{
	size_t soap_flag_Token = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ExchangeList___ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__ExchangeList___, sizeof(struct __ns1__ExchangeList___), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	soap_default___ns1__ExchangeList___(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Token", &a->Token, "xsd:string"))
				{	soap_flag_Token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ExchangeList___ * SOAP_FMAC2 soap_instantiate___ns1__ExchangeList___(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ExchangeList___(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ExchangeList___ *p;
	size_t k = sizeof(struct __ns1__ExchangeList___);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__ExchangeList___);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__ExchangeList___, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ExchangeList___ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__ExchangeList___, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ExchangeList___(struct soap *soap, const struct __ns1__ExchangeList___ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ExchangeList___(soap, tag?tag:"-ns1:ExchangeList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ExchangeList___ * SOAP_FMAC4 soap_get___ns1__ExchangeList___(struct soap *soap, struct __ns1__ExchangeList___ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ExchangeList___(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__Membership___::__ns1__Membership___()
{
	soap_default___ns1__Membership___(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Membership___(struct soap *soap, struct __ns1__Membership___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->Token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Membership___(struct soap *soap, const struct __ns1__Membership___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Token, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Token);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Membership___(struct soap *soap, const char *tag, int id, const struct __ns1__Membership___ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_std__string(soap, "ns1:Token", -1, &a->Token, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Membership___ * SOAP_FMAC4 soap_in___ns1__Membership___(struct soap *soap, const char *tag, struct __ns1__Membership___ *a, const char *type)
{
	size_t soap_flag_Token = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__Membership___ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__Membership___, sizeof(struct __ns1__Membership___), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	soap_default___ns1__Membership___(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Token", &a->Token, "xsd:string"))
				{	soap_flag_Token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__Membership___ * SOAP_FMAC2 soap_instantiate___ns1__Membership___(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Membership___(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__Membership___ *p;
	size_t k = sizeof(struct __ns1__Membership___);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__Membership___);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__Membership___, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__Membership___ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__Membership___, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Membership___(struct soap *soap, const struct __ns1__Membership___ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__Membership___(soap, tag?tag:"-ns1:Membership", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Membership___ * SOAP_FMAC4 soap_get___ns1__Membership___(struct soap *soap, struct __ns1__Membership___ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Membership___(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__Login2___::__ns1__Login2___()
{
	soap_default___ns1__Login2___(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Login2___(struct soap *soap, struct __ns1__Login2___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->Username);
	soap_default_std__string(soap, &a->Password);
	soap_default_std__string(soap, &a->Version);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Login2___(struct soap *soap, const struct __ns1__Login2___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Username, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Username);
	soap_embedded(soap, &a->Password, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Password);
	soap_embedded(soap, &a->Version, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Version);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Login2___(struct soap *soap, const char *tag, int id, const struct __ns1__Login2___ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_std__string(soap, "ns1:Username", -1, &a->Username, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Password", -1, &a->Password, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Version", -1, &a->Version, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Login2___ * SOAP_FMAC4 soap_in___ns1__Login2___(struct soap *soap, const char *tag, struct __ns1__Login2___ *a, const char *type)
{
	size_t soap_flag_Username = 1;
	size_t soap_flag_Password = 1;
	size_t soap_flag_Version = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__Login2___ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__Login2___, sizeof(struct __ns1__Login2___), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	soap_default___ns1__Login2___(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Username", &a->Username, "xsd:string"))
				{	soap_flag_Username--;
					continue;
				}
			if (soap_flag_Password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Password", &a->Password, "xsd:string"))
				{	soap_flag_Password--;
					continue;
				}
			if (soap_flag_Version && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Version", &a->Version, "xsd:string"))
				{	soap_flag_Version--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Username > 0 || soap_flag_Password > 0 || soap_flag_Version > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__Login2___ * SOAP_FMAC2 soap_instantiate___ns1__Login2___(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Login2___(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__Login2___ *p;
	size_t k = sizeof(struct __ns1__Login2___);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__Login2___);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__Login2___, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__Login2___ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__Login2___, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Login2___(struct soap *soap, const struct __ns1__Login2___ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__Login2___(soap, tag?tag:"-ns1:Login2", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Login2___ * SOAP_FMAC4 soap_get___ns1__Login2___(struct soap *soap, struct __ns1__Login2___ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Login2___(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__Login___::__ns1__Login___()
{
	soap_default___ns1__Login___(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Login___(struct soap *soap, struct __ns1__Login___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->Username);
	soap_default_std__string(soap, &a->Password);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Login___(struct soap *soap, const struct __ns1__Login___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Username, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Username);
	soap_embedded(soap, &a->Password, SOAP_TYPE_ns_std__string);
	soap_serialize_std__string(soap, &a->Password);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Login___(struct soap *soap, const char *tag, int id, const struct __ns1__Login___ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_std__string(soap, "ns1:Username", -1, &a->Username, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Password", -1, &a->Password, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Login___ * SOAP_FMAC4 soap_in___ns1__Login___(struct soap *soap, const char *tag, struct __ns1__Login___ *a, const char *type)
{
	size_t soap_flag_Username = 1;
	size_t soap_flag_Password = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__Login___ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__Login___, sizeof(struct __ns1__Login___), soap->type, soap->arrayType, ns_instantiate, ns_fbase);
	if (!a)
		return NULL;
	soap_default___ns1__Login___(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Username", &a->Username, "xsd:string"))
				{	soap_flag_Username--;
					continue;
				}
			if (soap_flag_Password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Password", &a->Password, "xsd:string"))
				{	soap_flag_Password--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Username > 0 || soap_flag_Password > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__Login___ * SOAP_FMAC2 soap_instantiate___ns1__Login___(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Login___(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__Login___ *p;
	size_t k = sizeof(struct __ns1__Login___);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__Login___);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__Login___, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__Login___ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__Login___, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Login___(struct soap *soap, const struct __ns1__Login___ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__Login___(soap, tag?tag:"-ns1:Login", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Login___ * SOAP_FMAC4 soap_get___ns1__Login___(struct soap *soap, struct __ns1__Login___ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Login___(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__ValidateAccessResponse__::__ns1__ValidateAccessResponse__()
{
	soap_default___ns1__ValidateAccessResponse__(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ValidateAccessResponse__(struct soap *soap, struct __ns1__ValidateAccessResponse__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ValidateAccessResponse__(struct soap *soap, const struct __ns1__ValidateAccessResponse__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ValidateAccessResponse__(struct soap *soap, const char *tag, int id, const struct __ns1__ValidateAccessResponse__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ValidateAccessResponse__ * SOAP_FMAC4 soap_in___ns1__ValidateAccessResponse__(struct soap *soap, const char *tag, struct __ns1__ValidateAccessResponse__ *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ValidateAccessResponse__ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__ValidateAccessResponse__, sizeof(struct __ns1__ValidateAccessResponse__), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ValidateAccessResponse__(soap, a);
	soap->error = SOAP_TAG_MISMATCH;
	a = NULL;
	return a;
}

SOAP_FMAC1 struct __ns1__ValidateAccessResponse__ * SOAP_FMAC2 soap_instantiate___ns1__ValidateAccessResponse__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ValidateAccessResponse__(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ValidateAccessResponse__ *p;
	size_t k = sizeof(struct __ns1__ValidateAccessResponse__);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__ValidateAccessResponse__);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__ValidateAccessResponse__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ValidateAccessResponse__ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__ValidateAccessResponse__, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ValidateAccessResponse__(struct soap *soap, const struct __ns1__ValidateAccessResponse__ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ValidateAccessResponse__(soap, tag?tag:"-ns1:ValidateAccessResponse", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ValidateAccessResponse__ * SOAP_FMAC4 soap_get___ns1__ValidateAccessResponse__(struct soap *soap, struct __ns1__ValidateAccessResponse__ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ValidateAccessResponse__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__UpdateDataFormatResponse__::__ns1__UpdateDataFormatResponse__()
{
	soap_default___ns1__UpdateDataFormatResponse__(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__UpdateDataFormatResponse__(struct soap *soap, struct __ns1__UpdateDataFormatResponse__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__UpdateDataFormatResponse__(struct soap *soap, const struct __ns1__UpdateDataFormatResponse__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__UpdateDataFormatResponse__(struct soap *soap, const char *tag, int id, const struct __ns1__UpdateDataFormatResponse__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UpdateDataFormatResponse__ * SOAP_FMAC4 soap_in___ns1__UpdateDataFormatResponse__(struct soap *soap, const char *tag, struct __ns1__UpdateDataFormatResponse__ *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__UpdateDataFormatResponse__ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__UpdateDataFormatResponse__, sizeof(struct __ns1__UpdateDataFormatResponse__), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__UpdateDataFormatResponse__(soap, a);
	soap->error = SOAP_TAG_MISMATCH;
	a = NULL;
	return a;
}

SOAP_FMAC1 struct __ns1__UpdateDataFormatResponse__ * SOAP_FMAC2 soap_instantiate___ns1__UpdateDataFormatResponse__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__UpdateDataFormatResponse__(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__UpdateDataFormatResponse__ *p;
	size_t k = sizeof(struct __ns1__UpdateDataFormatResponse__);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__UpdateDataFormatResponse__);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__UpdateDataFormatResponse__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__UpdateDataFormatResponse__ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__UpdateDataFormatResponse__, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__UpdateDataFormatResponse__(struct soap *soap, const struct __ns1__UpdateDataFormatResponse__ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__UpdateDataFormatResponse__(soap, tag?tag:"-ns1:UpdateDataFormatResponse", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UpdateDataFormatResponse__ * SOAP_FMAC4 soap_get___ns1__UpdateDataFormatResponse__(struct soap *soap, struct __ns1__UpdateDataFormatResponse__ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__UpdateDataFormatResponse__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__DataFormatsResponse__::__ns1__DataFormatsResponse__()
{
	soap_default___ns1__DataFormatsResponse__(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__DataFormatsResponse__(struct soap *soap, struct __ns1__DataFormatsResponse__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__DataFormatsResponse__(struct soap *soap, const struct __ns1__DataFormatsResponse__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__DataFormatsResponse__(struct soap *soap, const char *tag, int id, const struct __ns1__DataFormatsResponse__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DataFormatsResponse__ * SOAP_FMAC4 soap_in___ns1__DataFormatsResponse__(struct soap *soap, const char *tag, struct __ns1__DataFormatsResponse__ *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__DataFormatsResponse__ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__DataFormatsResponse__, sizeof(struct __ns1__DataFormatsResponse__), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__DataFormatsResponse__(soap, a);
	soap->error = SOAP_TAG_MISMATCH;
	a = NULL;
	return a;
}

SOAP_FMAC1 struct __ns1__DataFormatsResponse__ * SOAP_FMAC2 soap_instantiate___ns1__DataFormatsResponse__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__DataFormatsResponse__(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__DataFormatsResponse__ *p;
	size_t k = sizeof(struct __ns1__DataFormatsResponse__);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__DataFormatsResponse__);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__DataFormatsResponse__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__DataFormatsResponse__ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__DataFormatsResponse__, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__DataFormatsResponse__(struct soap *soap, const struct __ns1__DataFormatsResponse__ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__DataFormatsResponse__(soap, tag?tag:"-ns1:DataFormatsResponse", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DataFormatsResponse__ * SOAP_FMAC4 soap_get___ns1__DataFormatsResponse__(struct soap *soap, struct __ns1__DataFormatsResponse__ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__DataFormatsResponse__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__DataClientLatestVersionResponse__::__ns1__DataClientLatestVersionResponse__()
{
	soap_default___ns1__DataClientLatestVersionResponse__(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__DataClientLatestVersionResponse__(struct soap *soap, struct __ns1__DataClientLatestVersionResponse__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__DataClientLatestVersionResponse__(struct soap *soap, const struct __ns1__DataClientLatestVersionResponse__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__DataClientLatestVersionResponse__(struct soap *soap, const char *tag, int id, const struct __ns1__DataClientLatestVersionResponse__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DataClientLatestVersionResponse__ * SOAP_FMAC4 soap_in___ns1__DataClientLatestVersionResponse__(struct soap *soap, const char *tag, struct __ns1__DataClientLatestVersionResponse__ *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__DataClientLatestVersionResponse__ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__DataClientLatestVersionResponse__, sizeof(struct __ns1__DataClientLatestVersionResponse__), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__DataClientLatestVersionResponse__(soap, a);
	soap->error = SOAP_TAG_MISMATCH;
	a = NULL;
	return a;
}

SOAP_FMAC1 struct __ns1__DataClientLatestVersionResponse__ * SOAP_FMAC2 soap_instantiate___ns1__DataClientLatestVersionResponse__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__DataClientLatestVersionResponse__(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__DataClientLatestVersionResponse__ *p;
	size_t k = sizeof(struct __ns1__DataClientLatestVersionResponse__);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__DataClientLatestVersionResponse__);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__DataClientLatestVersionResponse__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__DataClientLatestVersionResponse__ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__DataClientLatestVersionResponse__, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__DataClientLatestVersionResponse__(struct soap *soap, const struct __ns1__DataClientLatestVersionResponse__ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__DataClientLatestVersionResponse__(soap, tag?tag:"-ns1:DataClientLatestVersionResponse", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DataClientLatestVersionResponse__ * SOAP_FMAC4 soap_get___ns1__DataClientLatestVersionResponse__(struct soap *soap, struct __ns1__DataClientLatestVersionResponse__ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__DataClientLatestVersionResponse__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__SymbolChangesByExchangeResponse__::__ns1__SymbolChangesByExchangeResponse__()
{
	soap_default___ns1__SymbolChangesByExchangeResponse__(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SymbolChangesByExchangeResponse__(struct soap *soap, struct __ns1__SymbolChangesByExchangeResponse__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SymbolChangesByExchangeResponse__(struct soap *soap, const struct __ns1__SymbolChangesByExchangeResponse__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SymbolChangesByExchangeResponse__(struct soap *soap, const char *tag, int id, const struct __ns1__SymbolChangesByExchangeResponse__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolChangesByExchangeResponse__ * SOAP_FMAC4 soap_in___ns1__SymbolChangesByExchangeResponse__(struct soap *soap, const char *tag, struct __ns1__SymbolChangesByExchangeResponse__ *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SymbolChangesByExchangeResponse__ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__SymbolChangesByExchangeResponse__, sizeof(struct __ns1__SymbolChangesByExchangeResponse__), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SymbolChangesByExchangeResponse__(soap, a);
	soap->error = SOAP_TAG_MISMATCH;
	a = NULL;
	return a;
}

SOAP_FMAC1 struct __ns1__SymbolChangesByExchangeResponse__ * SOAP_FMAC2 soap_instantiate___ns1__SymbolChangesByExchangeResponse__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SymbolChangesByExchangeResponse__(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SymbolChangesByExchangeResponse__ *p;
	size_t k = sizeof(struct __ns1__SymbolChangesByExchangeResponse__);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SymbolChangesByExchangeResponse__);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SymbolChangesByExchangeResponse__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SymbolChangesByExchangeResponse__ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__SymbolChangesByExchangeResponse__, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SymbolChangesByExchangeResponse__(struct soap *soap, const struct __ns1__SymbolChangesByExchangeResponse__ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SymbolChangesByExchangeResponse__(soap, tag?tag:"-ns1:SymbolChangesByExchangeResponse", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolChangesByExchangeResponse__ * SOAP_FMAC4 soap_get___ns1__SymbolChangesByExchangeResponse__(struct soap *soap, struct __ns1__SymbolChangesByExchangeResponse__ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SymbolChangesByExchangeResponse__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__QuoteListByDatePeriod2Response__::__ns1__QuoteListByDatePeriod2Response__()
{
	soap_default___ns1__QuoteListByDatePeriod2Response__(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__QuoteListByDatePeriod2Response__(struct soap *soap, struct __ns1__QuoteListByDatePeriod2Response__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__QuoteListByDatePeriod2Response__(struct soap *soap, const struct __ns1__QuoteListByDatePeriod2Response__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__QuoteListByDatePeriod2Response__(struct soap *soap, const char *tag, int id, const struct __ns1__QuoteListByDatePeriod2Response__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QuoteListByDatePeriod2Response__ * SOAP_FMAC4 soap_in___ns1__QuoteListByDatePeriod2Response__(struct soap *soap, const char *tag, struct __ns1__QuoteListByDatePeriod2Response__ *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__QuoteListByDatePeriod2Response__ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__QuoteListByDatePeriod2Response__, sizeof(struct __ns1__QuoteListByDatePeriod2Response__), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__QuoteListByDatePeriod2Response__(soap, a);
	soap->error = SOAP_TAG_MISMATCH;
	a = NULL;
	return a;
}

SOAP_FMAC1 struct __ns1__QuoteListByDatePeriod2Response__ * SOAP_FMAC2 soap_instantiate___ns1__QuoteListByDatePeriod2Response__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__QuoteListByDatePeriod2Response__(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__QuoteListByDatePeriod2Response__ *p;
	size_t k = sizeof(struct __ns1__QuoteListByDatePeriod2Response__);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__QuoteListByDatePeriod2Response__);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__QuoteListByDatePeriod2Response__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__QuoteListByDatePeriod2Response__ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__QuoteListByDatePeriod2Response__, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__QuoteListByDatePeriod2Response__(struct soap *soap, const struct __ns1__QuoteListByDatePeriod2Response__ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__QuoteListByDatePeriod2Response__(soap, tag?tag:"-ns1:QuoteListByDatePeriod2Response", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QuoteListByDatePeriod2Response__ * SOAP_FMAC4 soap_get___ns1__QuoteListByDatePeriod2Response__(struct soap *soap, struct __ns1__QuoteListByDatePeriod2Response__ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__QuoteListByDatePeriod2Response__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__QuoteListByDatePeriodResponse__::__ns1__QuoteListByDatePeriodResponse__()
{
	soap_default___ns1__QuoteListByDatePeriodResponse__(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__QuoteListByDatePeriodResponse__(struct soap *soap, struct __ns1__QuoteListByDatePeriodResponse__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__QuoteListByDatePeriodResponse__(struct soap *soap, const struct __ns1__QuoteListByDatePeriodResponse__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__QuoteListByDatePeriodResponse__(struct soap *soap, const char *tag, int id, const struct __ns1__QuoteListByDatePeriodResponse__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QuoteListByDatePeriodResponse__ * SOAP_FMAC4 soap_in___ns1__QuoteListByDatePeriodResponse__(struct soap *soap, const char *tag, struct __ns1__QuoteListByDatePeriodResponse__ *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__QuoteListByDatePeriodResponse__ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__QuoteListByDatePeriodResponse__, sizeof(struct __ns1__QuoteListByDatePeriodResponse__), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__QuoteListByDatePeriodResponse__(soap, a);
	soap->error = SOAP_TAG_MISMATCH;
	a = NULL;
	return a;
}

SOAP_FMAC1 struct __ns1__QuoteListByDatePeriodResponse__ * SOAP_FMAC2 soap_instantiate___ns1__QuoteListByDatePeriodResponse__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__QuoteListByDatePeriodResponse__(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__QuoteListByDatePeriodResponse__ *p;
	size_t k = sizeof(struct __ns1__QuoteListByDatePeriodResponse__);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__QuoteListByDatePeriodResponse__);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__QuoteListByDatePeriodResponse__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__QuoteListByDatePeriodResponse__ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__QuoteListByDatePeriodResponse__, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__QuoteListByDatePeriodResponse__(struct soap *soap, const struct __ns1__QuoteListByDatePeriodResponse__ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__QuoteListByDatePeriodResponse__(soap, tag?tag:"-ns1:QuoteListByDatePeriodResponse", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QuoteListByDatePeriodResponse__ * SOAP_FMAC4 soap_get___ns1__QuoteListByDatePeriodResponse__(struct soap *soap, struct __ns1__QuoteListByDatePeriodResponse__ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__QuoteListByDatePeriodResponse__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__SymbolHistoryPeriodByDateRangeResponse__::__ns1__SymbolHistoryPeriodByDateRangeResponse__()
{
	soap_default___ns1__SymbolHistoryPeriodByDateRangeResponse__(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SymbolHistoryPeriodByDateRangeResponse__(struct soap *soap, struct __ns1__SymbolHistoryPeriodByDateRangeResponse__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SymbolHistoryPeriodByDateRangeResponse__(struct soap *soap, const struct __ns1__SymbolHistoryPeriodByDateRangeResponse__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SymbolHistoryPeriodByDateRangeResponse__(struct soap *soap, const char *tag, int id, const struct __ns1__SymbolHistoryPeriodByDateRangeResponse__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolHistoryPeriodByDateRangeResponse__ * SOAP_FMAC4 soap_in___ns1__SymbolHistoryPeriodByDateRangeResponse__(struct soap *soap, const char *tag, struct __ns1__SymbolHistoryPeriodByDateRangeResponse__ *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SymbolHistoryPeriodByDateRangeResponse__ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__SymbolHistoryPeriodByDateRangeResponse__, sizeof(struct __ns1__SymbolHistoryPeriodByDateRangeResponse__), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SymbolHistoryPeriodByDateRangeResponse__(soap, a);
	soap->error = SOAP_TAG_MISMATCH;
	a = NULL;
	return a;
}

SOAP_FMAC1 struct __ns1__SymbolHistoryPeriodByDateRangeResponse__ * SOAP_FMAC2 soap_instantiate___ns1__SymbolHistoryPeriodByDateRangeResponse__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SymbolHistoryPeriodByDateRangeResponse__(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SymbolHistoryPeriodByDateRangeResponse__ *p;
	size_t k = sizeof(struct __ns1__SymbolHistoryPeriodByDateRangeResponse__);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SymbolHistoryPeriodByDateRangeResponse__);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SymbolHistoryPeriodByDateRangeResponse__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SymbolHistoryPeriodByDateRangeResponse__ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__SymbolHistoryPeriodByDateRangeResponse__, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SymbolHistoryPeriodByDateRangeResponse__(struct soap *soap, const struct __ns1__SymbolHistoryPeriodByDateRangeResponse__ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SymbolHistoryPeriodByDateRangeResponse__(soap, tag?tag:"-ns1:SymbolHistoryPeriodByDateRangeResponse", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolHistoryPeriodByDateRangeResponse__ * SOAP_FMAC4 soap_get___ns1__SymbolHistoryPeriodByDateRangeResponse__(struct soap *soap, struct __ns1__SymbolHistoryPeriodByDateRangeResponse__ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SymbolHistoryPeriodByDateRangeResponse__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__SymbolHistoryPeriodResponse__::__ns1__SymbolHistoryPeriodResponse__()
{
	soap_default___ns1__SymbolHistoryPeriodResponse__(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SymbolHistoryPeriodResponse__(struct soap *soap, struct __ns1__SymbolHistoryPeriodResponse__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SymbolHistoryPeriodResponse__(struct soap *soap, const struct __ns1__SymbolHistoryPeriodResponse__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SymbolHistoryPeriodResponse__(struct soap *soap, const char *tag, int id, const struct __ns1__SymbolHistoryPeriodResponse__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolHistoryPeriodResponse__ * SOAP_FMAC4 soap_in___ns1__SymbolHistoryPeriodResponse__(struct soap *soap, const char *tag, struct __ns1__SymbolHistoryPeriodResponse__ *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SymbolHistoryPeriodResponse__ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__SymbolHistoryPeriodResponse__, sizeof(struct __ns1__SymbolHistoryPeriodResponse__), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SymbolHistoryPeriodResponse__(soap, a);
	soap->error = SOAP_TAG_MISMATCH;
	a = NULL;
	return a;
}

SOAP_FMAC1 struct __ns1__SymbolHistoryPeriodResponse__ * SOAP_FMAC2 soap_instantiate___ns1__SymbolHistoryPeriodResponse__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SymbolHistoryPeriodResponse__(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SymbolHistoryPeriodResponse__ *p;
	size_t k = sizeof(struct __ns1__SymbolHistoryPeriodResponse__);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SymbolHistoryPeriodResponse__);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SymbolHistoryPeriodResponse__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SymbolHistoryPeriodResponse__ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__SymbolHistoryPeriodResponse__, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SymbolHistoryPeriodResponse__(struct soap *soap, const struct __ns1__SymbolHistoryPeriodResponse__ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SymbolHistoryPeriodResponse__(soap, tag?tag:"-ns1:SymbolHistoryPeriodResponse", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolHistoryPeriodResponse__ * SOAP_FMAC4 soap_get___ns1__SymbolHistoryPeriodResponse__(struct soap *soap, struct __ns1__SymbolHistoryPeriodResponse__ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SymbolHistoryPeriodResponse__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__CountryListResponse__::__ns1__CountryListResponse__()
{
	soap_default___ns1__CountryListResponse__(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__CountryListResponse__(struct soap *soap, struct __ns1__CountryListResponse__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__CountryListResponse__(struct soap *soap, const struct __ns1__CountryListResponse__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__CountryListResponse__(struct soap *soap, const char *tag, int id, const struct __ns1__CountryListResponse__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CountryListResponse__ * SOAP_FMAC4 soap_in___ns1__CountryListResponse__(struct soap *soap, const char *tag, struct __ns1__CountryListResponse__ *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__CountryListResponse__ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__CountryListResponse__, sizeof(struct __ns1__CountryListResponse__), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__CountryListResponse__(soap, a);
	soap->error = SOAP_TAG_MISMATCH;
	a = NULL;
	return a;
}

SOAP_FMAC1 struct __ns1__CountryListResponse__ * SOAP_FMAC2 soap_instantiate___ns1__CountryListResponse__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__CountryListResponse__(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__CountryListResponse__ *p;
	size_t k = sizeof(struct __ns1__CountryListResponse__);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__CountryListResponse__);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__CountryListResponse__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__CountryListResponse__ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__CountryListResponse__, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__CountryListResponse__(struct soap *soap, const struct __ns1__CountryListResponse__ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__CountryListResponse__(soap, tag?tag:"-ns1:CountryListResponse", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CountryListResponse__ * SOAP_FMAC4 soap_get___ns1__CountryListResponse__(struct soap *soap, struct __ns1__CountryListResponse__ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__CountryListResponse__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__SplitListBySymbolResponse__::__ns1__SplitListBySymbolResponse__()
{
	soap_default___ns1__SplitListBySymbolResponse__(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SplitListBySymbolResponse__(struct soap *soap, struct __ns1__SplitListBySymbolResponse__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SplitListBySymbolResponse__(struct soap *soap, const struct __ns1__SplitListBySymbolResponse__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SplitListBySymbolResponse__(struct soap *soap, const char *tag, int id, const struct __ns1__SplitListBySymbolResponse__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SplitListBySymbolResponse__ * SOAP_FMAC4 soap_in___ns1__SplitListBySymbolResponse__(struct soap *soap, const char *tag, struct __ns1__SplitListBySymbolResponse__ *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SplitListBySymbolResponse__ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__SplitListBySymbolResponse__, sizeof(struct __ns1__SplitListBySymbolResponse__), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SplitListBySymbolResponse__(soap, a);
	soap->error = SOAP_TAG_MISMATCH;
	a = NULL;
	return a;
}

SOAP_FMAC1 struct __ns1__SplitListBySymbolResponse__ * SOAP_FMAC2 soap_instantiate___ns1__SplitListBySymbolResponse__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SplitListBySymbolResponse__(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SplitListBySymbolResponse__ *p;
	size_t k = sizeof(struct __ns1__SplitListBySymbolResponse__);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SplitListBySymbolResponse__);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SplitListBySymbolResponse__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SplitListBySymbolResponse__ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__SplitListBySymbolResponse__, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SplitListBySymbolResponse__(struct soap *soap, const struct __ns1__SplitListBySymbolResponse__ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SplitListBySymbolResponse__(soap, tag?tag:"-ns1:SplitListBySymbolResponse", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SplitListBySymbolResponse__ * SOAP_FMAC4 soap_get___ns1__SplitListBySymbolResponse__(struct soap *soap, struct __ns1__SplitListBySymbolResponse__ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SplitListBySymbolResponse__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__SplitListByExchangeResponse__::__ns1__SplitListByExchangeResponse__()
{
	soap_default___ns1__SplitListByExchangeResponse__(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SplitListByExchangeResponse__(struct soap *soap, struct __ns1__SplitListByExchangeResponse__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SplitListByExchangeResponse__(struct soap *soap, const struct __ns1__SplitListByExchangeResponse__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SplitListByExchangeResponse__(struct soap *soap, const char *tag, int id, const struct __ns1__SplitListByExchangeResponse__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SplitListByExchangeResponse__ * SOAP_FMAC4 soap_in___ns1__SplitListByExchangeResponse__(struct soap *soap, const char *tag, struct __ns1__SplitListByExchangeResponse__ *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SplitListByExchangeResponse__ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__SplitListByExchangeResponse__, sizeof(struct __ns1__SplitListByExchangeResponse__), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SplitListByExchangeResponse__(soap, a);
	soap->error = SOAP_TAG_MISMATCH;
	a = NULL;
	return a;
}

SOAP_FMAC1 struct __ns1__SplitListByExchangeResponse__ * SOAP_FMAC2 soap_instantiate___ns1__SplitListByExchangeResponse__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SplitListByExchangeResponse__(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SplitListByExchangeResponse__ *p;
	size_t k = sizeof(struct __ns1__SplitListByExchangeResponse__);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SplitListByExchangeResponse__);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SplitListByExchangeResponse__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SplitListByExchangeResponse__ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__SplitListByExchangeResponse__, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SplitListByExchangeResponse__(struct soap *soap, const struct __ns1__SplitListByExchangeResponse__ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SplitListByExchangeResponse__(soap, tag?tag:"-ns1:SplitListByExchangeResponse", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SplitListByExchangeResponse__ * SOAP_FMAC4 soap_get___ns1__SplitListByExchangeResponse__(struct soap *soap, struct __ns1__SplitListByExchangeResponse__ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SplitListByExchangeResponse__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__ExchangeMonthsResponse__::__ns1__ExchangeMonthsResponse__()
{
	soap_default___ns1__ExchangeMonthsResponse__(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ExchangeMonthsResponse__(struct soap *soap, struct __ns1__ExchangeMonthsResponse__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ExchangeMonthsResponse__(struct soap *soap, const struct __ns1__ExchangeMonthsResponse__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ExchangeMonthsResponse__(struct soap *soap, const char *tag, int id, const struct __ns1__ExchangeMonthsResponse__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ExchangeMonthsResponse__ * SOAP_FMAC4 soap_in___ns1__ExchangeMonthsResponse__(struct soap *soap, const char *tag, struct __ns1__ExchangeMonthsResponse__ *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ExchangeMonthsResponse__ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__ExchangeMonthsResponse__, sizeof(struct __ns1__ExchangeMonthsResponse__), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ExchangeMonthsResponse__(soap, a);
	soap->error = SOAP_TAG_MISMATCH;
	a = NULL;
	return a;
}

SOAP_FMAC1 struct __ns1__ExchangeMonthsResponse__ * SOAP_FMAC2 soap_instantiate___ns1__ExchangeMonthsResponse__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ExchangeMonthsResponse__(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ExchangeMonthsResponse__ *p;
	size_t k = sizeof(struct __ns1__ExchangeMonthsResponse__);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__ExchangeMonthsResponse__);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__ExchangeMonthsResponse__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ExchangeMonthsResponse__ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__ExchangeMonthsResponse__, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ExchangeMonthsResponse__(struct soap *soap, const struct __ns1__ExchangeMonthsResponse__ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ExchangeMonthsResponse__(soap, tag?tag:"-ns1:ExchangeMonthsResponse", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ExchangeMonthsResponse__ * SOAP_FMAC4 soap_get___ns1__ExchangeMonthsResponse__(struct soap *soap, struct __ns1__ExchangeMonthsResponse__ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ExchangeMonthsResponse__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__SymbolChartResponse__::__ns1__SymbolChartResponse__()
{
	soap_default___ns1__SymbolChartResponse__(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SymbolChartResponse__(struct soap *soap, struct __ns1__SymbolChartResponse__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SymbolChartResponse__(struct soap *soap, const struct __ns1__SymbolChartResponse__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SymbolChartResponse__(struct soap *soap, const char *tag, int id, const struct __ns1__SymbolChartResponse__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolChartResponse__ * SOAP_FMAC4 soap_in___ns1__SymbolChartResponse__(struct soap *soap, const char *tag, struct __ns1__SymbolChartResponse__ *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SymbolChartResponse__ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__SymbolChartResponse__, sizeof(struct __ns1__SymbolChartResponse__), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SymbolChartResponse__(soap, a);
	soap->error = SOAP_TAG_MISMATCH;
	a = NULL;
	return a;
}

SOAP_FMAC1 struct __ns1__SymbolChartResponse__ * SOAP_FMAC2 soap_instantiate___ns1__SymbolChartResponse__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SymbolChartResponse__(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SymbolChartResponse__ *p;
	size_t k = sizeof(struct __ns1__SymbolChartResponse__);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SymbolChartResponse__);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SymbolChartResponse__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SymbolChartResponse__ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__SymbolChartResponse__, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SymbolChartResponse__(struct soap *soap, const struct __ns1__SymbolChartResponse__ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SymbolChartResponse__(soap, tag?tag:"-ns1:SymbolChartResponse", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolChartResponse__ * SOAP_FMAC4 soap_get___ns1__SymbolChartResponse__(struct soap *soap, struct __ns1__SymbolChartResponse__ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SymbolChartResponse__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__Top10LossesResponse__::__ns1__Top10LossesResponse__()
{
	soap_default___ns1__Top10LossesResponse__(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Top10LossesResponse__(struct soap *soap, struct __ns1__Top10LossesResponse__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Top10LossesResponse__(struct soap *soap, const struct __ns1__Top10LossesResponse__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Top10LossesResponse__(struct soap *soap, const char *tag, int id, const struct __ns1__Top10LossesResponse__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Top10LossesResponse__ * SOAP_FMAC4 soap_in___ns1__Top10LossesResponse__(struct soap *soap, const char *tag, struct __ns1__Top10LossesResponse__ *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__Top10LossesResponse__ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__Top10LossesResponse__, sizeof(struct __ns1__Top10LossesResponse__), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Top10LossesResponse__(soap, a);
	soap->error = SOAP_TAG_MISMATCH;
	a = NULL;
	return a;
}

SOAP_FMAC1 struct __ns1__Top10LossesResponse__ * SOAP_FMAC2 soap_instantiate___ns1__Top10LossesResponse__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Top10LossesResponse__(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__Top10LossesResponse__ *p;
	size_t k = sizeof(struct __ns1__Top10LossesResponse__);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__Top10LossesResponse__);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__Top10LossesResponse__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__Top10LossesResponse__ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__Top10LossesResponse__, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Top10LossesResponse__(struct soap *soap, const struct __ns1__Top10LossesResponse__ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__Top10LossesResponse__(soap, tag?tag:"-ns1:Top10LossesResponse", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Top10LossesResponse__ * SOAP_FMAC4 soap_get___ns1__Top10LossesResponse__(struct soap *soap, struct __ns1__Top10LossesResponse__ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Top10LossesResponse__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__Top10GainsResponse__::__ns1__Top10GainsResponse__()
{
	soap_default___ns1__Top10GainsResponse__(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Top10GainsResponse__(struct soap *soap, struct __ns1__Top10GainsResponse__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Top10GainsResponse__(struct soap *soap, const struct __ns1__Top10GainsResponse__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Top10GainsResponse__(struct soap *soap, const char *tag, int id, const struct __ns1__Top10GainsResponse__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Top10GainsResponse__ * SOAP_FMAC4 soap_in___ns1__Top10GainsResponse__(struct soap *soap, const char *tag, struct __ns1__Top10GainsResponse__ *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__Top10GainsResponse__ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__Top10GainsResponse__, sizeof(struct __ns1__Top10GainsResponse__), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Top10GainsResponse__(soap, a);
	soap->error = SOAP_TAG_MISMATCH;
	a = NULL;
	return a;
}

SOAP_FMAC1 struct __ns1__Top10GainsResponse__ * SOAP_FMAC2 soap_instantiate___ns1__Top10GainsResponse__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Top10GainsResponse__(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__Top10GainsResponse__ *p;
	size_t k = sizeof(struct __ns1__Top10GainsResponse__);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__Top10GainsResponse__);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__Top10GainsResponse__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__Top10GainsResponse__ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__Top10GainsResponse__, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Top10GainsResponse__(struct soap *soap, const struct __ns1__Top10GainsResponse__ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__Top10GainsResponse__(soap, tag?tag:"-ns1:Top10GainsResponse", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Top10GainsResponse__ * SOAP_FMAC4 soap_get___ns1__Top10GainsResponse__(struct soap *soap, struct __ns1__Top10GainsResponse__ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Top10GainsResponse__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__SymbolHistoryResponse__::__ns1__SymbolHistoryResponse__()
{
	soap_default___ns1__SymbolHistoryResponse__(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SymbolHistoryResponse__(struct soap *soap, struct __ns1__SymbolHistoryResponse__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SymbolHistoryResponse__(struct soap *soap, const struct __ns1__SymbolHistoryResponse__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SymbolHistoryResponse__(struct soap *soap, const char *tag, int id, const struct __ns1__SymbolHistoryResponse__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolHistoryResponse__ * SOAP_FMAC4 soap_in___ns1__SymbolHistoryResponse__(struct soap *soap, const char *tag, struct __ns1__SymbolHistoryResponse__ *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SymbolHistoryResponse__ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__SymbolHistoryResponse__, sizeof(struct __ns1__SymbolHistoryResponse__), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SymbolHistoryResponse__(soap, a);
	soap->error = SOAP_TAG_MISMATCH;
	a = NULL;
	return a;
}

SOAP_FMAC1 struct __ns1__SymbolHistoryResponse__ * SOAP_FMAC2 soap_instantiate___ns1__SymbolHistoryResponse__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SymbolHistoryResponse__(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SymbolHistoryResponse__ *p;
	size_t k = sizeof(struct __ns1__SymbolHistoryResponse__);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SymbolHistoryResponse__);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SymbolHistoryResponse__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SymbolHistoryResponse__ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__SymbolHistoryResponse__, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SymbolHistoryResponse__(struct soap *soap, const struct __ns1__SymbolHistoryResponse__ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SymbolHistoryResponse__(soap, tag?tag:"-ns1:SymbolHistoryResponse", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolHistoryResponse__ * SOAP_FMAC4 soap_get___ns1__SymbolHistoryResponse__(struct soap *soap, struct __ns1__SymbolHistoryResponse__ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SymbolHistoryResponse__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__QuoteListByDate2Response__::__ns1__QuoteListByDate2Response__()
{
	soap_default___ns1__QuoteListByDate2Response__(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__QuoteListByDate2Response__(struct soap *soap, struct __ns1__QuoteListByDate2Response__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__QuoteListByDate2Response__(struct soap *soap, const struct __ns1__QuoteListByDate2Response__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__QuoteListByDate2Response__(struct soap *soap, const char *tag, int id, const struct __ns1__QuoteListByDate2Response__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QuoteListByDate2Response__ * SOAP_FMAC4 soap_in___ns1__QuoteListByDate2Response__(struct soap *soap, const char *tag, struct __ns1__QuoteListByDate2Response__ *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__QuoteListByDate2Response__ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__QuoteListByDate2Response__, sizeof(struct __ns1__QuoteListByDate2Response__), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__QuoteListByDate2Response__(soap, a);
	soap->error = SOAP_TAG_MISMATCH;
	a = NULL;
	return a;
}

SOAP_FMAC1 struct __ns1__QuoteListByDate2Response__ * SOAP_FMAC2 soap_instantiate___ns1__QuoteListByDate2Response__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__QuoteListByDate2Response__(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__QuoteListByDate2Response__ *p;
	size_t k = sizeof(struct __ns1__QuoteListByDate2Response__);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__QuoteListByDate2Response__);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__QuoteListByDate2Response__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__QuoteListByDate2Response__ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__QuoteListByDate2Response__, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__QuoteListByDate2Response__(struct soap *soap, const struct __ns1__QuoteListByDate2Response__ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__QuoteListByDate2Response__(soap, tag?tag:"-ns1:QuoteListByDate2Response", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QuoteListByDate2Response__ * SOAP_FMAC4 soap_get___ns1__QuoteListByDate2Response__(struct soap *soap, struct __ns1__QuoteListByDate2Response__ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__QuoteListByDate2Response__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__QuoteListByDateResponse__::__ns1__QuoteListByDateResponse__()
{
	soap_default___ns1__QuoteListByDateResponse__(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__QuoteListByDateResponse__(struct soap *soap, struct __ns1__QuoteListByDateResponse__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__QuoteListByDateResponse__(struct soap *soap, const struct __ns1__QuoteListByDateResponse__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__QuoteListByDateResponse__(struct soap *soap, const char *tag, int id, const struct __ns1__QuoteListByDateResponse__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QuoteListByDateResponse__ * SOAP_FMAC4 soap_in___ns1__QuoteListByDateResponse__(struct soap *soap, const char *tag, struct __ns1__QuoteListByDateResponse__ *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__QuoteListByDateResponse__ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__QuoteListByDateResponse__, sizeof(struct __ns1__QuoteListByDateResponse__), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__QuoteListByDateResponse__(soap, a);
	soap->error = SOAP_TAG_MISMATCH;
	a = NULL;
	return a;
}

SOAP_FMAC1 struct __ns1__QuoteListByDateResponse__ * SOAP_FMAC2 soap_instantiate___ns1__QuoteListByDateResponse__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__QuoteListByDateResponse__(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__QuoteListByDateResponse__ *p;
	size_t k = sizeof(struct __ns1__QuoteListByDateResponse__);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__QuoteListByDateResponse__);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__QuoteListByDateResponse__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__QuoteListByDateResponse__ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__QuoteListByDateResponse__, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__QuoteListByDateResponse__(struct soap *soap, const struct __ns1__QuoteListByDateResponse__ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__QuoteListByDateResponse__(soap, tag?tag:"-ns1:QuoteListByDateResponse", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QuoteListByDateResponse__ * SOAP_FMAC4 soap_get___ns1__QuoteListByDateResponse__(struct soap *soap, struct __ns1__QuoteListByDateResponse__ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__QuoteListByDateResponse__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__TechnicalListResponse__::__ns1__TechnicalListResponse__()
{
	soap_default___ns1__TechnicalListResponse__(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__TechnicalListResponse__(struct soap *soap, struct __ns1__TechnicalListResponse__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__TechnicalListResponse__(struct soap *soap, const struct __ns1__TechnicalListResponse__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__TechnicalListResponse__(struct soap *soap, const char *tag, int id, const struct __ns1__TechnicalListResponse__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__TechnicalListResponse__ * SOAP_FMAC4 soap_in___ns1__TechnicalListResponse__(struct soap *soap, const char *tag, struct __ns1__TechnicalListResponse__ *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__TechnicalListResponse__ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__TechnicalListResponse__, sizeof(struct __ns1__TechnicalListResponse__), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__TechnicalListResponse__(soap, a);
	soap->error = SOAP_TAG_MISMATCH;
	a = NULL;
	return a;
}

SOAP_FMAC1 struct __ns1__TechnicalListResponse__ * SOAP_FMAC2 soap_instantiate___ns1__TechnicalListResponse__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__TechnicalListResponse__(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__TechnicalListResponse__ *p;
	size_t k = sizeof(struct __ns1__TechnicalListResponse__);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__TechnicalListResponse__);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__TechnicalListResponse__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__TechnicalListResponse__ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__TechnicalListResponse__, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__TechnicalListResponse__(struct soap *soap, const struct __ns1__TechnicalListResponse__ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__TechnicalListResponse__(soap, tag?tag:"-ns1:TechnicalListResponse", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__TechnicalListResponse__ * SOAP_FMAC4 soap_get___ns1__TechnicalListResponse__(struct soap *soap, struct __ns1__TechnicalListResponse__ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__TechnicalListResponse__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__FundamentalListResponse__::__ns1__FundamentalListResponse__()
{
	soap_default___ns1__FundamentalListResponse__(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__FundamentalListResponse__(struct soap *soap, struct __ns1__FundamentalListResponse__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__FundamentalListResponse__(struct soap *soap, const struct __ns1__FundamentalListResponse__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__FundamentalListResponse__(struct soap *soap, const char *tag, int id, const struct __ns1__FundamentalListResponse__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__FundamentalListResponse__ * SOAP_FMAC4 soap_in___ns1__FundamentalListResponse__(struct soap *soap, const char *tag, struct __ns1__FundamentalListResponse__ *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__FundamentalListResponse__ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__FundamentalListResponse__, sizeof(struct __ns1__FundamentalListResponse__), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__FundamentalListResponse__(soap, a);
	soap->error = SOAP_TAG_MISMATCH;
	a = NULL;
	return a;
}

SOAP_FMAC1 struct __ns1__FundamentalListResponse__ * SOAP_FMAC2 soap_instantiate___ns1__FundamentalListResponse__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__FundamentalListResponse__(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__FundamentalListResponse__ *p;
	size_t k = sizeof(struct __ns1__FundamentalListResponse__);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__FundamentalListResponse__);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__FundamentalListResponse__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__FundamentalListResponse__ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__FundamentalListResponse__, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__FundamentalListResponse__(struct soap *soap, const struct __ns1__FundamentalListResponse__ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__FundamentalListResponse__(soap, tag?tag:"-ns1:FundamentalListResponse", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__FundamentalListResponse__ * SOAP_FMAC4 soap_get___ns1__FundamentalListResponse__(struct soap *soap, struct __ns1__FundamentalListResponse__ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__FundamentalListResponse__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__NewsListBySymbolResponse__::__ns1__NewsListBySymbolResponse__()
{
	soap_default___ns1__NewsListBySymbolResponse__(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__NewsListBySymbolResponse__(struct soap *soap, struct __ns1__NewsListBySymbolResponse__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__NewsListBySymbolResponse__(struct soap *soap, const struct __ns1__NewsListBySymbolResponse__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__NewsListBySymbolResponse__(struct soap *soap, const char *tag, int id, const struct __ns1__NewsListBySymbolResponse__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__NewsListBySymbolResponse__ * SOAP_FMAC4 soap_in___ns1__NewsListBySymbolResponse__(struct soap *soap, const char *tag, struct __ns1__NewsListBySymbolResponse__ *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__NewsListBySymbolResponse__ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__NewsListBySymbolResponse__, sizeof(struct __ns1__NewsListBySymbolResponse__), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__NewsListBySymbolResponse__(soap, a);
	soap->error = SOAP_TAG_MISMATCH;
	a = NULL;
	return a;
}

SOAP_FMAC1 struct __ns1__NewsListBySymbolResponse__ * SOAP_FMAC2 soap_instantiate___ns1__NewsListBySymbolResponse__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__NewsListBySymbolResponse__(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__NewsListBySymbolResponse__ *p;
	size_t k = sizeof(struct __ns1__NewsListBySymbolResponse__);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__NewsListBySymbolResponse__);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__NewsListBySymbolResponse__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__NewsListBySymbolResponse__ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__NewsListBySymbolResponse__, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__NewsListBySymbolResponse__(struct soap *soap, const struct __ns1__NewsListBySymbolResponse__ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__NewsListBySymbolResponse__(soap, tag?tag:"-ns1:NewsListBySymbolResponse", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__NewsListBySymbolResponse__ * SOAP_FMAC4 soap_get___ns1__NewsListBySymbolResponse__(struct soap *soap, struct __ns1__NewsListBySymbolResponse__ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__NewsListBySymbolResponse__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__NewsListResponse__::__ns1__NewsListResponse__()
{
	soap_default___ns1__NewsListResponse__(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__NewsListResponse__(struct soap *soap, struct __ns1__NewsListResponse__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__NewsListResponse__(struct soap *soap, const struct __ns1__NewsListResponse__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__NewsListResponse__(struct soap *soap, const char *tag, int id, const struct __ns1__NewsListResponse__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__NewsListResponse__ * SOAP_FMAC4 soap_in___ns1__NewsListResponse__(struct soap *soap, const char *tag, struct __ns1__NewsListResponse__ *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__NewsListResponse__ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__NewsListResponse__, sizeof(struct __ns1__NewsListResponse__), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__NewsListResponse__(soap, a);
	soap->error = SOAP_TAG_MISMATCH;
	a = NULL;
	return a;
}

SOAP_FMAC1 struct __ns1__NewsListResponse__ * SOAP_FMAC2 soap_instantiate___ns1__NewsListResponse__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__NewsListResponse__(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__NewsListResponse__ *p;
	size_t k = sizeof(struct __ns1__NewsListResponse__);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__NewsListResponse__);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__NewsListResponse__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__NewsListResponse__ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__NewsListResponse__, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__NewsListResponse__(struct soap *soap, const struct __ns1__NewsListResponse__ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__NewsListResponse__(soap, tag?tag:"-ns1:NewsListResponse", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__NewsListResponse__ * SOAP_FMAC4 soap_get___ns1__NewsListResponse__(struct soap *soap, struct __ns1__NewsListResponse__ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__NewsListResponse__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__QuoteListResponse__::__ns1__QuoteListResponse__()
{
	soap_default___ns1__QuoteListResponse__(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__QuoteListResponse__(struct soap *soap, struct __ns1__QuoteListResponse__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__QuoteListResponse__(struct soap *soap, const struct __ns1__QuoteListResponse__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__QuoteListResponse__(struct soap *soap, const char *tag, int id, const struct __ns1__QuoteListResponse__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QuoteListResponse__ * SOAP_FMAC4 soap_in___ns1__QuoteListResponse__(struct soap *soap, const char *tag, struct __ns1__QuoteListResponse__ *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__QuoteListResponse__ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__QuoteListResponse__, sizeof(struct __ns1__QuoteListResponse__), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__QuoteListResponse__(soap, a);
	soap->error = SOAP_TAG_MISMATCH;
	a = NULL;
	return a;
}

SOAP_FMAC1 struct __ns1__QuoteListResponse__ * SOAP_FMAC2 soap_instantiate___ns1__QuoteListResponse__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__QuoteListResponse__(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__QuoteListResponse__ *p;
	size_t k = sizeof(struct __ns1__QuoteListResponse__);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__QuoteListResponse__);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__QuoteListResponse__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__QuoteListResponse__ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__QuoteListResponse__, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__QuoteListResponse__(struct soap *soap, const struct __ns1__QuoteListResponse__ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__QuoteListResponse__(soap, tag?tag:"-ns1:QuoteListResponse", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QuoteListResponse__ * SOAP_FMAC4 soap_get___ns1__QuoteListResponse__(struct soap *soap, struct __ns1__QuoteListResponse__ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__QuoteListResponse__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__SymbolGetResponse__::__ns1__SymbolGetResponse__()
{
	soap_default___ns1__SymbolGetResponse__(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SymbolGetResponse__(struct soap *soap, struct __ns1__SymbolGetResponse__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SymbolGetResponse__(struct soap *soap, const struct __ns1__SymbolGetResponse__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SymbolGetResponse__(struct soap *soap, const char *tag, int id, const struct __ns1__SymbolGetResponse__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolGetResponse__ * SOAP_FMAC4 soap_in___ns1__SymbolGetResponse__(struct soap *soap, const char *tag, struct __ns1__SymbolGetResponse__ *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SymbolGetResponse__ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__SymbolGetResponse__, sizeof(struct __ns1__SymbolGetResponse__), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SymbolGetResponse__(soap, a);
	soap->error = SOAP_TAG_MISMATCH;
	a = NULL;
	return a;
}

SOAP_FMAC1 struct __ns1__SymbolGetResponse__ * SOAP_FMAC2 soap_instantiate___ns1__SymbolGetResponse__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SymbolGetResponse__(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SymbolGetResponse__ *p;
	size_t k = sizeof(struct __ns1__SymbolGetResponse__);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SymbolGetResponse__);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SymbolGetResponse__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SymbolGetResponse__ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__SymbolGetResponse__, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SymbolGetResponse__(struct soap *soap, const struct __ns1__SymbolGetResponse__ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SymbolGetResponse__(soap, tag?tag:"-ns1:SymbolGetResponse", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolGetResponse__ * SOAP_FMAC4 soap_get___ns1__SymbolGetResponse__(struct soap *soap, struct __ns1__SymbolGetResponse__ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SymbolGetResponse__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__QuoteList2Response__::__ns1__QuoteList2Response__()
{
	soap_default___ns1__QuoteList2Response__(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__QuoteList2Response__(struct soap *soap, struct __ns1__QuoteList2Response__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__QuoteList2Response__(struct soap *soap, const struct __ns1__QuoteList2Response__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__QuoteList2Response__(struct soap *soap, const char *tag, int id, const struct __ns1__QuoteList2Response__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QuoteList2Response__ * SOAP_FMAC4 soap_in___ns1__QuoteList2Response__(struct soap *soap, const char *tag, struct __ns1__QuoteList2Response__ *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__QuoteList2Response__ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__QuoteList2Response__, sizeof(struct __ns1__QuoteList2Response__), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__QuoteList2Response__(soap, a);
	soap->error = SOAP_TAG_MISMATCH;
	a = NULL;
	return a;
}

SOAP_FMAC1 struct __ns1__QuoteList2Response__ * SOAP_FMAC2 soap_instantiate___ns1__QuoteList2Response__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__QuoteList2Response__(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__QuoteList2Response__ *p;
	size_t k = sizeof(struct __ns1__QuoteList2Response__);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__QuoteList2Response__);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__QuoteList2Response__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__QuoteList2Response__ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__QuoteList2Response__, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__QuoteList2Response__(struct soap *soap, const struct __ns1__QuoteList2Response__ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__QuoteList2Response__(soap, tag?tag:"-ns1:QuoteList2Response", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QuoteList2Response__ * SOAP_FMAC4 soap_get___ns1__QuoteList2Response__(struct soap *soap, struct __ns1__QuoteList2Response__ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__QuoteList2Response__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__QuoteGetResponse__::__ns1__QuoteGetResponse__()
{
	soap_default___ns1__QuoteGetResponse__(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__QuoteGetResponse__(struct soap *soap, struct __ns1__QuoteGetResponse__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__QuoteGetResponse__(struct soap *soap, const struct __ns1__QuoteGetResponse__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__QuoteGetResponse__(struct soap *soap, const char *tag, int id, const struct __ns1__QuoteGetResponse__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QuoteGetResponse__ * SOAP_FMAC4 soap_in___ns1__QuoteGetResponse__(struct soap *soap, const char *tag, struct __ns1__QuoteGetResponse__ *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__QuoteGetResponse__ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__QuoteGetResponse__, sizeof(struct __ns1__QuoteGetResponse__), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__QuoteGetResponse__(soap, a);
	soap->error = SOAP_TAG_MISMATCH;
	a = NULL;
	return a;
}

SOAP_FMAC1 struct __ns1__QuoteGetResponse__ * SOAP_FMAC2 soap_instantiate___ns1__QuoteGetResponse__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__QuoteGetResponse__(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__QuoteGetResponse__ *p;
	size_t k = sizeof(struct __ns1__QuoteGetResponse__);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__QuoteGetResponse__);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__QuoteGetResponse__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__QuoteGetResponse__ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__QuoteGetResponse__, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__QuoteGetResponse__(struct soap *soap, const struct __ns1__QuoteGetResponse__ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__QuoteGetResponse__(soap, tag?tag:"-ns1:QuoteGetResponse", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QuoteGetResponse__ * SOAP_FMAC4 soap_get___ns1__QuoteGetResponse__(struct soap *soap, struct __ns1__QuoteGetResponse__ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__QuoteGetResponse__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__SymbolList2Response__::__ns1__SymbolList2Response__()
{
	soap_default___ns1__SymbolList2Response__(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SymbolList2Response__(struct soap *soap, struct __ns1__SymbolList2Response__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SymbolList2Response__(struct soap *soap, const struct __ns1__SymbolList2Response__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SymbolList2Response__(struct soap *soap, const char *tag, int id, const struct __ns1__SymbolList2Response__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolList2Response__ * SOAP_FMAC4 soap_in___ns1__SymbolList2Response__(struct soap *soap, const char *tag, struct __ns1__SymbolList2Response__ *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SymbolList2Response__ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__SymbolList2Response__, sizeof(struct __ns1__SymbolList2Response__), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SymbolList2Response__(soap, a);
	soap->error = SOAP_TAG_MISMATCH;
	a = NULL;
	return a;
}

SOAP_FMAC1 struct __ns1__SymbolList2Response__ * SOAP_FMAC2 soap_instantiate___ns1__SymbolList2Response__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SymbolList2Response__(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SymbolList2Response__ *p;
	size_t k = sizeof(struct __ns1__SymbolList2Response__);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SymbolList2Response__);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SymbolList2Response__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SymbolList2Response__ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__SymbolList2Response__, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SymbolList2Response__(struct soap *soap, const struct __ns1__SymbolList2Response__ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SymbolList2Response__(soap, tag?tag:"-ns1:SymbolList2Response", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolList2Response__ * SOAP_FMAC4 soap_get___ns1__SymbolList2Response__(struct soap *soap, struct __ns1__SymbolList2Response__ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SymbolList2Response__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__SymbolListResponse__::__ns1__SymbolListResponse__()
{
	soap_default___ns1__SymbolListResponse__(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SymbolListResponse__(struct soap *soap, struct __ns1__SymbolListResponse__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SymbolListResponse__(struct soap *soap, const struct __ns1__SymbolListResponse__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SymbolListResponse__(struct soap *soap, const char *tag, int id, const struct __ns1__SymbolListResponse__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolListResponse__ * SOAP_FMAC4 soap_in___ns1__SymbolListResponse__(struct soap *soap, const char *tag, struct __ns1__SymbolListResponse__ *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SymbolListResponse__ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__SymbolListResponse__, sizeof(struct __ns1__SymbolListResponse__), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SymbolListResponse__(soap, a);
	soap->error = SOAP_TAG_MISMATCH;
	a = NULL;
	return a;
}

SOAP_FMAC1 struct __ns1__SymbolListResponse__ * SOAP_FMAC2 soap_instantiate___ns1__SymbolListResponse__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SymbolListResponse__(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SymbolListResponse__ *p;
	size_t k = sizeof(struct __ns1__SymbolListResponse__);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SymbolListResponse__);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SymbolListResponse__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SymbolListResponse__ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__SymbolListResponse__, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SymbolListResponse__(struct soap *soap, const struct __ns1__SymbolListResponse__ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SymbolListResponse__(soap, tag?tag:"-ns1:SymbolListResponse", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolListResponse__ * SOAP_FMAC4 soap_get___ns1__SymbolListResponse__(struct soap *soap, struct __ns1__SymbolListResponse__ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SymbolListResponse__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__ExchangeGetResponse__::__ns1__ExchangeGetResponse__()
{
	soap_default___ns1__ExchangeGetResponse__(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ExchangeGetResponse__(struct soap *soap, struct __ns1__ExchangeGetResponse__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ExchangeGetResponse__(struct soap *soap, const struct __ns1__ExchangeGetResponse__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ExchangeGetResponse__(struct soap *soap, const char *tag, int id, const struct __ns1__ExchangeGetResponse__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ExchangeGetResponse__ * SOAP_FMAC4 soap_in___ns1__ExchangeGetResponse__(struct soap *soap, const char *tag, struct __ns1__ExchangeGetResponse__ *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ExchangeGetResponse__ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__ExchangeGetResponse__, sizeof(struct __ns1__ExchangeGetResponse__), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ExchangeGetResponse__(soap, a);
	soap->error = SOAP_TAG_MISMATCH;
	a = NULL;
	return a;
}

SOAP_FMAC1 struct __ns1__ExchangeGetResponse__ * SOAP_FMAC2 soap_instantiate___ns1__ExchangeGetResponse__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ExchangeGetResponse__(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ExchangeGetResponse__ *p;
	size_t k = sizeof(struct __ns1__ExchangeGetResponse__);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__ExchangeGetResponse__);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__ExchangeGetResponse__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ExchangeGetResponse__ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__ExchangeGetResponse__, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ExchangeGetResponse__(struct soap *soap, const struct __ns1__ExchangeGetResponse__ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ExchangeGetResponse__(soap, tag?tag:"-ns1:ExchangeGetResponse", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ExchangeGetResponse__ * SOAP_FMAC4 soap_get___ns1__ExchangeGetResponse__(struct soap *soap, struct __ns1__ExchangeGetResponse__ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ExchangeGetResponse__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__ExchangeListResponse__::__ns1__ExchangeListResponse__()
{
	soap_default___ns1__ExchangeListResponse__(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ExchangeListResponse__(struct soap *soap, struct __ns1__ExchangeListResponse__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ExchangeListResponse__(struct soap *soap, const struct __ns1__ExchangeListResponse__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ExchangeListResponse__(struct soap *soap, const char *tag, int id, const struct __ns1__ExchangeListResponse__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ExchangeListResponse__ * SOAP_FMAC4 soap_in___ns1__ExchangeListResponse__(struct soap *soap, const char *tag, struct __ns1__ExchangeListResponse__ *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ExchangeListResponse__ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__ExchangeListResponse__, sizeof(struct __ns1__ExchangeListResponse__), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ExchangeListResponse__(soap, a);
	soap->error = SOAP_TAG_MISMATCH;
	a = NULL;
	return a;
}

SOAP_FMAC1 struct __ns1__ExchangeListResponse__ * SOAP_FMAC2 soap_instantiate___ns1__ExchangeListResponse__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ExchangeListResponse__(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ExchangeListResponse__ *p;
	size_t k = sizeof(struct __ns1__ExchangeListResponse__);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__ExchangeListResponse__);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__ExchangeListResponse__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ExchangeListResponse__ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__ExchangeListResponse__, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ExchangeListResponse__(struct soap *soap, const struct __ns1__ExchangeListResponse__ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ExchangeListResponse__(soap, tag?tag:"-ns1:ExchangeListResponse", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ExchangeListResponse__ * SOAP_FMAC4 soap_get___ns1__ExchangeListResponse__(struct soap *soap, struct __ns1__ExchangeListResponse__ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ExchangeListResponse__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__MembershipResponse__::__ns1__MembershipResponse__()
{
	soap_default___ns1__MembershipResponse__(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__MembershipResponse__(struct soap *soap, struct __ns1__MembershipResponse__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__MembershipResponse__(struct soap *soap, const struct __ns1__MembershipResponse__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__MembershipResponse__(struct soap *soap, const char *tag, int id, const struct __ns1__MembershipResponse__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__MembershipResponse__ * SOAP_FMAC4 soap_in___ns1__MembershipResponse__(struct soap *soap, const char *tag, struct __ns1__MembershipResponse__ *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__MembershipResponse__ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__MembershipResponse__, sizeof(struct __ns1__MembershipResponse__), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__MembershipResponse__(soap, a);
	soap->error = SOAP_TAG_MISMATCH;
	a = NULL;
	return a;
}

SOAP_FMAC1 struct __ns1__MembershipResponse__ * SOAP_FMAC2 soap_instantiate___ns1__MembershipResponse__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__MembershipResponse__(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__MembershipResponse__ *p;
	size_t k = sizeof(struct __ns1__MembershipResponse__);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__MembershipResponse__);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__MembershipResponse__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__MembershipResponse__ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__MembershipResponse__, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__MembershipResponse__(struct soap *soap, const struct __ns1__MembershipResponse__ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__MembershipResponse__(soap, tag?tag:"-ns1:MembershipResponse", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__MembershipResponse__ * SOAP_FMAC4 soap_get___ns1__MembershipResponse__(struct soap *soap, struct __ns1__MembershipResponse__ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__MembershipResponse__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__Login2Response__::__ns1__Login2Response__()
{
	soap_default___ns1__Login2Response__(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Login2Response__(struct soap *soap, struct __ns1__Login2Response__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Login2Response__(struct soap *soap, const struct __ns1__Login2Response__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Login2Response__(struct soap *soap, const char *tag, int id, const struct __ns1__Login2Response__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Login2Response__ * SOAP_FMAC4 soap_in___ns1__Login2Response__(struct soap *soap, const char *tag, struct __ns1__Login2Response__ *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__Login2Response__ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__Login2Response__, sizeof(struct __ns1__Login2Response__), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Login2Response__(soap, a);
	soap->error = SOAP_TAG_MISMATCH;
	a = NULL;
	return a;
}

SOAP_FMAC1 struct __ns1__Login2Response__ * SOAP_FMAC2 soap_instantiate___ns1__Login2Response__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Login2Response__(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__Login2Response__ *p;
	size_t k = sizeof(struct __ns1__Login2Response__);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__Login2Response__);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__Login2Response__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__Login2Response__ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__Login2Response__, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Login2Response__(struct soap *soap, const struct __ns1__Login2Response__ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__Login2Response__(soap, tag?tag:"-ns1:Login2Response", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Login2Response__ * SOAP_FMAC4 soap_get___ns1__Login2Response__(struct soap *soap, struct __ns1__Login2Response__ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Login2Response__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__LoginResponse__::__ns1__LoginResponse__()
{
	soap_default___ns1__LoginResponse__(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__LoginResponse__(struct soap *soap, struct __ns1__LoginResponse__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__LoginResponse__(struct soap *soap, const struct __ns1__LoginResponse__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__LoginResponse__(struct soap *soap, const char *tag, int id, const struct __ns1__LoginResponse__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__LoginResponse__ * SOAP_FMAC4 soap_in___ns1__LoginResponse__(struct soap *soap, const char *tag, struct __ns1__LoginResponse__ *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__LoginResponse__ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__LoginResponse__, sizeof(struct __ns1__LoginResponse__), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__LoginResponse__(soap, a);
	soap->error = SOAP_TAG_MISMATCH;
	a = NULL;
	return a;
}

SOAP_FMAC1 struct __ns1__LoginResponse__ * SOAP_FMAC2 soap_instantiate___ns1__LoginResponse__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__LoginResponse__(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__LoginResponse__ *p;
	size_t k = sizeof(struct __ns1__LoginResponse__);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__LoginResponse__);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__LoginResponse__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__LoginResponse__ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__LoginResponse__, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__LoginResponse__(struct soap *soap, const struct __ns1__LoginResponse__ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__LoginResponse__(soap, tag?tag:"-ns1:LoginResponse", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__LoginResponse__ * SOAP_FMAC4 soap_get___ns1__LoginResponse__(struct soap *soap, struct __ns1__LoginResponse__ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__LoginResponse__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__ValidateAccess_::__ns1__ValidateAccess_()
{
	soap_default___ns1__ValidateAccess_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ValidateAccess_(struct soap *soap, struct __ns1__ValidateAccess_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ValidateAccess = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ValidateAccess_(struct soap *soap, const struct __ns1__ValidateAccess_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__ValidateAccess(soap, &a->ns1__ValidateAccess);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ValidateAccess_(struct soap *soap, const char *tag, int id, const struct __ns1__ValidateAccess_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__ValidateAccess(soap, "ns1:ValidateAccess", -1, &a->ns1__ValidateAccess, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ValidateAccess_ * SOAP_FMAC4 soap_in___ns1__ValidateAccess_(struct soap *soap, const char *tag, struct __ns1__ValidateAccess_ *a, const char *type)
{
	size_t soap_flag_ns1__ValidateAccess = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ValidateAccess_ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__ValidateAccess_, sizeof(struct __ns1__ValidateAccess_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ValidateAccess_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ValidateAccess && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__ValidateAccess(soap, "ns1:ValidateAccess", &a->ns1__ValidateAccess, ""))
				{	soap_flag_ns1__ValidateAccess--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ValidateAccess_ * SOAP_FMAC2 soap_instantiate___ns1__ValidateAccess_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ValidateAccess_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ValidateAccess_ *p;
	size_t k = sizeof(struct __ns1__ValidateAccess_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__ValidateAccess_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__ValidateAccess_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ValidateAccess_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__ValidateAccess_, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ValidateAccess_(struct soap *soap, const struct __ns1__ValidateAccess_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ValidateAccess_(soap, tag?tag:"-ns1:ValidateAccess", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ValidateAccess_ * SOAP_FMAC4 soap_get___ns1__ValidateAccess_(struct soap *soap, struct __ns1__ValidateAccess_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ValidateAccess_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__UpdateDataFormat_::__ns1__UpdateDataFormat_()
{
	soap_default___ns1__UpdateDataFormat_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__UpdateDataFormat_(struct soap *soap, struct __ns1__UpdateDataFormat_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UpdateDataFormat = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__UpdateDataFormat_(struct soap *soap, const struct __ns1__UpdateDataFormat_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__UpdateDataFormat(soap, &a->ns1__UpdateDataFormat);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__UpdateDataFormat_(struct soap *soap, const char *tag, int id, const struct __ns1__UpdateDataFormat_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__UpdateDataFormat(soap, "ns1:UpdateDataFormat", -1, &a->ns1__UpdateDataFormat, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UpdateDataFormat_ * SOAP_FMAC4 soap_in___ns1__UpdateDataFormat_(struct soap *soap, const char *tag, struct __ns1__UpdateDataFormat_ *a, const char *type)
{
	size_t soap_flag_ns1__UpdateDataFormat = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__UpdateDataFormat_ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__UpdateDataFormat_, sizeof(struct __ns1__UpdateDataFormat_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__UpdateDataFormat_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UpdateDataFormat && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__UpdateDataFormat(soap, "ns1:UpdateDataFormat", &a->ns1__UpdateDataFormat, ""))
				{	soap_flag_ns1__UpdateDataFormat--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__UpdateDataFormat_ * SOAP_FMAC2 soap_instantiate___ns1__UpdateDataFormat_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__UpdateDataFormat_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__UpdateDataFormat_ *p;
	size_t k = sizeof(struct __ns1__UpdateDataFormat_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__UpdateDataFormat_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__UpdateDataFormat_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__UpdateDataFormat_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__UpdateDataFormat_, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__UpdateDataFormat_(struct soap *soap, const struct __ns1__UpdateDataFormat_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__UpdateDataFormat_(soap, tag?tag:"-ns1:UpdateDataFormat", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UpdateDataFormat_ * SOAP_FMAC4 soap_get___ns1__UpdateDataFormat_(struct soap *soap, struct __ns1__UpdateDataFormat_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__UpdateDataFormat_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__DataFormats_::__ns1__DataFormats_()
{
	soap_default___ns1__DataFormats_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__DataFormats_(struct soap *soap, struct __ns1__DataFormats_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__DataFormats = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__DataFormats_(struct soap *soap, const struct __ns1__DataFormats_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__DataFormats(soap, &a->ns1__DataFormats);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__DataFormats_(struct soap *soap, const char *tag, int id, const struct __ns1__DataFormats_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__DataFormats(soap, "ns1:DataFormats", -1, &a->ns1__DataFormats, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DataFormats_ * SOAP_FMAC4 soap_in___ns1__DataFormats_(struct soap *soap, const char *tag, struct __ns1__DataFormats_ *a, const char *type)
{
	size_t soap_flag_ns1__DataFormats = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__DataFormats_ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__DataFormats_, sizeof(struct __ns1__DataFormats_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__DataFormats_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__DataFormats && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__DataFormats(soap, "ns1:DataFormats", &a->ns1__DataFormats, ""))
				{	soap_flag_ns1__DataFormats--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__DataFormats_ * SOAP_FMAC2 soap_instantiate___ns1__DataFormats_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__DataFormats_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__DataFormats_ *p;
	size_t k = sizeof(struct __ns1__DataFormats_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__DataFormats_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__DataFormats_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__DataFormats_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__DataFormats_, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__DataFormats_(struct soap *soap, const struct __ns1__DataFormats_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__DataFormats_(soap, tag?tag:"-ns1:DataFormats", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DataFormats_ * SOAP_FMAC4 soap_get___ns1__DataFormats_(struct soap *soap, struct __ns1__DataFormats_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__DataFormats_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__DataClientLatestVersion_::__ns1__DataClientLatestVersion_()
{
	soap_default___ns1__DataClientLatestVersion_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__DataClientLatestVersion_(struct soap *soap, struct __ns1__DataClientLatestVersion_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__DataClientLatestVersion = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__DataClientLatestVersion_(struct soap *soap, const struct __ns1__DataClientLatestVersion_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__DataClientLatestVersion(soap, &a->ns1__DataClientLatestVersion);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__DataClientLatestVersion_(struct soap *soap, const char *tag, int id, const struct __ns1__DataClientLatestVersion_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__DataClientLatestVersion(soap, "ns1:DataClientLatestVersion", -1, &a->ns1__DataClientLatestVersion, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DataClientLatestVersion_ * SOAP_FMAC4 soap_in___ns1__DataClientLatestVersion_(struct soap *soap, const char *tag, struct __ns1__DataClientLatestVersion_ *a, const char *type)
{
	size_t soap_flag_ns1__DataClientLatestVersion = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__DataClientLatestVersion_ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__DataClientLatestVersion_, sizeof(struct __ns1__DataClientLatestVersion_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__DataClientLatestVersion_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__DataClientLatestVersion && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__DataClientLatestVersion(soap, "ns1:DataClientLatestVersion", &a->ns1__DataClientLatestVersion, ""))
				{	soap_flag_ns1__DataClientLatestVersion--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__DataClientLatestVersion_ * SOAP_FMAC2 soap_instantiate___ns1__DataClientLatestVersion_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__DataClientLatestVersion_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__DataClientLatestVersion_ *p;
	size_t k = sizeof(struct __ns1__DataClientLatestVersion_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__DataClientLatestVersion_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__DataClientLatestVersion_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__DataClientLatestVersion_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__DataClientLatestVersion_, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__DataClientLatestVersion_(struct soap *soap, const struct __ns1__DataClientLatestVersion_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__DataClientLatestVersion_(soap, tag?tag:"-ns1:DataClientLatestVersion", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DataClientLatestVersion_ * SOAP_FMAC4 soap_get___ns1__DataClientLatestVersion_(struct soap *soap, struct __ns1__DataClientLatestVersion_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__DataClientLatestVersion_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__SymbolChangesByExchange_::__ns1__SymbolChangesByExchange_()
{
	soap_default___ns1__SymbolChangesByExchange_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SymbolChangesByExchange_(struct soap *soap, struct __ns1__SymbolChangesByExchange_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SymbolChangesByExchange = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SymbolChangesByExchange_(struct soap *soap, const struct __ns1__SymbolChangesByExchange_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SymbolChangesByExchange(soap, &a->ns1__SymbolChangesByExchange);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SymbolChangesByExchange_(struct soap *soap, const char *tag, int id, const struct __ns1__SymbolChangesByExchange_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SymbolChangesByExchange(soap, "ns1:SymbolChangesByExchange", -1, &a->ns1__SymbolChangesByExchange, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolChangesByExchange_ * SOAP_FMAC4 soap_in___ns1__SymbolChangesByExchange_(struct soap *soap, const char *tag, struct __ns1__SymbolChangesByExchange_ *a, const char *type)
{
	size_t soap_flag_ns1__SymbolChangesByExchange = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SymbolChangesByExchange_ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__SymbolChangesByExchange_, sizeof(struct __ns1__SymbolChangesByExchange_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SymbolChangesByExchange_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SymbolChangesByExchange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SymbolChangesByExchange(soap, "ns1:SymbolChangesByExchange", &a->ns1__SymbolChangesByExchange, ""))
				{	soap_flag_ns1__SymbolChangesByExchange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SymbolChangesByExchange_ * SOAP_FMAC2 soap_instantiate___ns1__SymbolChangesByExchange_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SymbolChangesByExchange_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SymbolChangesByExchange_ *p;
	size_t k = sizeof(struct __ns1__SymbolChangesByExchange_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SymbolChangesByExchange_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SymbolChangesByExchange_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SymbolChangesByExchange_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__SymbolChangesByExchange_, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SymbolChangesByExchange_(struct soap *soap, const struct __ns1__SymbolChangesByExchange_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SymbolChangesByExchange_(soap, tag?tag:"-ns1:SymbolChangesByExchange", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolChangesByExchange_ * SOAP_FMAC4 soap_get___ns1__SymbolChangesByExchange_(struct soap *soap, struct __ns1__SymbolChangesByExchange_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SymbolChangesByExchange_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__QuoteListByDatePeriod2_::__ns1__QuoteListByDatePeriod2_()
{
	soap_default___ns1__QuoteListByDatePeriod2_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__QuoteListByDatePeriod2_(struct soap *soap, struct __ns1__QuoteListByDatePeriod2_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__QuoteListByDatePeriod2 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__QuoteListByDatePeriod2_(struct soap *soap, const struct __ns1__QuoteListByDatePeriod2_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__QuoteListByDatePeriod2(soap, &a->ns1__QuoteListByDatePeriod2);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__QuoteListByDatePeriod2_(struct soap *soap, const char *tag, int id, const struct __ns1__QuoteListByDatePeriod2_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__QuoteListByDatePeriod2(soap, "ns1:QuoteListByDatePeriod2", -1, &a->ns1__QuoteListByDatePeriod2, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QuoteListByDatePeriod2_ * SOAP_FMAC4 soap_in___ns1__QuoteListByDatePeriod2_(struct soap *soap, const char *tag, struct __ns1__QuoteListByDatePeriod2_ *a, const char *type)
{
	size_t soap_flag_ns1__QuoteListByDatePeriod2 = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__QuoteListByDatePeriod2_ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__QuoteListByDatePeriod2_, sizeof(struct __ns1__QuoteListByDatePeriod2_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__QuoteListByDatePeriod2_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__QuoteListByDatePeriod2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__QuoteListByDatePeriod2(soap, "ns1:QuoteListByDatePeriod2", &a->ns1__QuoteListByDatePeriod2, ""))
				{	soap_flag_ns1__QuoteListByDatePeriod2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__QuoteListByDatePeriod2_ * SOAP_FMAC2 soap_instantiate___ns1__QuoteListByDatePeriod2_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__QuoteListByDatePeriod2_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__QuoteListByDatePeriod2_ *p;
	size_t k = sizeof(struct __ns1__QuoteListByDatePeriod2_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__QuoteListByDatePeriod2_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__QuoteListByDatePeriod2_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__QuoteListByDatePeriod2_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__QuoteListByDatePeriod2_, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__QuoteListByDatePeriod2_(struct soap *soap, const struct __ns1__QuoteListByDatePeriod2_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__QuoteListByDatePeriod2_(soap, tag?tag:"-ns1:QuoteListByDatePeriod2", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QuoteListByDatePeriod2_ * SOAP_FMAC4 soap_get___ns1__QuoteListByDatePeriod2_(struct soap *soap, struct __ns1__QuoteListByDatePeriod2_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__QuoteListByDatePeriod2_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__QuoteListByDatePeriod_::__ns1__QuoteListByDatePeriod_()
{
	soap_default___ns1__QuoteListByDatePeriod_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__QuoteListByDatePeriod_(struct soap *soap, struct __ns1__QuoteListByDatePeriod_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__QuoteListByDatePeriod = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__QuoteListByDatePeriod_(struct soap *soap, const struct __ns1__QuoteListByDatePeriod_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__QuoteListByDatePeriod(soap, &a->ns1__QuoteListByDatePeriod);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__QuoteListByDatePeriod_(struct soap *soap, const char *tag, int id, const struct __ns1__QuoteListByDatePeriod_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__QuoteListByDatePeriod(soap, "ns1:QuoteListByDatePeriod", -1, &a->ns1__QuoteListByDatePeriod, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QuoteListByDatePeriod_ * SOAP_FMAC4 soap_in___ns1__QuoteListByDatePeriod_(struct soap *soap, const char *tag, struct __ns1__QuoteListByDatePeriod_ *a, const char *type)
{
	size_t soap_flag_ns1__QuoteListByDatePeriod = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__QuoteListByDatePeriod_ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__QuoteListByDatePeriod_, sizeof(struct __ns1__QuoteListByDatePeriod_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__QuoteListByDatePeriod_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__QuoteListByDatePeriod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__QuoteListByDatePeriod(soap, "ns1:QuoteListByDatePeriod", &a->ns1__QuoteListByDatePeriod, ""))
				{	soap_flag_ns1__QuoteListByDatePeriod--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__QuoteListByDatePeriod_ * SOAP_FMAC2 soap_instantiate___ns1__QuoteListByDatePeriod_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__QuoteListByDatePeriod_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__QuoteListByDatePeriod_ *p;
	size_t k = sizeof(struct __ns1__QuoteListByDatePeriod_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__QuoteListByDatePeriod_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__QuoteListByDatePeriod_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__QuoteListByDatePeriod_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__QuoteListByDatePeriod_, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__QuoteListByDatePeriod_(struct soap *soap, const struct __ns1__QuoteListByDatePeriod_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__QuoteListByDatePeriod_(soap, tag?tag:"-ns1:QuoteListByDatePeriod", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QuoteListByDatePeriod_ * SOAP_FMAC4 soap_get___ns1__QuoteListByDatePeriod_(struct soap *soap, struct __ns1__QuoteListByDatePeriod_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__QuoteListByDatePeriod_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__SymbolHistoryPeriodByDateRange_::__ns1__SymbolHistoryPeriodByDateRange_()
{
	soap_default___ns1__SymbolHistoryPeriodByDateRange_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SymbolHistoryPeriodByDateRange_(struct soap *soap, struct __ns1__SymbolHistoryPeriodByDateRange_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SymbolHistoryPeriodByDateRange = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SymbolHistoryPeriodByDateRange_(struct soap *soap, const struct __ns1__SymbolHistoryPeriodByDateRange_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SymbolHistoryPeriodByDateRange(soap, &a->ns1__SymbolHistoryPeriodByDateRange);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SymbolHistoryPeriodByDateRange_(struct soap *soap, const char *tag, int id, const struct __ns1__SymbolHistoryPeriodByDateRange_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SymbolHistoryPeriodByDateRange(soap, "ns1:SymbolHistoryPeriodByDateRange", -1, &a->ns1__SymbolHistoryPeriodByDateRange, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolHistoryPeriodByDateRange_ * SOAP_FMAC4 soap_in___ns1__SymbolHistoryPeriodByDateRange_(struct soap *soap, const char *tag, struct __ns1__SymbolHistoryPeriodByDateRange_ *a, const char *type)
{
	size_t soap_flag_ns1__SymbolHistoryPeriodByDateRange = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SymbolHistoryPeriodByDateRange_ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__SymbolHistoryPeriodByDateRange_, sizeof(struct __ns1__SymbolHistoryPeriodByDateRange_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SymbolHistoryPeriodByDateRange_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SymbolHistoryPeriodByDateRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SymbolHistoryPeriodByDateRange(soap, "ns1:SymbolHistoryPeriodByDateRange", &a->ns1__SymbolHistoryPeriodByDateRange, ""))
				{	soap_flag_ns1__SymbolHistoryPeriodByDateRange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SymbolHistoryPeriodByDateRange_ * SOAP_FMAC2 soap_instantiate___ns1__SymbolHistoryPeriodByDateRange_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SymbolHistoryPeriodByDateRange_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SymbolHistoryPeriodByDateRange_ *p;
	size_t k = sizeof(struct __ns1__SymbolHistoryPeriodByDateRange_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SymbolHistoryPeriodByDateRange_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SymbolHistoryPeriodByDateRange_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SymbolHistoryPeriodByDateRange_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__SymbolHistoryPeriodByDateRange_, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SymbolHistoryPeriodByDateRange_(struct soap *soap, const struct __ns1__SymbolHistoryPeriodByDateRange_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SymbolHistoryPeriodByDateRange_(soap, tag?tag:"-ns1:SymbolHistoryPeriodByDateRange", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolHistoryPeriodByDateRange_ * SOAP_FMAC4 soap_get___ns1__SymbolHistoryPeriodByDateRange_(struct soap *soap, struct __ns1__SymbolHistoryPeriodByDateRange_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SymbolHistoryPeriodByDateRange_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__SymbolHistoryPeriod_::__ns1__SymbolHistoryPeriod_()
{
	soap_default___ns1__SymbolHistoryPeriod_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SymbolHistoryPeriod_(struct soap *soap, struct __ns1__SymbolHistoryPeriod_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SymbolHistoryPeriod = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SymbolHistoryPeriod_(struct soap *soap, const struct __ns1__SymbolHistoryPeriod_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SymbolHistoryPeriod(soap, &a->ns1__SymbolHistoryPeriod);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SymbolHistoryPeriod_(struct soap *soap, const char *tag, int id, const struct __ns1__SymbolHistoryPeriod_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SymbolHistoryPeriod(soap, "ns1:SymbolHistoryPeriod", -1, &a->ns1__SymbolHistoryPeriod, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolHistoryPeriod_ * SOAP_FMAC4 soap_in___ns1__SymbolHistoryPeriod_(struct soap *soap, const char *tag, struct __ns1__SymbolHistoryPeriod_ *a, const char *type)
{
	size_t soap_flag_ns1__SymbolHistoryPeriod = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SymbolHistoryPeriod_ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__SymbolHistoryPeriod_, sizeof(struct __ns1__SymbolHistoryPeriod_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SymbolHistoryPeriod_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SymbolHistoryPeriod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SymbolHistoryPeriod(soap, "ns1:SymbolHistoryPeriod", &a->ns1__SymbolHistoryPeriod, ""))
				{	soap_flag_ns1__SymbolHistoryPeriod--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SymbolHistoryPeriod_ * SOAP_FMAC2 soap_instantiate___ns1__SymbolHistoryPeriod_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SymbolHistoryPeriod_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SymbolHistoryPeriod_ *p;
	size_t k = sizeof(struct __ns1__SymbolHistoryPeriod_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SymbolHistoryPeriod_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SymbolHistoryPeriod_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SymbolHistoryPeriod_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__SymbolHistoryPeriod_, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SymbolHistoryPeriod_(struct soap *soap, const struct __ns1__SymbolHistoryPeriod_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SymbolHistoryPeriod_(soap, tag?tag:"-ns1:SymbolHistoryPeriod", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolHistoryPeriod_ * SOAP_FMAC4 soap_get___ns1__SymbolHistoryPeriod_(struct soap *soap, struct __ns1__SymbolHistoryPeriod_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SymbolHistoryPeriod_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__CountryList_::__ns1__CountryList_()
{
	soap_default___ns1__CountryList_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__CountryList_(struct soap *soap, struct __ns1__CountryList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CountryList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__CountryList_(struct soap *soap, const struct __ns1__CountryList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__CountryList(soap, &a->ns1__CountryList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__CountryList_(struct soap *soap, const char *tag, int id, const struct __ns1__CountryList_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__CountryList(soap, "ns1:CountryList", -1, &a->ns1__CountryList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CountryList_ * SOAP_FMAC4 soap_in___ns1__CountryList_(struct soap *soap, const char *tag, struct __ns1__CountryList_ *a, const char *type)
{
	size_t soap_flag_ns1__CountryList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__CountryList_ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__CountryList_, sizeof(struct __ns1__CountryList_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__CountryList_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CountryList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__CountryList(soap, "ns1:CountryList", &a->ns1__CountryList, ""))
				{	soap_flag_ns1__CountryList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__CountryList_ * SOAP_FMAC2 soap_instantiate___ns1__CountryList_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__CountryList_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__CountryList_ *p;
	size_t k = sizeof(struct __ns1__CountryList_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__CountryList_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__CountryList_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__CountryList_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__CountryList_, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__CountryList_(struct soap *soap, const struct __ns1__CountryList_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__CountryList_(soap, tag?tag:"-ns1:CountryList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CountryList_ * SOAP_FMAC4 soap_get___ns1__CountryList_(struct soap *soap, struct __ns1__CountryList_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__CountryList_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__SplitListBySymbol_::__ns1__SplitListBySymbol_()
{
	soap_default___ns1__SplitListBySymbol_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SplitListBySymbol_(struct soap *soap, struct __ns1__SplitListBySymbol_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SplitListBySymbol = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SplitListBySymbol_(struct soap *soap, const struct __ns1__SplitListBySymbol_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SplitListBySymbol(soap, &a->ns1__SplitListBySymbol);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SplitListBySymbol_(struct soap *soap, const char *tag, int id, const struct __ns1__SplitListBySymbol_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SplitListBySymbol(soap, "ns1:SplitListBySymbol", -1, &a->ns1__SplitListBySymbol, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SplitListBySymbol_ * SOAP_FMAC4 soap_in___ns1__SplitListBySymbol_(struct soap *soap, const char *tag, struct __ns1__SplitListBySymbol_ *a, const char *type)
{
	size_t soap_flag_ns1__SplitListBySymbol = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SplitListBySymbol_ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__SplitListBySymbol_, sizeof(struct __ns1__SplitListBySymbol_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SplitListBySymbol_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SplitListBySymbol && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SplitListBySymbol(soap, "ns1:SplitListBySymbol", &a->ns1__SplitListBySymbol, ""))
				{	soap_flag_ns1__SplitListBySymbol--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SplitListBySymbol_ * SOAP_FMAC2 soap_instantiate___ns1__SplitListBySymbol_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SplitListBySymbol_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SplitListBySymbol_ *p;
	size_t k = sizeof(struct __ns1__SplitListBySymbol_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SplitListBySymbol_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SplitListBySymbol_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SplitListBySymbol_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__SplitListBySymbol_, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SplitListBySymbol_(struct soap *soap, const struct __ns1__SplitListBySymbol_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SplitListBySymbol_(soap, tag?tag:"-ns1:SplitListBySymbol", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SplitListBySymbol_ * SOAP_FMAC4 soap_get___ns1__SplitListBySymbol_(struct soap *soap, struct __ns1__SplitListBySymbol_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SplitListBySymbol_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__SplitListByExchange_::__ns1__SplitListByExchange_()
{
	soap_default___ns1__SplitListByExchange_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SplitListByExchange_(struct soap *soap, struct __ns1__SplitListByExchange_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SplitListByExchange = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SplitListByExchange_(struct soap *soap, const struct __ns1__SplitListByExchange_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SplitListByExchange(soap, &a->ns1__SplitListByExchange);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SplitListByExchange_(struct soap *soap, const char *tag, int id, const struct __ns1__SplitListByExchange_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SplitListByExchange(soap, "ns1:SplitListByExchange", -1, &a->ns1__SplitListByExchange, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SplitListByExchange_ * SOAP_FMAC4 soap_in___ns1__SplitListByExchange_(struct soap *soap, const char *tag, struct __ns1__SplitListByExchange_ *a, const char *type)
{
	size_t soap_flag_ns1__SplitListByExchange = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SplitListByExchange_ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__SplitListByExchange_, sizeof(struct __ns1__SplitListByExchange_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SplitListByExchange_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SplitListByExchange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SplitListByExchange(soap, "ns1:SplitListByExchange", &a->ns1__SplitListByExchange, ""))
				{	soap_flag_ns1__SplitListByExchange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SplitListByExchange_ * SOAP_FMAC2 soap_instantiate___ns1__SplitListByExchange_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SplitListByExchange_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SplitListByExchange_ *p;
	size_t k = sizeof(struct __ns1__SplitListByExchange_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SplitListByExchange_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SplitListByExchange_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SplitListByExchange_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__SplitListByExchange_, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SplitListByExchange_(struct soap *soap, const struct __ns1__SplitListByExchange_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SplitListByExchange_(soap, tag?tag:"-ns1:SplitListByExchange", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SplitListByExchange_ * SOAP_FMAC4 soap_get___ns1__SplitListByExchange_(struct soap *soap, struct __ns1__SplitListByExchange_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SplitListByExchange_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__ExchangeMonths_::__ns1__ExchangeMonths_()
{
	soap_default___ns1__ExchangeMonths_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ExchangeMonths_(struct soap *soap, struct __ns1__ExchangeMonths_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ExchangeMonths = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ExchangeMonths_(struct soap *soap, const struct __ns1__ExchangeMonths_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__ExchangeMonths(soap, &a->ns1__ExchangeMonths);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ExchangeMonths_(struct soap *soap, const char *tag, int id, const struct __ns1__ExchangeMonths_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__ExchangeMonths(soap, "ns1:ExchangeMonths", -1, &a->ns1__ExchangeMonths, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ExchangeMonths_ * SOAP_FMAC4 soap_in___ns1__ExchangeMonths_(struct soap *soap, const char *tag, struct __ns1__ExchangeMonths_ *a, const char *type)
{
	size_t soap_flag_ns1__ExchangeMonths = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ExchangeMonths_ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__ExchangeMonths_, sizeof(struct __ns1__ExchangeMonths_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ExchangeMonths_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ExchangeMonths && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__ExchangeMonths(soap, "ns1:ExchangeMonths", &a->ns1__ExchangeMonths, ""))
				{	soap_flag_ns1__ExchangeMonths--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ExchangeMonths_ * SOAP_FMAC2 soap_instantiate___ns1__ExchangeMonths_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ExchangeMonths_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ExchangeMonths_ *p;
	size_t k = sizeof(struct __ns1__ExchangeMonths_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__ExchangeMonths_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__ExchangeMonths_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ExchangeMonths_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__ExchangeMonths_, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ExchangeMonths_(struct soap *soap, const struct __ns1__ExchangeMonths_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ExchangeMonths_(soap, tag?tag:"-ns1:ExchangeMonths", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ExchangeMonths_ * SOAP_FMAC4 soap_get___ns1__ExchangeMonths_(struct soap *soap, struct __ns1__ExchangeMonths_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ExchangeMonths_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__SymbolChart_::__ns1__SymbolChart_()
{
	soap_default___ns1__SymbolChart_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SymbolChart_(struct soap *soap, struct __ns1__SymbolChart_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SymbolChart = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SymbolChart_(struct soap *soap, const struct __ns1__SymbolChart_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SymbolChart(soap, &a->ns1__SymbolChart);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SymbolChart_(struct soap *soap, const char *tag, int id, const struct __ns1__SymbolChart_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SymbolChart(soap, "ns1:SymbolChart", -1, &a->ns1__SymbolChart, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolChart_ * SOAP_FMAC4 soap_in___ns1__SymbolChart_(struct soap *soap, const char *tag, struct __ns1__SymbolChart_ *a, const char *type)
{
	size_t soap_flag_ns1__SymbolChart = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SymbolChart_ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__SymbolChart_, sizeof(struct __ns1__SymbolChart_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SymbolChart_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SymbolChart && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SymbolChart(soap, "ns1:SymbolChart", &a->ns1__SymbolChart, ""))
				{	soap_flag_ns1__SymbolChart--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SymbolChart_ * SOAP_FMAC2 soap_instantiate___ns1__SymbolChart_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SymbolChart_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SymbolChart_ *p;
	size_t k = sizeof(struct __ns1__SymbolChart_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SymbolChart_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SymbolChart_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SymbolChart_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__SymbolChart_, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SymbolChart_(struct soap *soap, const struct __ns1__SymbolChart_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SymbolChart_(soap, tag?tag:"-ns1:SymbolChart", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolChart_ * SOAP_FMAC4 soap_get___ns1__SymbolChart_(struct soap *soap, struct __ns1__SymbolChart_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SymbolChart_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__Top10Losses_::__ns1__Top10Losses_()
{
	soap_default___ns1__Top10Losses_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Top10Losses_(struct soap *soap, struct __ns1__Top10Losses_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__Top10Losses = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Top10Losses_(struct soap *soap, const struct __ns1__Top10Losses_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__Top10Losses(soap, &a->ns1__Top10Losses);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Top10Losses_(struct soap *soap, const char *tag, int id, const struct __ns1__Top10Losses_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__Top10Losses(soap, "ns1:Top10Losses", -1, &a->ns1__Top10Losses, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Top10Losses_ * SOAP_FMAC4 soap_in___ns1__Top10Losses_(struct soap *soap, const char *tag, struct __ns1__Top10Losses_ *a, const char *type)
{
	size_t soap_flag_ns1__Top10Losses = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__Top10Losses_ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__Top10Losses_, sizeof(struct __ns1__Top10Losses_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Top10Losses_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__Top10Losses && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__Top10Losses(soap, "ns1:Top10Losses", &a->ns1__Top10Losses, ""))
				{	soap_flag_ns1__Top10Losses--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__Top10Losses_ * SOAP_FMAC2 soap_instantiate___ns1__Top10Losses_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Top10Losses_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__Top10Losses_ *p;
	size_t k = sizeof(struct __ns1__Top10Losses_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__Top10Losses_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__Top10Losses_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__Top10Losses_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__Top10Losses_, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Top10Losses_(struct soap *soap, const struct __ns1__Top10Losses_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__Top10Losses_(soap, tag?tag:"-ns1:Top10Losses", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Top10Losses_ * SOAP_FMAC4 soap_get___ns1__Top10Losses_(struct soap *soap, struct __ns1__Top10Losses_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Top10Losses_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__Top10Gains_::__ns1__Top10Gains_()
{
	soap_default___ns1__Top10Gains_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Top10Gains_(struct soap *soap, struct __ns1__Top10Gains_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__Top10Gains = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Top10Gains_(struct soap *soap, const struct __ns1__Top10Gains_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__Top10Gains(soap, &a->ns1__Top10Gains);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Top10Gains_(struct soap *soap, const char *tag, int id, const struct __ns1__Top10Gains_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__Top10Gains(soap, "ns1:Top10Gains", -1, &a->ns1__Top10Gains, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Top10Gains_ * SOAP_FMAC4 soap_in___ns1__Top10Gains_(struct soap *soap, const char *tag, struct __ns1__Top10Gains_ *a, const char *type)
{
	size_t soap_flag_ns1__Top10Gains = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__Top10Gains_ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__Top10Gains_, sizeof(struct __ns1__Top10Gains_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Top10Gains_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__Top10Gains && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__Top10Gains(soap, "ns1:Top10Gains", &a->ns1__Top10Gains, ""))
				{	soap_flag_ns1__Top10Gains--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__Top10Gains_ * SOAP_FMAC2 soap_instantiate___ns1__Top10Gains_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Top10Gains_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__Top10Gains_ *p;
	size_t k = sizeof(struct __ns1__Top10Gains_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__Top10Gains_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__Top10Gains_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__Top10Gains_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__Top10Gains_, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Top10Gains_(struct soap *soap, const struct __ns1__Top10Gains_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__Top10Gains_(soap, tag?tag:"-ns1:Top10Gains", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Top10Gains_ * SOAP_FMAC4 soap_get___ns1__Top10Gains_(struct soap *soap, struct __ns1__Top10Gains_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Top10Gains_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__SymbolHistory_::__ns1__SymbolHistory_()
{
	soap_default___ns1__SymbolHistory_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SymbolHistory_(struct soap *soap, struct __ns1__SymbolHistory_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SymbolHistory = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SymbolHistory_(struct soap *soap, const struct __ns1__SymbolHistory_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SymbolHistory(soap, &a->ns1__SymbolHistory);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SymbolHistory_(struct soap *soap, const char *tag, int id, const struct __ns1__SymbolHistory_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SymbolHistory(soap, "ns1:SymbolHistory", -1, &a->ns1__SymbolHistory, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolHistory_ * SOAP_FMAC4 soap_in___ns1__SymbolHistory_(struct soap *soap, const char *tag, struct __ns1__SymbolHistory_ *a, const char *type)
{
	size_t soap_flag_ns1__SymbolHistory = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SymbolHistory_ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__SymbolHistory_, sizeof(struct __ns1__SymbolHistory_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SymbolHistory_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SymbolHistory && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SymbolHistory(soap, "ns1:SymbolHistory", &a->ns1__SymbolHistory, ""))
				{	soap_flag_ns1__SymbolHistory--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SymbolHistory_ * SOAP_FMAC2 soap_instantiate___ns1__SymbolHistory_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SymbolHistory_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SymbolHistory_ *p;
	size_t k = sizeof(struct __ns1__SymbolHistory_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SymbolHistory_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SymbolHistory_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SymbolHistory_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__SymbolHistory_, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SymbolHistory_(struct soap *soap, const struct __ns1__SymbolHistory_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SymbolHistory_(soap, tag?tag:"-ns1:SymbolHistory", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolHistory_ * SOAP_FMAC4 soap_get___ns1__SymbolHistory_(struct soap *soap, struct __ns1__SymbolHistory_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SymbolHistory_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__QuoteListByDate2_::__ns1__QuoteListByDate2_()
{
	soap_default___ns1__QuoteListByDate2_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__QuoteListByDate2_(struct soap *soap, struct __ns1__QuoteListByDate2_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__QuoteListByDate2 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__QuoteListByDate2_(struct soap *soap, const struct __ns1__QuoteListByDate2_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__QuoteListByDate2(soap, &a->ns1__QuoteListByDate2);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__QuoteListByDate2_(struct soap *soap, const char *tag, int id, const struct __ns1__QuoteListByDate2_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__QuoteListByDate2(soap, "ns1:QuoteListByDate2", -1, &a->ns1__QuoteListByDate2, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QuoteListByDate2_ * SOAP_FMAC4 soap_in___ns1__QuoteListByDate2_(struct soap *soap, const char *tag, struct __ns1__QuoteListByDate2_ *a, const char *type)
{
	size_t soap_flag_ns1__QuoteListByDate2 = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__QuoteListByDate2_ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__QuoteListByDate2_, sizeof(struct __ns1__QuoteListByDate2_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__QuoteListByDate2_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__QuoteListByDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__QuoteListByDate2(soap, "ns1:QuoteListByDate2", &a->ns1__QuoteListByDate2, ""))
				{	soap_flag_ns1__QuoteListByDate2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__QuoteListByDate2_ * SOAP_FMAC2 soap_instantiate___ns1__QuoteListByDate2_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__QuoteListByDate2_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__QuoteListByDate2_ *p;
	size_t k = sizeof(struct __ns1__QuoteListByDate2_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__QuoteListByDate2_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__QuoteListByDate2_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__QuoteListByDate2_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__QuoteListByDate2_, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__QuoteListByDate2_(struct soap *soap, const struct __ns1__QuoteListByDate2_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__QuoteListByDate2_(soap, tag?tag:"-ns1:QuoteListByDate2", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QuoteListByDate2_ * SOAP_FMAC4 soap_get___ns1__QuoteListByDate2_(struct soap *soap, struct __ns1__QuoteListByDate2_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__QuoteListByDate2_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__QuoteListByDate_::__ns1__QuoteListByDate_()
{
	soap_default___ns1__QuoteListByDate_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__QuoteListByDate_(struct soap *soap, struct __ns1__QuoteListByDate_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__QuoteListByDate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__QuoteListByDate_(struct soap *soap, const struct __ns1__QuoteListByDate_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__QuoteListByDate(soap, &a->ns1__QuoteListByDate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__QuoteListByDate_(struct soap *soap, const char *tag, int id, const struct __ns1__QuoteListByDate_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__QuoteListByDate(soap, "ns1:QuoteListByDate", -1, &a->ns1__QuoteListByDate, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QuoteListByDate_ * SOAP_FMAC4 soap_in___ns1__QuoteListByDate_(struct soap *soap, const char *tag, struct __ns1__QuoteListByDate_ *a, const char *type)
{
	size_t soap_flag_ns1__QuoteListByDate = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__QuoteListByDate_ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__QuoteListByDate_, sizeof(struct __ns1__QuoteListByDate_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__QuoteListByDate_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__QuoteListByDate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__QuoteListByDate(soap, "ns1:QuoteListByDate", &a->ns1__QuoteListByDate, ""))
				{	soap_flag_ns1__QuoteListByDate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__QuoteListByDate_ * SOAP_FMAC2 soap_instantiate___ns1__QuoteListByDate_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__QuoteListByDate_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__QuoteListByDate_ *p;
	size_t k = sizeof(struct __ns1__QuoteListByDate_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__QuoteListByDate_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__QuoteListByDate_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__QuoteListByDate_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__QuoteListByDate_, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__QuoteListByDate_(struct soap *soap, const struct __ns1__QuoteListByDate_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__QuoteListByDate_(soap, tag?tag:"-ns1:QuoteListByDate", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QuoteListByDate_ * SOAP_FMAC4 soap_get___ns1__QuoteListByDate_(struct soap *soap, struct __ns1__QuoteListByDate_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__QuoteListByDate_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__TechnicalList_::__ns1__TechnicalList_()
{
	soap_default___ns1__TechnicalList_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__TechnicalList_(struct soap *soap, struct __ns1__TechnicalList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__TechnicalList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__TechnicalList_(struct soap *soap, const struct __ns1__TechnicalList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__TechnicalList(soap, &a->ns1__TechnicalList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__TechnicalList_(struct soap *soap, const char *tag, int id, const struct __ns1__TechnicalList_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__TechnicalList(soap, "ns1:TechnicalList", -1, &a->ns1__TechnicalList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__TechnicalList_ * SOAP_FMAC4 soap_in___ns1__TechnicalList_(struct soap *soap, const char *tag, struct __ns1__TechnicalList_ *a, const char *type)
{
	size_t soap_flag_ns1__TechnicalList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__TechnicalList_ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__TechnicalList_, sizeof(struct __ns1__TechnicalList_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__TechnicalList_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__TechnicalList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__TechnicalList(soap, "ns1:TechnicalList", &a->ns1__TechnicalList, ""))
				{	soap_flag_ns1__TechnicalList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__TechnicalList_ * SOAP_FMAC2 soap_instantiate___ns1__TechnicalList_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__TechnicalList_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__TechnicalList_ *p;
	size_t k = sizeof(struct __ns1__TechnicalList_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__TechnicalList_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__TechnicalList_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__TechnicalList_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__TechnicalList_, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__TechnicalList_(struct soap *soap, const struct __ns1__TechnicalList_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__TechnicalList_(soap, tag?tag:"-ns1:TechnicalList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__TechnicalList_ * SOAP_FMAC4 soap_get___ns1__TechnicalList_(struct soap *soap, struct __ns1__TechnicalList_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__TechnicalList_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__FundamentalList_::__ns1__FundamentalList_()
{
	soap_default___ns1__FundamentalList_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__FundamentalList_(struct soap *soap, struct __ns1__FundamentalList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__FundamentalList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__FundamentalList_(struct soap *soap, const struct __ns1__FundamentalList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__FundamentalList(soap, &a->ns1__FundamentalList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__FundamentalList_(struct soap *soap, const char *tag, int id, const struct __ns1__FundamentalList_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__FundamentalList(soap, "ns1:FundamentalList", -1, &a->ns1__FundamentalList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__FundamentalList_ * SOAP_FMAC4 soap_in___ns1__FundamentalList_(struct soap *soap, const char *tag, struct __ns1__FundamentalList_ *a, const char *type)
{
	size_t soap_flag_ns1__FundamentalList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__FundamentalList_ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__FundamentalList_, sizeof(struct __ns1__FundamentalList_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__FundamentalList_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__FundamentalList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__FundamentalList(soap, "ns1:FundamentalList", &a->ns1__FundamentalList, ""))
				{	soap_flag_ns1__FundamentalList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__FundamentalList_ * SOAP_FMAC2 soap_instantiate___ns1__FundamentalList_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__FundamentalList_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__FundamentalList_ *p;
	size_t k = sizeof(struct __ns1__FundamentalList_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__FundamentalList_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__FundamentalList_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__FundamentalList_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__FundamentalList_, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__FundamentalList_(struct soap *soap, const struct __ns1__FundamentalList_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__FundamentalList_(soap, tag?tag:"-ns1:FundamentalList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__FundamentalList_ * SOAP_FMAC4 soap_get___ns1__FundamentalList_(struct soap *soap, struct __ns1__FundamentalList_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__FundamentalList_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__NewsListBySymbol_::__ns1__NewsListBySymbol_()
{
	soap_default___ns1__NewsListBySymbol_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__NewsListBySymbol_(struct soap *soap, struct __ns1__NewsListBySymbol_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__NewsListBySymbol = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__NewsListBySymbol_(struct soap *soap, const struct __ns1__NewsListBySymbol_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__NewsListBySymbol(soap, &a->ns1__NewsListBySymbol);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__NewsListBySymbol_(struct soap *soap, const char *tag, int id, const struct __ns1__NewsListBySymbol_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__NewsListBySymbol(soap, "ns1:NewsListBySymbol", -1, &a->ns1__NewsListBySymbol, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__NewsListBySymbol_ * SOAP_FMAC4 soap_in___ns1__NewsListBySymbol_(struct soap *soap, const char *tag, struct __ns1__NewsListBySymbol_ *a, const char *type)
{
	size_t soap_flag_ns1__NewsListBySymbol = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__NewsListBySymbol_ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__NewsListBySymbol_, sizeof(struct __ns1__NewsListBySymbol_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__NewsListBySymbol_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__NewsListBySymbol && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__NewsListBySymbol(soap, "ns1:NewsListBySymbol", &a->ns1__NewsListBySymbol, ""))
				{	soap_flag_ns1__NewsListBySymbol--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__NewsListBySymbol_ * SOAP_FMAC2 soap_instantiate___ns1__NewsListBySymbol_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__NewsListBySymbol_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__NewsListBySymbol_ *p;
	size_t k = sizeof(struct __ns1__NewsListBySymbol_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__NewsListBySymbol_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__NewsListBySymbol_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__NewsListBySymbol_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__NewsListBySymbol_, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__NewsListBySymbol_(struct soap *soap, const struct __ns1__NewsListBySymbol_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__NewsListBySymbol_(soap, tag?tag:"-ns1:NewsListBySymbol", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__NewsListBySymbol_ * SOAP_FMAC4 soap_get___ns1__NewsListBySymbol_(struct soap *soap, struct __ns1__NewsListBySymbol_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__NewsListBySymbol_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__NewsList_::__ns1__NewsList_()
{
	soap_default___ns1__NewsList_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__NewsList_(struct soap *soap, struct __ns1__NewsList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__NewsList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__NewsList_(struct soap *soap, const struct __ns1__NewsList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__NewsList(soap, &a->ns1__NewsList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__NewsList_(struct soap *soap, const char *tag, int id, const struct __ns1__NewsList_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__NewsList(soap, "ns1:NewsList", -1, &a->ns1__NewsList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__NewsList_ * SOAP_FMAC4 soap_in___ns1__NewsList_(struct soap *soap, const char *tag, struct __ns1__NewsList_ *a, const char *type)
{
	size_t soap_flag_ns1__NewsList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__NewsList_ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__NewsList_, sizeof(struct __ns1__NewsList_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__NewsList_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__NewsList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__NewsList(soap, "ns1:NewsList", &a->ns1__NewsList, ""))
				{	soap_flag_ns1__NewsList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__NewsList_ * SOAP_FMAC2 soap_instantiate___ns1__NewsList_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__NewsList_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__NewsList_ *p;
	size_t k = sizeof(struct __ns1__NewsList_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__NewsList_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__NewsList_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__NewsList_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__NewsList_, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__NewsList_(struct soap *soap, const struct __ns1__NewsList_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__NewsList_(soap, tag?tag:"-ns1:NewsList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__NewsList_ * SOAP_FMAC4 soap_get___ns1__NewsList_(struct soap *soap, struct __ns1__NewsList_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__NewsList_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__QuoteList_::__ns1__QuoteList_()
{
	soap_default___ns1__QuoteList_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__QuoteList_(struct soap *soap, struct __ns1__QuoteList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__QuoteList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__QuoteList_(struct soap *soap, const struct __ns1__QuoteList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__QuoteList(soap, &a->ns1__QuoteList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__QuoteList_(struct soap *soap, const char *tag, int id, const struct __ns1__QuoteList_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__QuoteList(soap, "ns1:QuoteList", -1, &a->ns1__QuoteList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QuoteList_ * SOAP_FMAC4 soap_in___ns1__QuoteList_(struct soap *soap, const char *tag, struct __ns1__QuoteList_ *a, const char *type)
{
	size_t soap_flag_ns1__QuoteList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__QuoteList_ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__QuoteList_, sizeof(struct __ns1__QuoteList_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__QuoteList_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__QuoteList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__QuoteList(soap, "ns1:QuoteList", &a->ns1__QuoteList, ""))
				{	soap_flag_ns1__QuoteList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__QuoteList_ * SOAP_FMAC2 soap_instantiate___ns1__QuoteList_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__QuoteList_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__QuoteList_ *p;
	size_t k = sizeof(struct __ns1__QuoteList_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__QuoteList_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__QuoteList_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__QuoteList_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__QuoteList_, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__QuoteList_(struct soap *soap, const struct __ns1__QuoteList_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__QuoteList_(soap, tag?tag:"-ns1:QuoteList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QuoteList_ * SOAP_FMAC4 soap_get___ns1__QuoteList_(struct soap *soap, struct __ns1__QuoteList_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__QuoteList_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__SymbolGet_::__ns1__SymbolGet_()
{
	soap_default___ns1__SymbolGet_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SymbolGet_(struct soap *soap, struct __ns1__SymbolGet_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SymbolGet = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SymbolGet_(struct soap *soap, const struct __ns1__SymbolGet_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SymbolGet(soap, &a->ns1__SymbolGet);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SymbolGet_(struct soap *soap, const char *tag, int id, const struct __ns1__SymbolGet_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SymbolGet(soap, "ns1:SymbolGet", -1, &a->ns1__SymbolGet, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolGet_ * SOAP_FMAC4 soap_in___ns1__SymbolGet_(struct soap *soap, const char *tag, struct __ns1__SymbolGet_ *a, const char *type)
{
	size_t soap_flag_ns1__SymbolGet = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SymbolGet_ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__SymbolGet_, sizeof(struct __ns1__SymbolGet_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SymbolGet_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SymbolGet && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SymbolGet(soap, "ns1:SymbolGet", &a->ns1__SymbolGet, ""))
				{	soap_flag_ns1__SymbolGet--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SymbolGet_ * SOAP_FMAC2 soap_instantiate___ns1__SymbolGet_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SymbolGet_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SymbolGet_ *p;
	size_t k = sizeof(struct __ns1__SymbolGet_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SymbolGet_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SymbolGet_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SymbolGet_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__SymbolGet_, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SymbolGet_(struct soap *soap, const struct __ns1__SymbolGet_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SymbolGet_(soap, tag?tag:"-ns1:SymbolGet", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolGet_ * SOAP_FMAC4 soap_get___ns1__SymbolGet_(struct soap *soap, struct __ns1__SymbolGet_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SymbolGet_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__QuoteList2_::__ns1__QuoteList2_()
{
	soap_default___ns1__QuoteList2_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__QuoteList2_(struct soap *soap, struct __ns1__QuoteList2_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__QuoteList2 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__QuoteList2_(struct soap *soap, const struct __ns1__QuoteList2_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__QuoteList2(soap, &a->ns1__QuoteList2);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__QuoteList2_(struct soap *soap, const char *tag, int id, const struct __ns1__QuoteList2_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__QuoteList2(soap, "ns1:QuoteList2", -1, &a->ns1__QuoteList2, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QuoteList2_ * SOAP_FMAC4 soap_in___ns1__QuoteList2_(struct soap *soap, const char *tag, struct __ns1__QuoteList2_ *a, const char *type)
{
	size_t soap_flag_ns1__QuoteList2 = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__QuoteList2_ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__QuoteList2_, sizeof(struct __ns1__QuoteList2_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__QuoteList2_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__QuoteList2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__QuoteList2(soap, "ns1:QuoteList2", &a->ns1__QuoteList2, ""))
				{	soap_flag_ns1__QuoteList2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__QuoteList2_ * SOAP_FMAC2 soap_instantiate___ns1__QuoteList2_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__QuoteList2_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__QuoteList2_ *p;
	size_t k = sizeof(struct __ns1__QuoteList2_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__QuoteList2_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__QuoteList2_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__QuoteList2_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__QuoteList2_, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__QuoteList2_(struct soap *soap, const struct __ns1__QuoteList2_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__QuoteList2_(soap, tag?tag:"-ns1:QuoteList2", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QuoteList2_ * SOAP_FMAC4 soap_get___ns1__QuoteList2_(struct soap *soap, struct __ns1__QuoteList2_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__QuoteList2_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__QuoteGet_::__ns1__QuoteGet_()
{
	soap_default___ns1__QuoteGet_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__QuoteGet_(struct soap *soap, struct __ns1__QuoteGet_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__QuoteGet = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__QuoteGet_(struct soap *soap, const struct __ns1__QuoteGet_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__QuoteGet(soap, &a->ns1__QuoteGet);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__QuoteGet_(struct soap *soap, const char *tag, int id, const struct __ns1__QuoteGet_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__QuoteGet(soap, "ns1:QuoteGet", -1, &a->ns1__QuoteGet, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QuoteGet_ * SOAP_FMAC4 soap_in___ns1__QuoteGet_(struct soap *soap, const char *tag, struct __ns1__QuoteGet_ *a, const char *type)
{
	size_t soap_flag_ns1__QuoteGet = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__QuoteGet_ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__QuoteGet_, sizeof(struct __ns1__QuoteGet_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__QuoteGet_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__QuoteGet && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__QuoteGet(soap, "ns1:QuoteGet", &a->ns1__QuoteGet, ""))
				{	soap_flag_ns1__QuoteGet--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__QuoteGet_ * SOAP_FMAC2 soap_instantiate___ns1__QuoteGet_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__QuoteGet_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__QuoteGet_ *p;
	size_t k = sizeof(struct __ns1__QuoteGet_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__QuoteGet_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__QuoteGet_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__QuoteGet_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__QuoteGet_, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__QuoteGet_(struct soap *soap, const struct __ns1__QuoteGet_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__QuoteGet_(soap, tag?tag:"-ns1:QuoteGet", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QuoteGet_ * SOAP_FMAC4 soap_get___ns1__QuoteGet_(struct soap *soap, struct __ns1__QuoteGet_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__QuoteGet_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__SymbolList2_::__ns1__SymbolList2_()
{
	soap_default___ns1__SymbolList2_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SymbolList2_(struct soap *soap, struct __ns1__SymbolList2_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SymbolList2 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SymbolList2_(struct soap *soap, const struct __ns1__SymbolList2_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SymbolList2(soap, &a->ns1__SymbolList2);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SymbolList2_(struct soap *soap, const char *tag, int id, const struct __ns1__SymbolList2_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SymbolList2(soap, "ns1:SymbolList2", -1, &a->ns1__SymbolList2, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolList2_ * SOAP_FMAC4 soap_in___ns1__SymbolList2_(struct soap *soap, const char *tag, struct __ns1__SymbolList2_ *a, const char *type)
{
	size_t soap_flag_ns1__SymbolList2 = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SymbolList2_ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__SymbolList2_, sizeof(struct __ns1__SymbolList2_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SymbolList2_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SymbolList2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SymbolList2(soap, "ns1:SymbolList2", &a->ns1__SymbolList2, ""))
				{	soap_flag_ns1__SymbolList2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SymbolList2_ * SOAP_FMAC2 soap_instantiate___ns1__SymbolList2_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SymbolList2_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SymbolList2_ *p;
	size_t k = sizeof(struct __ns1__SymbolList2_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SymbolList2_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SymbolList2_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SymbolList2_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__SymbolList2_, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SymbolList2_(struct soap *soap, const struct __ns1__SymbolList2_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SymbolList2_(soap, tag?tag:"-ns1:SymbolList2", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolList2_ * SOAP_FMAC4 soap_get___ns1__SymbolList2_(struct soap *soap, struct __ns1__SymbolList2_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SymbolList2_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__SymbolList_::__ns1__SymbolList_()
{
	soap_default___ns1__SymbolList_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SymbolList_(struct soap *soap, struct __ns1__SymbolList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SymbolList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SymbolList_(struct soap *soap, const struct __ns1__SymbolList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SymbolList(soap, &a->ns1__SymbolList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SymbolList_(struct soap *soap, const char *tag, int id, const struct __ns1__SymbolList_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SymbolList(soap, "ns1:SymbolList", -1, &a->ns1__SymbolList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolList_ * SOAP_FMAC4 soap_in___ns1__SymbolList_(struct soap *soap, const char *tag, struct __ns1__SymbolList_ *a, const char *type)
{
	size_t soap_flag_ns1__SymbolList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SymbolList_ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__SymbolList_, sizeof(struct __ns1__SymbolList_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SymbolList_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SymbolList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SymbolList(soap, "ns1:SymbolList", &a->ns1__SymbolList, ""))
				{	soap_flag_ns1__SymbolList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SymbolList_ * SOAP_FMAC2 soap_instantiate___ns1__SymbolList_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SymbolList_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SymbolList_ *p;
	size_t k = sizeof(struct __ns1__SymbolList_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SymbolList_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SymbolList_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SymbolList_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__SymbolList_, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SymbolList_(struct soap *soap, const struct __ns1__SymbolList_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SymbolList_(soap, tag?tag:"-ns1:SymbolList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolList_ * SOAP_FMAC4 soap_get___ns1__SymbolList_(struct soap *soap, struct __ns1__SymbolList_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SymbolList_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__ExchangeGet_::__ns1__ExchangeGet_()
{
	soap_default___ns1__ExchangeGet_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ExchangeGet_(struct soap *soap, struct __ns1__ExchangeGet_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ExchangeGet = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ExchangeGet_(struct soap *soap, const struct __ns1__ExchangeGet_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__ExchangeGet(soap, &a->ns1__ExchangeGet);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ExchangeGet_(struct soap *soap, const char *tag, int id, const struct __ns1__ExchangeGet_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__ExchangeGet(soap, "ns1:ExchangeGet", -1, &a->ns1__ExchangeGet, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ExchangeGet_ * SOAP_FMAC4 soap_in___ns1__ExchangeGet_(struct soap *soap, const char *tag, struct __ns1__ExchangeGet_ *a, const char *type)
{
	size_t soap_flag_ns1__ExchangeGet = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ExchangeGet_ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__ExchangeGet_, sizeof(struct __ns1__ExchangeGet_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ExchangeGet_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ExchangeGet && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__ExchangeGet(soap, "ns1:ExchangeGet", &a->ns1__ExchangeGet, ""))
				{	soap_flag_ns1__ExchangeGet--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ExchangeGet_ * SOAP_FMAC2 soap_instantiate___ns1__ExchangeGet_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ExchangeGet_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ExchangeGet_ *p;
	size_t k = sizeof(struct __ns1__ExchangeGet_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__ExchangeGet_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__ExchangeGet_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ExchangeGet_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__ExchangeGet_, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ExchangeGet_(struct soap *soap, const struct __ns1__ExchangeGet_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ExchangeGet_(soap, tag?tag:"-ns1:ExchangeGet", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ExchangeGet_ * SOAP_FMAC4 soap_get___ns1__ExchangeGet_(struct soap *soap, struct __ns1__ExchangeGet_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ExchangeGet_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__ExchangeList_::__ns1__ExchangeList_()
{
	soap_default___ns1__ExchangeList_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ExchangeList_(struct soap *soap, struct __ns1__ExchangeList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ExchangeList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ExchangeList_(struct soap *soap, const struct __ns1__ExchangeList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__ExchangeList(soap, &a->ns1__ExchangeList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ExchangeList_(struct soap *soap, const char *tag, int id, const struct __ns1__ExchangeList_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__ExchangeList(soap, "ns1:ExchangeList", -1, &a->ns1__ExchangeList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ExchangeList_ * SOAP_FMAC4 soap_in___ns1__ExchangeList_(struct soap *soap, const char *tag, struct __ns1__ExchangeList_ *a, const char *type)
{
	size_t soap_flag_ns1__ExchangeList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ExchangeList_ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__ExchangeList_, sizeof(struct __ns1__ExchangeList_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ExchangeList_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ExchangeList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__ExchangeList(soap, "ns1:ExchangeList", &a->ns1__ExchangeList, ""))
				{	soap_flag_ns1__ExchangeList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ExchangeList_ * SOAP_FMAC2 soap_instantiate___ns1__ExchangeList_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ExchangeList_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ExchangeList_ *p;
	size_t k = sizeof(struct __ns1__ExchangeList_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__ExchangeList_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__ExchangeList_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ExchangeList_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__ExchangeList_, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ExchangeList_(struct soap *soap, const struct __ns1__ExchangeList_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ExchangeList_(soap, tag?tag:"-ns1:ExchangeList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ExchangeList_ * SOAP_FMAC4 soap_get___ns1__ExchangeList_(struct soap *soap, struct __ns1__ExchangeList_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ExchangeList_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__Membership_::__ns1__Membership_()
{
	soap_default___ns1__Membership_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Membership_(struct soap *soap, struct __ns1__Membership_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__Membership = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Membership_(struct soap *soap, const struct __ns1__Membership_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__Membership(soap, &a->ns1__Membership);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Membership_(struct soap *soap, const char *tag, int id, const struct __ns1__Membership_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__Membership(soap, "ns1:Membership", -1, &a->ns1__Membership, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Membership_ * SOAP_FMAC4 soap_in___ns1__Membership_(struct soap *soap, const char *tag, struct __ns1__Membership_ *a, const char *type)
{
	size_t soap_flag_ns1__Membership = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__Membership_ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__Membership_, sizeof(struct __ns1__Membership_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Membership_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__Membership && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__Membership(soap, "ns1:Membership", &a->ns1__Membership, ""))
				{	soap_flag_ns1__Membership--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__Membership_ * SOAP_FMAC2 soap_instantiate___ns1__Membership_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Membership_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__Membership_ *p;
	size_t k = sizeof(struct __ns1__Membership_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__Membership_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__Membership_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__Membership_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__Membership_, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Membership_(struct soap *soap, const struct __ns1__Membership_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__Membership_(soap, tag?tag:"-ns1:Membership", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Membership_ * SOAP_FMAC4 soap_get___ns1__Membership_(struct soap *soap, struct __ns1__Membership_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Membership_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__Login2_::__ns1__Login2_()
{
	soap_default___ns1__Login2_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Login2_(struct soap *soap, struct __ns1__Login2_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__Login2 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Login2_(struct soap *soap, const struct __ns1__Login2_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__Login2(soap, &a->ns1__Login2);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Login2_(struct soap *soap, const char *tag, int id, const struct __ns1__Login2_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__Login2(soap, "ns1:Login2", -1, &a->ns1__Login2, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Login2_ * SOAP_FMAC4 soap_in___ns1__Login2_(struct soap *soap, const char *tag, struct __ns1__Login2_ *a, const char *type)
{
	size_t soap_flag_ns1__Login2 = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__Login2_ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__Login2_, sizeof(struct __ns1__Login2_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Login2_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__Login2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__Login2(soap, "ns1:Login2", &a->ns1__Login2, ""))
				{	soap_flag_ns1__Login2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__Login2_ * SOAP_FMAC2 soap_instantiate___ns1__Login2_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Login2_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__Login2_ *p;
	size_t k = sizeof(struct __ns1__Login2_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__Login2_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__Login2_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__Login2_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__Login2_, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Login2_(struct soap *soap, const struct __ns1__Login2_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__Login2_(soap, tag?tag:"-ns1:Login2", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Login2_ * SOAP_FMAC4 soap_get___ns1__Login2_(struct soap *soap, struct __ns1__Login2_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Login2_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__Login_::__ns1__Login_()
{
	soap_default___ns1__Login_(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Login_(struct soap *soap, struct __ns1__Login_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__Login = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Login_(struct soap *soap, const struct __ns1__Login_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__Login(soap, &a->ns1__Login);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Login_(struct soap *soap, const char *tag, int id, const struct __ns1__Login_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__Login(soap, "ns1:Login", -1, &a->ns1__Login, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Login_ * SOAP_FMAC4 soap_in___ns1__Login_(struct soap *soap, const char *tag, struct __ns1__Login_ *a, const char *type)
{
	size_t soap_flag_ns1__Login = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__Login_ *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__Login_, sizeof(struct __ns1__Login_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Login_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__Login && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__Login(soap, "ns1:Login", &a->ns1__Login, ""))
				{	soap_flag_ns1__Login--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__Login_ * SOAP_FMAC2 soap_instantiate___ns1__Login_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Login_(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__Login_ *p;
	size_t k = sizeof(struct __ns1__Login_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__Login_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__Login_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__Login_ location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__Login_, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Login_(struct soap *soap, const struct __ns1__Login_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__Login_(soap, tag?tag:"-ns1:Login", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Login_ * SOAP_FMAC4 soap_get___ns1__Login_(struct soap *soap, struct __ns1__Login_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Login_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__ValidateAccess::__ns1__ValidateAccess()
{
	soap_default___ns1__ValidateAccess(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ValidateAccess(struct soap *soap, struct __ns1__ValidateAccess *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ValidateAccess = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ValidateAccess(struct soap *soap, const struct __ns1__ValidateAccess *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__ValidateAccess(soap, &a->ns1__ValidateAccess);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ValidateAccess(struct soap *soap, const char *tag, int id, const struct __ns1__ValidateAccess *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__ValidateAccess(soap, "ns1:ValidateAccess", -1, &a->ns1__ValidateAccess, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ValidateAccess * SOAP_FMAC4 soap_in___ns1__ValidateAccess(struct soap *soap, const char *tag, struct __ns1__ValidateAccess *a, const char *type)
{
	size_t soap_flag_ns1__ValidateAccess = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ValidateAccess *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__ValidateAccess, sizeof(struct __ns1__ValidateAccess), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ValidateAccess(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ValidateAccess && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__ValidateAccess(soap, "ns1:ValidateAccess", &a->ns1__ValidateAccess, ""))
				{	soap_flag_ns1__ValidateAccess--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ValidateAccess * SOAP_FMAC2 soap_instantiate___ns1__ValidateAccess(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ValidateAccess(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ValidateAccess *p;
	size_t k = sizeof(struct __ns1__ValidateAccess);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__ValidateAccess);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__ValidateAccess, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ValidateAccess location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__ValidateAccess, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ValidateAccess(struct soap *soap, const struct __ns1__ValidateAccess *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ValidateAccess(soap, tag?tag:"-ns1:ValidateAccess", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ValidateAccess * SOAP_FMAC4 soap_get___ns1__ValidateAccess(struct soap *soap, struct __ns1__ValidateAccess *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ValidateAccess(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__UpdateDataFormat::__ns1__UpdateDataFormat()
{
	soap_default___ns1__UpdateDataFormat(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__UpdateDataFormat(struct soap *soap, struct __ns1__UpdateDataFormat *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UpdateDataFormat = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__UpdateDataFormat(struct soap *soap, const struct __ns1__UpdateDataFormat *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__UpdateDataFormat(soap, &a->ns1__UpdateDataFormat);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__UpdateDataFormat(struct soap *soap, const char *tag, int id, const struct __ns1__UpdateDataFormat *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__UpdateDataFormat(soap, "ns1:UpdateDataFormat", -1, &a->ns1__UpdateDataFormat, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UpdateDataFormat * SOAP_FMAC4 soap_in___ns1__UpdateDataFormat(struct soap *soap, const char *tag, struct __ns1__UpdateDataFormat *a, const char *type)
{
	size_t soap_flag_ns1__UpdateDataFormat = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__UpdateDataFormat *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__UpdateDataFormat, sizeof(struct __ns1__UpdateDataFormat), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__UpdateDataFormat(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UpdateDataFormat && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__UpdateDataFormat(soap, "ns1:UpdateDataFormat", &a->ns1__UpdateDataFormat, ""))
				{	soap_flag_ns1__UpdateDataFormat--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__UpdateDataFormat * SOAP_FMAC2 soap_instantiate___ns1__UpdateDataFormat(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__UpdateDataFormat(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__UpdateDataFormat *p;
	size_t k = sizeof(struct __ns1__UpdateDataFormat);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__UpdateDataFormat);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__UpdateDataFormat, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__UpdateDataFormat location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__UpdateDataFormat, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__UpdateDataFormat(struct soap *soap, const struct __ns1__UpdateDataFormat *a, const char *tag, const char *type)
{
	if (soap_out___ns1__UpdateDataFormat(soap, tag?tag:"-ns1:UpdateDataFormat", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UpdateDataFormat * SOAP_FMAC4 soap_get___ns1__UpdateDataFormat(struct soap *soap, struct __ns1__UpdateDataFormat *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__UpdateDataFormat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__DataFormats::__ns1__DataFormats()
{
	soap_default___ns1__DataFormats(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__DataFormats(struct soap *soap, struct __ns1__DataFormats *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__DataFormats = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__DataFormats(struct soap *soap, const struct __ns1__DataFormats *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__DataFormats(soap, &a->ns1__DataFormats);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__DataFormats(struct soap *soap, const char *tag, int id, const struct __ns1__DataFormats *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__DataFormats(soap, "ns1:DataFormats", -1, &a->ns1__DataFormats, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DataFormats * SOAP_FMAC4 soap_in___ns1__DataFormats(struct soap *soap, const char *tag, struct __ns1__DataFormats *a, const char *type)
{
	size_t soap_flag_ns1__DataFormats = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__DataFormats *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__DataFormats, sizeof(struct __ns1__DataFormats), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__DataFormats(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__DataFormats && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__DataFormats(soap, "ns1:DataFormats", &a->ns1__DataFormats, ""))
				{	soap_flag_ns1__DataFormats--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__DataFormats * SOAP_FMAC2 soap_instantiate___ns1__DataFormats(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__DataFormats(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__DataFormats *p;
	size_t k = sizeof(struct __ns1__DataFormats);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__DataFormats);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__DataFormats, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__DataFormats location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__DataFormats, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__DataFormats(struct soap *soap, const struct __ns1__DataFormats *a, const char *tag, const char *type)
{
	if (soap_out___ns1__DataFormats(soap, tag?tag:"-ns1:DataFormats", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DataFormats * SOAP_FMAC4 soap_get___ns1__DataFormats(struct soap *soap, struct __ns1__DataFormats *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__DataFormats(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__DataClientLatestVersion::__ns1__DataClientLatestVersion()
{
	soap_default___ns1__DataClientLatestVersion(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__DataClientLatestVersion(struct soap *soap, struct __ns1__DataClientLatestVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__DataClientLatestVersion = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__DataClientLatestVersion(struct soap *soap, const struct __ns1__DataClientLatestVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__DataClientLatestVersion(soap, &a->ns1__DataClientLatestVersion);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__DataClientLatestVersion(struct soap *soap, const char *tag, int id, const struct __ns1__DataClientLatestVersion *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__DataClientLatestVersion(soap, "ns1:DataClientLatestVersion", -1, &a->ns1__DataClientLatestVersion, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DataClientLatestVersion * SOAP_FMAC4 soap_in___ns1__DataClientLatestVersion(struct soap *soap, const char *tag, struct __ns1__DataClientLatestVersion *a, const char *type)
{
	size_t soap_flag_ns1__DataClientLatestVersion = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__DataClientLatestVersion *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__DataClientLatestVersion, sizeof(struct __ns1__DataClientLatestVersion), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__DataClientLatestVersion(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__DataClientLatestVersion && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__DataClientLatestVersion(soap, "ns1:DataClientLatestVersion", &a->ns1__DataClientLatestVersion, ""))
				{	soap_flag_ns1__DataClientLatestVersion--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__DataClientLatestVersion * SOAP_FMAC2 soap_instantiate___ns1__DataClientLatestVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__DataClientLatestVersion(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__DataClientLatestVersion *p;
	size_t k = sizeof(struct __ns1__DataClientLatestVersion);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__DataClientLatestVersion);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__DataClientLatestVersion, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__DataClientLatestVersion location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__DataClientLatestVersion, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__DataClientLatestVersion(struct soap *soap, const struct __ns1__DataClientLatestVersion *a, const char *tag, const char *type)
{
	if (soap_out___ns1__DataClientLatestVersion(soap, tag?tag:"-ns1:DataClientLatestVersion", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DataClientLatestVersion * SOAP_FMAC4 soap_get___ns1__DataClientLatestVersion(struct soap *soap, struct __ns1__DataClientLatestVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__DataClientLatestVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__SymbolChangesByExchange::__ns1__SymbolChangesByExchange()
{
	soap_default___ns1__SymbolChangesByExchange(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SymbolChangesByExchange(struct soap *soap, struct __ns1__SymbolChangesByExchange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SymbolChangesByExchange = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SymbolChangesByExchange(struct soap *soap, const struct __ns1__SymbolChangesByExchange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SymbolChangesByExchange(soap, &a->ns1__SymbolChangesByExchange);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SymbolChangesByExchange(struct soap *soap, const char *tag, int id, const struct __ns1__SymbolChangesByExchange *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SymbolChangesByExchange(soap, "ns1:SymbolChangesByExchange", -1, &a->ns1__SymbolChangesByExchange, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolChangesByExchange * SOAP_FMAC4 soap_in___ns1__SymbolChangesByExchange(struct soap *soap, const char *tag, struct __ns1__SymbolChangesByExchange *a, const char *type)
{
	size_t soap_flag_ns1__SymbolChangesByExchange = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SymbolChangesByExchange *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__SymbolChangesByExchange, sizeof(struct __ns1__SymbolChangesByExchange), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SymbolChangesByExchange(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SymbolChangesByExchange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SymbolChangesByExchange(soap, "ns1:SymbolChangesByExchange", &a->ns1__SymbolChangesByExchange, ""))
				{	soap_flag_ns1__SymbolChangesByExchange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SymbolChangesByExchange * SOAP_FMAC2 soap_instantiate___ns1__SymbolChangesByExchange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SymbolChangesByExchange(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SymbolChangesByExchange *p;
	size_t k = sizeof(struct __ns1__SymbolChangesByExchange);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SymbolChangesByExchange);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SymbolChangesByExchange, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SymbolChangesByExchange location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__SymbolChangesByExchange, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SymbolChangesByExchange(struct soap *soap, const struct __ns1__SymbolChangesByExchange *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SymbolChangesByExchange(soap, tag?tag:"-ns1:SymbolChangesByExchange", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolChangesByExchange * SOAP_FMAC4 soap_get___ns1__SymbolChangesByExchange(struct soap *soap, struct __ns1__SymbolChangesByExchange *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SymbolChangesByExchange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__QuoteListByDatePeriod2::__ns1__QuoteListByDatePeriod2()
{
	soap_default___ns1__QuoteListByDatePeriod2(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__QuoteListByDatePeriod2(struct soap *soap, struct __ns1__QuoteListByDatePeriod2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__QuoteListByDatePeriod2 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__QuoteListByDatePeriod2(struct soap *soap, const struct __ns1__QuoteListByDatePeriod2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__QuoteListByDatePeriod2(soap, &a->ns1__QuoteListByDatePeriod2);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__QuoteListByDatePeriod2(struct soap *soap, const char *tag, int id, const struct __ns1__QuoteListByDatePeriod2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__QuoteListByDatePeriod2(soap, "ns1:QuoteListByDatePeriod2", -1, &a->ns1__QuoteListByDatePeriod2, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QuoteListByDatePeriod2 * SOAP_FMAC4 soap_in___ns1__QuoteListByDatePeriod2(struct soap *soap, const char *tag, struct __ns1__QuoteListByDatePeriod2 *a, const char *type)
{
	size_t soap_flag_ns1__QuoteListByDatePeriod2 = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__QuoteListByDatePeriod2 *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__QuoteListByDatePeriod2, sizeof(struct __ns1__QuoteListByDatePeriod2), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__QuoteListByDatePeriod2(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__QuoteListByDatePeriod2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__QuoteListByDatePeriod2(soap, "ns1:QuoteListByDatePeriod2", &a->ns1__QuoteListByDatePeriod2, ""))
				{	soap_flag_ns1__QuoteListByDatePeriod2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__QuoteListByDatePeriod2 * SOAP_FMAC2 soap_instantiate___ns1__QuoteListByDatePeriod2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__QuoteListByDatePeriod2(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__QuoteListByDatePeriod2 *p;
	size_t k = sizeof(struct __ns1__QuoteListByDatePeriod2);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__QuoteListByDatePeriod2);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__QuoteListByDatePeriod2, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__QuoteListByDatePeriod2 location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__QuoteListByDatePeriod2, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__QuoteListByDatePeriod2(struct soap *soap, const struct __ns1__QuoteListByDatePeriod2 *a, const char *tag, const char *type)
{
	if (soap_out___ns1__QuoteListByDatePeriod2(soap, tag?tag:"-ns1:QuoteListByDatePeriod2", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QuoteListByDatePeriod2 * SOAP_FMAC4 soap_get___ns1__QuoteListByDatePeriod2(struct soap *soap, struct __ns1__QuoteListByDatePeriod2 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__QuoteListByDatePeriod2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__QuoteListByDatePeriod::__ns1__QuoteListByDatePeriod()
{
	soap_default___ns1__QuoteListByDatePeriod(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__QuoteListByDatePeriod(struct soap *soap, struct __ns1__QuoteListByDatePeriod *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__QuoteListByDatePeriod = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__QuoteListByDatePeriod(struct soap *soap, const struct __ns1__QuoteListByDatePeriod *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__QuoteListByDatePeriod(soap, &a->ns1__QuoteListByDatePeriod);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__QuoteListByDatePeriod(struct soap *soap, const char *tag, int id, const struct __ns1__QuoteListByDatePeriod *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__QuoteListByDatePeriod(soap, "ns1:QuoteListByDatePeriod", -1, &a->ns1__QuoteListByDatePeriod, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QuoteListByDatePeriod * SOAP_FMAC4 soap_in___ns1__QuoteListByDatePeriod(struct soap *soap, const char *tag, struct __ns1__QuoteListByDatePeriod *a, const char *type)
{
	size_t soap_flag_ns1__QuoteListByDatePeriod = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__QuoteListByDatePeriod *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__QuoteListByDatePeriod, sizeof(struct __ns1__QuoteListByDatePeriod), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__QuoteListByDatePeriod(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__QuoteListByDatePeriod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__QuoteListByDatePeriod(soap, "ns1:QuoteListByDatePeriod", &a->ns1__QuoteListByDatePeriod, ""))
				{	soap_flag_ns1__QuoteListByDatePeriod--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__QuoteListByDatePeriod * SOAP_FMAC2 soap_instantiate___ns1__QuoteListByDatePeriod(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__QuoteListByDatePeriod(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__QuoteListByDatePeriod *p;
	size_t k = sizeof(struct __ns1__QuoteListByDatePeriod);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__QuoteListByDatePeriod);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__QuoteListByDatePeriod, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__QuoteListByDatePeriod location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__QuoteListByDatePeriod, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__QuoteListByDatePeriod(struct soap *soap, const struct __ns1__QuoteListByDatePeriod *a, const char *tag, const char *type)
{
	if (soap_out___ns1__QuoteListByDatePeriod(soap, tag?tag:"-ns1:QuoteListByDatePeriod", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QuoteListByDatePeriod * SOAP_FMAC4 soap_get___ns1__QuoteListByDatePeriod(struct soap *soap, struct __ns1__QuoteListByDatePeriod *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__QuoteListByDatePeriod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__SymbolHistoryPeriodByDateRange::__ns1__SymbolHistoryPeriodByDateRange()
{
	soap_default___ns1__SymbolHistoryPeriodByDateRange(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SymbolHistoryPeriodByDateRange(struct soap *soap, struct __ns1__SymbolHistoryPeriodByDateRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SymbolHistoryPeriodByDateRange = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SymbolHistoryPeriodByDateRange(struct soap *soap, const struct __ns1__SymbolHistoryPeriodByDateRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SymbolHistoryPeriodByDateRange(soap, &a->ns1__SymbolHistoryPeriodByDateRange);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SymbolHistoryPeriodByDateRange(struct soap *soap, const char *tag, int id, const struct __ns1__SymbolHistoryPeriodByDateRange *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SymbolHistoryPeriodByDateRange(soap, "ns1:SymbolHistoryPeriodByDateRange", -1, &a->ns1__SymbolHistoryPeriodByDateRange, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolHistoryPeriodByDateRange * SOAP_FMAC4 soap_in___ns1__SymbolHistoryPeriodByDateRange(struct soap *soap, const char *tag, struct __ns1__SymbolHistoryPeriodByDateRange *a, const char *type)
{
	size_t soap_flag_ns1__SymbolHistoryPeriodByDateRange = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SymbolHistoryPeriodByDateRange *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__SymbolHistoryPeriodByDateRange, sizeof(struct __ns1__SymbolHistoryPeriodByDateRange), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SymbolHistoryPeriodByDateRange(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SymbolHistoryPeriodByDateRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SymbolHistoryPeriodByDateRange(soap, "ns1:SymbolHistoryPeriodByDateRange", &a->ns1__SymbolHistoryPeriodByDateRange, ""))
				{	soap_flag_ns1__SymbolHistoryPeriodByDateRange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SymbolHistoryPeriodByDateRange * SOAP_FMAC2 soap_instantiate___ns1__SymbolHistoryPeriodByDateRange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SymbolHistoryPeriodByDateRange(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SymbolHistoryPeriodByDateRange *p;
	size_t k = sizeof(struct __ns1__SymbolHistoryPeriodByDateRange);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SymbolHistoryPeriodByDateRange);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SymbolHistoryPeriodByDateRange, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SymbolHistoryPeriodByDateRange location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__SymbolHistoryPeriodByDateRange, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SymbolHistoryPeriodByDateRange(struct soap *soap, const struct __ns1__SymbolHistoryPeriodByDateRange *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SymbolHistoryPeriodByDateRange(soap, tag?tag:"-ns1:SymbolHistoryPeriodByDateRange", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolHistoryPeriodByDateRange * SOAP_FMAC4 soap_get___ns1__SymbolHistoryPeriodByDateRange(struct soap *soap, struct __ns1__SymbolHistoryPeriodByDateRange *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SymbolHistoryPeriodByDateRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__SymbolHistoryPeriod::__ns1__SymbolHistoryPeriod()
{
	soap_default___ns1__SymbolHistoryPeriod(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SymbolHistoryPeriod(struct soap *soap, struct __ns1__SymbolHistoryPeriod *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SymbolHistoryPeriod = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SymbolHistoryPeriod(struct soap *soap, const struct __ns1__SymbolHistoryPeriod *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SymbolHistoryPeriod(soap, &a->ns1__SymbolHistoryPeriod);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SymbolHistoryPeriod(struct soap *soap, const char *tag, int id, const struct __ns1__SymbolHistoryPeriod *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SymbolHistoryPeriod(soap, "ns1:SymbolHistoryPeriod", -1, &a->ns1__SymbolHistoryPeriod, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolHistoryPeriod * SOAP_FMAC4 soap_in___ns1__SymbolHistoryPeriod(struct soap *soap, const char *tag, struct __ns1__SymbolHistoryPeriod *a, const char *type)
{
	size_t soap_flag_ns1__SymbolHistoryPeriod = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SymbolHistoryPeriod *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__SymbolHistoryPeriod, sizeof(struct __ns1__SymbolHistoryPeriod), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SymbolHistoryPeriod(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SymbolHistoryPeriod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SymbolHistoryPeriod(soap, "ns1:SymbolHistoryPeriod", &a->ns1__SymbolHistoryPeriod, ""))
				{	soap_flag_ns1__SymbolHistoryPeriod--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SymbolHistoryPeriod * SOAP_FMAC2 soap_instantiate___ns1__SymbolHistoryPeriod(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SymbolHistoryPeriod(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SymbolHistoryPeriod *p;
	size_t k = sizeof(struct __ns1__SymbolHistoryPeriod);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SymbolHistoryPeriod);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SymbolHistoryPeriod, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SymbolHistoryPeriod location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__SymbolHistoryPeriod, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SymbolHistoryPeriod(struct soap *soap, const struct __ns1__SymbolHistoryPeriod *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SymbolHistoryPeriod(soap, tag?tag:"-ns1:SymbolHistoryPeriod", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolHistoryPeriod * SOAP_FMAC4 soap_get___ns1__SymbolHistoryPeriod(struct soap *soap, struct __ns1__SymbolHistoryPeriod *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SymbolHistoryPeriod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__CountryList::__ns1__CountryList()
{
	soap_default___ns1__CountryList(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__CountryList(struct soap *soap, struct __ns1__CountryList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CountryList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__CountryList(struct soap *soap, const struct __ns1__CountryList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__CountryList(soap, &a->ns1__CountryList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__CountryList(struct soap *soap, const char *tag, int id, const struct __ns1__CountryList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__CountryList(soap, "ns1:CountryList", -1, &a->ns1__CountryList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CountryList * SOAP_FMAC4 soap_in___ns1__CountryList(struct soap *soap, const char *tag, struct __ns1__CountryList *a, const char *type)
{
	size_t soap_flag_ns1__CountryList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__CountryList *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__CountryList, sizeof(struct __ns1__CountryList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__CountryList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CountryList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__CountryList(soap, "ns1:CountryList", &a->ns1__CountryList, ""))
				{	soap_flag_ns1__CountryList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__CountryList * SOAP_FMAC2 soap_instantiate___ns1__CountryList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__CountryList(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__CountryList *p;
	size_t k = sizeof(struct __ns1__CountryList);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__CountryList);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__CountryList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__CountryList location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__CountryList, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__CountryList(struct soap *soap, const struct __ns1__CountryList *a, const char *tag, const char *type)
{
	if (soap_out___ns1__CountryList(soap, tag?tag:"-ns1:CountryList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CountryList * SOAP_FMAC4 soap_get___ns1__CountryList(struct soap *soap, struct __ns1__CountryList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__CountryList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__SplitListBySymbol::__ns1__SplitListBySymbol()
{
	soap_default___ns1__SplitListBySymbol(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SplitListBySymbol(struct soap *soap, struct __ns1__SplitListBySymbol *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SplitListBySymbol = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SplitListBySymbol(struct soap *soap, const struct __ns1__SplitListBySymbol *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SplitListBySymbol(soap, &a->ns1__SplitListBySymbol);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SplitListBySymbol(struct soap *soap, const char *tag, int id, const struct __ns1__SplitListBySymbol *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SplitListBySymbol(soap, "ns1:SplitListBySymbol", -1, &a->ns1__SplitListBySymbol, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SplitListBySymbol * SOAP_FMAC4 soap_in___ns1__SplitListBySymbol(struct soap *soap, const char *tag, struct __ns1__SplitListBySymbol *a, const char *type)
{
	size_t soap_flag_ns1__SplitListBySymbol = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SplitListBySymbol *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__SplitListBySymbol, sizeof(struct __ns1__SplitListBySymbol), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SplitListBySymbol(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SplitListBySymbol && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SplitListBySymbol(soap, "ns1:SplitListBySymbol", &a->ns1__SplitListBySymbol, ""))
				{	soap_flag_ns1__SplitListBySymbol--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SplitListBySymbol * SOAP_FMAC2 soap_instantiate___ns1__SplitListBySymbol(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SplitListBySymbol(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SplitListBySymbol *p;
	size_t k = sizeof(struct __ns1__SplitListBySymbol);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SplitListBySymbol);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SplitListBySymbol, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SplitListBySymbol location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__SplitListBySymbol, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SplitListBySymbol(struct soap *soap, const struct __ns1__SplitListBySymbol *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SplitListBySymbol(soap, tag?tag:"-ns1:SplitListBySymbol", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SplitListBySymbol * SOAP_FMAC4 soap_get___ns1__SplitListBySymbol(struct soap *soap, struct __ns1__SplitListBySymbol *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SplitListBySymbol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__SplitListByExchange::__ns1__SplitListByExchange()
{
	soap_default___ns1__SplitListByExchange(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SplitListByExchange(struct soap *soap, struct __ns1__SplitListByExchange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SplitListByExchange = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SplitListByExchange(struct soap *soap, const struct __ns1__SplitListByExchange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SplitListByExchange(soap, &a->ns1__SplitListByExchange);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SplitListByExchange(struct soap *soap, const char *tag, int id, const struct __ns1__SplitListByExchange *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SplitListByExchange(soap, "ns1:SplitListByExchange", -1, &a->ns1__SplitListByExchange, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SplitListByExchange * SOAP_FMAC4 soap_in___ns1__SplitListByExchange(struct soap *soap, const char *tag, struct __ns1__SplitListByExchange *a, const char *type)
{
	size_t soap_flag_ns1__SplitListByExchange = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SplitListByExchange *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__SplitListByExchange, sizeof(struct __ns1__SplitListByExchange), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SplitListByExchange(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SplitListByExchange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SplitListByExchange(soap, "ns1:SplitListByExchange", &a->ns1__SplitListByExchange, ""))
				{	soap_flag_ns1__SplitListByExchange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SplitListByExchange * SOAP_FMAC2 soap_instantiate___ns1__SplitListByExchange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SplitListByExchange(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SplitListByExchange *p;
	size_t k = sizeof(struct __ns1__SplitListByExchange);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SplitListByExchange);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SplitListByExchange, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SplitListByExchange location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__SplitListByExchange, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SplitListByExchange(struct soap *soap, const struct __ns1__SplitListByExchange *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SplitListByExchange(soap, tag?tag:"-ns1:SplitListByExchange", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SplitListByExchange * SOAP_FMAC4 soap_get___ns1__SplitListByExchange(struct soap *soap, struct __ns1__SplitListByExchange *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SplitListByExchange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__ExchangeMonths::__ns1__ExchangeMonths()
{
	soap_default___ns1__ExchangeMonths(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ExchangeMonths(struct soap *soap, struct __ns1__ExchangeMonths *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ExchangeMonths = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ExchangeMonths(struct soap *soap, const struct __ns1__ExchangeMonths *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__ExchangeMonths(soap, &a->ns1__ExchangeMonths);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ExchangeMonths(struct soap *soap, const char *tag, int id, const struct __ns1__ExchangeMonths *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__ExchangeMonths(soap, "ns1:ExchangeMonths", -1, &a->ns1__ExchangeMonths, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ExchangeMonths * SOAP_FMAC4 soap_in___ns1__ExchangeMonths(struct soap *soap, const char *tag, struct __ns1__ExchangeMonths *a, const char *type)
{
	size_t soap_flag_ns1__ExchangeMonths = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ExchangeMonths *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__ExchangeMonths, sizeof(struct __ns1__ExchangeMonths), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ExchangeMonths(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ExchangeMonths && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__ExchangeMonths(soap, "ns1:ExchangeMonths", &a->ns1__ExchangeMonths, ""))
				{	soap_flag_ns1__ExchangeMonths--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ExchangeMonths * SOAP_FMAC2 soap_instantiate___ns1__ExchangeMonths(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ExchangeMonths(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ExchangeMonths *p;
	size_t k = sizeof(struct __ns1__ExchangeMonths);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__ExchangeMonths);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__ExchangeMonths, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ExchangeMonths location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__ExchangeMonths, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ExchangeMonths(struct soap *soap, const struct __ns1__ExchangeMonths *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ExchangeMonths(soap, tag?tag:"-ns1:ExchangeMonths", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ExchangeMonths * SOAP_FMAC4 soap_get___ns1__ExchangeMonths(struct soap *soap, struct __ns1__ExchangeMonths *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ExchangeMonths(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__SymbolChart::__ns1__SymbolChart()
{
	soap_default___ns1__SymbolChart(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SymbolChart(struct soap *soap, struct __ns1__SymbolChart *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SymbolChart = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SymbolChart(struct soap *soap, const struct __ns1__SymbolChart *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SymbolChart(soap, &a->ns1__SymbolChart);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SymbolChart(struct soap *soap, const char *tag, int id, const struct __ns1__SymbolChart *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SymbolChart(soap, "ns1:SymbolChart", -1, &a->ns1__SymbolChart, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolChart * SOAP_FMAC4 soap_in___ns1__SymbolChart(struct soap *soap, const char *tag, struct __ns1__SymbolChart *a, const char *type)
{
	size_t soap_flag_ns1__SymbolChart = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SymbolChart *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__SymbolChart, sizeof(struct __ns1__SymbolChart), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SymbolChart(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SymbolChart && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SymbolChart(soap, "ns1:SymbolChart", &a->ns1__SymbolChart, ""))
				{	soap_flag_ns1__SymbolChart--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SymbolChart * SOAP_FMAC2 soap_instantiate___ns1__SymbolChart(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SymbolChart(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SymbolChart *p;
	size_t k = sizeof(struct __ns1__SymbolChart);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SymbolChart);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SymbolChart, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SymbolChart location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__SymbolChart, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SymbolChart(struct soap *soap, const struct __ns1__SymbolChart *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SymbolChart(soap, tag?tag:"-ns1:SymbolChart", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolChart * SOAP_FMAC4 soap_get___ns1__SymbolChart(struct soap *soap, struct __ns1__SymbolChart *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SymbolChart(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__Top10Losses::__ns1__Top10Losses()
{
	soap_default___ns1__Top10Losses(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Top10Losses(struct soap *soap, struct __ns1__Top10Losses *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__Top10Losses = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Top10Losses(struct soap *soap, const struct __ns1__Top10Losses *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__Top10Losses(soap, &a->ns1__Top10Losses);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Top10Losses(struct soap *soap, const char *tag, int id, const struct __ns1__Top10Losses *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__Top10Losses(soap, "ns1:Top10Losses", -1, &a->ns1__Top10Losses, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Top10Losses * SOAP_FMAC4 soap_in___ns1__Top10Losses(struct soap *soap, const char *tag, struct __ns1__Top10Losses *a, const char *type)
{
	size_t soap_flag_ns1__Top10Losses = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__Top10Losses *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__Top10Losses, sizeof(struct __ns1__Top10Losses), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Top10Losses(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__Top10Losses && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__Top10Losses(soap, "ns1:Top10Losses", &a->ns1__Top10Losses, ""))
				{	soap_flag_ns1__Top10Losses--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__Top10Losses * SOAP_FMAC2 soap_instantiate___ns1__Top10Losses(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Top10Losses(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__Top10Losses *p;
	size_t k = sizeof(struct __ns1__Top10Losses);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__Top10Losses);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__Top10Losses, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__Top10Losses location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__Top10Losses, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Top10Losses(struct soap *soap, const struct __ns1__Top10Losses *a, const char *tag, const char *type)
{
	if (soap_out___ns1__Top10Losses(soap, tag?tag:"-ns1:Top10Losses", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Top10Losses * SOAP_FMAC4 soap_get___ns1__Top10Losses(struct soap *soap, struct __ns1__Top10Losses *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Top10Losses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__Top10Gains::__ns1__Top10Gains()
{
	soap_default___ns1__Top10Gains(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Top10Gains(struct soap *soap, struct __ns1__Top10Gains *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__Top10Gains = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Top10Gains(struct soap *soap, const struct __ns1__Top10Gains *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__Top10Gains(soap, &a->ns1__Top10Gains);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Top10Gains(struct soap *soap, const char *tag, int id, const struct __ns1__Top10Gains *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__Top10Gains(soap, "ns1:Top10Gains", -1, &a->ns1__Top10Gains, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Top10Gains * SOAP_FMAC4 soap_in___ns1__Top10Gains(struct soap *soap, const char *tag, struct __ns1__Top10Gains *a, const char *type)
{
	size_t soap_flag_ns1__Top10Gains = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__Top10Gains *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__Top10Gains, sizeof(struct __ns1__Top10Gains), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Top10Gains(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__Top10Gains && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__Top10Gains(soap, "ns1:Top10Gains", &a->ns1__Top10Gains, ""))
				{	soap_flag_ns1__Top10Gains--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__Top10Gains * SOAP_FMAC2 soap_instantiate___ns1__Top10Gains(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Top10Gains(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__Top10Gains *p;
	size_t k = sizeof(struct __ns1__Top10Gains);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__Top10Gains);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__Top10Gains, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__Top10Gains location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__Top10Gains, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Top10Gains(struct soap *soap, const struct __ns1__Top10Gains *a, const char *tag, const char *type)
{
	if (soap_out___ns1__Top10Gains(soap, tag?tag:"-ns1:Top10Gains", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Top10Gains * SOAP_FMAC4 soap_get___ns1__Top10Gains(struct soap *soap, struct __ns1__Top10Gains *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Top10Gains(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__SymbolHistory::__ns1__SymbolHistory()
{
	soap_default___ns1__SymbolHistory(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SymbolHistory(struct soap *soap, struct __ns1__SymbolHistory *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SymbolHistory = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SymbolHistory(struct soap *soap, const struct __ns1__SymbolHistory *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SymbolHistory(soap, &a->ns1__SymbolHistory);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SymbolHistory(struct soap *soap, const char *tag, int id, const struct __ns1__SymbolHistory *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SymbolHistory(soap, "ns1:SymbolHistory", -1, &a->ns1__SymbolHistory, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolHistory * SOAP_FMAC4 soap_in___ns1__SymbolHistory(struct soap *soap, const char *tag, struct __ns1__SymbolHistory *a, const char *type)
{
	size_t soap_flag_ns1__SymbolHistory = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SymbolHistory *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__SymbolHistory, sizeof(struct __ns1__SymbolHistory), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SymbolHistory(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SymbolHistory && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SymbolHistory(soap, "ns1:SymbolHistory", &a->ns1__SymbolHistory, ""))
				{	soap_flag_ns1__SymbolHistory--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SymbolHistory * SOAP_FMAC2 soap_instantiate___ns1__SymbolHistory(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SymbolHistory(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SymbolHistory *p;
	size_t k = sizeof(struct __ns1__SymbolHistory);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SymbolHistory);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SymbolHistory, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SymbolHistory location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__SymbolHistory, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SymbolHistory(struct soap *soap, const struct __ns1__SymbolHistory *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SymbolHistory(soap, tag?tag:"-ns1:SymbolHistory", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolHistory * SOAP_FMAC4 soap_get___ns1__SymbolHistory(struct soap *soap, struct __ns1__SymbolHistory *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SymbolHistory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__QuoteListByDate2::__ns1__QuoteListByDate2()
{
	soap_default___ns1__QuoteListByDate2(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__QuoteListByDate2(struct soap *soap, struct __ns1__QuoteListByDate2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__QuoteListByDate2 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__QuoteListByDate2(struct soap *soap, const struct __ns1__QuoteListByDate2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__QuoteListByDate2(soap, &a->ns1__QuoteListByDate2);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__QuoteListByDate2(struct soap *soap, const char *tag, int id, const struct __ns1__QuoteListByDate2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__QuoteListByDate2(soap, "ns1:QuoteListByDate2", -1, &a->ns1__QuoteListByDate2, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QuoteListByDate2 * SOAP_FMAC4 soap_in___ns1__QuoteListByDate2(struct soap *soap, const char *tag, struct __ns1__QuoteListByDate2 *a, const char *type)
{
	size_t soap_flag_ns1__QuoteListByDate2 = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__QuoteListByDate2 *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__QuoteListByDate2, sizeof(struct __ns1__QuoteListByDate2), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__QuoteListByDate2(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__QuoteListByDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__QuoteListByDate2(soap, "ns1:QuoteListByDate2", &a->ns1__QuoteListByDate2, ""))
				{	soap_flag_ns1__QuoteListByDate2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__QuoteListByDate2 * SOAP_FMAC2 soap_instantiate___ns1__QuoteListByDate2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__QuoteListByDate2(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__QuoteListByDate2 *p;
	size_t k = sizeof(struct __ns1__QuoteListByDate2);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__QuoteListByDate2);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__QuoteListByDate2, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__QuoteListByDate2 location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__QuoteListByDate2, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__QuoteListByDate2(struct soap *soap, const struct __ns1__QuoteListByDate2 *a, const char *tag, const char *type)
{
	if (soap_out___ns1__QuoteListByDate2(soap, tag?tag:"-ns1:QuoteListByDate2", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QuoteListByDate2 * SOAP_FMAC4 soap_get___ns1__QuoteListByDate2(struct soap *soap, struct __ns1__QuoteListByDate2 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__QuoteListByDate2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__QuoteListByDate::__ns1__QuoteListByDate()
{
	soap_default___ns1__QuoteListByDate(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__QuoteListByDate(struct soap *soap, struct __ns1__QuoteListByDate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__QuoteListByDate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__QuoteListByDate(struct soap *soap, const struct __ns1__QuoteListByDate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__QuoteListByDate(soap, &a->ns1__QuoteListByDate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__QuoteListByDate(struct soap *soap, const char *tag, int id, const struct __ns1__QuoteListByDate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__QuoteListByDate(soap, "ns1:QuoteListByDate", -1, &a->ns1__QuoteListByDate, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QuoteListByDate * SOAP_FMAC4 soap_in___ns1__QuoteListByDate(struct soap *soap, const char *tag, struct __ns1__QuoteListByDate *a, const char *type)
{
	size_t soap_flag_ns1__QuoteListByDate = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__QuoteListByDate *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__QuoteListByDate, sizeof(struct __ns1__QuoteListByDate), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__QuoteListByDate(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__QuoteListByDate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__QuoteListByDate(soap, "ns1:QuoteListByDate", &a->ns1__QuoteListByDate, ""))
				{	soap_flag_ns1__QuoteListByDate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__QuoteListByDate * SOAP_FMAC2 soap_instantiate___ns1__QuoteListByDate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__QuoteListByDate(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__QuoteListByDate *p;
	size_t k = sizeof(struct __ns1__QuoteListByDate);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__QuoteListByDate);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__QuoteListByDate, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__QuoteListByDate location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__QuoteListByDate, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__QuoteListByDate(struct soap *soap, const struct __ns1__QuoteListByDate *a, const char *tag, const char *type)
{
	if (soap_out___ns1__QuoteListByDate(soap, tag?tag:"-ns1:QuoteListByDate", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QuoteListByDate * SOAP_FMAC4 soap_get___ns1__QuoteListByDate(struct soap *soap, struct __ns1__QuoteListByDate *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__QuoteListByDate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__TechnicalList::__ns1__TechnicalList()
{
	soap_default___ns1__TechnicalList(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__TechnicalList(struct soap *soap, struct __ns1__TechnicalList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__TechnicalList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__TechnicalList(struct soap *soap, const struct __ns1__TechnicalList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__TechnicalList(soap, &a->ns1__TechnicalList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__TechnicalList(struct soap *soap, const char *tag, int id, const struct __ns1__TechnicalList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__TechnicalList(soap, "ns1:TechnicalList", -1, &a->ns1__TechnicalList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__TechnicalList * SOAP_FMAC4 soap_in___ns1__TechnicalList(struct soap *soap, const char *tag, struct __ns1__TechnicalList *a, const char *type)
{
	size_t soap_flag_ns1__TechnicalList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__TechnicalList *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__TechnicalList, sizeof(struct __ns1__TechnicalList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__TechnicalList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__TechnicalList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__TechnicalList(soap, "ns1:TechnicalList", &a->ns1__TechnicalList, ""))
				{	soap_flag_ns1__TechnicalList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__TechnicalList * SOAP_FMAC2 soap_instantiate___ns1__TechnicalList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__TechnicalList(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__TechnicalList *p;
	size_t k = sizeof(struct __ns1__TechnicalList);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__TechnicalList);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__TechnicalList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__TechnicalList location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__TechnicalList, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__TechnicalList(struct soap *soap, const struct __ns1__TechnicalList *a, const char *tag, const char *type)
{
	if (soap_out___ns1__TechnicalList(soap, tag?tag:"-ns1:TechnicalList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__TechnicalList * SOAP_FMAC4 soap_get___ns1__TechnicalList(struct soap *soap, struct __ns1__TechnicalList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__TechnicalList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__FundamentalList::__ns1__FundamentalList()
{
	soap_default___ns1__FundamentalList(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__FundamentalList(struct soap *soap, struct __ns1__FundamentalList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__FundamentalList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__FundamentalList(struct soap *soap, const struct __ns1__FundamentalList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__FundamentalList(soap, &a->ns1__FundamentalList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__FundamentalList(struct soap *soap, const char *tag, int id, const struct __ns1__FundamentalList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__FundamentalList(soap, "ns1:FundamentalList", -1, &a->ns1__FundamentalList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__FundamentalList * SOAP_FMAC4 soap_in___ns1__FundamentalList(struct soap *soap, const char *tag, struct __ns1__FundamentalList *a, const char *type)
{
	size_t soap_flag_ns1__FundamentalList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__FundamentalList *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__FundamentalList, sizeof(struct __ns1__FundamentalList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__FundamentalList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__FundamentalList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__FundamentalList(soap, "ns1:FundamentalList", &a->ns1__FundamentalList, ""))
				{	soap_flag_ns1__FundamentalList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__FundamentalList * SOAP_FMAC2 soap_instantiate___ns1__FundamentalList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__FundamentalList(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__FundamentalList *p;
	size_t k = sizeof(struct __ns1__FundamentalList);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__FundamentalList);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__FundamentalList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__FundamentalList location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__FundamentalList, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__FundamentalList(struct soap *soap, const struct __ns1__FundamentalList *a, const char *tag, const char *type)
{
	if (soap_out___ns1__FundamentalList(soap, tag?tag:"-ns1:FundamentalList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__FundamentalList * SOAP_FMAC4 soap_get___ns1__FundamentalList(struct soap *soap, struct __ns1__FundamentalList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__FundamentalList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__NewsListBySymbol::__ns1__NewsListBySymbol()
{
	soap_default___ns1__NewsListBySymbol(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__NewsListBySymbol(struct soap *soap, struct __ns1__NewsListBySymbol *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__NewsListBySymbol = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__NewsListBySymbol(struct soap *soap, const struct __ns1__NewsListBySymbol *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__NewsListBySymbol(soap, &a->ns1__NewsListBySymbol);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__NewsListBySymbol(struct soap *soap, const char *tag, int id, const struct __ns1__NewsListBySymbol *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__NewsListBySymbol(soap, "ns1:NewsListBySymbol", -1, &a->ns1__NewsListBySymbol, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__NewsListBySymbol * SOAP_FMAC4 soap_in___ns1__NewsListBySymbol(struct soap *soap, const char *tag, struct __ns1__NewsListBySymbol *a, const char *type)
{
	size_t soap_flag_ns1__NewsListBySymbol = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__NewsListBySymbol *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__NewsListBySymbol, sizeof(struct __ns1__NewsListBySymbol), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__NewsListBySymbol(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__NewsListBySymbol && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__NewsListBySymbol(soap, "ns1:NewsListBySymbol", &a->ns1__NewsListBySymbol, ""))
				{	soap_flag_ns1__NewsListBySymbol--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__NewsListBySymbol * SOAP_FMAC2 soap_instantiate___ns1__NewsListBySymbol(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__NewsListBySymbol(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__NewsListBySymbol *p;
	size_t k = sizeof(struct __ns1__NewsListBySymbol);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__NewsListBySymbol);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__NewsListBySymbol, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__NewsListBySymbol location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__NewsListBySymbol, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__NewsListBySymbol(struct soap *soap, const struct __ns1__NewsListBySymbol *a, const char *tag, const char *type)
{
	if (soap_out___ns1__NewsListBySymbol(soap, tag?tag:"-ns1:NewsListBySymbol", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__NewsListBySymbol * SOAP_FMAC4 soap_get___ns1__NewsListBySymbol(struct soap *soap, struct __ns1__NewsListBySymbol *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__NewsListBySymbol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__NewsList::__ns1__NewsList()
{
	soap_default___ns1__NewsList(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__NewsList(struct soap *soap, struct __ns1__NewsList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__NewsList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__NewsList(struct soap *soap, const struct __ns1__NewsList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__NewsList(soap, &a->ns1__NewsList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__NewsList(struct soap *soap, const char *tag, int id, const struct __ns1__NewsList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__NewsList(soap, "ns1:NewsList", -1, &a->ns1__NewsList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__NewsList * SOAP_FMAC4 soap_in___ns1__NewsList(struct soap *soap, const char *tag, struct __ns1__NewsList *a, const char *type)
{
	size_t soap_flag_ns1__NewsList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__NewsList *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__NewsList, sizeof(struct __ns1__NewsList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__NewsList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__NewsList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__NewsList(soap, "ns1:NewsList", &a->ns1__NewsList, ""))
				{	soap_flag_ns1__NewsList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__NewsList * SOAP_FMAC2 soap_instantiate___ns1__NewsList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__NewsList(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__NewsList *p;
	size_t k = sizeof(struct __ns1__NewsList);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__NewsList);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__NewsList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__NewsList location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__NewsList, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__NewsList(struct soap *soap, const struct __ns1__NewsList *a, const char *tag, const char *type)
{
	if (soap_out___ns1__NewsList(soap, tag?tag:"-ns1:NewsList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__NewsList * SOAP_FMAC4 soap_get___ns1__NewsList(struct soap *soap, struct __ns1__NewsList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__NewsList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__QuoteList::__ns1__QuoteList()
{
	soap_default___ns1__QuoteList(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__QuoteList(struct soap *soap, struct __ns1__QuoteList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__QuoteList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__QuoteList(struct soap *soap, const struct __ns1__QuoteList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__QuoteList(soap, &a->ns1__QuoteList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__QuoteList(struct soap *soap, const char *tag, int id, const struct __ns1__QuoteList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__QuoteList(soap, "ns1:QuoteList", -1, &a->ns1__QuoteList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QuoteList * SOAP_FMAC4 soap_in___ns1__QuoteList(struct soap *soap, const char *tag, struct __ns1__QuoteList *a, const char *type)
{
	size_t soap_flag_ns1__QuoteList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__QuoteList *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__QuoteList, sizeof(struct __ns1__QuoteList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__QuoteList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__QuoteList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__QuoteList(soap, "ns1:QuoteList", &a->ns1__QuoteList, ""))
				{	soap_flag_ns1__QuoteList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__QuoteList * SOAP_FMAC2 soap_instantiate___ns1__QuoteList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__QuoteList(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__QuoteList *p;
	size_t k = sizeof(struct __ns1__QuoteList);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__QuoteList);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__QuoteList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__QuoteList location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__QuoteList, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__QuoteList(struct soap *soap, const struct __ns1__QuoteList *a, const char *tag, const char *type)
{
	if (soap_out___ns1__QuoteList(soap, tag?tag:"-ns1:QuoteList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QuoteList * SOAP_FMAC4 soap_get___ns1__QuoteList(struct soap *soap, struct __ns1__QuoteList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__QuoteList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__SymbolGet::__ns1__SymbolGet()
{
	soap_default___ns1__SymbolGet(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SymbolGet(struct soap *soap, struct __ns1__SymbolGet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SymbolGet = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SymbolGet(struct soap *soap, const struct __ns1__SymbolGet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SymbolGet(soap, &a->ns1__SymbolGet);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SymbolGet(struct soap *soap, const char *tag, int id, const struct __ns1__SymbolGet *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SymbolGet(soap, "ns1:SymbolGet", -1, &a->ns1__SymbolGet, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolGet * SOAP_FMAC4 soap_in___ns1__SymbolGet(struct soap *soap, const char *tag, struct __ns1__SymbolGet *a, const char *type)
{
	size_t soap_flag_ns1__SymbolGet = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SymbolGet *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__SymbolGet, sizeof(struct __ns1__SymbolGet), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SymbolGet(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SymbolGet && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SymbolGet(soap, "ns1:SymbolGet", &a->ns1__SymbolGet, ""))
				{	soap_flag_ns1__SymbolGet--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SymbolGet * SOAP_FMAC2 soap_instantiate___ns1__SymbolGet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SymbolGet(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SymbolGet *p;
	size_t k = sizeof(struct __ns1__SymbolGet);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SymbolGet);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SymbolGet, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SymbolGet location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__SymbolGet, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SymbolGet(struct soap *soap, const struct __ns1__SymbolGet *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SymbolGet(soap, tag?tag:"-ns1:SymbolGet", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolGet * SOAP_FMAC4 soap_get___ns1__SymbolGet(struct soap *soap, struct __ns1__SymbolGet *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SymbolGet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__QuoteList2::__ns1__QuoteList2()
{
	soap_default___ns1__QuoteList2(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__QuoteList2(struct soap *soap, struct __ns1__QuoteList2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__QuoteList2 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__QuoteList2(struct soap *soap, const struct __ns1__QuoteList2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__QuoteList2(soap, &a->ns1__QuoteList2);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__QuoteList2(struct soap *soap, const char *tag, int id, const struct __ns1__QuoteList2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__QuoteList2(soap, "ns1:QuoteList2", -1, &a->ns1__QuoteList2, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QuoteList2 * SOAP_FMAC4 soap_in___ns1__QuoteList2(struct soap *soap, const char *tag, struct __ns1__QuoteList2 *a, const char *type)
{
	size_t soap_flag_ns1__QuoteList2 = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__QuoteList2 *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__QuoteList2, sizeof(struct __ns1__QuoteList2), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__QuoteList2(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__QuoteList2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__QuoteList2(soap, "ns1:QuoteList2", &a->ns1__QuoteList2, ""))
				{	soap_flag_ns1__QuoteList2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__QuoteList2 * SOAP_FMAC2 soap_instantiate___ns1__QuoteList2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__QuoteList2(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__QuoteList2 *p;
	size_t k = sizeof(struct __ns1__QuoteList2);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__QuoteList2);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__QuoteList2, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__QuoteList2 location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__QuoteList2, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__QuoteList2(struct soap *soap, const struct __ns1__QuoteList2 *a, const char *tag, const char *type)
{
	if (soap_out___ns1__QuoteList2(soap, tag?tag:"-ns1:QuoteList2", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QuoteList2 * SOAP_FMAC4 soap_get___ns1__QuoteList2(struct soap *soap, struct __ns1__QuoteList2 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__QuoteList2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__QuoteGet::__ns1__QuoteGet()
{
	soap_default___ns1__QuoteGet(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__QuoteGet(struct soap *soap, struct __ns1__QuoteGet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__QuoteGet = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__QuoteGet(struct soap *soap, const struct __ns1__QuoteGet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__QuoteGet(soap, &a->ns1__QuoteGet);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__QuoteGet(struct soap *soap, const char *tag, int id, const struct __ns1__QuoteGet *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__QuoteGet(soap, "ns1:QuoteGet", -1, &a->ns1__QuoteGet, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QuoteGet * SOAP_FMAC4 soap_in___ns1__QuoteGet(struct soap *soap, const char *tag, struct __ns1__QuoteGet *a, const char *type)
{
	size_t soap_flag_ns1__QuoteGet = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__QuoteGet *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__QuoteGet, sizeof(struct __ns1__QuoteGet), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__QuoteGet(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__QuoteGet && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__QuoteGet(soap, "ns1:QuoteGet", &a->ns1__QuoteGet, ""))
				{	soap_flag_ns1__QuoteGet--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__QuoteGet * SOAP_FMAC2 soap_instantiate___ns1__QuoteGet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__QuoteGet(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__QuoteGet *p;
	size_t k = sizeof(struct __ns1__QuoteGet);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__QuoteGet);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__QuoteGet, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__QuoteGet location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__QuoteGet, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__QuoteGet(struct soap *soap, const struct __ns1__QuoteGet *a, const char *tag, const char *type)
{
	if (soap_out___ns1__QuoteGet(soap, tag?tag:"-ns1:QuoteGet", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QuoteGet * SOAP_FMAC4 soap_get___ns1__QuoteGet(struct soap *soap, struct __ns1__QuoteGet *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__QuoteGet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__SymbolList2::__ns1__SymbolList2()
{
	soap_default___ns1__SymbolList2(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SymbolList2(struct soap *soap, struct __ns1__SymbolList2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SymbolList2 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SymbolList2(struct soap *soap, const struct __ns1__SymbolList2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SymbolList2(soap, &a->ns1__SymbolList2);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SymbolList2(struct soap *soap, const char *tag, int id, const struct __ns1__SymbolList2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SymbolList2(soap, "ns1:SymbolList2", -1, &a->ns1__SymbolList2, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolList2 * SOAP_FMAC4 soap_in___ns1__SymbolList2(struct soap *soap, const char *tag, struct __ns1__SymbolList2 *a, const char *type)
{
	size_t soap_flag_ns1__SymbolList2 = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SymbolList2 *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__SymbolList2, sizeof(struct __ns1__SymbolList2), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SymbolList2(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SymbolList2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SymbolList2(soap, "ns1:SymbolList2", &a->ns1__SymbolList2, ""))
				{	soap_flag_ns1__SymbolList2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SymbolList2 * SOAP_FMAC2 soap_instantiate___ns1__SymbolList2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SymbolList2(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SymbolList2 *p;
	size_t k = sizeof(struct __ns1__SymbolList2);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SymbolList2);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SymbolList2, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SymbolList2 location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__SymbolList2, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SymbolList2(struct soap *soap, const struct __ns1__SymbolList2 *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SymbolList2(soap, tag?tag:"-ns1:SymbolList2", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolList2 * SOAP_FMAC4 soap_get___ns1__SymbolList2(struct soap *soap, struct __ns1__SymbolList2 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SymbolList2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__SymbolList::__ns1__SymbolList()
{
	soap_default___ns1__SymbolList(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SymbolList(struct soap *soap, struct __ns1__SymbolList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SymbolList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SymbolList(struct soap *soap, const struct __ns1__SymbolList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SymbolList(soap, &a->ns1__SymbolList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SymbolList(struct soap *soap, const char *tag, int id, const struct __ns1__SymbolList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SymbolList(soap, "ns1:SymbolList", -1, &a->ns1__SymbolList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolList * SOAP_FMAC4 soap_in___ns1__SymbolList(struct soap *soap, const char *tag, struct __ns1__SymbolList *a, const char *type)
{
	size_t soap_flag_ns1__SymbolList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SymbolList *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__SymbolList, sizeof(struct __ns1__SymbolList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SymbolList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SymbolList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SymbolList(soap, "ns1:SymbolList", &a->ns1__SymbolList, ""))
				{	soap_flag_ns1__SymbolList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SymbolList * SOAP_FMAC2 soap_instantiate___ns1__SymbolList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SymbolList(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SymbolList *p;
	size_t k = sizeof(struct __ns1__SymbolList);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SymbolList);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SymbolList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SymbolList location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__SymbolList, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SymbolList(struct soap *soap, const struct __ns1__SymbolList *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SymbolList(soap, tag?tag:"-ns1:SymbolList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SymbolList * SOAP_FMAC4 soap_get___ns1__SymbolList(struct soap *soap, struct __ns1__SymbolList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SymbolList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__ExchangeGet::__ns1__ExchangeGet()
{
	soap_default___ns1__ExchangeGet(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ExchangeGet(struct soap *soap, struct __ns1__ExchangeGet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ExchangeGet = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ExchangeGet(struct soap *soap, const struct __ns1__ExchangeGet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__ExchangeGet(soap, &a->ns1__ExchangeGet);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ExchangeGet(struct soap *soap, const char *tag, int id, const struct __ns1__ExchangeGet *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__ExchangeGet(soap, "ns1:ExchangeGet", -1, &a->ns1__ExchangeGet, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ExchangeGet * SOAP_FMAC4 soap_in___ns1__ExchangeGet(struct soap *soap, const char *tag, struct __ns1__ExchangeGet *a, const char *type)
{
	size_t soap_flag_ns1__ExchangeGet = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ExchangeGet *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__ExchangeGet, sizeof(struct __ns1__ExchangeGet), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ExchangeGet(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ExchangeGet && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__ExchangeGet(soap, "ns1:ExchangeGet", &a->ns1__ExchangeGet, ""))
				{	soap_flag_ns1__ExchangeGet--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ExchangeGet * SOAP_FMAC2 soap_instantiate___ns1__ExchangeGet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ExchangeGet(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ExchangeGet *p;
	size_t k = sizeof(struct __ns1__ExchangeGet);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__ExchangeGet);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__ExchangeGet, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ExchangeGet location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__ExchangeGet, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ExchangeGet(struct soap *soap, const struct __ns1__ExchangeGet *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ExchangeGet(soap, tag?tag:"-ns1:ExchangeGet", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ExchangeGet * SOAP_FMAC4 soap_get___ns1__ExchangeGet(struct soap *soap, struct __ns1__ExchangeGet *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ExchangeGet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__ExchangeList::__ns1__ExchangeList()
{
	soap_default___ns1__ExchangeList(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ExchangeList(struct soap *soap, struct __ns1__ExchangeList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ExchangeList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ExchangeList(struct soap *soap, const struct __ns1__ExchangeList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__ExchangeList(soap, &a->ns1__ExchangeList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ExchangeList(struct soap *soap, const char *tag, int id, const struct __ns1__ExchangeList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__ExchangeList(soap, "ns1:ExchangeList", -1, &a->ns1__ExchangeList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ExchangeList * SOAP_FMAC4 soap_in___ns1__ExchangeList(struct soap *soap, const char *tag, struct __ns1__ExchangeList *a, const char *type)
{
	size_t soap_flag_ns1__ExchangeList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ExchangeList *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__ExchangeList, sizeof(struct __ns1__ExchangeList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ExchangeList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ExchangeList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__ExchangeList(soap, "ns1:ExchangeList", &a->ns1__ExchangeList, ""))
				{	soap_flag_ns1__ExchangeList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ExchangeList * SOAP_FMAC2 soap_instantiate___ns1__ExchangeList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ExchangeList(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ExchangeList *p;
	size_t k = sizeof(struct __ns1__ExchangeList);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__ExchangeList);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__ExchangeList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ExchangeList location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__ExchangeList, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ExchangeList(struct soap *soap, const struct __ns1__ExchangeList *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ExchangeList(soap, tag?tag:"-ns1:ExchangeList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ExchangeList * SOAP_FMAC4 soap_get___ns1__ExchangeList(struct soap *soap, struct __ns1__ExchangeList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ExchangeList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__Membership::__ns1__Membership()
{
	soap_default___ns1__Membership(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Membership(struct soap *soap, struct __ns1__Membership *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__Membership = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Membership(struct soap *soap, const struct __ns1__Membership *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__Membership(soap, &a->ns1__Membership);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Membership(struct soap *soap, const char *tag, int id, const struct __ns1__Membership *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__Membership(soap, "ns1:Membership", -1, &a->ns1__Membership, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Membership * SOAP_FMAC4 soap_in___ns1__Membership(struct soap *soap, const char *tag, struct __ns1__Membership *a, const char *type)
{
	size_t soap_flag_ns1__Membership = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__Membership *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__Membership, sizeof(struct __ns1__Membership), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Membership(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__Membership && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__Membership(soap, "ns1:Membership", &a->ns1__Membership, ""))
				{	soap_flag_ns1__Membership--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__Membership * SOAP_FMAC2 soap_instantiate___ns1__Membership(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Membership(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__Membership *p;
	size_t k = sizeof(struct __ns1__Membership);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__Membership);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__Membership, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__Membership location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__Membership, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Membership(struct soap *soap, const struct __ns1__Membership *a, const char *tag, const char *type)
{
	if (soap_out___ns1__Membership(soap, tag?tag:"-ns1:Membership", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Membership * SOAP_FMAC4 soap_get___ns1__Membership(struct soap *soap, struct __ns1__Membership *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Membership(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__Login2::__ns1__Login2()
{
	soap_default___ns1__Login2(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Login2(struct soap *soap, struct __ns1__Login2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__Login2 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Login2(struct soap *soap, const struct __ns1__Login2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__Login2(soap, &a->ns1__Login2);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Login2(struct soap *soap, const char *tag, int id, const struct __ns1__Login2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__Login2(soap, "ns1:Login2", -1, &a->ns1__Login2, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Login2 * SOAP_FMAC4 soap_in___ns1__Login2(struct soap *soap, const char *tag, struct __ns1__Login2 *a, const char *type)
{
	size_t soap_flag_ns1__Login2 = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__Login2 *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__Login2, sizeof(struct __ns1__Login2), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Login2(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__Login2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__Login2(soap, "ns1:Login2", &a->ns1__Login2, ""))
				{	soap_flag_ns1__Login2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__Login2 * SOAP_FMAC2 soap_instantiate___ns1__Login2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Login2(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__Login2 *p;
	size_t k = sizeof(struct __ns1__Login2);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__Login2);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__Login2, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__Login2 location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__Login2, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Login2(struct soap *soap, const struct __ns1__Login2 *a, const char *tag, const char *type)
{
	if (soap_out___ns1__Login2(soap, tag?tag:"-ns1:Login2", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Login2 * SOAP_FMAC4 soap_get___ns1__Login2(struct soap *soap, struct __ns1__Login2 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Login2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

__ns1__Login::__ns1__Login()
{
	soap_default___ns1__Login(NULL, this);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Login(struct soap *soap, struct __ns1__Login *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__Login = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Login(struct soap *soap, const struct __ns1__Login *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__Login(soap, &a->ns1__Login);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Login(struct soap *soap, const char *tag, int id, const struct __ns1__Login *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__Login(soap, "ns1:Login", -1, &a->ns1__Login, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Login * SOAP_FMAC4 soap_in___ns1__Login(struct soap *soap, const char *tag, struct __ns1__Login *a, const char *type)
{
	size_t soap_flag_ns1__Login = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__Login *)soap_id_enter(soap, "", a, SOAP_TYPE_ns___ns1__Login, sizeof(struct __ns1__Login), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Login(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__Login && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__Login(soap, "ns1:Login", &a->ns1__Login, ""))
				{	soap_flag_ns1__Login--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__Login * SOAP_FMAC2 soap_instantiate___ns1__Login(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Login(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__Login *p;
	size_t k = sizeof(struct __ns1__Login);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__Login);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__Login, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__Login location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns___ns1__Login, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Login(struct soap *soap, const struct __ns1__Login *a, const char *tag, const char *type)
{
	if (soap_out___ns1__Login(soap, tag?tag:"-ns1:Login", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Login * SOAP_FMAC4 soap_get___ns1__Login(struct soap *soap, struct __ns1__Login *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Login(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns_SOAP_ENV__Reason, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns_SOAP_ENV__Detail, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns_SOAP_ENV__Code, &mark);
	if (id < 0)
		return soap->error;
	soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ValidateAccess(struct soap *soap, _ns1__ValidateAccess *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__ns1__ValidateAccess))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ValidateAccess(struct soap *soap, const char *tag, int id, _ns1__ValidateAccess *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__ns1__ValidateAccess, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__ValidateAccess ** SOAP_FMAC4 soap_in_PointerTo_ns1__ValidateAccess(struct soap *soap, const char *tag, _ns1__ValidateAccess **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__ValidateAccess **)soap_malloc(soap, sizeof(_ns1__ValidateAccess *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__ValidateAccess *)soap_instantiate__ns1__ValidateAccess(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__ValidateAccess **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__ns1__ValidateAccess, sizeof(_ns1__ValidateAccess), 0, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ValidateAccess(struct soap *soap, _ns1__ValidateAccess *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__ValidateAccess(soap, tag?tag:"ns1:ValidateAccess", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__ValidateAccess ** SOAP_FMAC4 soap_get_PointerTo_ns1__ValidateAccess(struct soap *soap, _ns1__ValidateAccess **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ValidateAccess(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__UpdateDataFormat(struct soap *soap, _ns1__UpdateDataFormat *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__ns1__UpdateDataFormat))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__UpdateDataFormat(struct soap *soap, const char *tag, int id, _ns1__UpdateDataFormat *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__ns1__UpdateDataFormat, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__UpdateDataFormat ** SOAP_FMAC4 soap_in_PointerTo_ns1__UpdateDataFormat(struct soap *soap, const char *tag, _ns1__UpdateDataFormat **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__UpdateDataFormat **)soap_malloc(soap, sizeof(_ns1__UpdateDataFormat *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__UpdateDataFormat *)soap_instantiate__ns1__UpdateDataFormat(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__UpdateDataFormat **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__ns1__UpdateDataFormat, sizeof(_ns1__UpdateDataFormat), 0, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__UpdateDataFormat(struct soap *soap, _ns1__UpdateDataFormat *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__UpdateDataFormat(soap, tag?tag:"ns1:UpdateDataFormat", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__UpdateDataFormat ** SOAP_FMAC4 soap_get_PointerTo_ns1__UpdateDataFormat(struct soap *soap, _ns1__UpdateDataFormat **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__UpdateDataFormat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__DataFormats(struct soap *soap, _ns1__DataFormats *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__ns1__DataFormats))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__DataFormats(struct soap *soap, const char *tag, int id, _ns1__DataFormats *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__ns1__DataFormats, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__DataFormats ** SOAP_FMAC4 soap_in_PointerTo_ns1__DataFormats(struct soap *soap, const char *tag, _ns1__DataFormats **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__DataFormats **)soap_malloc(soap, sizeof(_ns1__DataFormats *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__DataFormats *)soap_instantiate__ns1__DataFormats(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__DataFormats **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__ns1__DataFormats, sizeof(_ns1__DataFormats), 0, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__DataFormats(struct soap *soap, _ns1__DataFormats *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__DataFormats(soap, tag?tag:"ns1:DataFormats", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__DataFormats ** SOAP_FMAC4 soap_get_PointerTo_ns1__DataFormats(struct soap *soap, _ns1__DataFormats **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__DataFormats(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__DataClientLatestVersion(struct soap *soap, _ns1__DataClientLatestVersion *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__ns1__DataClientLatestVersion))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__DataClientLatestVersion(struct soap *soap, const char *tag, int id, _ns1__DataClientLatestVersion *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__ns1__DataClientLatestVersion, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__DataClientLatestVersion ** SOAP_FMAC4 soap_in_PointerTo_ns1__DataClientLatestVersion(struct soap *soap, const char *tag, _ns1__DataClientLatestVersion **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__DataClientLatestVersion **)soap_malloc(soap, sizeof(_ns1__DataClientLatestVersion *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__DataClientLatestVersion *)soap_instantiate__ns1__DataClientLatestVersion(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__DataClientLatestVersion **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__ns1__DataClientLatestVersion, sizeof(_ns1__DataClientLatestVersion), 0, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__DataClientLatestVersion(struct soap *soap, _ns1__DataClientLatestVersion *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__DataClientLatestVersion(soap, tag?tag:"ns1:DataClientLatestVersion", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__DataClientLatestVersion ** SOAP_FMAC4 soap_get_PointerTo_ns1__DataClientLatestVersion(struct soap *soap, _ns1__DataClientLatestVersion **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__DataClientLatestVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SymbolChangesByExchange(struct soap *soap, _ns1__SymbolChangesByExchange *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__ns1__SymbolChangesByExchange))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SymbolChangesByExchange(struct soap *soap, const char *tag, int id, _ns1__SymbolChangesByExchange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__ns1__SymbolChangesByExchange, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__SymbolChangesByExchange ** SOAP_FMAC4 soap_in_PointerTo_ns1__SymbolChangesByExchange(struct soap *soap, const char *tag, _ns1__SymbolChangesByExchange **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SymbolChangesByExchange **)soap_malloc(soap, sizeof(_ns1__SymbolChangesByExchange *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SymbolChangesByExchange *)soap_instantiate__ns1__SymbolChangesByExchange(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__SymbolChangesByExchange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__ns1__SymbolChangesByExchange, sizeof(_ns1__SymbolChangesByExchange), 0, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SymbolChangesByExchange(struct soap *soap, _ns1__SymbolChangesByExchange *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__SymbolChangesByExchange(soap, tag?tag:"ns1:SymbolChangesByExchange", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SymbolChangesByExchange ** SOAP_FMAC4 soap_get_PointerTo_ns1__SymbolChangesByExchange(struct soap *soap, _ns1__SymbolChangesByExchange **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SymbolChangesByExchange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__QuoteListByDatePeriod2(struct soap *soap, _ns1__QuoteListByDatePeriod2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__ns1__QuoteListByDatePeriod2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__QuoteListByDatePeriod2(struct soap *soap, const char *tag, int id, _ns1__QuoteListByDatePeriod2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__ns1__QuoteListByDatePeriod2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__QuoteListByDatePeriod2 ** SOAP_FMAC4 soap_in_PointerTo_ns1__QuoteListByDatePeriod2(struct soap *soap, const char *tag, _ns1__QuoteListByDatePeriod2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__QuoteListByDatePeriod2 **)soap_malloc(soap, sizeof(_ns1__QuoteListByDatePeriod2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__QuoteListByDatePeriod2 *)soap_instantiate__ns1__QuoteListByDatePeriod2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__QuoteListByDatePeriod2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__ns1__QuoteListByDatePeriod2, sizeof(_ns1__QuoteListByDatePeriod2), 0, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__QuoteListByDatePeriod2(struct soap *soap, _ns1__QuoteListByDatePeriod2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__QuoteListByDatePeriod2(soap, tag?tag:"ns1:QuoteListByDatePeriod2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__QuoteListByDatePeriod2 ** SOAP_FMAC4 soap_get_PointerTo_ns1__QuoteListByDatePeriod2(struct soap *soap, _ns1__QuoteListByDatePeriod2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__QuoteListByDatePeriod2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__QuoteListByDatePeriod(struct soap *soap, _ns1__QuoteListByDatePeriod *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__ns1__QuoteListByDatePeriod))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__QuoteListByDatePeriod(struct soap *soap, const char *tag, int id, _ns1__QuoteListByDatePeriod *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__ns1__QuoteListByDatePeriod, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__QuoteListByDatePeriod ** SOAP_FMAC4 soap_in_PointerTo_ns1__QuoteListByDatePeriod(struct soap *soap, const char *tag, _ns1__QuoteListByDatePeriod **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__QuoteListByDatePeriod **)soap_malloc(soap, sizeof(_ns1__QuoteListByDatePeriod *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__QuoteListByDatePeriod *)soap_instantiate__ns1__QuoteListByDatePeriod(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__QuoteListByDatePeriod **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__ns1__QuoteListByDatePeriod, sizeof(_ns1__QuoteListByDatePeriod), 0, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__QuoteListByDatePeriod(struct soap *soap, _ns1__QuoteListByDatePeriod *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__QuoteListByDatePeriod(soap, tag?tag:"ns1:QuoteListByDatePeriod", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__QuoteListByDatePeriod ** SOAP_FMAC4 soap_get_PointerTo_ns1__QuoteListByDatePeriod(struct soap *soap, _ns1__QuoteListByDatePeriod **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__QuoteListByDatePeriod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SymbolHistoryPeriodByDateRange(struct soap *soap, _ns1__SymbolHistoryPeriodByDateRange *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__ns1__SymbolHistoryPeriodByDateRange))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SymbolHistoryPeriodByDateRange(struct soap *soap, const char *tag, int id, _ns1__SymbolHistoryPeriodByDateRange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__ns1__SymbolHistoryPeriodByDateRange, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__SymbolHistoryPeriodByDateRange ** SOAP_FMAC4 soap_in_PointerTo_ns1__SymbolHistoryPeriodByDateRange(struct soap *soap, const char *tag, _ns1__SymbolHistoryPeriodByDateRange **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SymbolHistoryPeriodByDateRange **)soap_malloc(soap, sizeof(_ns1__SymbolHistoryPeriodByDateRange *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SymbolHistoryPeriodByDateRange *)soap_instantiate__ns1__SymbolHistoryPeriodByDateRange(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__SymbolHistoryPeriodByDateRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__ns1__SymbolHistoryPeriodByDateRange, sizeof(_ns1__SymbolHistoryPeriodByDateRange), 0, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SymbolHistoryPeriodByDateRange(struct soap *soap, _ns1__SymbolHistoryPeriodByDateRange *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__SymbolHistoryPeriodByDateRange(soap, tag?tag:"ns1:SymbolHistoryPeriodByDateRange", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SymbolHistoryPeriodByDateRange ** SOAP_FMAC4 soap_get_PointerTo_ns1__SymbolHistoryPeriodByDateRange(struct soap *soap, _ns1__SymbolHistoryPeriodByDateRange **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SymbolHistoryPeriodByDateRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SymbolHistoryPeriod(struct soap *soap, _ns1__SymbolHistoryPeriod *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__ns1__SymbolHistoryPeriod))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SymbolHistoryPeriod(struct soap *soap, const char *tag, int id, _ns1__SymbolHistoryPeriod *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__ns1__SymbolHistoryPeriod, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__SymbolHistoryPeriod ** SOAP_FMAC4 soap_in_PointerTo_ns1__SymbolHistoryPeriod(struct soap *soap, const char *tag, _ns1__SymbolHistoryPeriod **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SymbolHistoryPeriod **)soap_malloc(soap, sizeof(_ns1__SymbolHistoryPeriod *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SymbolHistoryPeriod *)soap_instantiate__ns1__SymbolHistoryPeriod(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__SymbolHistoryPeriod **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__ns1__SymbolHistoryPeriod, sizeof(_ns1__SymbolHistoryPeriod), 0, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SymbolHistoryPeriod(struct soap *soap, _ns1__SymbolHistoryPeriod *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__SymbolHistoryPeriod(soap, tag?tag:"ns1:SymbolHistoryPeriod", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SymbolHistoryPeriod ** SOAP_FMAC4 soap_get_PointerTo_ns1__SymbolHistoryPeriod(struct soap *soap, _ns1__SymbolHistoryPeriod **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SymbolHistoryPeriod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__CountryList(struct soap *soap, _ns1__CountryList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__ns1__CountryList))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__CountryList(struct soap *soap, const char *tag, int id, _ns1__CountryList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__ns1__CountryList, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__CountryList ** SOAP_FMAC4 soap_in_PointerTo_ns1__CountryList(struct soap *soap, const char *tag, _ns1__CountryList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__CountryList **)soap_malloc(soap, sizeof(_ns1__CountryList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__CountryList *)soap_instantiate__ns1__CountryList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__CountryList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__ns1__CountryList, sizeof(_ns1__CountryList), 0, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__CountryList(struct soap *soap, _ns1__CountryList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__CountryList(soap, tag?tag:"ns1:CountryList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__CountryList ** SOAP_FMAC4 soap_get_PointerTo_ns1__CountryList(struct soap *soap, _ns1__CountryList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__CountryList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SplitListBySymbol(struct soap *soap, _ns1__SplitListBySymbol *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__ns1__SplitListBySymbol))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SplitListBySymbol(struct soap *soap, const char *tag, int id, _ns1__SplitListBySymbol *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__ns1__SplitListBySymbol, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__SplitListBySymbol ** SOAP_FMAC4 soap_in_PointerTo_ns1__SplitListBySymbol(struct soap *soap, const char *tag, _ns1__SplitListBySymbol **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SplitListBySymbol **)soap_malloc(soap, sizeof(_ns1__SplitListBySymbol *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SplitListBySymbol *)soap_instantiate__ns1__SplitListBySymbol(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__SplitListBySymbol **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__ns1__SplitListBySymbol, sizeof(_ns1__SplitListBySymbol), 0, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SplitListBySymbol(struct soap *soap, _ns1__SplitListBySymbol *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__SplitListBySymbol(soap, tag?tag:"ns1:SplitListBySymbol", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SplitListBySymbol ** SOAP_FMAC4 soap_get_PointerTo_ns1__SplitListBySymbol(struct soap *soap, _ns1__SplitListBySymbol **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SplitListBySymbol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SplitListByExchange(struct soap *soap, _ns1__SplitListByExchange *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__ns1__SplitListByExchange))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SplitListByExchange(struct soap *soap, const char *tag, int id, _ns1__SplitListByExchange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__ns1__SplitListByExchange, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__SplitListByExchange ** SOAP_FMAC4 soap_in_PointerTo_ns1__SplitListByExchange(struct soap *soap, const char *tag, _ns1__SplitListByExchange **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SplitListByExchange **)soap_malloc(soap, sizeof(_ns1__SplitListByExchange *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SplitListByExchange *)soap_instantiate__ns1__SplitListByExchange(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__SplitListByExchange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__ns1__SplitListByExchange, sizeof(_ns1__SplitListByExchange), 0, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SplitListByExchange(struct soap *soap, _ns1__SplitListByExchange *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__SplitListByExchange(soap, tag?tag:"ns1:SplitListByExchange", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SplitListByExchange ** SOAP_FMAC4 soap_get_PointerTo_ns1__SplitListByExchange(struct soap *soap, _ns1__SplitListByExchange **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SplitListByExchange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ExchangeMonths(struct soap *soap, _ns1__ExchangeMonths *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__ns1__ExchangeMonths))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ExchangeMonths(struct soap *soap, const char *tag, int id, _ns1__ExchangeMonths *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__ns1__ExchangeMonths, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__ExchangeMonths ** SOAP_FMAC4 soap_in_PointerTo_ns1__ExchangeMonths(struct soap *soap, const char *tag, _ns1__ExchangeMonths **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__ExchangeMonths **)soap_malloc(soap, sizeof(_ns1__ExchangeMonths *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__ExchangeMonths *)soap_instantiate__ns1__ExchangeMonths(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__ExchangeMonths **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__ns1__ExchangeMonths, sizeof(_ns1__ExchangeMonths), 0, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ExchangeMonths(struct soap *soap, _ns1__ExchangeMonths *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__ExchangeMonths(soap, tag?tag:"ns1:ExchangeMonths", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__ExchangeMonths ** SOAP_FMAC4 soap_get_PointerTo_ns1__ExchangeMonths(struct soap *soap, _ns1__ExchangeMonths **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ExchangeMonths(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SymbolChart(struct soap *soap, _ns1__SymbolChart *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__ns1__SymbolChart))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SymbolChart(struct soap *soap, const char *tag, int id, _ns1__SymbolChart *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__ns1__SymbolChart, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__SymbolChart ** SOAP_FMAC4 soap_in_PointerTo_ns1__SymbolChart(struct soap *soap, const char *tag, _ns1__SymbolChart **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SymbolChart **)soap_malloc(soap, sizeof(_ns1__SymbolChart *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SymbolChart *)soap_instantiate__ns1__SymbolChart(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__SymbolChart **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__ns1__SymbolChart, sizeof(_ns1__SymbolChart), 0, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SymbolChart(struct soap *soap, _ns1__SymbolChart *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__SymbolChart(soap, tag?tag:"ns1:SymbolChart", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SymbolChart ** SOAP_FMAC4 soap_get_PointerTo_ns1__SymbolChart(struct soap *soap, _ns1__SymbolChart **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SymbolChart(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__Top10Losses(struct soap *soap, _ns1__Top10Losses *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__ns1__Top10Losses))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__Top10Losses(struct soap *soap, const char *tag, int id, _ns1__Top10Losses *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__ns1__Top10Losses, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__Top10Losses ** SOAP_FMAC4 soap_in_PointerTo_ns1__Top10Losses(struct soap *soap, const char *tag, _ns1__Top10Losses **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__Top10Losses **)soap_malloc(soap, sizeof(_ns1__Top10Losses *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__Top10Losses *)soap_instantiate__ns1__Top10Losses(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__Top10Losses **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__ns1__Top10Losses, sizeof(_ns1__Top10Losses), 0, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__Top10Losses(struct soap *soap, _ns1__Top10Losses *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__Top10Losses(soap, tag?tag:"ns1:Top10Losses", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__Top10Losses ** SOAP_FMAC4 soap_get_PointerTo_ns1__Top10Losses(struct soap *soap, _ns1__Top10Losses **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__Top10Losses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__Top10Gains(struct soap *soap, _ns1__Top10Gains *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__ns1__Top10Gains))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__Top10Gains(struct soap *soap, const char *tag, int id, _ns1__Top10Gains *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__ns1__Top10Gains, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__Top10Gains ** SOAP_FMAC4 soap_in_PointerTo_ns1__Top10Gains(struct soap *soap, const char *tag, _ns1__Top10Gains **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__Top10Gains **)soap_malloc(soap, sizeof(_ns1__Top10Gains *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__Top10Gains *)soap_instantiate__ns1__Top10Gains(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__Top10Gains **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__ns1__Top10Gains, sizeof(_ns1__Top10Gains), 0, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__Top10Gains(struct soap *soap, _ns1__Top10Gains *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__Top10Gains(soap, tag?tag:"ns1:Top10Gains", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__Top10Gains ** SOAP_FMAC4 soap_get_PointerTo_ns1__Top10Gains(struct soap *soap, _ns1__Top10Gains **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__Top10Gains(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SymbolHistory(struct soap *soap, _ns1__SymbolHistory *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__ns1__SymbolHistory))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SymbolHistory(struct soap *soap, const char *tag, int id, _ns1__SymbolHistory *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__ns1__SymbolHistory, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__SymbolHistory ** SOAP_FMAC4 soap_in_PointerTo_ns1__SymbolHistory(struct soap *soap, const char *tag, _ns1__SymbolHistory **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SymbolHistory **)soap_malloc(soap, sizeof(_ns1__SymbolHistory *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SymbolHistory *)soap_instantiate__ns1__SymbolHistory(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__SymbolHistory **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__ns1__SymbolHistory, sizeof(_ns1__SymbolHistory), 0, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SymbolHistory(struct soap *soap, _ns1__SymbolHistory *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__SymbolHistory(soap, tag?tag:"ns1:SymbolHistory", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SymbolHistory ** SOAP_FMAC4 soap_get_PointerTo_ns1__SymbolHistory(struct soap *soap, _ns1__SymbolHistory **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SymbolHistory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__QuoteListByDate2(struct soap *soap, _ns1__QuoteListByDate2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__ns1__QuoteListByDate2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__QuoteListByDate2(struct soap *soap, const char *tag, int id, _ns1__QuoteListByDate2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__ns1__QuoteListByDate2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__QuoteListByDate2 ** SOAP_FMAC4 soap_in_PointerTo_ns1__QuoteListByDate2(struct soap *soap, const char *tag, _ns1__QuoteListByDate2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__QuoteListByDate2 **)soap_malloc(soap, sizeof(_ns1__QuoteListByDate2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__QuoteListByDate2 *)soap_instantiate__ns1__QuoteListByDate2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__QuoteListByDate2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__ns1__QuoteListByDate2, sizeof(_ns1__QuoteListByDate2), 0, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__QuoteListByDate2(struct soap *soap, _ns1__QuoteListByDate2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__QuoteListByDate2(soap, tag?tag:"ns1:QuoteListByDate2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__QuoteListByDate2 ** SOAP_FMAC4 soap_get_PointerTo_ns1__QuoteListByDate2(struct soap *soap, _ns1__QuoteListByDate2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__QuoteListByDate2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__QuoteListByDate(struct soap *soap, _ns1__QuoteListByDate *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__ns1__QuoteListByDate))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__QuoteListByDate(struct soap *soap, const char *tag, int id, _ns1__QuoteListByDate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__ns1__QuoteListByDate, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__QuoteListByDate ** SOAP_FMAC4 soap_in_PointerTo_ns1__QuoteListByDate(struct soap *soap, const char *tag, _ns1__QuoteListByDate **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__QuoteListByDate **)soap_malloc(soap, sizeof(_ns1__QuoteListByDate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__QuoteListByDate *)soap_instantiate__ns1__QuoteListByDate(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__QuoteListByDate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__ns1__QuoteListByDate, sizeof(_ns1__QuoteListByDate), 0, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__QuoteListByDate(struct soap *soap, _ns1__QuoteListByDate *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__QuoteListByDate(soap, tag?tag:"ns1:QuoteListByDate", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__QuoteListByDate ** SOAP_FMAC4 soap_get_PointerTo_ns1__QuoteListByDate(struct soap *soap, _ns1__QuoteListByDate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__QuoteListByDate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__TechnicalList(struct soap *soap, _ns1__TechnicalList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__ns1__TechnicalList))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__TechnicalList(struct soap *soap, const char *tag, int id, _ns1__TechnicalList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__ns1__TechnicalList, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__TechnicalList ** SOAP_FMAC4 soap_in_PointerTo_ns1__TechnicalList(struct soap *soap, const char *tag, _ns1__TechnicalList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__TechnicalList **)soap_malloc(soap, sizeof(_ns1__TechnicalList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__TechnicalList *)soap_instantiate__ns1__TechnicalList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__TechnicalList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__ns1__TechnicalList, sizeof(_ns1__TechnicalList), 0, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__TechnicalList(struct soap *soap, _ns1__TechnicalList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__TechnicalList(soap, tag?tag:"ns1:TechnicalList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__TechnicalList ** SOAP_FMAC4 soap_get_PointerTo_ns1__TechnicalList(struct soap *soap, _ns1__TechnicalList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__TechnicalList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__FundamentalList(struct soap *soap, _ns1__FundamentalList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__ns1__FundamentalList))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__FundamentalList(struct soap *soap, const char *tag, int id, _ns1__FundamentalList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__ns1__FundamentalList, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__FundamentalList ** SOAP_FMAC4 soap_in_PointerTo_ns1__FundamentalList(struct soap *soap, const char *tag, _ns1__FundamentalList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__FundamentalList **)soap_malloc(soap, sizeof(_ns1__FundamentalList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__FundamentalList *)soap_instantiate__ns1__FundamentalList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__FundamentalList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__ns1__FundamentalList, sizeof(_ns1__FundamentalList), 0, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__FundamentalList(struct soap *soap, _ns1__FundamentalList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__FundamentalList(soap, tag?tag:"ns1:FundamentalList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__FundamentalList ** SOAP_FMAC4 soap_get_PointerTo_ns1__FundamentalList(struct soap *soap, _ns1__FundamentalList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__FundamentalList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__NewsListBySymbol(struct soap *soap, _ns1__NewsListBySymbol *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__ns1__NewsListBySymbol))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__NewsListBySymbol(struct soap *soap, const char *tag, int id, _ns1__NewsListBySymbol *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__ns1__NewsListBySymbol, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__NewsListBySymbol ** SOAP_FMAC4 soap_in_PointerTo_ns1__NewsListBySymbol(struct soap *soap, const char *tag, _ns1__NewsListBySymbol **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__NewsListBySymbol **)soap_malloc(soap, sizeof(_ns1__NewsListBySymbol *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__NewsListBySymbol *)soap_instantiate__ns1__NewsListBySymbol(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__NewsListBySymbol **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__ns1__NewsListBySymbol, sizeof(_ns1__NewsListBySymbol), 0, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__NewsListBySymbol(struct soap *soap, _ns1__NewsListBySymbol *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__NewsListBySymbol(soap, tag?tag:"ns1:NewsListBySymbol", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__NewsListBySymbol ** SOAP_FMAC4 soap_get_PointerTo_ns1__NewsListBySymbol(struct soap *soap, _ns1__NewsListBySymbol **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__NewsListBySymbol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__NewsList(struct soap *soap, _ns1__NewsList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__ns1__NewsList))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__NewsList(struct soap *soap, const char *tag, int id, _ns1__NewsList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__ns1__NewsList, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__NewsList ** SOAP_FMAC4 soap_in_PointerTo_ns1__NewsList(struct soap *soap, const char *tag, _ns1__NewsList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__NewsList **)soap_malloc(soap, sizeof(_ns1__NewsList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__NewsList *)soap_instantiate__ns1__NewsList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__NewsList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__ns1__NewsList, sizeof(_ns1__NewsList), 0, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__NewsList(struct soap *soap, _ns1__NewsList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__NewsList(soap, tag?tag:"ns1:NewsList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__NewsList ** SOAP_FMAC4 soap_get_PointerTo_ns1__NewsList(struct soap *soap, _ns1__NewsList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__NewsList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__QuoteList(struct soap *soap, _ns1__QuoteList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__ns1__QuoteList))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__QuoteList(struct soap *soap, const char *tag, int id, _ns1__QuoteList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__ns1__QuoteList, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__QuoteList ** SOAP_FMAC4 soap_in_PointerTo_ns1__QuoteList(struct soap *soap, const char *tag, _ns1__QuoteList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__QuoteList **)soap_malloc(soap, sizeof(_ns1__QuoteList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__QuoteList *)soap_instantiate__ns1__QuoteList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__QuoteList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__ns1__QuoteList, sizeof(_ns1__QuoteList), 0, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__QuoteList(struct soap *soap, _ns1__QuoteList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__QuoteList(soap, tag?tag:"ns1:QuoteList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__QuoteList ** SOAP_FMAC4 soap_get_PointerTo_ns1__QuoteList(struct soap *soap, _ns1__QuoteList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__QuoteList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SymbolGet(struct soap *soap, _ns1__SymbolGet *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__ns1__SymbolGet))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SymbolGet(struct soap *soap, const char *tag, int id, _ns1__SymbolGet *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__ns1__SymbolGet, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__SymbolGet ** SOAP_FMAC4 soap_in_PointerTo_ns1__SymbolGet(struct soap *soap, const char *tag, _ns1__SymbolGet **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SymbolGet **)soap_malloc(soap, sizeof(_ns1__SymbolGet *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SymbolGet *)soap_instantiate__ns1__SymbolGet(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__SymbolGet **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__ns1__SymbolGet, sizeof(_ns1__SymbolGet), 0, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SymbolGet(struct soap *soap, _ns1__SymbolGet *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__SymbolGet(soap, tag?tag:"ns1:SymbolGet", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SymbolGet ** SOAP_FMAC4 soap_get_PointerTo_ns1__SymbolGet(struct soap *soap, _ns1__SymbolGet **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SymbolGet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__QuoteList2(struct soap *soap, _ns1__QuoteList2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__ns1__QuoteList2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__QuoteList2(struct soap *soap, const char *tag, int id, _ns1__QuoteList2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__ns1__QuoteList2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__QuoteList2 ** SOAP_FMAC4 soap_in_PointerTo_ns1__QuoteList2(struct soap *soap, const char *tag, _ns1__QuoteList2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__QuoteList2 **)soap_malloc(soap, sizeof(_ns1__QuoteList2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__QuoteList2 *)soap_instantiate__ns1__QuoteList2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__QuoteList2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__ns1__QuoteList2, sizeof(_ns1__QuoteList2), 0, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__QuoteList2(struct soap *soap, _ns1__QuoteList2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__QuoteList2(soap, tag?tag:"ns1:QuoteList2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__QuoteList2 ** SOAP_FMAC4 soap_get_PointerTo_ns1__QuoteList2(struct soap *soap, _ns1__QuoteList2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__QuoteList2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__QuoteGet(struct soap *soap, _ns1__QuoteGet *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__ns1__QuoteGet))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__QuoteGet(struct soap *soap, const char *tag, int id, _ns1__QuoteGet *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__ns1__QuoteGet, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__QuoteGet ** SOAP_FMAC4 soap_in_PointerTo_ns1__QuoteGet(struct soap *soap, const char *tag, _ns1__QuoteGet **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__QuoteGet **)soap_malloc(soap, sizeof(_ns1__QuoteGet *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__QuoteGet *)soap_instantiate__ns1__QuoteGet(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__QuoteGet **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__ns1__QuoteGet, sizeof(_ns1__QuoteGet), 0, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__QuoteGet(struct soap *soap, _ns1__QuoteGet *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__QuoteGet(soap, tag?tag:"ns1:QuoteGet", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__QuoteGet ** SOAP_FMAC4 soap_get_PointerTo_ns1__QuoteGet(struct soap *soap, _ns1__QuoteGet **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__QuoteGet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SymbolList2(struct soap *soap, _ns1__SymbolList2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__ns1__SymbolList2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SymbolList2(struct soap *soap, const char *tag, int id, _ns1__SymbolList2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__ns1__SymbolList2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__SymbolList2 ** SOAP_FMAC4 soap_in_PointerTo_ns1__SymbolList2(struct soap *soap, const char *tag, _ns1__SymbolList2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SymbolList2 **)soap_malloc(soap, sizeof(_ns1__SymbolList2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SymbolList2 *)soap_instantiate__ns1__SymbolList2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__SymbolList2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__ns1__SymbolList2, sizeof(_ns1__SymbolList2), 0, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SymbolList2(struct soap *soap, _ns1__SymbolList2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__SymbolList2(soap, tag?tag:"ns1:SymbolList2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SymbolList2 ** SOAP_FMAC4 soap_get_PointerTo_ns1__SymbolList2(struct soap *soap, _ns1__SymbolList2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SymbolList2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SymbolList(struct soap *soap, _ns1__SymbolList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__ns1__SymbolList))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SymbolList(struct soap *soap, const char *tag, int id, _ns1__SymbolList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__ns1__SymbolList, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__SymbolList ** SOAP_FMAC4 soap_in_PointerTo_ns1__SymbolList(struct soap *soap, const char *tag, _ns1__SymbolList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SymbolList **)soap_malloc(soap, sizeof(_ns1__SymbolList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SymbolList *)soap_instantiate__ns1__SymbolList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__SymbolList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__ns1__SymbolList, sizeof(_ns1__SymbolList), 0, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SymbolList(struct soap *soap, _ns1__SymbolList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__SymbolList(soap, tag?tag:"ns1:SymbolList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SymbolList ** SOAP_FMAC4 soap_get_PointerTo_ns1__SymbolList(struct soap *soap, _ns1__SymbolList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SymbolList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ExchangeGet(struct soap *soap, _ns1__ExchangeGet *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__ns1__ExchangeGet))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ExchangeGet(struct soap *soap, const char *tag, int id, _ns1__ExchangeGet *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__ns1__ExchangeGet, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__ExchangeGet ** SOAP_FMAC4 soap_in_PointerTo_ns1__ExchangeGet(struct soap *soap, const char *tag, _ns1__ExchangeGet **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__ExchangeGet **)soap_malloc(soap, sizeof(_ns1__ExchangeGet *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__ExchangeGet *)soap_instantiate__ns1__ExchangeGet(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__ExchangeGet **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__ns1__ExchangeGet, sizeof(_ns1__ExchangeGet), 0, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ExchangeGet(struct soap *soap, _ns1__ExchangeGet *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__ExchangeGet(soap, tag?tag:"ns1:ExchangeGet", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__ExchangeGet ** SOAP_FMAC4 soap_get_PointerTo_ns1__ExchangeGet(struct soap *soap, _ns1__ExchangeGet **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ExchangeGet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ExchangeList(struct soap *soap, _ns1__ExchangeList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__ns1__ExchangeList))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ExchangeList(struct soap *soap, const char *tag, int id, _ns1__ExchangeList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__ns1__ExchangeList, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__ExchangeList ** SOAP_FMAC4 soap_in_PointerTo_ns1__ExchangeList(struct soap *soap, const char *tag, _ns1__ExchangeList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__ExchangeList **)soap_malloc(soap, sizeof(_ns1__ExchangeList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__ExchangeList *)soap_instantiate__ns1__ExchangeList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__ExchangeList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__ns1__ExchangeList, sizeof(_ns1__ExchangeList), 0, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ExchangeList(struct soap *soap, _ns1__ExchangeList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__ExchangeList(soap, tag?tag:"ns1:ExchangeList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__ExchangeList ** SOAP_FMAC4 soap_get_PointerTo_ns1__ExchangeList(struct soap *soap, _ns1__ExchangeList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ExchangeList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__Membership(struct soap *soap, _ns1__Membership *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__ns1__Membership))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__Membership(struct soap *soap, const char *tag, int id, _ns1__Membership *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__ns1__Membership, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__Membership ** SOAP_FMAC4 soap_in_PointerTo_ns1__Membership(struct soap *soap, const char *tag, _ns1__Membership **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__Membership **)soap_malloc(soap, sizeof(_ns1__Membership *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__Membership *)soap_instantiate__ns1__Membership(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__Membership **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__ns1__Membership, sizeof(_ns1__Membership), 0, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__Membership(struct soap *soap, _ns1__Membership *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__Membership(soap, tag?tag:"ns1:Membership", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__Membership ** SOAP_FMAC4 soap_get_PointerTo_ns1__Membership(struct soap *soap, _ns1__Membership **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__Membership(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__Login2(struct soap *soap, _ns1__Login2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__ns1__Login2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__Login2(struct soap *soap, const char *tag, int id, _ns1__Login2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__ns1__Login2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__Login2 ** SOAP_FMAC4 soap_in_PointerTo_ns1__Login2(struct soap *soap, const char *tag, _ns1__Login2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__Login2 **)soap_malloc(soap, sizeof(_ns1__Login2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__Login2 *)soap_instantiate__ns1__Login2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__Login2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__ns1__Login2, sizeof(_ns1__Login2), 0, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__Login2(struct soap *soap, _ns1__Login2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__Login2(soap, tag?tag:"ns1:Login2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__Login2 ** SOAP_FMAC4 soap_get_PointerTo_ns1__Login2(struct soap *soap, _ns1__Login2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__Login2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__Login(struct soap *soap, _ns1__Login *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__ns1__Login))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__Login(struct soap *soap, const char *tag, int id, _ns1__Login *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__ns1__Login, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__Login ** SOAP_FMAC4 soap_in_PointerTo_ns1__Login(struct soap *soap, const char *tag, _ns1__Login **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__Login **)soap_malloc(soap, sizeof(_ns1__Login *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__Login *)soap_instantiate__ns1__Login(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__Login **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__ns1__Login, sizeof(_ns1__Login), 0, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__Login(struct soap *soap, _ns1__Login *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__Login(soap, tag?tag:"ns1:Login", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__Login ** SOAP_FMAC4 soap_get_PointerTo_ns1__Login(struct soap *soap, _ns1__Login **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__Login(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__RESPONSE(struct soap *soap, ns1__RESPONSE *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns_ns1__RESPONSE))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__RESPONSE(struct soap *soap, const char *tag, int id, ns1__RESPONSE *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns_ns1__RESPONSE, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__RESPONSE ** SOAP_FMAC4 soap_in_PointerTons1__RESPONSE(struct soap *soap, const char *tag, ns1__RESPONSE **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__RESPONSE **)soap_malloc(soap, sizeof(ns1__RESPONSE *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__RESPONSE *)soap_instantiate_ns1__RESPONSE(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__RESPONSE **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns_ns1__RESPONSE, sizeof(ns1__RESPONSE), 0, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__RESPONSE(struct soap *soap, ns1__RESPONSE *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__RESPONSE(soap, tag?tag:"ns1:RESPONSE", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__RESPONSE ** SOAP_FMAC4 soap_get_PointerTons1__RESPONSE(struct soap *soap, ns1__RESPONSE **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__RESPONSE(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__LOGINRESPONSE(struct soap *soap, ns1__LOGINRESPONSE *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns_ns1__LOGINRESPONSE))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__LOGINRESPONSE(struct soap *soap, const char *tag, int id, ns1__LOGINRESPONSE *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns_ns1__LOGINRESPONSE, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__LOGINRESPONSE ** SOAP_FMAC4 soap_in_PointerTons1__LOGINRESPONSE(struct soap *soap, const char *tag, ns1__LOGINRESPONSE **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__LOGINRESPONSE **)soap_malloc(soap, sizeof(ns1__LOGINRESPONSE *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__LOGINRESPONSE *)soap_instantiate_ns1__LOGINRESPONSE(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__LOGINRESPONSE **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns_ns1__LOGINRESPONSE, sizeof(ns1__LOGINRESPONSE), 0, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__LOGINRESPONSE(struct soap *soap, ns1__LOGINRESPONSE *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__LOGINRESPONSE(soap, tag?tag:"ns1:LOGINRESPONSE", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__LOGINRESPONSE ** SOAP_FMAC4 soap_get_PointerTons1__LOGINRESPONSE(struct soap *soap, ns1__LOGINRESPONSE **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__LOGINRESPONSE(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__DATAFORMAT_USCORECOLUMN(struct soap *soap, ns1__DATAFORMAT_USCORECOLUMN *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns_ns1__DATAFORMAT_USCORECOLUMN))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__DATAFORMAT_USCORECOLUMN(struct soap *soap, const char *tag, int id, ns1__DATAFORMAT_USCORECOLUMN *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns_ns1__DATAFORMAT_USCORECOLUMN, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__DATAFORMAT_USCORECOLUMN ** SOAP_FMAC4 soap_in_PointerTons1__DATAFORMAT_USCORECOLUMN(struct soap *soap, const char *tag, ns1__DATAFORMAT_USCORECOLUMN **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__DATAFORMAT_USCORECOLUMN **)soap_malloc(soap, sizeof(ns1__DATAFORMAT_USCORECOLUMN *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__DATAFORMAT_USCORECOLUMN *)soap_instantiate_ns1__DATAFORMAT_USCORECOLUMN(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__DATAFORMAT_USCORECOLUMN **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns_ns1__DATAFORMAT_USCORECOLUMN, sizeof(ns1__DATAFORMAT_USCORECOLUMN), 0, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__DATAFORMAT_USCORECOLUMN(struct soap *soap, ns1__DATAFORMAT_USCORECOLUMN *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__DATAFORMAT_USCORECOLUMN(soap, tag?tag:"ns1:DATAFORMAT_COLUMN", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__DATAFORMAT_USCORECOLUMN ** SOAP_FMAC4 soap_get_PointerTons1__DATAFORMAT_USCORECOLUMN(struct soap *soap, ns1__DATAFORMAT_USCORECOLUMN **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__DATAFORMAT_USCORECOLUMN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfDATAFORMAT_USCORECOLUMN(struct soap *soap, ns1__ArrayOfDATAFORMAT_USCORECOLUMN *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns_ns1__ArrayOfDATAFORMAT_USCORECOLUMN))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfDATAFORMAT_USCORECOLUMN(struct soap *soap, const char *tag, int id, ns1__ArrayOfDATAFORMAT_USCORECOLUMN *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns_ns1__ArrayOfDATAFORMAT_USCORECOLUMN, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfDATAFORMAT_USCORECOLUMN ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfDATAFORMAT_USCORECOLUMN(struct soap *soap, const char *tag, ns1__ArrayOfDATAFORMAT_USCORECOLUMN **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfDATAFORMAT_USCORECOLUMN **)soap_malloc(soap, sizeof(ns1__ArrayOfDATAFORMAT_USCORECOLUMN *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfDATAFORMAT_USCORECOLUMN *)soap_instantiate_ns1__ArrayOfDATAFORMAT_USCORECOLUMN(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ArrayOfDATAFORMAT_USCORECOLUMN **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns_ns1__ArrayOfDATAFORMAT_USCORECOLUMN, sizeof(ns1__ArrayOfDATAFORMAT_USCORECOLUMN), 0, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfDATAFORMAT_USCORECOLUMN(struct soap *soap, ns1__ArrayOfDATAFORMAT_USCORECOLUMN *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ArrayOfDATAFORMAT_USCORECOLUMN(soap, tag?tag:"ns1:ArrayOfDATAFORMAT_COLUMN", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfDATAFORMAT_USCORECOLUMN ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfDATAFORMAT_USCORECOLUMN(struct soap *soap, ns1__ArrayOfDATAFORMAT_USCORECOLUMN **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfDATAFORMAT_USCORECOLUMN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__DATAFORMAT(struct soap *soap, ns1__DATAFORMAT *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns_ns1__DATAFORMAT))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__DATAFORMAT(struct soap *soap, const char *tag, int id, ns1__DATAFORMAT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns_ns1__DATAFORMAT, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__DATAFORMAT ** SOAP_FMAC4 soap_in_PointerTons1__DATAFORMAT(struct soap *soap, const char *tag, ns1__DATAFORMAT **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__DATAFORMAT **)soap_malloc(soap, sizeof(ns1__DATAFORMAT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__DATAFORMAT *)soap_instantiate_ns1__DATAFORMAT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__DATAFORMAT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns_ns1__DATAFORMAT, sizeof(ns1__DATAFORMAT), 0, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__DATAFORMAT(struct soap *soap, ns1__DATAFORMAT *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__DATAFORMAT(soap, tag?tag:"ns1:DATAFORMAT", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__DATAFORMAT ** SOAP_FMAC4 soap_get_PointerTons1__DATAFORMAT(struct soap *soap, ns1__DATAFORMAT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__DATAFORMAT(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__NEWS(struct soap *soap, ns1__NEWS *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns_ns1__NEWS))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__NEWS(struct soap *soap, const char *tag, int id, ns1__NEWS *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns_ns1__NEWS, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__NEWS ** SOAP_FMAC4 soap_in_PointerTons1__NEWS(struct soap *soap, const char *tag, ns1__NEWS **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__NEWS **)soap_malloc(soap, sizeof(ns1__NEWS *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__NEWS *)soap_instantiate_ns1__NEWS(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__NEWS **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns_ns1__NEWS, sizeof(ns1__NEWS), 0, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__NEWS(struct soap *soap, ns1__NEWS *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__NEWS(soap, tag?tag:"ns1:NEWS", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__NEWS ** SOAP_FMAC4 soap_get_PointerTons1__NEWS(struct soap *soap, ns1__NEWS **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__NEWS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SYMBOLCHANGE(struct soap *soap, ns1__SYMBOLCHANGE *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns_ns1__SYMBOLCHANGE))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SYMBOLCHANGE(struct soap *soap, const char *tag, int id, ns1__SYMBOLCHANGE *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns_ns1__SYMBOLCHANGE, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__SYMBOLCHANGE ** SOAP_FMAC4 soap_in_PointerTons1__SYMBOLCHANGE(struct soap *soap, const char *tag, ns1__SYMBOLCHANGE **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SYMBOLCHANGE **)soap_malloc(soap, sizeof(ns1__SYMBOLCHANGE *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SYMBOLCHANGE *)soap_instantiate_ns1__SYMBOLCHANGE(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__SYMBOLCHANGE **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns_ns1__SYMBOLCHANGE, sizeof(ns1__SYMBOLCHANGE), 0, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SYMBOLCHANGE(struct soap *soap, ns1__SYMBOLCHANGE *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SYMBOLCHANGE(soap, tag?tag:"ns1:SYMBOLCHANGE", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__SYMBOLCHANGE ** SOAP_FMAC4 soap_get_PointerTons1__SYMBOLCHANGE(struct soap *soap, ns1__SYMBOLCHANGE **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SYMBOLCHANGE(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TECHNICAL(struct soap *soap, ns1__TECHNICAL *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns_ns1__TECHNICAL))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TECHNICAL(struct soap *soap, const char *tag, int id, ns1__TECHNICAL *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns_ns1__TECHNICAL, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__TECHNICAL ** SOAP_FMAC4 soap_in_PointerTons1__TECHNICAL(struct soap *soap, const char *tag, ns1__TECHNICAL **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__TECHNICAL **)soap_malloc(soap, sizeof(ns1__TECHNICAL *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__TECHNICAL *)soap_instantiate_ns1__TECHNICAL(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__TECHNICAL **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns_ns1__TECHNICAL, sizeof(ns1__TECHNICAL), 0, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TECHNICAL(struct soap *soap, ns1__TECHNICAL *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__TECHNICAL(soap, tag?tag:"ns1:TECHNICAL", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__TECHNICAL ** SOAP_FMAC4 soap_get_PointerTons1__TECHNICAL(struct soap *soap, ns1__TECHNICAL **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TECHNICAL(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__FUNDAMENTAL(struct soap *soap, ns1__FUNDAMENTAL *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns_ns1__FUNDAMENTAL))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__FUNDAMENTAL(struct soap *soap, const char *tag, int id, ns1__FUNDAMENTAL *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns_ns1__FUNDAMENTAL, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__FUNDAMENTAL ** SOAP_FMAC4 soap_in_PointerTons1__FUNDAMENTAL(struct soap *soap, const char *tag, ns1__FUNDAMENTAL **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__FUNDAMENTAL **)soap_malloc(soap, sizeof(ns1__FUNDAMENTAL *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__FUNDAMENTAL *)soap_instantiate_ns1__FUNDAMENTAL(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__FUNDAMENTAL **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns_ns1__FUNDAMENTAL, sizeof(ns1__FUNDAMENTAL), 0, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__FUNDAMENTAL(struct soap *soap, ns1__FUNDAMENTAL *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__FUNDAMENTAL(soap, tag?tag:"ns1:FUNDAMENTAL", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__FUNDAMENTAL ** SOAP_FMAC4 soap_get_PointerTons1__FUNDAMENTAL(struct soap *soap, ns1__FUNDAMENTAL **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__FUNDAMENTAL(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CountryBase(struct soap *soap, ns1__CountryBase *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns_ns1__CountryBase))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CountryBase(struct soap *soap, const char *tag, int id, ns1__CountryBase *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns_ns1__CountryBase, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CountryBase ** SOAP_FMAC4 soap_in_PointerTons1__CountryBase(struct soap *soap, const char *tag, ns1__CountryBase **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CountryBase **)soap_malloc(soap, sizeof(ns1__CountryBase *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CountryBase *)soap_instantiate_ns1__CountryBase(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__CountryBase **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns_ns1__CountryBase, sizeof(ns1__CountryBase), 0, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CountryBase(struct soap *soap, ns1__CountryBase *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__CountryBase(soap, tag?tag:"ns1:CountryBase", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CountryBase ** SOAP_FMAC4 soap_get_PointerTons1__CountryBase(struct soap *soap, ns1__CountryBase **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CountryBase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SPLIT(struct soap *soap, ns1__SPLIT *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns_ns1__SPLIT))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SPLIT(struct soap *soap, const char *tag, int id, ns1__SPLIT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns_ns1__SPLIT, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__SPLIT ** SOAP_FMAC4 soap_in_PointerTons1__SPLIT(struct soap *soap, const char *tag, ns1__SPLIT **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SPLIT **)soap_malloc(soap, sizeof(ns1__SPLIT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SPLIT *)soap_instantiate_ns1__SPLIT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__SPLIT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns_ns1__SPLIT, sizeof(ns1__SPLIT), 0, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SPLIT(struct soap *soap, ns1__SPLIT *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SPLIT(soap, tag?tag:"ns1:SPLIT", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__SPLIT ** SOAP_FMAC4 soap_get_PointerTons1__SPLIT(struct soap *soap, ns1__SPLIT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SPLIT(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__QUOTE2(struct soap *soap, ns1__QUOTE2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns_ns1__QUOTE2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__QUOTE2(struct soap *soap, const char *tag, int id, ns1__QUOTE2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns_ns1__QUOTE2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__QUOTE2 ** SOAP_FMAC4 soap_in_PointerTons1__QUOTE2(struct soap *soap, const char *tag, ns1__QUOTE2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__QUOTE2 **)soap_malloc(soap, sizeof(ns1__QUOTE2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__QUOTE2 *)soap_instantiate_ns1__QUOTE2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__QUOTE2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns_ns1__QUOTE2, sizeof(ns1__QUOTE2), 0, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__QUOTE2(struct soap *soap, ns1__QUOTE2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__QUOTE2(soap, tag?tag:"ns1:QUOTE2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__QUOTE2 ** SOAP_FMAC4 soap_get_PointerTons1__QUOTE2(struct soap *soap, ns1__QUOTE2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__QUOTE2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SYMBOL2(struct soap *soap, ns1__SYMBOL2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns_ns1__SYMBOL2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SYMBOL2(struct soap *soap, const char *tag, int id, ns1__SYMBOL2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns_ns1__SYMBOL2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__SYMBOL2 ** SOAP_FMAC4 soap_in_PointerTons1__SYMBOL2(struct soap *soap, const char *tag, ns1__SYMBOL2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SYMBOL2 **)soap_malloc(soap, sizeof(ns1__SYMBOL2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SYMBOL2 *)soap_instantiate_ns1__SYMBOL2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__SYMBOL2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns_ns1__SYMBOL2, sizeof(ns1__SYMBOL2), 0, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SYMBOL2(struct soap *soap, ns1__SYMBOL2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SYMBOL2(soap, tag?tag:"ns1:SYMBOL2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__SYMBOL2 ** SOAP_FMAC4 soap_get_PointerTons1__SYMBOL2(struct soap *soap, ns1__SYMBOL2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SYMBOL2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfDATAFORMAT(struct soap *soap, ns1__ArrayOfDATAFORMAT *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns_ns1__ArrayOfDATAFORMAT))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfDATAFORMAT(struct soap *soap, const char *tag, int id, ns1__ArrayOfDATAFORMAT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns_ns1__ArrayOfDATAFORMAT, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfDATAFORMAT ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfDATAFORMAT(struct soap *soap, const char *tag, ns1__ArrayOfDATAFORMAT **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfDATAFORMAT **)soap_malloc(soap, sizeof(ns1__ArrayOfDATAFORMAT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfDATAFORMAT *)soap_instantiate_ns1__ArrayOfDATAFORMAT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ArrayOfDATAFORMAT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns_ns1__ArrayOfDATAFORMAT, sizeof(ns1__ArrayOfDATAFORMAT), 0, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfDATAFORMAT(struct soap *soap, ns1__ArrayOfDATAFORMAT *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ArrayOfDATAFORMAT(soap, tag?tag:"ns1:ArrayOfDATAFORMAT", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfDATAFORMAT ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfDATAFORMAT(struct soap *soap, ns1__ArrayOfDATAFORMAT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfDATAFORMAT(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfNEWS(struct soap *soap, ns1__ArrayOfNEWS *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns_ns1__ArrayOfNEWS))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfNEWS(struct soap *soap, const char *tag, int id, ns1__ArrayOfNEWS *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns_ns1__ArrayOfNEWS, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfNEWS ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfNEWS(struct soap *soap, const char *tag, ns1__ArrayOfNEWS **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfNEWS **)soap_malloc(soap, sizeof(ns1__ArrayOfNEWS *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfNEWS *)soap_instantiate_ns1__ArrayOfNEWS(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ArrayOfNEWS **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns_ns1__ArrayOfNEWS, sizeof(ns1__ArrayOfNEWS), 0, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfNEWS(struct soap *soap, ns1__ArrayOfNEWS *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ArrayOfNEWS(soap, tag?tag:"ns1:ArrayOfNEWS", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfNEWS ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfNEWS(struct soap *soap, ns1__ArrayOfNEWS **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfNEWS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfSYMBOLCHANGE(struct soap *soap, ns1__ArrayOfSYMBOLCHANGE *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns_ns1__ArrayOfSYMBOLCHANGE))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfSYMBOLCHANGE(struct soap *soap, const char *tag, int id, ns1__ArrayOfSYMBOLCHANGE *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns_ns1__ArrayOfSYMBOLCHANGE, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfSYMBOLCHANGE ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfSYMBOLCHANGE(struct soap *soap, const char *tag, ns1__ArrayOfSYMBOLCHANGE **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfSYMBOLCHANGE **)soap_malloc(soap, sizeof(ns1__ArrayOfSYMBOLCHANGE *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfSYMBOLCHANGE *)soap_instantiate_ns1__ArrayOfSYMBOLCHANGE(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ArrayOfSYMBOLCHANGE **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns_ns1__ArrayOfSYMBOLCHANGE, sizeof(ns1__ArrayOfSYMBOLCHANGE), 0, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfSYMBOLCHANGE(struct soap *soap, ns1__ArrayOfSYMBOLCHANGE *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ArrayOfSYMBOLCHANGE(soap, tag?tag:"ns1:ArrayOfSYMBOLCHANGE", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfSYMBOLCHANGE ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfSYMBOLCHANGE(struct soap *soap, ns1__ArrayOfSYMBOLCHANGE **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfSYMBOLCHANGE(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfTECHNICAL(struct soap *soap, ns1__ArrayOfTECHNICAL *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns_ns1__ArrayOfTECHNICAL))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfTECHNICAL(struct soap *soap, const char *tag, int id, ns1__ArrayOfTECHNICAL *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns_ns1__ArrayOfTECHNICAL, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfTECHNICAL ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfTECHNICAL(struct soap *soap, const char *tag, ns1__ArrayOfTECHNICAL **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfTECHNICAL **)soap_malloc(soap, sizeof(ns1__ArrayOfTECHNICAL *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfTECHNICAL *)soap_instantiate_ns1__ArrayOfTECHNICAL(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ArrayOfTECHNICAL **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns_ns1__ArrayOfTECHNICAL, sizeof(ns1__ArrayOfTECHNICAL), 0, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfTECHNICAL(struct soap *soap, ns1__ArrayOfTECHNICAL *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ArrayOfTECHNICAL(soap, tag?tag:"ns1:ArrayOfTECHNICAL", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfTECHNICAL ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfTECHNICAL(struct soap *soap, ns1__ArrayOfTECHNICAL **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfTECHNICAL(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfFUNDAMENTAL(struct soap *soap, ns1__ArrayOfFUNDAMENTAL *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns_ns1__ArrayOfFUNDAMENTAL))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfFUNDAMENTAL(struct soap *soap, const char *tag, int id, ns1__ArrayOfFUNDAMENTAL *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns_ns1__ArrayOfFUNDAMENTAL, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfFUNDAMENTAL ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfFUNDAMENTAL(struct soap *soap, const char *tag, ns1__ArrayOfFUNDAMENTAL **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfFUNDAMENTAL **)soap_malloc(soap, sizeof(ns1__ArrayOfFUNDAMENTAL *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfFUNDAMENTAL *)soap_instantiate_ns1__ArrayOfFUNDAMENTAL(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ArrayOfFUNDAMENTAL **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns_ns1__ArrayOfFUNDAMENTAL, sizeof(ns1__ArrayOfFUNDAMENTAL), 0, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfFUNDAMENTAL(struct soap *soap, ns1__ArrayOfFUNDAMENTAL *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ArrayOfFUNDAMENTAL(soap, tag?tag:"ns1:ArrayOfFUNDAMENTAL", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfFUNDAMENTAL ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfFUNDAMENTAL(struct soap *soap, ns1__ArrayOfFUNDAMENTAL **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfFUNDAMENTAL(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfCountryBase(struct soap *soap, ns1__ArrayOfCountryBase *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns_ns1__ArrayOfCountryBase))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfCountryBase(struct soap *soap, const char *tag, int id, ns1__ArrayOfCountryBase *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns_ns1__ArrayOfCountryBase, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfCountryBase ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfCountryBase(struct soap *soap, const char *tag, ns1__ArrayOfCountryBase **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfCountryBase **)soap_malloc(soap, sizeof(ns1__ArrayOfCountryBase *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfCountryBase *)soap_instantiate_ns1__ArrayOfCountryBase(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ArrayOfCountryBase **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns_ns1__ArrayOfCountryBase, sizeof(ns1__ArrayOfCountryBase), 0, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfCountryBase(struct soap *soap, ns1__ArrayOfCountryBase *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ArrayOfCountryBase(soap, tag?tag:"ns1:ArrayOfCountryBase", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfCountryBase ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfCountryBase(struct soap *soap, ns1__ArrayOfCountryBase **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfCountryBase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfSPLIT(struct soap *soap, ns1__ArrayOfSPLIT *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns_ns1__ArrayOfSPLIT))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfSPLIT(struct soap *soap, const char *tag, int id, ns1__ArrayOfSPLIT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns_ns1__ArrayOfSPLIT, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfSPLIT ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfSPLIT(struct soap *soap, const char *tag, ns1__ArrayOfSPLIT **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfSPLIT **)soap_malloc(soap, sizeof(ns1__ArrayOfSPLIT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfSPLIT *)soap_instantiate_ns1__ArrayOfSPLIT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ArrayOfSPLIT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns_ns1__ArrayOfSPLIT, sizeof(ns1__ArrayOfSPLIT), 0, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfSPLIT(struct soap *soap, ns1__ArrayOfSPLIT *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ArrayOfSPLIT(soap, tag?tag:"ns1:ArrayOfSPLIT", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfSPLIT ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfSPLIT(struct soap *soap, ns1__ArrayOfSPLIT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfSPLIT(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfQUOTE2(struct soap *soap, ns1__ArrayOfQUOTE2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns_ns1__ArrayOfQUOTE2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfQUOTE2(struct soap *soap, const char *tag, int id, ns1__ArrayOfQUOTE2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns_ns1__ArrayOfQUOTE2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfQUOTE2 ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfQUOTE2(struct soap *soap, const char *tag, ns1__ArrayOfQUOTE2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfQUOTE2 **)soap_malloc(soap, sizeof(ns1__ArrayOfQUOTE2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfQUOTE2 *)soap_instantiate_ns1__ArrayOfQUOTE2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ArrayOfQUOTE2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns_ns1__ArrayOfQUOTE2, sizeof(ns1__ArrayOfQUOTE2), 0, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfQUOTE2(struct soap *soap, ns1__ArrayOfQUOTE2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ArrayOfQUOTE2(soap, tag?tag:"ns1:ArrayOfQUOTE2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfQUOTE2 ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfQUOTE2(struct soap *soap, ns1__ArrayOfQUOTE2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfQUOTE2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfQUOTE(struct soap *soap, ns1__ArrayOfQUOTE *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns_ns1__ArrayOfQUOTE))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfQUOTE(struct soap *soap, const char *tag, int id, ns1__ArrayOfQUOTE *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns_ns1__ArrayOfQUOTE, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfQUOTE ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfQUOTE(struct soap *soap, const char *tag, ns1__ArrayOfQUOTE **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfQUOTE **)soap_malloc(soap, sizeof(ns1__ArrayOfQUOTE *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfQUOTE *)soap_instantiate_ns1__ArrayOfQUOTE(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ArrayOfQUOTE **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns_ns1__ArrayOfQUOTE, sizeof(ns1__ArrayOfQUOTE), 0, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfQUOTE(struct soap *soap, ns1__ArrayOfQUOTE *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ArrayOfQUOTE(soap, tag?tag:"ns1:ArrayOfQUOTE", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfQUOTE ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfQUOTE(struct soap *soap, ns1__ArrayOfQUOTE **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfQUOTE(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__QUOTE(struct soap *soap, ns1__QUOTE *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns_ns1__QUOTE))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__QUOTE(struct soap *soap, const char *tag, int id, ns1__QUOTE *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns_ns1__QUOTE, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__QUOTE ** SOAP_FMAC4 soap_in_PointerTons1__QUOTE(struct soap *soap, const char *tag, ns1__QUOTE **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__QUOTE **)soap_malloc(soap, sizeof(ns1__QUOTE *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__QUOTE *)soap_instantiate_ns1__QUOTE(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__QUOTE **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns_ns1__QUOTE, sizeof(ns1__QUOTE), 0, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__QUOTE(struct soap *soap, ns1__QUOTE *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__QUOTE(soap, tag?tag:"ns1:QUOTE", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__QUOTE ** SOAP_FMAC4 soap_get_PointerTons1__QUOTE(struct soap *soap, ns1__QUOTE **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__QUOTE(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfSYMBOL2(struct soap *soap, ns1__ArrayOfSYMBOL2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns_ns1__ArrayOfSYMBOL2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfSYMBOL2(struct soap *soap, const char *tag, int id, ns1__ArrayOfSYMBOL2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns_ns1__ArrayOfSYMBOL2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfSYMBOL2 ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfSYMBOL2(struct soap *soap, const char *tag, ns1__ArrayOfSYMBOL2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfSYMBOL2 **)soap_malloc(soap, sizeof(ns1__ArrayOfSYMBOL2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfSYMBOL2 *)soap_instantiate_ns1__ArrayOfSYMBOL2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ArrayOfSYMBOL2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns_ns1__ArrayOfSYMBOL2, sizeof(ns1__ArrayOfSYMBOL2), 0, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfSYMBOL2(struct soap *soap, ns1__ArrayOfSYMBOL2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ArrayOfSYMBOL2(soap, tag?tag:"ns1:ArrayOfSYMBOL2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfSYMBOL2 ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfSYMBOL2(struct soap *soap, ns1__ArrayOfSYMBOL2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfSYMBOL2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfSYMBOL(struct soap *soap, ns1__ArrayOfSYMBOL *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns_ns1__ArrayOfSYMBOL))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfSYMBOL(struct soap *soap, const char *tag, int id, ns1__ArrayOfSYMBOL *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns_ns1__ArrayOfSYMBOL, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfSYMBOL ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfSYMBOL(struct soap *soap, const char *tag, ns1__ArrayOfSYMBOL **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfSYMBOL **)soap_malloc(soap, sizeof(ns1__ArrayOfSYMBOL *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfSYMBOL *)soap_instantiate_ns1__ArrayOfSYMBOL(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ArrayOfSYMBOL **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns_ns1__ArrayOfSYMBOL, sizeof(ns1__ArrayOfSYMBOL), 0, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfSYMBOL(struct soap *soap, ns1__ArrayOfSYMBOL *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ArrayOfSYMBOL(soap, tag?tag:"ns1:ArrayOfSYMBOL", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfSYMBOL ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfSYMBOL(struct soap *soap, ns1__ArrayOfSYMBOL **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfSYMBOL(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SYMBOL(struct soap *soap, ns1__SYMBOL *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns_ns1__SYMBOL))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SYMBOL(struct soap *soap, const char *tag, int id, ns1__SYMBOL *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns_ns1__SYMBOL, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__SYMBOL ** SOAP_FMAC4 soap_in_PointerTons1__SYMBOL(struct soap *soap, const char *tag, ns1__SYMBOL **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SYMBOL **)soap_malloc(soap, sizeof(ns1__SYMBOL *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SYMBOL *)soap_instantiate_ns1__SYMBOL(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__SYMBOL **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns_ns1__SYMBOL, sizeof(ns1__SYMBOL), 0, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SYMBOL(struct soap *soap, ns1__SYMBOL *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SYMBOL(soap, tag?tag:"ns1:SYMBOL", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__SYMBOL ** SOAP_FMAC4 soap_get_PointerTons1__SYMBOL(struct soap *soap, ns1__SYMBOL **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SYMBOL(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfEXCHANGE(struct soap *soap, ns1__ArrayOfEXCHANGE *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns_ns1__ArrayOfEXCHANGE))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfEXCHANGE(struct soap *soap, const char *tag, int id, ns1__ArrayOfEXCHANGE *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns_ns1__ArrayOfEXCHANGE, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfEXCHANGE ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfEXCHANGE(struct soap *soap, const char *tag, ns1__ArrayOfEXCHANGE **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfEXCHANGE **)soap_malloc(soap, sizeof(ns1__ArrayOfEXCHANGE *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfEXCHANGE *)soap_instantiate_ns1__ArrayOfEXCHANGE(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ArrayOfEXCHANGE **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns_ns1__ArrayOfEXCHANGE, sizeof(ns1__ArrayOfEXCHANGE), 0, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfEXCHANGE(struct soap *soap, ns1__ArrayOfEXCHANGE *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ArrayOfEXCHANGE(soap, tag?tag:"ns1:ArrayOfEXCHANGE", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfEXCHANGE ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfEXCHANGE(struct soap *soap, ns1__ArrayOfEXCHANGE **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfEXCHANGE(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__EXCHANGE(struct soap *soap, ns1__EXCHANGE *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns_ns1__EXCHANGE))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__EXCHANGE(struct soap *soap, const char *tag, int id, ns1__EXCHANGE *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns_ns1__EXCHANGE, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__EXCHANGE ** SOAP_FMAC4 soap_in_PointerTons1__EXCHANGE(struct soap *soap, const char *tag, ns1__EXCHANGE **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__EXCHANGE **)soap_malloc(soap, sizeof(ns1__EXCHANGE *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__EXCHANGE *)soap_instantiate_ns1__EXCHANGE(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__EXCHANGE **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns_ns1__EXCHANGE, sizeof(ns1__EXCHANGE), 0, ns_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__EXCHANGE(struct soap *soap, ns1__EXCHANGE *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__EXCHANGE(soap, tag?tag:"ns1:EXCHANGE", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__EXCHANGE ** SOAP_FMAC4 soap_get_PointerTons1__EXCHANGE(struct soap *soap, ns1__EXCHANGE **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__EXCHANGE(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns_std__string))
		soap_serialize_std__string(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns_std__string, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns_std__string, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTostd__string(soap, tag?tag:"string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_ns__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ns__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_ns__QName, 2, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__QName(soap, tag?tag:"QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_ns_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ns_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_ns_string, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_string(soap, tag?tag:"string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__DATAFORMAT_USCORECOLUMN(struct soap *soap, std::vector<ns1__DATAFORMAT_USCORECOLUMN *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__DATAFORMAT_USCORECOLUMN(struct soap *soap, const std::vector<ns1__DATAFORMAT_USCORECOLUMN *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__DATAFORMAT_USCORECOLUMN *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__DATAFORMAT_USCORECOLUMN(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__DATAFORMAT_USCORECOLUMN(struct soap *soap, const char *tag, int id, const std::vector<ns1__DATAFORMAT_USCORECOLUMN *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__DATAFORMAT_USCORECOLUMN *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__DATAFORMAT_USCORECOLUMN(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__DATAFORMAT_USCORECOLUMN *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__DATAFORMAT_USCORECOLUMN(struct soap *soap, const char *tag, std::vector<ns1__DATAFORMAT_USCORECOLUMN *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__DATAFORMAT_USCORECOLUMN(soap)))
			return NULL;
		ns1__DATAFORMAT_USCORECOLUMN *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns_ns1__DATAFORMAT_USCORECOLUMN, SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__DATAFORMAT_USCORECOLUMN, sizeof(ns1__DATAFORMAT_USCORECOLUMN), 1, ns_finsert, ns_fbase))
				break;
			if (!soap_in_PointerTons1__DATAFORMAT_USCORECOLUMN(soap, tag, NULL, "ns1:DATAFORMAT_COLUMN"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__DATAFORMAT_USCORECOLUMN(soap, tag, &n, "ns1:DATAFORMAT_COLUMN"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__DATAFORMAT_USCORECOLUMN *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__DATAFORMAT_USCORECOLUMN(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__DATAFORMAT_USCORECOLUMN(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__DATAFORMAT_USCORECOLUMN *> *p;
	size_t k = sizeof(std::vector<ns1__DATAFORMAT_USCORECOLUMN *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns1__DATAFORMAT_USCORECOLUMN *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns1__DATAFORMAT_USCORECOLUMN *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__DATAFORMAT_USCORECOLUMN *>  location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__DATAFORMAT_USCORECOLUMN, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__DATAFORMAT(struct soap *soap, std::vector<ns1__DATAFORMAT *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__DATAFORMAT(struct soap *soap, const std::vector<ns1__DATAFORMAT *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__DATAFORMAT *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__DATAFORMAT(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__DATAFORMAT(struct soap *soap, const char *tag, int id, const std::vector<ns1__DATAFORMAT *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__DATAFORMAT *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__DATAFORMAT(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__DATAFORMAT *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__DATAFORMAT(struct soap *soap, const char *tag, std::vector<ns1__DATAFORMAT *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__DATAFORMAT(soap)))
			return NULL;
		ns1__DATAFORMAT *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns_ns1__DATAFORMAT, SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__DATAFORMAT, sizeof(ns1__DATAFORMAT), 1, ns_finsert, ns_fbase))
				break;
			if (!soap_in_PointerTons1__DATAFORMAT(soap, tag, NULL, "ns1:DATAFORMAT"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__DATAFORMAT(soap, tag, &n, "ns1:DATAFORMAT"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__DATAFORMAT *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__DATAFORMAT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__DATAFORMAT(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__DATAFORMAT *> *p;
	size_t k = sizeof(std::vector<ns1__DATAFORMAT *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns1__DATAFORMAT *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns1__DATAFORMAT *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__DATAFORMAT *>  location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__DATAFORMAT, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__NEWS(struct soap *soap, std::vector<ns1__NEWS *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__NEWS(struct soap *soap, const std::vector<ns1__NEWS *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__NEWS *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__NEWS(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__NEWS(struct soap *soap, const char *tag, int id, const std::vector<ns1__NEWS *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__NEWS *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__NEWS(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__NEWS *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__NEWS(struct soap *soap, const char *tag, std::vector<ns1__NEWS *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__NEWS(soap)))
			return NULL;
		ns1__NEWS *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns_ns1__NEWS, SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__NEWS, sizeof(ns1__NEWS), 1, ns_finsert, ns_fbase))
				break;
			if (!soap_in_PointerTons1__NEWS(soap, tag, NULL, "ns1:NEWS"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__NEWS(soap, tag, &n, "ns1:NEWS"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__NEWS *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__NEWS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__NEWS(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__NEWS *> *p;
	size_t k = sizeof(std::vector<ns1__NEWS *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns1__NEWS *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns1__NEWS *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__NEWS *>  location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__NEWS, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__SYMBOLCHANGE(struct soap *soap, std::vector<ns1__SYMBOLCHANGE *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__SYMBOLCHANGE(struct soap *soap, const std::vector<ns1__SYMBOLCHANGE *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__SYMBOLCHANGE *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__SYMBOLCHANGE(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__SYMBOLCHANGE(struct soap *soap, const char *tag, int id, const std::vector<ns1__SYMBOLCHANGE *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__SYMBOLCHANGE *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__SYMBOLCHANGE(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__SYMBOLCHANGE *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__SYMBOLCHANGE(struct soap *soap, const char *tag, std::vector<ns1__SYMBOLCHANGE *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__SYMBOLCHANGE(soap)))
			return NULL;
		ns1__SYMBOLCHANGE *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns_ns1__SYMBOLCHANGE, SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__SYMBOLCHANGE, sizeof(ns1__SYMBOLCHANGE), 1, ns_finsert, ns_fbase))
				break;
			if (!soap_in_PointerTons1__SYMBOLCHANGE(soap, tag, NULL, "ns1:SYMBOLCHANGE"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__SYMBOLCHANGE(soap, tag, &n, "ns1:SYMBOLCHANGE"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__SYMBOLCHANGE *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__SYMBOLCHANGE(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__SYMBOLCHANGE(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__SYMBOLCHANGE *> *p;
	size_t k = sizeof(std::vector<ns1__SYMBOLCHANGE *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns1__SYMBOLCHANGE *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns1__SYMBOLCHANGE *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__SYMBOLCHANGE *>  location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__SYMBOLCHANGE, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__TECHNICAL(struct soap *soap, std::vector<ns1__TECHNICAL *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__TECHNICAL(struct soap *soap, const std::vector<ns1__TECHNICAL *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__TECHNICAL *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__TECHNICAL(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__TECHNICAL(struct soap *soap, const char *tag, int id, const std::vector<ns1__TECHNICAL *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__TECHNICAL *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__TECHNICAL(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__TECHNICAL *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__TECHNICAL(struct soap *soap, const char *tag, std::vector<ns1__TECHNICAL *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__TECHNICAL(soap)))
			return NULL;
		ns1__TECHNICAL *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns_ns1__TECHNICAL, SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__TECHNICAL, sizeof(ns1__TECHNICAL), 1, ns_finsert, ns_fbase))
				break;
			if (!soap_in_PointerTons1__TECHNICAL(soap, tag, NULL, "ns1:TECHNICAL"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__TECHNICAL(soap, tag, &n, "ns1:TECHNICAL"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__TECHNICAL *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__TECHNICAL(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__TECHNICAL(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__TECHNICAL *> *p;
	size_t k = sizeof(std::vector<ns1__TECHNICAL *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns1__TECHNICAL *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns1__TECHNICAL *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__TECHNICAL *>  location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__TECHNICAL, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__FUNDAMENTAL(struct soap *soap, std::vector<ns1__FUNDAMENTAL *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__FUNDAMENTAL(struct soap *soap, const std::vector<ns1__FUNDAMENTAL *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__FUNDAMENTAL *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__FUNDAMENTAL(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__FUNDAMENTAL(struct soap *soap, const char *tag, int id, const std::vector<ns1__FUNDAMENTAL *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__FUNDAMENTAL *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__FUNDAMENTAL(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__FUNDAMENTAL *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__FUNDAMENTAL(struct soap *soap, const char *tag, std::vector<ns1__FUNDAMENTAL *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__FUNDAMENTAL(soap)))
			return NULL;
		ns1__FUNDAMENTAL *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns_ns1__FUNDAMENTAL, SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__FUNDAMENTAL, sizeof(ns1__FUNDAMENTAL), 1, ns_finsert, ns_fbase))
				break;
			if (!soap_in_PointerTons1__FUNDAMENTAL(soap, tag, NULL, "ns1:FUNDAMENTAL"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__FUNDAMENTAL(soap, tag, &n, "ns1:FUNDAMENTAL"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__FUNDAMENTAL *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__FUNDAMENTAL(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__FUNDAMENTAL(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__FUNDAMENTAL *> *p;
	size_t k = sizeof(std::vector<ns1__FUNDAMENTAL *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns1__FUNDAMENTAL *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns1__FUNDAMENTAL *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__FUNDAMENTAL *>  location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__FUNDAMENTAL, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__CountryBase(struct soap *soap, std::vector<ns1__CountryBase *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__CountryBase(struct soap *soap, const std::vector<ns1__CountryBase *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__CountryBase *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__CountryBase(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__CountryBase(struct soap *soap, const char *tag, int id, const std::vector<ns1__CountryBase *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__CountryBase *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__CountryBase(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__CountryBase *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__CountryBase(struct soap *soap, const char *tag, std::vector<ns1__CountryBase *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__CountryBase(soap)))
			return NULL;
		ns1__CountryBase *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns_ns1__CountryBase, SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__CountryBase, sizeof(ns1__CountryBase), 1, ns_finsert, ns_fbase))
				break;
			if (!soap_in_PointerTons1__CountryBase(soap, tag, NULL, "ns1:CountryBase"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__CountryBase(soap, tag, &n, "ns1:CountryBase"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__CountryBase *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__CountryBase(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__CountryBase(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__CountryBase *> *p;
	size_t k = sizeof(std::vector<ns1__CountryBase *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns1__CountryBase *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns1__CountryBase *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__CountryBase *>  location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__CountryBase, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__SPLIT(struct soap *soap, std::vector<ns1__SPLIT *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__SPLIT(struct soap *soap, const std::vector<ns1__SPLIT *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__SPLIT *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__SPLIT(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__SPLIT(struct soap *soap, const char *tag, int id, const std::vector<ns1__SPLIT *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__SPLIT *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__SPLIT(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__SPLIT *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__SPLIT(struct soap *soap, const char *tag, std::vector<ns1__SPLIT *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__SPLIT(soap)))
			return NULL;
		ns1__SPLIT *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns_ns1__SPLIT, SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__SPLIT, sizeof(ns1__SPLIT), 1, ns_finsert, ns_fbase))
				break;
			if (!soap_in_PointerTons1__SPLIT(soap, tag, NULL, "ns1:SPLIT"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__SPLIT(soap, tag, &n, "ns1:SPLIT"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__SPLIT *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__SPLIT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__SPLIT(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__SPLIT *> *p;
	size_t k = sizeof(std::vector<ns1__SPLIT *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns1__SPLIT *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns1__SPLIT *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__SPLIT *>  location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__SPLIT, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__QUOTE2(struct soap *soap, std::vector<ns1__QUOTE2 *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__QUOTE2(struct soap *soap, const std::vector<ns1__QUOTE2 *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__QUOTE2 *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__QUOTE2(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__QUOTE2(struct soap *soap, const char *tag, int id, const std::vector<ns1__QUOTE2 *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__QUOTE2 *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__QUOTE2(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__QUOTE2 *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__QUOTE2(struct soap *soap, const char *tag, std::vector<ns1__QUOTE2 *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__QUOTE2(soap)))
			return NULL;
		ns1__QUOTE2 *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns_ns1__QUOTE2, SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__QUOTE2, sizeof(ns1__QUOTE2), 1, ns_finsert, ns_fbase))
				break;
			if (!soap_in_PointerTons1__QUOTE2(soap, tag, NULL, "ns1:QUOTE2"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__QUOTE2(soap, tag, &n, "ns1:QUOTE2"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__QUOTE2 *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__QUOTE2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__QUOTE2(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__QUOTE2 *> *p;
	size_t k = sizeof(std::vector<ns1__QUOTE2 *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns1__QUOTE2 *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns1__QUOTE2 *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__QUOTE2 *>  location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__QUOTE2, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__QUOTE(struct soap *soap, std::vector<ns1__QUOTE *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__QUOTE(struct soap *soap, const std::vector<ns1__QUOTE *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__QUOTE *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__QUOTE(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__QUOTE(struct soap *soap, const char *tag, int id, const std::vector<ns1__QUOTE *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__QUOTE *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__QUOTE(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__QUOTE *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__QUOTE(struct soap *soap, const char *tag, std::vector<ns1__QUOTE *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__QUOTE(soap)))
			return NULL;
		ns1__QUOTE *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns_ns1__QUOTE, SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__QUOTE, sizeof(ns1__QUOTE), 1, ns_finsert, ns_fbase))
				break;
			if (!soap_in_PointerTons1__QUOTE(soap, tag, NULL, "ns1:QUOTE"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__QUOTE(soap, tag, &n, "ns1:QUOTE"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__QUOTE *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__QUOTE(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__QUOTE(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__QUOTE *> *p;
	size_t k = sizeof(std::vector<ns1__QUOTE *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns1__QUOTE *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns1__QUOTE *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__QUOTE *>  location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__QUOTE, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__SYMBOL2(struct soap *soap, std::vector<ns1__SYMBOL2 *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__SYMBOL2(struct soap *soap, const std::vector<ns1__SYMBOL2 *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__SYMBOL2 *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__SYMBOL2(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__SYMBOL2(struct soap *soap, const char *tag, int id, const std::vector<ns1__SYMBOL2 *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__SYMBOL2 *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__SYMBOL2(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__SYMBOL2 *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__SYMBOL2(struct soap *soap, const char *tag, std::vector<ns1__SYMBOL2 *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__SYMBOL2(soap)))
			return NULL;
		ns1__SYMBOL2 *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns_ns1__SYMBOL2, SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__SYMBOL2, sizeof(ns1__SYMBOL2), 1, ns_finsert, ns_fbase))
				break;
			if (!soap_in_PointerTons1__SYMBOL2(soap, tag, NULL, "ns1:SYMBOL2"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__SYMBOL2(soap, tag, &n, "ns1:SYMBOL2"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__SYMBOL2 *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__SYMBOL2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__SYMBOL2(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__SYMBOL2 *> *p;
	size_t k = sizeof(std::vector<ns1__SYMBOL2 *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns1__SYMBOL2 *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns1__SYMBOL2 *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__SYMBOL2 *>  location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__SYMBOL2, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__SYMBOL(struct soap *soap, std::vector<ns1__SYMBOL *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__SYMBOL(struct soap *soap, const std::vector<ns1__SYMBOL *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__SYMBOL *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__SYMBOL(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__SYMBOL(struct soap *soap, const char *tag, int id, const std::vector<ns1__SYMBOL *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__SYMBOL *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__SYMBOL(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__SYMBOL *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__SYMBOL(struct soap *soap, const char *tag, std::vector<ns1__SYMBOL *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__SYMBOL(soap)))
			return NULL;
		ns1__SYMBOL *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns_ns1__SYMBOL, SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__SYMBOL, sizeof(ns1__SYMBOL), 1, ns_finsert, ns_fbase))
				break;
			if (!soap_in_PointerTons1__SYMBOL(soap, tag, NULL, "ns1:SYMBOL"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__SYMBOL(soap, tag, &n, "ns1:SYMBOL"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__SYMBOL *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__SYMBOL(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__SYMBOL(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__SYMBOL *> *p;
	size_t k = sizeof(std::vector<ns1__SYMBOL *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns1__SYMBOL *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns1__SYMBOL *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__SYMBOL *>  location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__SYMBOL, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__EXCHANGE(struct soap *soap, std::vector<ns1__EXCHANGE *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__EXCHANGE(struct soap *soap, const std::vector<ns1__EXCHANGE *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__EXCHANGE *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__EXCHANGE(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__EXCHANGE(struct soap *soap, const char *tag, int id, const std::vector<ns1__EXCHANGE *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__EXCHANGE *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__EXCHANGE(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__EXCHANGE *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__EXCHANGE(struct soap *soap, const char *tag, std::vector<ns1__EXCHANGE *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__EXCHANGE(soap)))
			return NULL;
		ns1__EXCHANGE *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns_ns1__EXCHANGE, SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__EXCHANGE, sizeof(ns1__EXCHANGE), 1, ns_finsert, ns_fbase))
				break;
			if (!soap_in_PointerTons1__EXCHANGE(soap, tag, NULL, "ns1:EXCHANGE"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__EXCHANGE(soap, tag, &n, "ns1:EXCHANGE"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__EXCHANGE *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__EXCHANGE(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__EXCHANGE(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__EXCHANGE *> *p;
	size_t k = sizeof(std::vector<ns1__EXCHANGE *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns1__EXCHANGE *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns1__EXCHANGE *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__EXCHANGE *>  location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns_std__vectorTemplateOfPointerTons1__EXCHANGE, n, ns_fdelete);
	if (size)
		*size = k;
	return p;
}

} // namespace ns


#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of nsC.cpp */
